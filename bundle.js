(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":1,"ieee754":4}],4:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],5:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],6:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":5,"timers":6}],7:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="./node_modules/phaser-ce/typescript/phaser.d.ts" />
const neural_1 = require("./neural");
const genetic_1 = require("./genetic");
var velocidade = -300;
class SimpleGame {
    constructor() {
        this.players = [];
        this.velocidade = -300;
        this.game = new Phaser.Game(800, 600, Phaser.AUTO, 'content', { preload: this.preload, create: this.create, update: this.update });
    }
    preload() {
        return __awaiter(this, void 0, void 0, function* () {
            this.game.load.image('sky', 'assets/sky.png');
            this.game.load.image('ground', 'assets/platform.png');
            this.game.load.image('star', 'assets/star.png');
            this.game.load.spritesheet('dude', 'assets/dude.png', 32, 48);
            this.cursors = this.game.input.keyboard.createCursorKeys();
            this.players = [];
            this.genetic = new genetic_1.Genetic();
            this.genetic.createFirstGeneration();
        });
    }
    create() {
        return __awaiter(this, void 0, void 0, function* () {
            this.game.physics.startSystem(Phaser.Physics.ARCADE);
            this.platforms = this.game.add.group();
            this.platforms.enableBody = true;
            var ground = this.platforms.create(0, this.game.world.height - 64, 'ground');
            ground.scale.setTo(2, 2);
            ground.body.immovable = true;
            this.obstaculo = this.game.add.sprite(700, 500, 'ground');
            this.game.physics.arcade.enable(this.obstaculo);
            this.obstaculo.width = 30;
            for (let i = 0; i < this.genetic.population; i++) {
                let player;
                player = this.game.add.sprite(this.game.width * .2, ground.y - 300, "dude");
                this.game.physics.arcade.enable(player);
                player.body.bounce.y = 0.2;
                player.body.gravity.y = 800;
                player.body.collideWorldBounds = true;
                player.animations.add('left', [0, 1, 2, 3], 10, true);
                player.animations.add('right', [5, 6, 7, 8], 10, true);
                player.people = this.genetic.peoples[i];
                /// console.log(await player.people.neural.predict([1]))
                this.players.push(player);
            }
        });
    }
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.players.length < 5)
                return;
            var hitground = [];
            var hitPlatform = [];
            //console.log(this.players);
            for (let i = 0; i < this.players.length; i++) {
                hitground.push(this.game.physics.arcade.collide(this.players[i], this.platforms));
                hitPlatform.push(this.game.physics.arcade.overlap(this.players[i], this.obstaculo));
                if (hitPlatform[i])
                    this.players[i].kill();
            }
            for (let i = 0; i < this.players.length; i++) {
                this.players[i].animations.play('right');
                let distance = (this.obstaculo.x - this.players[i].x).toFixed(2);
                //console.log(distance)
                let move = yield this.players[i].people.neural.predict([distance]);
                console.log('==>' + i + ' M:' + move[0]);
                if (move[0] > 0.2) {
                    if (this.players[i].body.touching.down) {
                        this.players[i].body.velocity.y = -350;
                    }
                }
            }
            if (this.obstaculo.x < 0) {
                //velocidade += -100
                this.obstaculo.x = 700;
            }
            //console.log(distance)
            this.obstaculo.body.velocity.x = velocidade;
            // if (this.cursors.left.isDown) {
            //     this.player.body.velocity.x = -150;
            //     this.player.animations.play('left');
            // }
            // else if (this.cursors.right.isDown) {
            //     this.player.body.velocity.x = 150;
            //     this.player.animations.play('right');
            // }
        });
    }
}
var neural;
window.onload = () => __awaiter(this, void 0, void 0, function* () {
    neural = new neural_1.Neural();
    for (let i = 0; i < 10; i++) {
        yield neural.initalize();
        // console.log(await neural.predict([1]))
    }
    var game = new SimpleGame();
});

},{"./genetic":8,"./neural":9}],8:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const neural_1 = require("./neural");
const faker = require("faker");
//import { TicTacToe, Player } from "./tictactoe";
//const fs = require('fs');
const _ = require("lodash");
class People {
    constructor() {
        this.neural = new neural_1.Neural;
        this.isWinner = false;
        this.points = 0;
    }
    initalize(genoma) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.neural.initalize();
            this.name = faker.name.findName();
            if (genoma)
                yield this.neural.setWeights(genoma);
        });
    }
    predict(distance) {
        return __awaiter(this, void 0, void 0, function* () {
            let move = yield this.neural.predict(distance);
            return move;
        });
    }
}
exports.People = People;
class Genetic {
    constructor() {
        this.crossOverIndice = 0.15;
        this.mutationIndice = 0.1;
        this.population = 5;
        this.peoples = [];
        this.genomaWinner1 = [];
        this.genomaWinner2 = [];
    }
    createFirstGeneration(genoma1, genoma2) {
        return __awaiter(this, void 0, void 0, function* () {
            if (genoma1) {
                let people1 = new People;
                yield people1.initalize(genoma1);
                this.peoples.push(people1);
                let people2 = new People;
                yield people2.initalize(genoma1);
                this.peoples.push(people2);
                return;
            }
            for (let i = 0; i < this.population; i++) {
                let player = new People();
                yield player.initalize();
                this.peoples.push(player);
            }
        });
    }
    setWinners() {
        return __awaiter(this, void 0, void 0, function* () {
            // let winners = this.peoples.filter((people, index) => {
            //     return (index == firstPlace || index == secondPlace)
            // })
            this.genomaWinner1 = yield this.peoples[this.population - 1].neural.getWeights();
            this.genomaWinner2 = yield this.peoples[this.population - 2].neural.getWeights();
            this.nameWinner1 = this.peoples[this.population - 1].name;
            this.nameWinner2 = this.peoples[this.population - 2].name;
        });
    }
    createNextGenerations() {
        return __awaiter(this, void 0, void 0, function* () {
            this.peoples[0].name = this.nameWinner1;
            this.peoples[0].neural.setWeights(this.genomaWinner1);
            this.peoples[0].points = 0;
            this.peoples[1].name = this.nameWinner2;
            this.peoples[1].neural.setWeights(this.genomaWinner2);
            this.peoples[1].points = 0;
            for (let i = 2; i < this.population; i++) {
                this.peoples[i].name = faker.name.findName();
                this.peoples[i].isWinner = true;
                this.peoples[i].points = 0;
                let newGenoma = yield this.genomaCrossOver();
                newGenoma = yield this.genenomaMutation(newGenoma);
                yield this.peoples[i].neural.setWeights(newGenoma);
            }
            this.peoples = _.shuffle(this.peoples);
        });
    }
    genenomaMutation(genoma) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let layer = 0; layer < genoma.length; layer++) {
                for (let i = 0; i < genoma[layer].length; i++) {
                    if (Math.random() <= this.mutationIndice) {
                        var value = (Math.random() <= 0.5) ? -1 : 1;
                        value = Math.random();
                        genoma[layer][i] *= value;
                    }
                }
            }
            return genoma;
        });
    }
    // Uniform Crossover
    genomaCrossOver() {
        return __awaiter(this, void 0, void 0, function* () {
            let newGenoma = [];
            let copyfrom2 = false;
            for (let layer = 0; layer < this.genomaWinner1.length; layer++) {
                newGenoma.push(this.genomaWinner1[layer]);
                for (let i = 0; i < this.genomaWinner1[layer].length; i++) {
                    if (Math.random() <= this.crossOverIndice)
                        copyfrom2 = !copyfrom2;
                    if (copyfrom2)
                        newGenoma[layer][i] = this.genomaWinner2[layer][i];
                }
            }
            return newGenoma;
        });
    }
    printGenomas() {
        return __awaiter(this, void 0, void 0, function* () {
            var print = [];
            for (let i = 0; i < this.peoples.length; i++) {
                let weight = yield this.peoples[i].neural.getWeights();
                print.push({ name: this.peoples[i].name, genoma: weight });
            }
            console.log(print);
            //fs.writeFile('./data.json', JSON.stringify(print, null, 2), 'utf-8');
        });
    }
}
exports.Genetic = Genetic;
// async function main() {
//     var genetic = new Genetic;
//     await genetic.createFirstGeneration();
//     // await genetic.setWinners(0, 7);
//     //  await genetic.createNextGenerations();
//     //await genetic.printGenomas();
//     var ticTacToe = new TicTacToe;
//     for (let i = 0; i < 8; i++) {
//         let move = await genetic.peoples[i].predict(ticTacToe.getBoard());
//         ticTacToe.play(move, Player.X);
//     }
// }
// main()

},{"./neural":9,"faker":260,"lodash":1308}],9:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const tf = require("@tensorflow/tfjs");
class Neural {
    initalize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.model = yield tf.sequential({
                layers: [tf.layers.dense({ units: 1, inputShape: [1], activation: 'relu', useBias: true })]
            });
            this.model.add(tf.layers.dense({ units: 2, activation: 'sigmoid', useBias: true }));
            this.model.add(tf.layers.dense({ units: 1, activation: 'relu', useBias: true }));
            yield this.model.compile({ optimizer: 'adam', loss: 'meanSquaredError', metrics: ['accuracy'] });
        });
    }
    predict(input) {
        return __awaiter(this, void 0, void 0, function* () {
            let tensorResult = yield this.model.predict(tf.tensor([input])).data();
            return tensorResult;
        });
    }
    getWeight(layer) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.model.layers[layer].getWeights()[0].data();
        });
    }
    getWeights() {
        return __awaiter(this, void 0, void 0, function* () {
            let weights = [];
            weights.push(yield this.getWeight(0));
            weights.push(yield this.getWeight(1));
            weights.push(yield this.getWeight(2));
            // weights.push(await this.getWeight(3));
            return weights;
        });
    }
    setWeights(weights) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setWeight(0, weights[0]);
            yield this.setWeight(1, weights[1]);
            yield this.setWeight(2, weights[2]);
            // await this.setWeight(3,weights[3]);
        });
    }
    setWeight(layer, weights) {
        return __awaiter(this, void 0, void 0, function* () {
            var newWights = [];
            var shape;
            if (layer == 0)
                shape = [1, 1];
            else if (layer == 1)
                shape = [1, 2];
            //else if (layer == 2) shape = [50,20]
            else if (layer == 2)
                shape = [2, 1];
            return tf.tensor(weights, shape);
            yield this.model.layers[layer].setWeights(newWights);
        });
    }
}
exports.Neural = Neural;
//window.Neural = Neural;

},{"@tensorflow/tfjs":258}],10:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],11:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],12:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],13:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],14:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],15:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],16:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],17:[function(require,module,exports){
/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
"use strict";

var $protobuf = require("protobufjs/minimal");

var $Reader = $protobuf.Reader, $util = $protobuf.util;

var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.tensorflow = (function() {

    var tensorflow = {};

    tensorflow.Any = (function() {

        function Any(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        Any.prototype.typeUrl = "";
        Any.prototype.value = $util.newBuffer([]);

        Any.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.Any();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.typeUrl = r.string();
                    break;
                case 2:
                    m.value = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Any;
    })();

    tensorflow.DataType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DT_INVALID"] = 0;
        values[valuesById[1] = "DT_FLOAT"] = 1;
        values[valuesById[2] = "DT_DOUBLE"] = 2;
        values[valuesById[3] = "DT_INT32"] = 3;
        values[valuesById[4] = "DT_UINT8"] = 4;
        values[valuesById[5] = "DT_INT16"] = 5;
        values[valuesById[6] = "DT_INT8"] = 6;
        values[valuesById[7] = "DT_STRING"] = 7;
        values[valuesById[8] = "DT_COMPLEX64"] = 8;
        values[valuesById[9] = "DT_INT64"] = 9;
        values[valuesById[10] = "DT_BOOL"] = 10;
        values[valuesById[11] = "DT_QINT8"] = 11;
        values[valuesById[12] = "DT_QUINT8"] = 12;
        values[valuesById[13] = "DT_QINT32"] = 13;
        values[valuesById[14] = "DT_BFLOAT16"] = 14;
        values[valuesById[101] = "DT_FLOAT_REF"] = 101;
        values[valuesById[102] = "DT_DOUBLE_REF"] = 102;
        values[valuesById[103] = "DT_INT32_REF"] = 103;
        values[valuesById[104] = "DT_UINT8_REF"] = 104;
        values[valuesById[105] = "DT_INT16_REF"] = 105;
        values[valuesById[106] = "DT_INT8_REF"] = 106;
        values[valuesById[107] = "DT_STRING_REF"] = 107;
        values[valuesById[108] = "DT_COMPLEX64_REF"] = 108;
        values[valuesById[109] = "DT_INT64_REF"] = 109;
        values[valuesById[110] = "DT_BOOL_REF"] = 110;
        values[valuesById[111] = "DT_QINT8_REF"] = 111;
        values[valuesById[112] = "DT_QUINT8_REF"] = 112;
        values[valuesById[113] = "DT_QINT32_REF"] = 113;
        values[valuesById[114] = "DT_BFLOAT16_REF"] = 114;
        return values;
    })();

    tensorflow.TensorShape = (function() {

        function TensorShape(p) {
            this.dim = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        TensorShape.prototype.dim = $util.emptyArray;
        TensorShape.prototype.unknownRank = false;

        TensorShape.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorShape();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 2:
                    if (!(m.dim && m.dim.length))
                        m.dim = [];
                    m.dim.push($root.tensorflow.TensorShape.Dim.decode(r, r.uint32()));
                    break;
                case 3:
                    m.unknownRank = r.bool();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        TensorShape.Dim = (function() {

            function Dim(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Dim.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
            Dim.prototype.name = "";

            Dim.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorShape.Dim();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.size = r.int64();
                        break;
                    case 2:
                        m.name = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Dim;
        })();

        return TensorShape;
    })();

    tensorflow.Tensor = (function() {

        function Tensor(p) {
            this.floatVal = [];
            this.doubleVal = [];
            this.intVal = [];
            this.stringVal = [];
            this.scomplexVal = [];
            this.int64Val = [];
            this.boolVal = [];
            this.uint32Val = [];
            this.uint64Val = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        Tensor.prototype.dtype = 0;
        Tensor.prototype.tensorShape = null;
        Tensor.prototype.versionNumber = 0;
        Tensor.prototype.tensorContent = $util.newBuffer([]);
        Tensor.prototype.floatVal = $util.emptyArray;
        Tensor.prototype.doubleVal = $util.emptyArray;
        Tensor.prototype.intVal = $util.emptyArray;
        Tensor.prototype.stringVal = $util.emptyArray;
        Tensor.prototype.scomplexVal = $util.emptyArray;
        Tensor.prototype.int64Val = $util.emptyArray;
        Tensor.prototype.boolVal = $util.emptyArray;
        Tensor.prototype.uint32Val = $util.emptyArray;
        Tensor.prototype.uint64Val = $util.emptyArray;

        Tensor.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.Tensor();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.dtype = r.int32();
                    break;
                case 2:
                    m.tensorShape = $root.tensorflow.TensorShape.decode(r, r.uint32());
                    break;
                case 3:
                    m.versionNumber = r.int32();
                    break;
                case 4:
                    m.tensorContent = r.bytes();
                    break;
                case 5:
                    if (!(m.floatVal && m.floatVal.length))
                        m.floatVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.floatVal.push(r.float());
                    } else
                        m.floatVal.push(r.float());
                    break;
                case 6:
                    if (!(m.doubleVal && m.doubleVal.length))
                        m.doubleVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.doubleVal.push(r.double());
                    } else
                        m.doubleVal.push(r.double());
                    break;
                case 7:
                    if (!(m.intVal && m.intVal.length))
                        m.intVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.intVal.push(r.int32());
                    } else
                        m.intVal.push(r.int32());
                    break;
                case 8:
                    if (!(m.stringVal && m.stringVal.length))
                        m.stringVal = [];
                    m.stringVal.push(r.bytes());
                    break;
                case 9:
                    if (!(m.scomplexVal && m.scomplexVal.length))
                        m.scomplexVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.scomplexVal.push(r.float());
                    } else
                        m.scomplexVal.push(r.float());
                    break;
                case 10:
                    if (!(m.int64Val && m.int64Val.length))
                        m.int64Val = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.int64Val.push(r.int64());
                    } else
                        m.int64Val.push(r.int64());
                    break;
                case 11:
                    if (!(m.boolVal && m.boolVal.length))
                        m.boolVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.boolVal.push(r.bool());
                    } else
                        m.boolVal.push(r.bool());
                    break;
                case 16:
                    if (!(m.uint32Val && m.uint32Val.length))
                        m.uint32Val = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.uint32Val.push(r.uint32());
                    } else
                        m.uint32Val.push(r.uint32());
                    break;
                case 17:
                    if (!(m.uint64Val && m.uint64Val.length))
                        m.uint64Val = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.uint64Val.push(r.uint64());
                    } else
                        m.uint64Val.push(r.uint64());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Tensor;
    })();

    tensorflow.AttrValue = (function() {

        function AttrValue(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        AttrValue.prototype.list = null;
        AttrValue.prototype.s = $util.newBuffer([]);
        AttrValue.prototype.i = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        AttrValue.prototype.f = 0;
        AttrValue.prototype.b = false;
        AttrValue.prototype.type = 0;
        AttrValue.prototype.shape = null;
        AttrValue.prototype.tensor = null;
        AttrValue.prototype.placeholder = "";
        AttrValue.prototype.func = null;

        var $oneOfFields;

        Object.defineProperty(AttrValue.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["list", "s", "i", "f", "b", "type", "shape", "tensor", "placeholder", "func"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        AttrValue.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.AttrValue();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.list = $root.tensorflow.AttrValue.ListValue.decode(r, r.uint32());
                    break;
                case 2:
                    m.s = r.bytes();
                    break;
                case 3:
                    m.i = r.int64();
                    break;
                case 4:
                    m.f = r.float();
                    break;
                case 5:
                    m.b = r.bool();
                    break;
                case 6:
                    m.type = r.int32();
                    break;
                case 7:
                    m.shape = $root.tensorflow.TensorShape.decode(r, r.uint32());
                    break;
                case 8:
                    m.tensor = $root.tensorflow.Tensor.decode(r, r.uint32());
                    break;
                case 9:
                    m.placeholder = r.string();
                    break;
                case 10:
                    m.func = $root.tensorflow.NameAttrList.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        AttrValue.ListValue = (function() {

            function ListValue(p) {
                this.s = [];
                this.i = [];
                this.f = [];
                this.b = [];
                this.type = [];
                this.shape = [];
                this.tensor = [];
                this.func = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            ListValue.prototype.s = $util.emptyArray;
            ListValue.prototype.i = $util.emptyArray;
            ListValue.prototype.f = $util.emptyArray;
            ListValue.prototype.b = $util.emptyArray;
            ListValue.prototype.type = $util.emptyArray;
            ListValue.prototype.shape = $util.emptyArray;
            ListValue.prototype.tensor = $util.emptyArray;
            ListValue.prototype.func = $util.emptyArray;

            ListValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.AttrValue.ListValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 2:
                        if (!(m.s && m.s.length))
                            m.s = [];
                        m.s.push(r.bytes());
                        break;
                    case 3:
                        if (!(m.i && m.i.length))
                            m.i = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.i.push(r.int64());
                        } else
                            m.i.push(r.int64());
                        break;
                    case 4:
                        if (!(m.f && m.f.length))
                            m.f = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.f.push(r.float());
                        } else
                            m.f.push(r.float());
                        break;
                    case 5:
                        if (!(m.b && m.b.length))
                            m.b = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.b.push(r.bool());
                        } else
                            m.b.push(r.bool());
                        break;
                    case 6:
                        if (!(m.type && m.type.length))
                            m.type = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.type.push(r.int32());
                        } else
                            m.type.push(r.int32());
                        break;
                    case 7:
                        if (!(m.shape && m.shape.length))
                            m.shape = [];
                        m.shape.push($root.tensorflow.TensorShape.decode(r, r.uint32()));
                        break;
                    case 8:
                        if (!(m.tensor && m.tensor.length))
                            m.tensor = [];
                        m.tensor.push($root.tensorflow.Tensor.decode(r, r.uint32()));
                        break;
                    case 9:
                        if (!(m.func && m.func.length))
                            m.func = [];
                        m.func.push($root.tensorflow.NameAttrList.decode(r, r.uint32()));
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return ListValue;
        })();

        return AttrValue;
    })();

    tensorflow.NameAttrList = (function() {

        function NameAttrList(p) {
            this.attr = {};
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        NameAttrList.prototype.name = "";
        NameAttrList.prototype.attr = $util.emptyObject;

        NameAttrList.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.NameAttrList(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    r.skip().pos++;
                    if (m.attr === $util.emptyObject)
                        m.attr = {};
                    k = r.string();
                    r.pos++;
                    m.attr[k] = $root.tensorflow.AttrValue.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return NameAttrList;
    })();

    tensorflow.NodeDef = (function() {

        function NodeDef(p) {
            this.input = [];
            this.attr = {};
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        NodeDef.prototype.name = "";
        NodeDef.prototype.op = "";
        NodeDef.prototype.input = $util.emptyArray;
        NodeDef.prototype.device = "";
        NodeDef.prototype.attr = $util.emptyObject;

        NodeDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.NodeDef(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    m.op = r.string();
                    break;
                case 3:
                    if (!(m.input && m.input.length))
                        m.input = [];
                    m.input.push(r.string());
                    break;
                case 4:
                    m.device = r.string();
                    break;
                case 5:
                    r.skip().pos++;
                    if (m.attr === $util.emptyObject)
                        m.attr = {};
                    k = r.string();
                    r.pos++;
                    m.attr[k] = $root.tensorflow.AttrValue.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return NodeDef;
    })();

    tensorflow.VersionDef = (function() {

        function VersionDef(p) {
            this.badConsumers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        VersionDef.prototype.producer = 0;
        VersionDef.prototype.minConsumer = 0;
        VersionDef.prototype.badConsumers = $util.emptyArray;

        VersionDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.VersionDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.producer = r.int32();
                    break;
                case 2:
                    m.minConsumer = r.int32();
                    break;
                case 3:
                    if (!(m.badConsumers && m.badConsumers.length))
                        m.badConsumers = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.badConsumers.push(r.int32());
                    } else
                        m.badConsumers.push(r.int32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return VersionDef;
    })();

    tensorflow.GraphDef = (function() {

        function GraphDef(p) {
            this.node = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        GraphDef.prototype.node = $util.emptyArray;
        GraphDef.prototype.versions = null;
        GraphDef.prototype.library = null;

        GraphDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.GraphDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.node && m.node.length))
                        m.node = [];
                    m.node.push($root.tensorflow.NodeDef.decode(r, r.uint32()));
                    break;
                case 4:
                    m.versions = $root.tensorflow.VersionDef.decode(r, r.uint32());
                    break;
                case 2:
                    m.library = $root.tensorflow.FunctionDefLibrary.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return GraphDef;
    })();

    tensorflow.CollectionDef = (function() {

        function CollectionDef(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        CollectionDef.prototype.nodeList = null;
        CollectionDef.prototype.bytesList = null;
        CollectionDef.prototype.int64List = null;
        CollectionDef.prototype.floatList = null;
        CollectionDef.prototype.anyList = null;

        var $oneOfFields;

        Object.defineProperty(CollectionDef.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["nodeList", "bytesList", "int64List", "floatList", "anyList"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        CollectionDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.nodeList = $root.tensorflow.CollectionDef.NodeList.decode(r, r.uint32());
                    break;
                case 2:
                    m.bytesList = $root.tensorflow.CollectionDef.BytesList.decode(r, r.uint32());
                    break;
                case 3:
                    m.int64List = $root.tensorflow.CollectionDef.Int64List.decode(r, r.uint32());
                    break;
                case 4:
                    m.floatList = $root.tensorflow.CollectionDef.FloatList.decode(r, r.uint32());
                    break;
                case 5:
                    m.anyList = $root.tensorflow.CollectionDef.AnyList.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        CollectionDef.NodeList = (function() {

            function NodeList(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            NodeList.prototype.value = $util.emptyArray;

            NodeList.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.NodeList();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        m.value.push(r.string());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return NodeList;
        })();

        CollectionDef.BytesList = (function() {

            function BytesList(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            BytesList.prototype.value = $util.emptyArray;

            BytesList.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.BytesList();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        m.value.push(r.bytes());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return BytesList;
        })();

        CollectionDef.Int64List = (function() {

            function Int64List(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Int64List.prototype.value = $util.emptyArray;

            Int64List.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.Int64List();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.value.push(r.int64());
                        } else
                            m.value.push(r.int64());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Int64List;
        })();

        CollectionDef.FloatList = (function() {

            function FloatList(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            FloatList.prototype.value = $util.emptyArray;

            FloatList.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.FloatList();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.value.push(r.float());
                        } else
                            m.value.push(r.float());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return FloatList;
        })();

        CollectionDef.AnyList = (function() {

            function AnyList(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            AnyList.prototype.value = $util.emptyArray;

            AnyList.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.AnyList();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        m.value.push($root.tensorflow.Any.decode(r, r.uint32()));
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return AnyList;
        })();

        return CollectionDef;
    })();

    tensorflow.SaverDef = (function() {

        function SaverDef(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SaverDef.prototype.filenameTensorName = "";
        SaverDef.prototype.saveTensorName = "";
        SaverDef.prototype.restoreOpName = "";
        SaverDef.prototype.maxToKeep = 0;
        SaverDef.prototype.sharded = false;
        SaverDef.prototype.keepCheckpointEveryNHours = 0;
        SaverDef.prototype.version = 0;

        SaverDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.SaverDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.filenameTensorName = r.string();
                    break;
                case 2:
                    m.saveTensorName = r.string();
                    break;
                case 3:
                    m.restoreOpName = r.string();
                    break;
                case 4:
                    m.maxToKeep = r.int32();
                    break;
                case 5:
                    m.sharded = r.bool();
                    break;
                case 6:
                    m.keepCheckpointEveryNHours = r.float();
                    break;
                case 7:
                    m.version = r.int32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        SaverDef.CheckpointFormatVersion = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LEGACY"] = 0;
            values[valuesById[1] = "V1"] = 1;
            values[valuesById[2] = "V2"] = 2;
            return values;
        })();

        return SaverDef;
    })();

    tensorflow.TensorInfo = (function() {

        function TensorInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        TensorInfo.prototype.name = "";
        TensorInfo.prototype.cooSparse = null;
        TensorInfo.prototype.dtype = 0;
        TensorInfo.prototype.tensorShape = null;

        var $oneOfFields;

        Object.defineProperty(TensorInfo.prototype, "encoding", {
            get: $util.oneOfGetter($oneOfFields = ["name", "cooSparse"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        TensorInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 4:
                    m.cooSparse = $root.tensorflow.TensorInfo.CooSparse.decode(r, r.uint32());
                    break;
                case 2:
                    m.dtype = r.int32();
                    break;
                case 3:
                    m.tensorShape = $root.tensorflow.TensorShape.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        TensorInfo.CooSparse = (function() {

            function CooSparse(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            CooSparse.prototype.valuesTensorName = "";
            CooSparse.prototype.indicesTensorName = "";
            CooSparse.prototype.denseShapeTensorName = "";

            CooSparse.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorInfo.CooSparse();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.valuesTensorName = r.string();
                        break;
                    case 2:
                        m.indicesTensorName = r.string();
                        break;
                    case 3:
                        m.denseShapeTensorName = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return CooSparse;
        })();

        return TensorInfo;
    })();

    tensorflow.SignatureDef = (function() {

        function SignatureDef(p) {
            this.inputs = {};
            this.outputs = {};
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SignatureDef.prototype.inputs = $util.emptyObject;
        SignatureDef.prototype.outputs = $util.emptyObject;
        SignatureDef.prototype.methodName = "";

        SignatureDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.SignatureDef(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    r.skip().pos++;
                    if (m.inputs === $util.emptyObject)
                        m.inputs = {};
                    k = r.string();
                    r.pos++;
                    m.inputs[k] = $root.tensorflow.TensorInfo.decode(r, r.uint32());
                    break;
                case 2:
                    r.skip().pos++;
                    if (m.outputs === $util.emptyObject)
                        m.outputs = {};
                    k = r.string();
                    r.pos++;
                    m.outputs[k] = $root.tensorflow.TensorInfo.decode(r, r.uint32());
                    break;
                case 3:
                    m.methodName = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SignatureDef;
    })();

    tensorflow.AssetFileDef = (function() {

        function AssetFileDef(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        AssetFileDef.prototype.tensorInfo = null;
        AssetFileDef.prototype.filename = "";

        AssetFileDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.AssetFileDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.tensorInfo = $root.tensorflow.TensorInfo.decode(r, r.uint32());
                    break;
                case 2:
                    m.filename = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return AssetFileDef;
    })();

    tensorflow.OpDef = (function() {

        function OpDef(p) {
            this.inputArg = [];
            this.outputArg = [];
            this.attr = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        OpDef.prototype.name = "";
        OpDef.prototype.inputArg = $util.emptyArray;
        OpDef.prototype.outputArg = $util.emptyArray;
        OpDef.prototype.attr = $util.emptyArray;
        OpDef.prototype.deprecation = null;
        OpDef.prototype.summary = "";
        OpDef.prototype.description = "";
        OpDef.prototype.isCommutative = false;
        OpDef.prototype.isAggregate = false;
        OpDef.prototype.isStateful = false;
        OpDef.prototype.allowsUninitializedInput = false;

        OpDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    if (!(m.inputArg && m.inputArg.length))
                        m.inputArg = [];
                    m.inputArg.push($root.tensorflow.OpDef.ArgDef.decode(r, r.uint32()));
                    break;
                case 3:
                    if (!(m.outputArg && m.outputArg.length))
                        m.outputArg = [];
                    m.outputArg.push($root.tensorflow.OpDef.ArgDef.decode(r, r.uint32()));
                    break;
                case 4:
                    if (!(m.attr && m.attr.length))
                        m.attr = [];
                    m.attr.push($root.tensorflow.OpDef.AttrDef.decode(r, r.uint32()));
                    break;
                case 8:
                    m.deprecation = $root.tensorflow.OpDef.OpDeprecation.decode(r, r.uint32());
                    break;
                case 5:
                    m.summary = r.string();
                    break;
                case 6:
                    m.description = r.string();
                    break;
                case 18:
                    m.isCommutative = r.bool();
                    break;
                case 16:
                    m.isAggregate = r.bool();
                    break;
                case 17:
                    m.isStateful = r.bool();
                    break;
                case 19:
                    m.allowsUninitializedInput = r.bool();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        OpDef.ArgDef = (function() {

            function ArgDef(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            ArgDef.prototype.name = "";
            ArgDef.prototype.description = "";
            ArgDef.prototype.type = 0;
            ArgDef.prototype.typeAttr = "";
            ArgDef.prototype.numberAttr = "";
            ArgDef.prototype.typeListAttr = "";
            ArgDef.prototype.isRef = false;

            ArgDef.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef.ArgDef();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.name = r.string();
                        break;
                    case 2:
                        m.description = r.string();
                        break;
                    case 3:
                        m.type = r.int32();
                        break;
                    case 4:
                        m.typeAttr = r.string();
                        break;
                    case 5:
                        m.numberAttr = r.string();
                        break;
                    case 6:
                        m.typeListAttr = r.string();
                        break;
                    case 16:
                        m.isRef = r.bool();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return ArgDef;
        })();

        OpDef.AttrDef = (function() {

            function AttrDef(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            AttrDef.prototype.name = "";
            AttrDef.prototype.type = "";
            AttrDef.prototype.defaultValue = null;
            AttrDef.prototype.description = "";
            AttrDef.prototype.hasMinimum = false;
            AttrDef.prototype.minimum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
            AttrDef.prototype.allowedValues = null;

            AttrDef.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef.AttrDef();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.name = r.string();
                        break;
                    case 2:
                        m.type = r.string();
                        break;
                    case 3:
                        m.defaultValue = $root.tensorflow.AttrValue.decode(r, r.uint32());
                        break;
                    case 4:
                        m.description = r.string();
                        break;
                    case 5:
                        m.hasMinimum = r.bool();
                        break;
                    case 6:
                        m.minimum = r.int64();
                        break;
                    case 7:
                        m.allowedValues = $root.tensorflow.AttrValue.decode(r, r.uint32());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return AttrDef;
        })();

        OpDef.OpDeprecation = (function() {

            function OpDeprecation(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            OpDeprecation.prototype.version = 0;
            OpDeprecation.prototype.explanation = "";

            OpDeprecation.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef.OpDeprecation();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.version = r.int32();
                        break;
                    case 2:
                        m.explanation = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return OpDeprecation;
        })();

        return OpDef;
    })();

    tensorflow.OpList = (function() {

        function OpList(p) {
            this.op = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        OpList.prototype.op = $util.emptyArray;

        OpList.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.op && m.op.length))
                        m.op = [];
                    m.op.push($root.tensorflow.OpDef.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return OpList;
    })();

    tensorflow.MetaGraphDef = (function() {

        function MetaGraphDef(p) {
            this.collectionDef = {};
            this.signatureDef = {};
            this.assetFileDef = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        MetaGraphDef.prototype.metaInfoDef = null;
        MetaGraphDef.prototype.graphDef = null;
        MetaGraphDef.prototype.saverDef = null;
        MetaGraphDef.prototype.collectionDef = $util.emptyObject;
        MetaGraphDef.prototype.signatureDef = $util.emptyObject;
        MetaGraphDef.prototype.assetFileDef = $util.emptyArray;

        MetaGraphDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.MetaGraphDef(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.metaInfoDef = $root.tensorflow.MetaGraphDef.MetaInfoDef.decode(r, r.uint32());
                    break;
                case 2:
                    m.graphDef = $root.tensorflow.GraphDef.decode(r, r.uint32());
                    break;
                case 3:
                    m.saverDef = $root.tensorflow.SaverDef.decode(r, r.uint32());
                    break;
                case 4:
                    r.skip().pos++;
                    if (m.collectionDef === $util.emptyObject)
                        m.collectionDef = {};
                    k = r.string();
                    r.pos++;
                    m.collectionDef[k] = $root.tensorflow.CollectionDef.decode(r, r.uint32());
                    break;
                case 5:
                    r.skip().pos++;
                    if (m.signatureDef === $util.emptyObject)
                        m.signatureDef = {};
                    k = r.string();
                    r.pos++;
                    m.signatureDef[k] = $root.tensorflow.SignatureDef.decode(r, r.uint32());
                    break;
                case 6:
                    if (!(m.assetFileDef && m.assetFileDef.length))
                        m.assetFileDef = [];
                    m.assetFileDef.push($root.tensorflow.AssetFileDef.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        MetaGraphDef.MetaInfoDef = (function() {

            function MetaInfoDef(p) {
                this.tags = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            MetaInfoDef.prototype.metaGraphVersion = "";
            MetaInfoDef.prototype.strippedOpList = null;
            MetaInfoDef.prototype.anyInfo = null;
            MetaInfoDef.prototype.tags = $util.emptyArray;
            MetaInfoDef.prototype.tensorflowVersion = "";
            MetaInfoDef.prototype.tensorflowGitVersion = "";

            MetaInfoDef.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.MetaGraphDef.MetaInfoDef();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.metaGraphVersion = r.string();
                        break;
                    case 2:
                        m.strippedOpList = $root.tensorflow.OpList.decode(r, r.uint32());
                        break;
                    case 3:
                        m.anyInfo = $root.tensorflow.Any.decode(r, r.uint32());
                        break;
                    case 4:
                        if (!(m.tags && m.tags.length))
                            m.tags = [];
                        m.tags.push(r.string());
                        break;
                    case 5:
                        m.tensorflowVersion = r.string();
                        break;
                    case 6:
                        m.tensorflowGitVersion = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return MetaInfoDef;
        })();

        return MetaGraphDef;
    })();

    tensorflow.SavedModel = (function() {

        function SavedModel(p) {
            this.metaGraphs = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SavedModel.prototype.savedModelSchemaVersion = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        SavedModel.prototype.metaGraphs = $util.emptyArray;

        SavedModel.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.SavedModel();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.savedModelSchemaVersion = r.int64();
                    break;
                case 2:
                    if (!(m.metaGraphs && m.metaGraphs.length))
                        m.metaGraphs = [];
                    m.metaGraphs.push($root.tensorflow.MetaGraphDef.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SavedModel;
    })();

    tensorflow.FunctionDefLibrary = (function() {

        function FunctionDefLibrary(p) {
            this["function"] = [];
            this.gradient = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        FunctionDefLibrary.prototype["function"] = $util.emptyArray;
        FunctionDefLibrary.prototype.gradient = $util.emptyArray;

        FunctionDefLibrary.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.FunctionDefLibrary();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m["function"] && m["function"].length))
                        m["function"] = [];
                    m["function"].push($root.tensorflow.FunctionDef.decode(r, r.uint32()));
                    break;
                case 2:
                    if (!(m.gradient && m.gradient.length))
                        m.gradient = [];
                    m.gradient.push($root.tensorflow.GradientDef.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FunctionDefLibrary;
    })();

    tensorflow.FunctionDef = (function() {

        function FunctionDef(p) {
            this.attr = {};
            this.nodeDef = [];
            this.ret = {};
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        FunctionDef.prototype.signature = null;
        FunctionDef.prototype.attr = $util.emptyObject;
        FunctionDef.prototype.nodeDef = $util.emptyArray;
        FunctionDef.prototype.ret = $util.emptyObject;

        FunctionDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.FunctionDef(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.signature = $root.tensorflow.OpDef.decode(r, r.uint32());
                    break;
                case 5:
                    r.skip().pos++;
                    if (m.attr === $util.emptyObject)
                        m.attr = {};
                    k = r.string();
                    r.pos++;
                    m.attr[k] = $root.tensorflow.AttrValue.decode(r, r.uint32());
                    break;
                case 3:
                    if (!(m.nodeDef && m.nodeDef.length))
                        m.nodeDef = [];
                    m.nodeDef.push($root.tensorflow.NodeDef.decode(r, r.uint32()));
                    break;
                case 4:
                    r.skip().pos++;
                    if (m.ret === $util.emptyObject)
                        m.ret = {};
                    k = r.string();
                    r.pos++;
                    m.ret[k] = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FunctionDef;
    })();

    tensorflow.GradientDef = (function() {

        function GradientDef(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        GradientDef.prototype.functionName = "";
        GradientDef.prototype.gradientFunc = "";

        GradientDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.GradientDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.functionName = r.string();
                    break;
                case 2:
                    m.gradientFunc = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return GradientDef;
    })();

    return tensorflow;
})();

module.exports = $root;

},{"protobufjs/minimal":1309}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ExecutionContext = (function () {
    function ExecutionContext(weightMap, tensorArrayMap) {
        this.weightMap = weightMap;
        this.tensorArrayMap = tensorArrayMap;
        this.rootContext = { id: 0, frameName: '', iterationId: 0 };
        this.contexts = [this.rootContext];
        this.lastId = 0;
        this.generateCurrentContextIds();
    }
    ExecutionContext.prototype.newFrame = function (id, frameName) {
        return { id: id, frameName: frameName, iterationId: 0 };
    };
    Object.defineProperty(ExecutionContext.prototype, "currentContext", {
        get: function () {
            return this.contexts;
        },
        set: function (contexts) {
            if (this.contexts !== contexts) {
                this.contexts = contexts;
                this.generateCurrentContextIds();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExecutionContext.prototype, "currentContextId", {
        get: function () {
            return this._currentContextIds[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExecutionContext.prototype, "currentContextIds", {
        get: function () {
            return this._currentContextIds;
        },
        enumerable: true,
        configurable: true
    });
    ExecutionContext.prototype.generateCurrentContextIds = function () {
        var names = [];
        for (var i = 0; i < this.contexts.length - 1; i++) {
            var contexts = this.contexts.slice(0, this.contexts.length - i);
            names.push(this.contextIdforContexts(contexts));
        }
        names.push('');
        this._currentContextIds = names;
    };
    ExecutionContext.prototype.contextIdforContexts = function (contexts) {
        return contexts ?
            contexts
                .map(function (context) { return (context.id === 0 && context.iterationId === 0) ?
                '' :
                context.frameName + "-" + context.iterationId; })
                .join('/') :
            '';
    };
    ExecutionContext.prototype.enterFrame = function (frameId) {
        if (this.contexts) {
            this.lastId++;
            this.contexts = this.contexts.slice();
            this.contexts.push(this.newFrame(this.lastId, frameId));
            this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));
        }
    };
    ExecutionContext.prototype.exitFrame = function () {
        if (this.contexts && this.contexts.length > 1) {
            this.contexts = this.contexts.slice();
            this.contexts.splice(-1);
            this.currentContextIds.shift();
        }
        else {
            throw new Error('Cannot exit frame, the context is empty');
        }
    };
    ExecutionContext.prototype.nextIteration = function () {
        if (this.contexts && this.contexts.length > 0) {
            this.contexts = this.contexts.slice();
            this.lastId++;
            var context = Object.assign({}, this.contexts[this.contexts.length - 1]);
            context.iterationId += 1;
            context.id = this.lastId;
            this.contexts.splice(-1, 1, context);
            this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
        }
        else {
            throw new Error('Cannot increase frame iteration, the context is empty');
        }
    };
    ExecutionContext.prototype.getWeight = function (name) {
        return this.weightMap[name];
    };
    ExecutionContext.prototype.addTensorArray = function (tensorArray) {
        this.tensorArrayMap[tensorArray.id] = tensorArray;
    };
    ExecutionContext.prototype.getTensorArray = function (id) {
        return this.tensorArrayMap[id];
    };
    return ExecutionContext;
}());
exports.ExecutionContext = ExecutionContext;

},{}],19:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var compiled_api_1 = require("../data/compiled_api");
var operation_mapper_1 = require("../operations/operation_mapper");
var graph_executor_1 = require("./graph_executor");
var FrozenModel = (function () {
    function FrozenModel(modelUrl, weightManifestUrl, requestOption) {
        this.modelUrl = modelUrl;
        this.weightManifestUrl = weightManifestUrl;
        this.requestOption = requestOption;
        this.version = 'n/a';
    }
    Object.defineProperty(FrozenModel.prototype, "modelVersion", {
        get: function () {
            return this.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrozenModel.prototype, "inputNodes", {
        get: function () {
            return this.executor.inputNodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrozenModel.prototype, "outputNodes", {
        get: function () {
            return this.executor.outputNodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrozenModel.prototype, "inputs", {
        get: function () {
            return this.executor.inputs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrozenModel.prototype, "outputs", {
        get: function () {
            return this.executor.outputs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrozenModel.prototype, "weights", {
        get: function () {
            return this.executor.weightMap;
        },
        enumerable: true,
        configurable: true
    });
    FrozenModel.prototype.findIOHandler = function () {
        var path = [this.modelUrl, this.weightManifestUrl];
        if (this.requestOption) {
            this.handler = tfc.io.browserHTTPRequest(path, this.requestOption);
        }
        else {
            var handlers = tfc.io.getLoadHandlers(path);
            if (handlers.length === 0) {
                handlers.push(tfc.io.browserHTTPRequest(path, this.requestOption));
            }
            else if (handlers.length > 1) {
                throw new Error("Found more than one (" + handlers.length + ") load handlers for " +
                    ("URL '" + [path] + "'"));
            }
            this.handler = handlers[0];
        }
    };
    FrozenModel.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var artifacts, graph, weightMap;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.findIOHandler();
                        if (this.handler.load == null) {
                            throw new Error('Cannot proceed with model loading because the IOHandler provided ' +
                                'does not have the `load` method implemented.');
                        }
                        return [4, this.handler.load()];
                    case 1:
                        artifacts = _a.sent();
                        graph = compiled_api_1.tensorflow.GraphDef.decode(new Uint8Array(artifacts.modelTopology));
                        this.version = graph.versions.producer + "." + graph.versions.minConsumer;
                        weightMap = tfc.io.decodeWeights(artifacts.weightData, artifacts.weightSpecs);
                        this.executor =
                            new graph_executor_1.GraphExecutor(operation_mapper_1.OperationMapper.Instance.transformGraph(graph));
                        this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
                        return [2, true];
                }
            });
        });
    };
    FrozenModel.prototype.predict = function (inputs, config) {
        return this.execute_(inputs, true, this.outputNodes);
    };
    FrozenModel.prototype.constructTensorMap = function (inputs) {
        var inputArray = inputs instanceof tfc.Tensor ? [inputs] : inputs;
        if (inputArray.length !== this.inputNodes.length) {
            throw new Error('Input tensor count mismatch,' +
                ("the frozen model has " + this.inputNodes.length + " placeholders, ") +
                ("while there are " + inputArray.length + " input tensors."));
        }
        return this.inputNodes.reduce(function (map, inputName, i) {
            map[inputName] = inputArray[i];
            return map;
        }, {});
    };
    FrozenModel.prototype.execute = function (inputs, outputs) {
        return this.execute_(inputs, false, outputs);
    };
    FrozenModel.prototype.execute_ = function (inputs, strictInputCheck, outputs) {
        if (strictInputCheck === void 0) { strictInputCheck = true; }
        outputs = outputs || this.outputNodes;
        if (inputs instanceof tfc.Tensor || Array.isArray(inputs)) {
            inputs = this.constructTensorMap(inputs);
        }
        if (this.executor.isControlFlowModel || this.executor.isDynamicShapeModel) {
            throw new Error('The model contains control flow or dynamic shape ops, ' +
                'please use executeAsync method');
        }
        var result = this.executor.execute(this.convertTensorMapToTensorsMap(inputs), strictInputCheck, outputs);
        var keys = Object.keys(result);
        return (Array.isArray(outputs) && outputs.length > 1) ?
            outputs.map(function (node) { return result[node]; }) :
            result[keys[0]];
    };
    FrozenModel.prototype.executeAsync = function (inputs, outputs) {
        return __awaiter(this, void 0, void 0, function () {
            var result, keys;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.executor.isControlFlowModel ||
                            this.executor.isDynamicShapeModel)) {
                            throw new Error('The model does not contain control flow or dynamic shape ops, ' +
                                'please use execute method for better performance.');
                        }
                        outputs = outputs || this.outputNodes;
                        if (inputs instanceof tfc.Tensor || Array.isArray(inputs)) {
                            inputs = this.constructTensorMap(inputs);
                        }
                        return [4, this.executor.executeAsync(this.convertTensorMapToTensorsMap(inputs), outputs)];
                    case 1:
                        result = _a.sent();
                        keys = Object.keys(result);
                        return [2, Array.isArray(outputs) && outputs.length > 1 ?
                                outputs.map(function (node) { return result[node]; }) :
                                result[keys[0]]];
                }
            });
        });
    };
    FrozenModel.prototype.convertTensorMapToTensorsMap = function (map) {
        return Object.keys(map).reduce(function (newMap, key) {
            newMap[key] = [map[key]];
            return newMap;
        }, {});
    };
    FrozenModel.prototype.dispose = function () {
        this.executor.dispose();
    };
    return FrozenModel;
}());
exports.FrozenModel = FrozenModel;
function loadFrozenModel(modelUrl, weightsManifestUrl, requestOption) {
    return __awaiter(this, void 0, void 0, function () {
        var model;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    model = new FrozenModel(modelUrl, weightsManifestUrl, requestOption);
                    return [4, model.load()];
                case 1:
                    _a.sent();
                    return [2, model];
            }
        });
    });
}
exports.loadFrozenModel = loadFrozenModel;

},{"../data/compiled_api":17,"../operations/operation_mapper":55,"./graph_executor":20,"@tensorflow/tfjs-core":64}],20:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var utils_1 = require("../operations/executors/utils");
var operation_executor_1 = require("../operations/operation_executor");
var execution_context_1 = require("./execution_context");
var GraphExecutor = (function () {
    function GraphExecutor(graph) {
        this.graph = graph;
        this.compiledMap = new Map();
        this._weightMap = {};
        this.SEPERATOR = ',';
        this.placeholders = graph.placeholders;
        this._outputs = graph.outputs;
        this.compile();
    }
    Object.defineProperty(GraphExecutor.prototype, "weightMap", {
        get: function () {
            return this._weightMap;
        },
        set: function (weightMap) {
            var weightIds = Object.keys(weightMap).map(function (key) { return weightMap[key].map(function (tensor) { return tensor.id; }); });
            this.weightIds = [].concat.apply([], weightIds);
            this._weightMap = weightMap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "inputs", {
        get: function () {
            return this.placeholders.map(function (node) {
                return {
                    name: node.name,
                    shape: node.params['shape'] ? node.params['shape'].value :
                        undefined,
                    dtype: node.params['dtype'] ? node.params['dtype'].value :
                        undefined
                };
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "outputs", {
        get: function () {
            return this._outputs.map(function (node) {
                return {
                    name: node.name,
                    shape: node.params['shape'] ? node.params['shape'].value :
                        undefined,
                    dtype: node.params['dtype'] ? node.params['dtype'].value :
                        undefined
                };
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "inputNodes", {
        get: function () {
            return this.placeholders.map(function (node) { return node.name; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "outputNodes", {
        get: function () {
            return this.outputs.map(function (node) { return node.name; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "isControlFlowModel", {
        get: function () {
            return this.graph.withControlFlow;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "isDynamicShapeModel", {
        get: function () {
            return this.graph.withDynamicShape;
        },
        enumerable: true,
        configurable: true
    });
    GraphExecutor.prototype.compile = function (startNodes) {
        if (this.graph.withControlFlow || this.graph.withDynamicShape) {
            return;
        }
        var compiledOrder = [];
        var inputs = startNodes || this.graph.placeholders;
        var sortedNodeNames = inputs.map(function (node) { return node.name; }).sort();
        var nameKey = sortedNodeNames.join(this.SEPERATOR);
        if (this.compiledMap.get(nameKey)) {
            return;
        }
        var stack = inputs.concat(this.graph.weights);
        var visited = {};
        while (stack.length > 0) {
            var node = stack.pop();
            visited[node.name] = true;
            compiledOrder.push(node);
            node.children.forEach(function (childNode) {
                if (!visited[childNode.name] && childNode.inputNames.every(function (name) {
                    var nodeName = utils_1.getNodeNameAndIndex(name)[0];
                    return visited[nodeName];
                })) {
                    stack.push(childNode);
                }
            });
        }
        this.compiledMap.set(nameKey, compiledOrder);
    };
    GraphExecutor.prototype.execute = function (inputs, strictInputCheck, outputs) {
        var _this = this;
        if (strictInputCheck === void 0) { strictInputCheck = true; }
        var names = Object.keys(inputs).sort();
        this.checkInput(inputs, strictInputCheck);
        this.checkInputShapeAndType(inputs, strictInputCheck);
        this.compile(names.map(function (name) { return _this.graph.nodes[name]; }));
        var outputNames = this.calculateOutputs(outputs);
        this.checkOutput(this.compiledMap.get(names.join(this.SEPERATOR)), outputNames);
        var tensorArrayMap = {};
        var result = tfjs_core_1.tidy(function () {
            var context = new execution_context_1.ExecutionContext(_this._weightMap, tensorArrayMap);
            var tensorMap = __assign({}, _this.weightMap, inputs);
            var compiledNodes = _this.compiledMap.get(names.join(_this.SEPERATOR));
            for (var i = 0; i < compiledNodes.length; i++) {
                var node = compiledNodes[i];
                if (!tensorMap[node.name]) {
                    tensorMap[node.name] =
                        operation_executor_1.executeOp(node, tensorMap, context);
                }
                if (outputNames.every(function (name) { return !!tensorMap[name]; })) {
                    break;
                }
            }
            return _this.findOutputs(tensorMap, context, outputNames);
        });
        return result;
    };
    GraphExecutor.prototype.executeAsync = function (inputs, outputs) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var tensorArrayMap, context, tensors, results, outputIds, inputIdArray, inputIds;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.checkInput(inputs, false);
                        this.checkInputShapeAndType(inputs, false);
                        tensorArrayMap = {};
                        context = new execution_context_1.ExecutionContext(this._weightMap, tensorArrayMap);
                        return [4, this.executeWithControlFlow(inputs, context)];
                    case 1:
                        tensors = _a.sent();
                        results = this.findOutputs(tensors, context, outputs);
                        outputIds = Object.keys(results).map(function (key) { return results[key].id; });
                        inputIdArray = Object.keys(inputs).map(function (key) { return inputs[key].map(function (input) { return input.id; }); });
                        inputIds = [].concat.apply([], inputIdArray);
                        Object.keys(tensors).forEach(function (key) {
                            var tensorArray = tensors[key];
                            tensorArray.forEach(function (tensor) {
                                if (tensor && outputIds.indexOf(tensor.id) === -1 &&
                                    inputIds.indexOf(tensor.id) === -1 &&
                                    _this.weightIds.indexOf(tensor.id) === -1) {
                                    tensor.dispose();
                                }
                            });
                        });
                        return [2, results];
                }
            });
        });
    };
    GraphExecutor.prototype.executeWithControlFlow = function (inputs, context) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var names, inputNodes, stack, tensorMap, added, promises;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        names = Object.keys(inputs);
                        inputNodes = names.map(function (name) { return _this.graph.nodes[name]; });
                        stack = inputNodes.concat(this.graph.weights).map(function (node) {
                            return { node: node, contexts: context.currentContext };
                        });
                        tensorMap = __assign({}, this.weightMap, inputs);
                        added = {};
                        _a.label = 1;
                    case 1:
                        if (!(stack.length > 0)) return [3, 3];
                        promises = this.processStack(inputNodes, stack, context, tensorMap, added);
                        return [4, Promise.all(promises)];
                    case 2:
                        _a.sent();
                        return [3, 1];
                    case 3: return [2, tensorMap];
                }
            });
        });
    };
    GraphExecutor.prototype.processStack = function (inputNodes, stack, context, tensorMap, added) {
        var _this = this;
        var promises = [];
        var _loop_1 = function () {
            var item = stack.pop();
            context.currentContext = item.contexts;
            var nodeName = '';
            if (item.node.op === 'enter' &&
                utils_1.getParamValue('isConstant', item.node, tensorMap, context)) {
                nodeName = utils_1.getNodeNameAndIndex(item.node.name, context)[0];
            }
            if (inputNodes.indexOf(item.node) === -1) {
                var tensors = operation_executor_1.executeOp(item.node, tensorMap, context);
                if (!nodeName) {
                    nodeName = utils_1.getNodeNameAndIndex(item.node.name, context)[0];
                }
                var currentContext_1 = context.currentContext;
                if (tensors instanceof Promise) {
                    promises.push(tensors.then(function (t) {
                        tensorMap[nodeName] = t;
                        context.currentContext = currentContext_1;
                        _this.processChildNodes(item.node, stack, context, tensorMap, added);
                        return t;
                    }));
                }
                else {
                    tensorMap[nodeName] = tensors;
                    this_1.processChildNodes(item.node, stack, context, tensorMap, added);
                }
            }
            else {
                this_1.processChildNodes(item.node, stack, context, tensorMap, added);
            }
        };
        var this_1 = this;
        while (stack.length > 0) {
            _loop_1();
        }
        return promises;
    };
    GraphExecutor.prototype.processChildNodes = function (node, stack, context, tensorMap, added) {
        node.children.forEach(function (childNode) {
            var nodeName = utils_1.getNodeNameAndIndex(childNode.name, context)[0];
            if (!added[nodeName]) {
                if (childNode.op === 'merge') {
                    if (childNode.inputNames.some(function (name) {
                        return !!utils_1.getTensor(name, tensorMap, context);
                    })) {
                        added[nodeName] = true;
                        stack.push({ contexts: context.currentContext, node: childNode });
                    }
                }
                else if (childNode.inputNames.every(function (name) {
                    return !!utils_1.getTensor(name, tensorMap, context);
                })) {
                    added[nodeName] = true;
                    stack.push({ contexts: context.currentContext, node: childNode });
                }
            }
        });
    };
    GraphExecutor.prototype.calculateOutputs = function (outputs) {
        if (outputs && !(outputs instanceof Array)) {
            outputs = [outputs];
        }
        return (outputs || this.graph.outputs.map(function (node) { return node.name; }));
    };
    GraphExecutor.prototype.findOutputs = function (tensorMap, context, outputs) {
        var requestedOutputs = this.calculateOutputs(outputs);
        return requestedOutputs.reduce(function (map, name) {
            map[name] = utils_1.getTensor(name, tensorMap, context);
            return map;
        }, {});
    };
    GraphExecutor.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.weightMap)
            .forEach(function (key) { return _this.weightMap[key].forEach(function (tensor) { return tensor.dispose(); }); });
    };
    GraphExecutor.prototype.checkInputShapeAndType = function (inputs, strictInputCheck) {
        if (strictInputCheck === void 0) { strictInputCheck = true; }
        this.placeholders.forEach(function (node) {
            var inputTensors = inputs[node.name];
            if (!strictInputCheck && !inputTensors) {
                return;
            }
            var input = inputTensors[0];
            if (node.params['shape'] && node.params['shape'].value) {
                var shape_1 = node.params['shape'].value;
                var match = shape_1.length === input.shape.length &&
                    input.shape.every(function (dim, index) { return shape_1[index] === -1 || shape_1[index] === dim; });
                tfjs_core_1.util.assert(match, "The shape of dict['" + node.name + "'] provided in model.execute(dict) must be [" + shape_1 + "], but was [" + input.shape + "]");
            }
            if (node.params['dtype'] && node.params['dtype'].value) {
                tfjs_core_1.util.assert(input.dtype === node.params['dtype'].value, "The dtype of dict['" + node.name + "'] provided in model.execute(dict) must be " + node.params['dtype'].value + ", but was " + input.dtype);
            }
        });
    };
    GraphExecutor.prototype.checkInput = function (inputs, strictInputCheck) {
        var _this = this;
        if (strictInputCheck === void 0) { strictInputCheck = true; }
        var inputKeys = Object.keys(inputs);
        var missing = [];
        var extra = [];
        this.inputNodes.forEach(function (name) {
            if (inputKeys.indexOf(name) === -1)
                missing.push(name);
        });
        inputKeys.forEach(function (name) {
            if (_this.inputNodes.indexOf(name) === -1)
                extra.push(name);
        });
        var notInGraph = extra.filter(function (name) { return !_this.graph.nodes[name]; });
        if (missing.length > 0 && strictInputCheck) {
            throw new Error("The dict provided in model.execute(dict) has the keys " +
                ("[" + inputKeys + "], but is missing the required keys: [" + missing + "]."));
        }
        if (extra.length > 0 && strictInputCheck) {
            throw new Error("The dict provided in model.execute(dict) has " +
                ("unused keys: [" + extra + "]. Please provide only the following keys: ") +
                ("[" + this.inputNodes + "]."));
        }
        if (notInGraph.length > 0) {
            throw new Error("The dict provided in model.execute(dict) has " +
                ("keys: [" + notInGraph + "] not part of model graph."));
        }
    };
    GraphExecutor.prototype.checkOutput = function (compiledNodes, outputs) {
        var compiledNodeNames = compiledNodes.map(function (node) { return node.name; });
        var extra = [];
        outputs.forEach(function (name) {
            if (compiledNodeNames.indexOf(name) === -1)
                extra.push(name);
        });
        if (extra.length > 0) {
            throw new Error("The following outputs are not be generated by the execution: " +
                ("[" + extra + "]."));
        }
    };
    return GraphExecutor;
}());
exports.GraphExecutor = GraphExecutor;

},{"../operations/executors/utils":38,"../operations/operation_executor":54,"./execution_context":18,"@tensorflow/tfjs-core":64}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var TensorArray = (function () {
    function TensorArray(name, dtype, maxSize, elementShape, identicalElementShapes, dynamicSize, clearAfterRead) {
        this.name = name;
        this.dtype = dtype;
        this.maxSize = maxSize;
        this.elementShape = elementShape;
        this.identicalElementShapes = identicalElementShapes;
        this.dynamicSize = dynamicSize;
        this.clearAfterRead = clearAfterRead;
        this.tensors = [];
        this.closed_ = false;
        this.id = TensorArray.nextId++;
    }
    Object.defineProperty(TensorArray.prototype, "closed", {
        get: function () {
            return this.closed_;
        },
        enumerable: true,
        configurable: true
    });
    TensorArray.prototype.clearAndClose = function () {
        this.tensors.forEach(function (tensor) { return tensor.tensor.dispose(); });
        this.tensors = [];
        this.closed_ = true;
    };
    TensorArray.prototype.size = function () {
        return this.tensors.length;
    };
    TensorArray.prototype.read = function (index) {
        if (this.closed_) {
            throw new Error("TensorArray " + this.name + " has already been closed.");
        }
        if (index < 0 || index >= this.tensors.length) {
            throw new Error("Tried to read from index " + index + ", but array size is: " + this.tensors.length);
        }
        var tensorWithState = this.tensors[index];
        if (tensorWithState.cleared) {
            throw new Error("TensorArray " + this.name + ": Could not read index " + index + " twice because it was cleared after a previous read " +
                "(perhaps try setting clear_after_read = false?).");
        }
        if (this.clearAfterRead) {
            tensorWithState.cleared = true;
        }
        tensorWithState.read = true;
        return tensorWithState.tensor;
    };
    TensorArray.prototype.readMany = function (indices) {
        var _this = this;
        return indices.map(function (index) { return _this.read(index); });
    };
    TensorArray.prototype.write = function (index, tensor) {
        if (this.closed_) {
            throw new Error("TensorArray " + this.name + " has already been closed.");
        }
        if (index < 0 || !this.dynamicSize && index >= this.maxSize) {
            throw new Error("Tried to write to index " + index + ", but array is not resizeable and size is: " + this.maxSize);
        }
        var t = this.tensors[index] || {};
        if (tensor.dtype !== this.dtype) {
            throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + index + ",\n          because the value dtype is " + tensor.dtype + ", but TensorArray dtype is " + this.dtype + ".");
        }
        if (this.size() === 0 && this.elementShape.length === 0) {
            this.elementShape = tensor.shape;
        }
        this.assertShapesMatch(this.elementShape, tensor.shape, "TensorArray " + this.name + ": Could not write to TensorArray index " + index + ".");
        if (t && t.read) {
            throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + index + ", because it has already been read.");
        }
        if (t && t.written) {
            throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + index + ", because it has already been written.");
        }
        t.tensor = tensor;
        t.written = true;
        this.tensors[index] = t;
    };
    TensorArray.prototype.writeMany = function (indices, tensors) {
        var _this = this;
        if (indices.length !== tensors.length) {
            throw new Error("TensorArray " + this.name + ": could not write multiple tensors," +
                ("because the index size: " + indices.length + " is not the same as tensors size: " + tensors.length + "."));
        }
        indices.forEach(function (i, index) { return _this.write(i, tensors[index]); });
    };
    TensorArray.prototype.gather = function (indices, dtype) {
        if (!!dtype && dtype !== this.dtype) {
            throw new Error("TensorArray dtype is " + this.dtype + " but gather requested dtype " + dtype);
        }
        if (!indices) {
            indices = [];
            for (var i = 0; i < this.size(); i++) {
                indices.push(i);
            }
        }
        if (indices.length === 0) {
            return tfjs_core_1.tensor([], [0].concat(this.elementShape));
        }
        var tensors = this.readMany(indices);
        this.assertShapesMatch(this.elementShape, tensors[0].shape, 'TensorArray shape mismatch: ');
        return tfjs_core_1.stack(tensors, 0);
    };
    TensorArray.prototype.concat = function (dtype) {
        if (!!dtype && dtype !== this.dtype) {
            throw new Error("TensorArray dtype is " + this.dtype + " but concat requested dtype " + dtype);
        }
        if (this.size() === 0) {
            return tfjs_core_1.tensor([], [0].concat(this.elementShape));
        }
        var indices = [];
        for (var i = 0; i < this.size(); i++) {
            indices.push(i);
        }
        var tensors = this.readMany(indices);
        this.assertShapesMatch(this.elementShape, tensors[0].shape, "TensorArray shape mismatch: tensor array shape (" + this.elementShape + ") vs first tensor shape (" + tensors[0].shape + ")");
        return tfjs_core_1.concat(tensors, 0);
    };
    TensorArray.prototype.scatter = function (indices, tensor) {
        if (tensor.dtype !== this.dtype) {
            throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + tensor.dtype);
        }
        if (indices.length !== tensor.shape[0]) {
            throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + indices.length + " vs. " + tensor.shape[0]);
        }
        var maxIndex = Math.max.apply(Math, indices);
        if (!this.dynamicSize && maxIndex >= this.maxSize) {
            throw new Error("Max index must be < array size (" + maxIndex + "  vs. " + this.maxSize + ")");
        }
        this.writeMany(indices, tfjs_core_1.unstack(tensor, 0));
    };
    TensorArray.prototype.split = function (length, tensor) {
        var _this = this;
        if (tensor.dtype !== this.dtype) {
            throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + tensor.dtype);
        }
        var totalLength = 0;
        var cumulativeLengths = length.map(function (len) {
            totalLength += len;
            return totalLength;
        });
        if (totalLength !== tensor.shape[0]) {
            throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + totalLength + ", and tensor's shape is: " + tensor.shape);
        }
        if (!this.dynamicSize && length.length !== this.maxSize) {
            throw new Error("TensorArray's size is not equal to the size of lengths (" + this.maxSize + " vs. " + length.length + "), " +
                'and the TensorArray is not marked as dynamically resizeable');
        }
        var elementPerRow = totalLength === 0 ? 0 : tensor.size / totalLength;
        var tensors = [];
        tfjs_core_1.tidy(function () {
            tensor = tensor.reshape([1, totalLength, elementPerRow]);
            for (var i = 0; i < length.length; ++i) {
                var previousLength = (i === 0) ? 0 : cumulativeLengths[i - 1];
                var indices_1 = [0, previousLength, 0];
                var sizes = [1, length[i], elementPerRow];
                tensors[i] = tfjs_core_1.slice(tensor, indices_1, sizes).reshape(_this.elementShape);
            }
            return tensors;
        });
        var indices = [];
        for (var i = 0; i < length.length; i++) {
            indices[i] = i;
        }
        this.writeMany(indices, tensors);
    };
    TensorArray.prototype.assertShapesMatch = function (shapeA, shapeB, errorMessagePrefix) {
        if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
        tfjs_core_1.util.assert(this.arraysEqual(shapeA, shapeB), errorMessagePrefix + (" Shapes " + shapeA + " and " + shapeB + " must match"));
    };
    TensorArray.prototype.arraysEqual = function (n1, n2) {
        if (n1.length !== n2.length) {
            return false;
        }
        for (var i = 0; i < n1.length; i++) {
            if (n1[i] !== -1 && n2[i] !== -1 && n1[i] !== n2[i]) {
                return false;
            }
        }
        return true;
    };
    TensorArray.nextId = 0;
    return TensorArray;
}());
exports.TensorArray = TensorArray;

},{"@tensorflow/tfjs-core":64}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var frozen_model_1 = require("./executor/frozen_model");
exports.FrozenModel = frozen_model_1.FrozenModel;
exports.loadFrozenModel = frozen_model_1.loadFrozenModel;
var version_1 = require("./version");
exports.version_converter = version_1.version;

},{"./executor/frozen_model":19,"./version":56}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'add': {
            return [tfc.add(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'addN': {
            return [tfc.addN(utils_1.getParamValue('tensors', node, tensorMap, context))];
        }
        case 'mod':
            return [tfc.mod(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        case 'mul':
            return [tfc.mul(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        case 'div': {
            return [tfc.div(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'floorDiv': {
            return [tfc.floorDiv(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'sub': {
            return [tfc.sub(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'minimum': {
            return [tfc.minimum(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'maximum': {
            return [tfc.maximum(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'pow': {
            return [tfc.pow(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'squaredDifference': {
            return [tfc.squaredDifference(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'arithmetic';

},{"./utils":38,"@tensorflow/tfjs-core":64}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'abs':
            return [tfc.abs(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'acos':
            return [tfc.acos(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'acosh':
            return [tfc.acosh(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'asin':
            return [tfc.asin(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'asinh':
            return [tfc.asinh(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'atan':
            return [tfc.atan(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'atanh':
            return [tfc.atanh(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'ceil':
            return [tfc.ceil(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'cos':
            return [tfc.cos(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'cosh':
            return [tfc.cosh(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'elu':
            return [tfc.elu(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'erf':
            return [tfc.erf(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'exp':
            return [tfc.exp(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'expm1': {
            return [tfc.expm1(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'floor':
            return [tfc.floor(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'log':
            return [tfc.log(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'log1p': {
            return [tfc.log1p(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'neg':
            return [tfc.neg(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'reciprocal': {
            return [tfc.reciprocal(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'relu':
            return [tfc.relu(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'round': {
            return [tfc.round(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'selu':
            return [tfc.selu(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'sigmoid':
            return [tfc.sigmoid(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'sin':
            return [tfc.sin(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'sign': {
            return [tfc.sign(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'sinh': {
            return [tfc.sinh(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'softplus': {
            return [tfc.softplus(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'sqrt': {
            return [tfc.sqrt(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'square': {
            return [tfc.square(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'tanh': {
            return [tfc.tanh(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'tan':
            return [tfc.tan(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'clipByValue':
            return [tfc.clipByValue(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('clipValueMin', node, tensorMap, context), utils_1.getParamValue('clipValueMax', node, tensorMap, context))];
        case 'rsqrt':
            return [tfc.div(tfc.scalar(1.0, 'float32'), tfc.sqrt(utils_1.getTensor(node.inputNames[0], tensorMap, context)))];
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'basic_math';

},{"./utils":38,"@tensorflow/tfjs-core":64}],25:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var tensor_array_1 = require("../../executor/tensor_array");
var utils_1 = require("./utils");
function executeOp(node, tensorMap, context) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, pred, data_1, inputName, frameId, data, tensor, input, size, dtype, elementShape, dynamicSize, clearAfterRead, identicalElementShapes, name_1, tensorArray, id, index, writeTensor, writeTensorArray, readId, readIndex, readTensorArray, gatherId, gatherIndices, gatherDtype, gatherTensorArray, scatterId, scatterIndices, scatterTensor, scatterTensorArray, concatId, concatTensorArray, concatDtype, splitId, splitTensor, lengths, splitTensorArray, sizeId, sizeTensorArray, closeId, closeTensorArray;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = node.op;
                    switch (_a) {
                        case 'loopCond': return [3, 1];
                        case 'switch': return [3, 2];
                        case 'merge': return [3, 4];
                        case 'enter': return [3, 5];
                        case 'exit': return [3, 6];
                        case 'nextIteration': return [3, 7];
                        case 'tensorArray': return [3, 8];
                        case 'tensorArrayWrite': return [3, 9];
                        case 'tensorArrayRead': return [3, 10];
                        case 'tensorArrayGather': return [3, 11];
                        case 'tensorArrayScatter': return [3, 12];
                        case 'tensorArrayConcat': return [3, 13];
                        case 'tensorArraySplit': return [3, 14];
                        case 'tensorArraySize': return [3, 15];
                        case 'tensorArrayClose': return [3, 16];
                    }
                    return [3, 17];
                case 1: return [2, [utils_1.getParamValue('pred', node, tensorMap, context)]];
                case 2:
                    pred = utils_1.getParamValue('pred', node, tensorMap, context);
                    data_1 = utils_1.getParamValue('data', node, tensorMap, context);
                    return [4, pred.data()];
                case 3: return [2, (_b.sent())[0] ? [undefined, data_1] : [data_1, undefined]];
                case 4:
                    inputName = node.inputNames.find(function (name) { return utils_1.getTensor(name, tensorMap, context) !== undefined; });
                    return [2, inputName ? [utils_1.getTensor(inputName, tensorMap, context)] : undefined];
                case 5:
                    frameId = utils_1.getParamValue('frameName', node, tensorMap, context);
                    data = utils_1.getParamValue('tensor', node, tensorMap, context);
                    context.enterFrame(frameId);
                    return [2, [data]];
                case 6:
                    tensor = utils_1.getParamValue('tensor', node, tensorMap, context);
                    context.exitFrame();
                    return [2, [tensor]];
                case 7:
                    input = utils_1.getParamValue('tensor', node, tensorMap, context);
                    context.nextIteration();
                    return [2, [input]];
                case 8:
                    size = utils_1.getParamValue('size', node, tensorMap, context);
                    dtype = utils_1.getParamValue('dtype', node, tensorMap, context);
                    elementShape = utils_1.getParamValue('elementShape', node, tensorMap, context);
                    dynamicSize = utils_1.getParamValue('dynamicSize', node, tensorMap, context);
                    clearAfterRead = utils_1.getParamValue('clearAfterRead', node, tensorMap, context);
                    identicalElementShapes = utils_1.getParamValue('identicalElementShapes', node, tensorMap, context);
                    name_1 = utils_1.getParamValue('name', node, tensorMap, context);
                    tensorArray = new tensor_array_1.TensorArray(name_1, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);
                    context.addTensorArray(tensorArray);
                    return [2, [tfjs_core_1.scalar(tensorArray.id), tfjs_core_1.scalar(1.0)]];
                case 9:
                    id = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);
                    index = utils_1.getParamValue('index', node, tensorMap, context);
                    writeTensor = utils_1.getParamValue('tensor', node, tensorMap, context);
                    writeTensorArray = context.getTensorArray(id);
                    writeTensorArray.write(index, writeTensor);
                    return [2, [tfjs_core_1.scalar(1.0)]];
                case 10:
                    readId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);
                    readIndex = utils_1.getParamValue('index', node, tensorMap, context);
                    readTensorArray = context.getTensorArray(readId);
                    return [2, [readTensorArray.read(readIndex)]];
                case 11:
                    gatherId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);
                    gatherIndices = utils_1.getParamValue('indices', node, tensorMap, context);
                    gatherDtype = utils_1.getParamValue('dtype', node, tensorMap, context);
                    gatherTensorArray = context.getTensorArray(gatherId);
                    return [2, [gatherTensorArray.gather(gatherIndices, gatherDtype)]];
                case 12:
                    scatterId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);
                    scatterIndices = utils_1.getParamValue('indices', node, tensorMap, context);
                    scatterTensor = utils_1.getParamValue('tensor', node, tensorMap, context);
                    scatterTensorArray = context.getTensorArray(scatterId);
                    scatterTensorArray.scatter(scatterIndices, scatterTensor);
                    return [2, [tfjs_core_1.scalar(1.0)]];
                case 13:
                    concatId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);
                    concatTensorArray = context.getTensorArray(concatId);
                    concatDtype = utils_1.getParamValue('dtype', node, tensorMap, context);
                    return [2, [concatTensorArray.concat(concatDtype)]];
                case 14:
                    splitId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);
                    splitTensor = utils_1.getParamValue('tensor', node, tensorMap, context);
                    lengths = utils_1.getParamValue('lengths', node, tensorMap, context);
                    splitTensorArray = context.getTensorArray(splitId);
                    splitTensorArray.split(lengths, splitTensor);
                    return [2, [tfjs_core_1.scalar(1.0)]];
                case 15:
                    sizeId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);
                    sizeTensorArray = context.getTensorArray(sizeId);
                    return [2, [tfjs_core_1.scalar(sizeTensorArray.size(), 'int32')]];
                case 16:
                    closeId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);
                    closeTensorArray = context.getTensorArray(closeId);
                    closeTensorArray.clearAndClose();
                    return [2, []];
                case 17: throw TypeError("Node type " + node.op + " is not implemented");
            }
        });
    });
}
exports.executeOp = executeOp;
exports.CATEGORY = 'control';

},{"../../executor/tensor_array":21,"./utils":38,"@tensorflow/tfjs-core":64}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'conv1d': {
            var stride = utils_1.getParamValue('stride', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)
                .toUpperCase();
            var dilation = utils_1.getParamValue('dilation', node, tensorMap, context);
            return [tfc.conv1d(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), stride, pad, dataFormat, dilation)];
        }
        case 'conv2d': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)
                .toUpperCase();
            var dilations = utils_1.getParamValue('dilations', node, tensorMap, context);
            return [tfc.conv2d(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[0], dilations[1]])];
        }
        case 'conv2dTranspose': {
            var shape = utils_1.getParamValue('outputShape', node, tensorMap, context);
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            return [tfc.conv2dTranspose(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), shape, [stride[1], stride[2]], pad)];
        }
        case 'depthwiseConv2d': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var dilations = utils_1.getParamValue('dilations', node, tensorMap, context);
            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)
                .toUpperCase();
            return [tfc.depthwiseConv2d(utils_1.getParamValue('input', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[0], dilations[1]])];
        }
        case 'avgPool': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var kernelSize = utils_1.getParamValue('kernelSize', node, tensorMap, context);
            return [tfc.avgPool(utils_1.getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];
        }
        case 'maxPool': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var kernelSize = utils_1.getParamValue('kernelSize', node, tensorMap, context);
            return [tfc.maxPool(utils_1.getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'convolution';

},{"./utils":38,"@tensorflow/tfjs-core":64}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'fill': {
            var shape = utils_1.getParamValue('shape', node, tensorMap, context);
            var dtype = utils_1.getParamValue('dtype', node, tensorMap, context);
            var value = utils_1.getParamValue('value', node, tensorMap, context);
            return [tfc.fill(shape, value, dtype)];
        }
        case 'linspace': {
            var start = utils_1.getParamValue('start', node, tensorMap, context);
            var stop_1 = utils_1.getParamValue('stop', node, tensorMap, context);
            var num = utils_1.getParamValue('num', node, tensorMap, context);
            return [tfc.linspace(start, stop_1, num)];
        }
        case 'oneHot': {
            var indices = utils_1.getParamValue('indices', node, tensorMap, context);
            var depth = utils_1.getParamValue('depth', node, tensorMap, context);
            var onValue = utils_1.getParamValue('onValue', node, tensorMap, context);
            var offValue = utils_1.getParamValue('offValue', node, tensorMap, context);
            return [tfc.oneHot(indices, depth, onValue, offValue)];
        }
        case 'ones': {
            return [tfc.ones(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'onesLike': {
            return [tfc.onesLike(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'randomUniform': {
            return [tfc.randomUniform(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('minval', node, tensorMap, context), utils_1.getParamValue('maxval', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'range': {
            var start = utils_1.getParamValue('start', node, tensorMap, context);
            var stop_2 = utils_1.getParamValue('stop', node, tensorMap, context);
            var step = utils_1.getParamValue('step', node, tensorMap, context);
            return [tfc.range(start, stop_2, step, utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'truncatedNormal': {
            var shape = utils_1.getParamValue('shape', node, tensorMap, context);
            var mean = utils_1.getParamValue('mean', node, tensorMap, context);
            var stdDev = utils_1.getParamValue('stdDev', node, tensorMap, context);
            var seed = utils_1.getParamValue('seed', node, tensorMap, context);
            return [tfc.truncatedNormal(shape, mean, stdDev, utils_1.getParamValue('dtype', node, tensorMap, context), seed)];
        }
        case 'zeros': {
            return [tfc.zeros(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'zerosLike': {
            return [tfc.zerosLike(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'creation';

},{"./utils":38,"@tensorflow/tfjs-core":64}],28:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
function executeOp(node, tensorMap, context) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, boxes, scores, maxOutputSize, iouThreshold, scoreThreshold;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = node.op;
                    switch (_a) {
                        case 'nonMaxSuppression': return [3, 1];
                        case 'whereAsync': return [3, 3];
                    }
                    return [3, 5];
                case 1:
                    boxes = utils_1.getParamValue('boxes', node, tensorMap, context);
                    scores = utils_1.getParamValue('scores', node, tensorMap, context);
                    maxOutputSize = utils_1.getParamValue('maxOutputSize', node, tensorMap, context);
                    iouThreshold = utils_1.getParamValue('iouThreshold', node, tensorMap, context);
                    scoreThreshold = utils_1.getParamValue('scoreThreshold', node, tensorMap, context);
                    return [4, tfc.image.nonMaxSuppressionAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold)];
                case 2: return [2, [_b.sent()]];
                case 3: return [4, tfc.whereAsync(utils_1.getParamValue('condition', node, tensorMap, context))];
                case 4: return [2, [_b.sent()]];
                case 5: throw TypeError("Node type " + node.op + " is not implemented");
            }
        });
    });
}
exports.executeOp = executeOp;
exports.CATEGORY = 'dynamic';

},{"./utils":38,"@tensorflow/tfjs-core":64}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'topK': {
            var x = utils_1.getParamValue('x', node, tensorMap, context);
            var k = utils_1.getParamValue('k', node, tensorMap, context);
            var sorted = utils_1.getParamValue('sorted', node, tensorMap, context);
            var result = tfc.topk(x, k, sorted);
            return [result.values, result.indices];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'evaluation';

},{"./utils":38,"@tensorflow/tfjs-core":64}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'const': {
            return tensorMap[node.name];
        }
        case 'placeholder':
            var def = utils_1.getParamValue('default', node, tensorMap, context);
            return [utils_1.getTensor(node.name, tensorMap, context) || def];
        case 'identity':
        case 'stopGradient':
        case 'fakeQuantWithMinMaxVars':
            return [utils_1.getParamValue('x', node, tensorMap, context)];
        case 'snapshot':
            var snapshot = utils_1.getParamValue('x', node, tensorMap, context);
            return [snapshot.clone()];
        case 'shape':
            return [tfc.tensor1d(utils_1.getParamValue('x', node, tensorMap, context).shape, 'int32')];
        case 'shapeN':
            return utils_1.getParamValue('x', node, tensorMap, context)
                .map(function (t) { return tfc.tensor1d(t.shape); });
        case 'size':
            return [tfc.scalar(utils_1.getParamValue('x', node, tensorMap, context).size, 'int32')];
        case 'rank':
            return [tfc.scalar(utils_1.getParamValue('x', node, tensorMap, context).rank, 'int32')];
        case 'noop':
            return [];
        case 'print':
            var input = utils_1.getParamValue('x', node, tensorMap, context);
            var data = utils_1.getParamValue('data', node, tensorMap, context);
            var message = utils_1.getParamValue('message', node, tensorMap, context);
            var summarize = utils_1.getParamValue('summarize', node, tensorMap, context);
            console.warn('The graph has a tf.print() operation,' +
                'usually used for debugging, which slows down performance.');
            console.log(message);
            for (var i = 0; i < data.length; i++) {
                console.log(Array.prototype.slice.call(data[0].dataSync()).slice(0, summarize));
            }
            return [input];
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'graph';

},{"./utils":38,"@tensorflow/tfjs-core":64}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'resizeBilinear': {
            var images = utils_1.getParamValue('images', node, tensorMap, context);
            var size = utils_1.getParamValue('size', node, tensorMap, context);
            var alignCorners = utils_1.getParamValue('alignCorners', node, tensorMap, context);
            return [tfc.image.resizeBilinear(images, [size[0], size[1]], alignCorners)];
        }
        case 'resizeNearestNeighbor': {
            var images = utils_1.getParamValue('images', node, tensorMap, context);
            var size = utils_1.getParamValue('size', node, tensorMap, context);
            var alignCorners = utils_1.getParamValue('alignCorners', node, tensorMap, context);
            return [tfc.image.resizeNearestNeighbor(images, [size[0], size[1]], alignCorners)];
        }
        case 'cropAndResize': {
            var image = utils_1.getParamValue('image', node, tensorMap, context);
            var boxes = utils_1.getParamValue('boxes', node, tensorMap, context);
            var boxInd = utils_1.getParamValue('boxInd', node, tensorMap, context);
            var cropSize = utils_1.getParamValue('cropSize', node, tensorMap, context);
            var method = utils_1.getParamValue('method', node, tensorMap, context);
            var extrapolationValue = utils_1.getParamValue('extrapolationValue', node, tensorMap, context);
            return [tfc.image.cropAndResize(image, boxes, boxInd, cropSize, method, extrapolationValue)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'image';

},{"./utils":38,"@tensorflow/tfjs-core":64}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'equal': {
            return [tfc.equal(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'notEqual': {
            return [tfc.notEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'greater': {
            return [tfc.greater(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'greaterEqual': {
            return [tfc.greaterEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'less': {
            return [tfc.less(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'lessEqual': {
            return [tfc.lessEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'logicalAnd': {
            return [tfc.logicalAnd(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'logicalNot': {
            return [tfc.logicalNot(utils_1.getParamValue('a', node, tensorMap, context))];
        }
        case 'logicalOr': {
            return [tfc.logicalOr(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'where': {
            return [tfc.where(utils_1.getParamValue('condition', node, tensorMap, context), utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'logical';

},{"./utils":38,"@tensorflow/tfjs-core":64}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'matMul':
            return [tfc.matMul(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context), utils_1.getParamValue('transposeA', node, tensorMap, context), utils_1.getParamValue('transposeB', node, tensorMap, context))];
        case 'transpose':
            return [tfc.transpose(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('perm', node, tensorMap, context))];
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'matrices';

},{"./utils":38,"@tensorflow/tfjs-core":64}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'batchNormalization': {
            return [tfc.batchNormalization(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('mean', node, tensorMap, context), utils_1.getParamValue('variance', node, tensorMap, context), utils_1.getParamValue('epsilon', node, tensorMap, context), utils_1.getParamValue('scale', node, tensorMap, context), utils_1.getParamValue('offset', node, tensorMap, context))];
        }
        case 'localResponseNormalization': {
            return [tfc.localResponseNormalization(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('radius', node, tensorMap, context), utils_1.getParamValue('bias', node, tensorMap, context), utils_1.getParamValue('alpha', node, tensorMap, context), utils_1.getParamValue('beta', node, tensorMap, context))];
        }
        case 'softmax': {
            return [tfc.softmax(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'normalization';

},{"./utils":38,"@tensorflow/tfjs-core":64}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'max': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.max(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'mean': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.mean(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'min': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.min(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'sum': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.sum(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'all': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.all(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'any': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.any(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'argMax': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            return [tfc.argMax(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        case 'argMin': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            return [tfc.argMin(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        case 'prod': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.prod(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'reduction';

},{"./utils":38,"@tensorflow/tfjs-core":64}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'concat': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var inputs = utils_1.getParamValue('tensors', node, tensorMap, context);
            return [tfc.concat(inputs, axis)];
        }
        case 'gather': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var input = utils_1.getParamValue('x', node, tensorMap, context);
            var indices = utils_1.getParamValue('indices', node, tensorMap, context);
            return [tfc.gather(input, indices, axis)];
        }
        case 'reverse': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var input = utils_1.getParamValue('x', node, tensorMap, context);
            return [tfc.reverse(input, axis)];
        }
        case 'slice': {
            var begin = utils_1.getParamValue('begin', node, tensorMap, context);
            var size = utils_1.getParamValue('size', node, tensorMap, context);
            return [tfc.slice(utils_1.getParamValue('x', node, tensorMap, context), begin, size)];
        }
        case 'stridedSlice': {
            var begin = utils_1.getParamValue('begin', node, tensorMap, context);
            var end = utils_1.getParamValue('end', node, tensorMap, context);
            var strides = utils_1.getParamValue('strides', node, tensorMap, context);
            var beginMask = utils_1.getParamValue('beginMask', node, tensorMap, context);
            var endMask = utils_1.getParamValue('endMask', node, tensorMap, context);
            var ellipsisMask = utils_1.getParamValue('ellipsisMask', node, tensorMap, context);
            var newAxisMask = utils_1.getParamValue('newAxisMask', node, tensorMap, context);
            var shrinkAxisMask = utils_1.getParamValue('shrinkAxisMask', node, tensorMap, context);
            var tensor = utils_1.getParamValue('x', node, tensorMap, context);
            if (begin.length === 1 && tensor.shape.length > 1) {
                for (var i = 1; i < tensor.shape.length; i++) {
                    begin.push(0);
                    end.push(tensor.shape[i]);
                    strides.push(strides[0]);
                }
            }
            return [tfc.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];
        }
        case 'stack': {
            return tfc.tidy(function () {
                var axis = utils_1.getParamValue('axis', node, tensorMap, context);
                var tensors = utils_1.getParamValue('tensors', node, tensorMap, context);
                var shape = tensors[0].shape;
                var squeezedShape = tensors[0].squeeze().shape;
                var mapped = tensors.map(function (tensor) {
                    var sameShape = tfc.util.arraysEqual(tensor.shape, shape);
                    if (!sameShape &&
                        !tfc.util.arraysEqual(tensor.squeeze().shape, squeezedShape)) {
                        throw new Error('the input tensors shape does not match');
                    }
                    return sameShape ? tensor : tensor.reshape(shape);
                });
                return [tfc.stack(mapped, axis)];
            });
        }
        case 'unstack': {
            return tfc.tidy(function () {
                var axis = utils_1.getParamValue('axis', node, tensorMap, context);
                var tensor = utils_1.getParamValue('tensor', node, tensorMap, context);
                return tfc.unstack(tensor, axis);
            });
        }
        case 'tile': {
            var reps = utils_1.getParamValue('reps', node, tensorMap, context);
            return [tfc.tile(utils_1.getParamValue('x', node, tensorMap, context), reps)];
        }
        case 'split': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var numOrSizeSplits = utils_1.getParamValue('numOrSizeSplits', node, tensorMap, context);
            return tfc.split(utils_1.getParamValue('x', node, tensorMap, context), numOrSizeSplits, axis);
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'slice_join';

},{"./utils":38,"@tensorflow/tfjs-core":64}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'cast': {
            return [tfc.cast(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'expandDims': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            return [tfc.expandDims(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        case 'squeeze': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            return [tfc.squeeze(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        case 'reshape': {
            return [tfc.reshape(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('shape', node, tensorMap, context))];
        }
        case 'pad': {
            return [tfc.pad(utils_1.getParamValue('x', node, tensorMap, context), utils_1.split(utils_1.getParamValue('padding', node, tensorMap, context), 2), utils_1.getParamValue('constantValue', node, tensorMap, context))];
        }
        case 'spaceToBatchND': {
            var blockShape = utils_1.getParamValue('blockShape', node, tensorMap, context);
            var paddings = utils_1.split(utils_1.getParamValue('paddings', node, tensorMap, context), 2);
            return [tfc.spaceToBatchND(utils_1.getParamValue('x', node, tensorMap, context), blockShape, paddings)];
        }
        case 'batchToSpaceND': {
            var blockShape = utils_1.getParamValue('blockShape', node, tensorMap, context);
            var crops = utils_1.split(utils_1.getParamValue('crops', node, tensorMap, context), 2);
            return [tfc.batchToSpaceND(utils_1.getParamValue('x', node, tensorMap, context), blockShape, crops)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'transformation';

},{"./utils":38,"@tensorflow/tfjs-core":64}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getParamValue(paramName, node, tensorMap, context) {
    var param = node.params[paramName];
    if (param && param.inputIndex !== undefined) {
        if (param.type === 'tensor') {
            return getTensor(node.inputNames[param.inputIndex], tensorMap, context);
        }
        if (param.type === 'tensors') {
            var inputs = param.inputIndex === 0 ?
                (param.inputParamLength === 0 ?
                    node.inputNames :
                    node.inputNames.slice(param.inputIndex, -param.inputParamLength)) :
                node.inputNames.splice(param.inputIndex);
            return inputs.map(function (name) { return getTensor(name, tensorMap, context); });
        }
        var data = Array.prototype.slice.call(getTensor(node.inputNames.slice(param.inputIndex)[0], tensorMap, context)
            .dataSync());
        return param.type === 'number' ? data[0] : data;
    }
    return param && param.value;
}
exports.getParamValue = getParamValue;
function getTensor(name, tensorsMap, context) {
    var _a = parseNodeName(name), nodeName = _a[0], index = _a[1];
    var contextId = context.currentContextIds.find(function (contextId) {
        return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];
    });
    return contextId !== undefined ?
        tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] :
        undefined;
}
exports.getTensor = getTensor;
function getNodeNameAndIndex(inputName, context) {
    var _a = parseNodeName(inputName), nodeName = _a[0], index = _a[1];
    return [
        getNodeNameWithContextId(nodeName, context && context.currentContextId),
        index
    ];
}
exports.getNodeNameAndIndex = getNodeNameAndIndex;
function getNodeNameWithContextId(name, contextId) {
    return !!contextId ? name + "-" + contextId : name;
}
function parseNodeName(name) {
    var index = name.lastIndexOf(':');
    if (index === -1)
        return [name, 0];
    var nodeName = name.substring(0, index);
    return [nodeName, Number(name.substring(index + 1))];
}
exports.parseNodeName = parseNodeName;
function split(arr, size) {
    var res = [];
    for (var i = 0; i < arr.length; i += size) {
        res.push(arr.slice(i, i + size));
    }
    return res;
}
exports.split = split;

},{}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'Add',
        'dlOpName': 'add',
        'category': 'arithmetic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'AddN',
        'dlOpName': 'addN',
        'category': 'arithmetic',
        'params': [{
                'tfInputIndex': 0,
                'tfInputParamLength': 0,
                'dlParamName': 'tensors',
                'type': 'tensors'
            }]
    },
    {
        'tfOpName': 'BiasAdd',
        'dlOpName': 'add',
        'category': 'arithmetic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Sub',
        'dlOpName': 'sub',
        'category': 'arithmetic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'RealDiv',
        'dlOpName': 'div',
        'category': 'arithmetic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Div',
        'dlOpName': 'div',
        'category': 'arithmetic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'FloorDiv',
        'dlOpName': 'floorDiv',
        'category': 'arithmetic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Mul',
        'dlOpName': 'mul',
        'category': 'arithmetic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Maximum',
        'dlOpName': 'maximum',
        'category': 'arithmetic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }
        ]
    },
    {
        'tfOpName': 'Minimum',
        'dlOpName': 'minimum',
        'category': 'arithmetic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }
        ]
    },
    {
        'tfOpName': 'Pow',
        'dlOpName': 'pow',
        'category': 'arithmetic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'SquaredDifference',
        'dlOpName': 'squaredDifference',
        'category': 'arithmetic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Mod',
        'dlOpName': 'mod',
        'category': 'arithmetic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'FloorMod',
        'dlOpName': 'mod',
        'category': 'arithmetic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    }
];

},{}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'Abs',
        'dlOpName': 'abs',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Acos',
        'dlOpName': 'acos',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Asin',
        'dlOpName': 'asin',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'atan',
        'dlOpName': 'atan',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Ceil',
        'dlOpName': 'ceil',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'ClipByValue',
        'dlOpName': 'clipByValue',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'clip_value_min',
                'dlParamName': 'clipValueMin',
                'type': 'number'
            },
            {
                'tfParamName': 'clip_value_max',
                'dlParamName': 'clipValueMax',
                'type': 'number'
            }
        ]
    },
    {
        'tfOpName': 'Cos',
        'dlOpName': 'cos',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Cosh',
        'dlOpName': 'cosh',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Elu',
        'dlOpName': 'elu',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Exp',
        'dlOpName': 'exp',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Floor',
        'dlOpName': 'floor',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Log',
        'dlOpName': 'log',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Neg',
        'dlOpName': 'neg',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Relu',
        'dlOpName': 'relu',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Relu6',
        'dlOpName': 'clipByValue',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            },
            { 'dlParamName': 'clipValueMin', 'type': 'number', 'defaultValue': 0 },
            { 'dlParamName': 'clipValueMax', 'type': 'number', 'defaultValue': 6 }
        ]
    },
    {
        'tfOpName': 'Selu',
        'dlOpName': 'selu',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Sigmoid',
        'dlOpName': 'sigmoid',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Sin',
        'dlOpName': 'sin',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Sinh',
        'dlOpName': 'sinh',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Sqrt',
        'dlOpName': 'sqrt',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Rsqrt',
        'dlOpName': 'rsqrt',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Square',
        'dlOpName': 'square',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Tan',
        'dlOpName': 'tan',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Tanh',
        'dlOpName': 'tanh',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Sign',
        'dlOpName': 'sign',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Round',
        'dlOpName': 'round',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Expm1',
        'dlOpName': 'expm1',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Log1p',
        'dlOpName': 'log1p',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Reciprocal',
        'dlOpName': 'reciprocal',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Reciprocal',
        'dlOpName': 'reciprocal',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Softplus',
        'dlOpName': 'softplus',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Asinh',
        'dlOpName': 'asinh',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Acosh',
        'dlOpName': 'acosh',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Atanh',
        'dlOpName': 'atanh',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Erf',
        'dlOpName': 'erf',
        'category': 'basic_math',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    }
];

},{}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'LoopCond',
        'dlOpName': 'loopCond',
        'category': 'control',
        'params': [{ 'tfInputIndex': 0, 'dlParamName': 'pred', 'type': 'tensor' }]
    },
    {
        'tfOpName': 'Switch',
        'dlOpName': 'switch',
        'category': 'control',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'data', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'pred', 'type': 'tensor' }
        ]
    },
    {
        'tfOpName': 'Merge',
        'dlOpName': 'merge',
        'category': 'control',
        'params': [{
                'tfInputIndex': 0,
                'tfInputParamLength': 0,
                'dlParamName': 'tensors',
                'type': 'tensors'
            }]
    },
    {
        'tfOpName': 'Enter',
        'dlOpName': 'enter',
        'category': 'control',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'tensor', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            },
            {
                'tfParamName': 'frame_name',
                'dlParamName': 'frameName',
                'type': 'string'
            },
            {
                'tfParamName': 'is_constant',
                'dlParamName': 'isConstant',
                'type': 'bool'
            }
        ]
    },
    {
        'tfOpName': 'Exit',
        'dlOpName': 'exit',
        'category': 'control',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'tensor', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'NextIteration',
        'dlOpName': 'nextIteration',
        'category': 'control',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'tensor', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'TensorArrayV3',
        'dlOpName': 'tensorArray',
        'category': 'control',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'size', 'type': 'number' },
            { 'tfParamName': 'dtype', 'dlParamName': 'dtype', 'type': 'dtype' }, {
                'tfParamName': 'element_shape',
                'dlParamName': 'elementShape',
                'type': 'shape'
            },
            {
                'tfParamName': 'dynamic_size',
                'dlParamName': 'dynamicSize',
                'type': 'bool'
            },
            {
                'tfParamName': 'clear_after_read',
                'dlParamName': 'clearAfterRead',
                'type': 'bool'
            },
            {
                'tfParamName': 'identical_element_shapes',
                'dlParamName': 'identicalElementShapes',
                'type': 'bool'
            },
            {
                'tfParamName': 'tensor_array_name',
                'dlParamName': 'name',
                'type': 'string'
            }
        ]
    },
    {
        'tfOpName': 'TensorArrayWriteV3',
        'dlOpName': 'tensorArrayWrite',
        'category': 'control',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'tensorArrayId', 'type': 'number' },
            { 'tfInputIndex': 1, 'dlParamName': 'index', 'type': 'number' },
            { 'tfInputIndex': 2, 'dlParamName': 'tensor', 'type': 'tensor' },
            { 'tfInputIndex': 3, 'dlParamName': 'flowIn', 'type': 'number' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'TensorArrayReadV3',
        'dlOpName': 'tensorArrayRead',
        'category': 'control',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'tensorArrayId', 'type': 'number' },
            { 'tfInputIndex': 1, 'dlParamName': 'index', 'type': 'number' },
            { 'tfInputIndex': 2, 'dlParamName': 'flowIn', 'type': 'number' }, {
                'tfParamName': 'dtype',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'TensorArrayGatherV3',
        'dlOpName': 'tensorArrayGather',
        'category': 'control',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'tensorArrayId', 'type': 'number' },
            { 'tfInputIndex': 1, 'dlParamName': 'indices', 'type': 'number[]' },
            { 'tfInputIndex': 2, 'dlParamName': 'flowIn', 'type': 'number' },
            { 'tfParamName': 'dtype', 'dlParamName': 'dtype', 'type': 'dtype' }, {
                'tfParamName': 'element_shape',
                'dlParamName': 'elementShape',
                'type': 'shape'
            }
        ]
    },
    {
        'tfOpName': 'TensorArrayScatterV3',
        'dlOpName': 'tensorArrayScatter',
        'category': 'control',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'tensorArrayId', 'type': 'number' },
            { 'tfInputIndex': 1, 'dlParamName': 'indices', 'type': 'number[]' },
            { 'tfInputIndex': 2, 'dlParamName': 'tensor', 'type': 'tensor' },
            { 'tfInputIndex': 3, 'dlParamName': 'flowIn', 'type': 'number' },
            { 'tfParamName': 'T', 'dlParamName': 'dtype', 'type': 'dtype' }
        ]
    },
    {
        'tfOpName': 'TensorArrayConcatV3',
        'dlOpName': 'tensorArrayConcat',
        'category': 'control',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'tensorArrayId', 'type': 'number' },
            { 'tfInputIndex': 1, 'dlParamName': 'flowIn', 'type': 'number' },
            { 'tfParamName': 'dtype', 'dlParamName': 'dtype', 'type': 'dtype' }, {
                'tfParamName': 'element_shape_except0',
                'dlParamName': 'elementShapeExcept0',
                'type': 'shape',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'TensorArraySplitV3',
        'dlOpName': 'tensorArraySplit',
        'category': 'control',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'tensorArrayId', 'type': 'number' },
            { 'tfInputIndex': 1, 'dlParamName': 'tensor', 'type': 'tensor' },
            { 'tfInputIndex': 2, 'dlParamName': 'lengths', 'type': 'number[]' },
            { 'tfInputIndex': 3, 'dlParamName': 'flowIn', 'type': 'number' },
            { 'tfParamName': 'T', 'dlParamName': 'dtype', 'type': 'dtype' }
        ]
    },
    {
        'tfOpName': 'TensorArraySizeV3',
        'dlOpName': 'tensorArraySize',
        'category': 'control',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'tensorArrayId', 'type': 'number' },
            { 'tfInputIndex': 1, 'dlParamName': 'flowIn', 'type': 'number' }
        ]
    },
    {
        'tfOpName': 'TensorArrayCloseV3',
        'dlOpName': 'tensorArrayClose',
        'category': 'control',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'tensorArrayId', 'type': 'number' }
        ]
    }
];

},{}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'AvgPool',
        'dlOpName': 'avgPool',
        'category': 'convolution',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfParamName': 'strides', 'dlParamName': 'strides', 'type': 'number[]' },
            { 'tfParamName': 'padding', 'dlParamName': 'pad', 'type': 'string' }, {
                'tfParamName': 'data_format',
                'dlParamName': 'dataFormat',
                'type': 'string',
                'notSupported': true
            },
            { 'tfParamName': 'ksize', 'dlParamName': 'kernelSize', 'type': 'number[]' },
            {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'MaxPool',
        'dlOpName': 'maxPool',
        'category': 'convolution',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfParamName': 'strides', 'dlParamName': 'strides', 'type': 'number[]' },
            { 'tfParamName': 'padding', 'dlParamName': 'pad', 'type': 'string' }, {
                'tfParamName': 'data_format',
                'dlParamName': 'dataFormat',
                'type': 'string',
                'notSupported': true
            },
            { 'tfParamName': 'ksize', 'dlParamName': 'kernelSize', 'type': 'number[]' },
            {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Conv1D',
        'dlOpName': 'conv1d',
        'category': 'convolution',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'filter', 'type': 'tensor' },
            { 'tfParamName': 'stride', 'dlParamName': 'stride', 'type': 'number' },
            { 'tfParamName': 'padding', 'dlParamName': 'pad', 'type': 'string' }, {
                'tfParamName': 'data_format',
                'dlParamName': 'dataFormat',
                'type': 'string',
                'defaultValue': 'NWC'
            },
            {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            },
            {
                'tfParamName': 'dilation',
                'dlParamName': 'dilation',
                'type': 'number',
                'defaultValue': 1
            }
        ]
    },
    {
        'tfOpName': 'Conv2D',
        'dlOpName': 'conv2d',
        'category': 'convolution',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'filter', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            },
            { 'tfParamName': 'strides', 'dlParamName': 'strides', 'type': 'number[]' },
            { 'tfParamName': 'padding', 'dlParamName': 'pad', 'type': 'string' }, {
                'tfParamName': 'useCudnnOnGpu',
                'dlParamName': 'useCudnnOnGpu',
                'type': 'bool'
            },
            {
                'tfParamName': 'data_format',
                'dlParamName': 'dataFormat',
                'type': 'string',
                'defaultValue': 'NHWC'
            },
            {
                'tfParamName': 'dilations',
                'dlParamName': 'dilations',
                'type': 'number[]'
            }
        ]
    },
    {
        'tfOpName': 'Conv2DBackpropInput',
        'dlOpName': 'conv2dTranspose',
        'category': 'convolution',
        'params': [
            { 'tfInputIndex': 2, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'filter', 'type': 'tensor' },
            { 'tfInputIndex': 0, 'dlParamName': 'outputShape', 'type': 'number[]' },
            { 'tfParamName': 'strides', 'dlParamName': 'strides', 'type': 'number[]' },
            { 'tfParamName': 'padding', 'dlParamName': 'pad', 'type': 'string' }, {
                'tfParamName': 'data_format',
                'dlParamName': 'dataFormat',
                'type': 'string',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'DepthwiseConv2d',
        'dlOpName': 'depthwiseConv2d',
        'category': 'convolution',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'input', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'filter', 'type': 'tensor' },
            { 'tfParamName': 'strides', 'dlParamName': 'strides', 'type': 'number[]' },
            { 'tfParamName': 'padding', 'dlParamName': 'pad', 'type': 'string' }, {
                'tfParamName': 'data_format',
                'dlParamName': 'dataFormat',
                'type': 'string',
                'defaultValue': 'NHWC'
            },
            {
                'tfParamName': 'dilations',
                'dlParamName': 'dilations',
                'type': 'number[]'
            }
        ]
    },
    {
        'tfOpName': 'DepthwiseConv2dNative',
        'dlOpName': 'depthwiseConv2d',
        'category': 'convolution',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'input', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'filter', 'type': 'tensor' },
            { 'tfParamName': 'strides', 'dlParamName': 'strides', 'type': 'number[]' },
            { 'tfParamName': 'padding', 'dlParamName': 'pad', 'type': 'string' }, {
                'tfParamName': 'data_format',
                'dlParamName': 'dataFormat',
                'type': 'string',
                'defaultValue': 'NHWC'
            },
            {
                'tfParamName': 'dilations',
                'dlParamName': 'dilations',
                'type': 'number[]'
            }
        ]
    }
];

},{}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'Fill',
        'dlOpName': 'fill',
        'category': 'creation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'shape', 'type': 'number[]' },
            { 'tfInputIndex': 1, 'dlParamName': 'value', 'type': 'number' },
            { 'tfParamName': 'T', 'dlParamName': 'dtype', 'type': 'dtype' }
        ]
    },
    {
        'tfOpName': 'LinSpace',
        'dlOpName': 'linspace',
        'category': 'creation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'start', 'type': 'number' },
            { 'tfInputIndex': 1, 'dlParamName': 'stop', 'type': 'number' },
            { 'tfInputIndex': 2, 'dlParamName': 'num', 'type': 'number' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'OneHot',
        'dlOpName': 'oneHot',
        'category': 'creation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'indices', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'depth', 'type': 'number' }, {
                'tfInputIndex': 2,
                'dlParamName': 'onValue',
                'type': 'number',
                'defaultValue': 1
            },
            {
                'tfInputIndex': 3,
                'dlParamName': 'offValue',
                'type': 'number',
                'defaultValue': 0
            },
            {
                'tfParamName': 'axis',
                'dlParamName': 'axis',
                'type': 'number',
                'notSupported': true
            },
            {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Ones',
        'dlOpName': 'ones',
        'category': 'creation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'shape', 'type': 'number[]' },
            { 'tfParamName': 'T', 'dlParamName': 'dtype', 'type': 'dtype' }
        ]
    },
    {
        'tfOpName': 'OnesLike',
        'dlOpName': 'onesLike',
        'category': 'creation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfParamName': 'dtype', 'dlParamName': 'dtype', 'type': 'dtype' }
        ]
    },
    {
        'tfOpName': 'RandomUniform',
        'dlOpName': 'randomUniform',
        'category': 'creation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'shape', 'type': 'number[]' }, {
                'tfParamName': 'minval',
                'dlParamName': 'minval',
                'type': 'number',
                'defaultValue': 0
            },
            {
                'tfParamName': 'maxval',
                'dlParamName': 'maxval',
                'type': 'number',
                'defaultValue': 1
            },
            { 'tfParamName': 'dtype', 'dlParamName': 'dtype', 'type': 'dtype' }, {
                'tfParamName': 'seed',
                'dlParamName': 'seed',
                'type': 'number',
                'defaultValue': 0
            },
            {
                'tfParamName': 'seed2',
                'dlParamName': 'seed2',
                'type': 'number',
                'defaultValue': 0,
                'notSupported': true
            },
            {
                'tfParamName': 'T',
                'dlParamName': 'T',
                'type': 'number',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Range',
        'dlOpName': 'range',
        'category': 'creation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'start', 'type': 'number' },
            { 'tfInputIndex': 1, 'dlParamName': 'stop', 'type': 'number' }, {
                'tfInputIndex': 2,
                'dlParamName': 'step',
                'type': 'number',
                'defaultValue': 0
            },
            { 'tfParamName': 'Tidx', 'dlParamName': 'dtype', 'type': 'dtype' }
        ]
    },
    {
        'tfOpName': 'truncatedNormal',
        'dlOpName': 'truncatedNormal',
        'category': 'creation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'shape', 'type': 'number[]' }, {
                'tfParamName': 'means',
                'dlParamName': 'mean',
                'type': 'number',
                'defaultValue': 0.0
            },
            {
                'tfParamName': 'stddev',
                'dlParamName': 'stdDev',
                'type': 'number',
                'defaultValue': 1.0
            },
            { 'tfParamName': 'seed', 'dlParamName': 'seed', 'type': 'number' }, {
                'tfParamName': 'seed2',
                'dlParamName': 'seed2',
                'type': 'number',
                'defaultValue': 0,
                'notSupported': true
            },
            { 'tfParamName': 'dtype', 'dlParamName': 'dtype', 'type': 'dtype' }, {
                'tfParamName': 'T',
                'dlParamName': 'T',
                'type': 'number',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Zeros',
        'dlOpName': 'zeros',
        'category': 'creation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'shape', 'type': 'number[]' },
            { 'tfParamName': 'T', 'dlParamName': 'dtype', 'type': 'dtype' }
        ]
    },
    {
        'tfOpName': 'ZerosLike',
        'dlOpName': 'zerosLike',
        'category': 'creation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfParamName': 'T', 'dlParamName': 'dtype', 'type': 'dtype' }
        ]
    }
];

},{}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'NonMaxSuppressionV2',
        'dlOpName': 'nonMaxSuppression',
        'category': 'dynamic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'boxes', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'scores', 'type': 'tensor' },
            { 'tfInputIndex': 2, 'dlParamName': 'maxOutputSize', 'type': 'number' },
            { 'tfInputIndex': 3, 'dlParamName': 'iouThreshold', 'type': 'number' }
        ]
    },
    {
        'tfOpName': 'NonMaxSuppressionV3',
        'dlOpName': 'nonMaxSuppression',
        'category': 'dynamic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'boxes', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'scores', 'type': 'tensor' },
            { 'tfInputIndex': 2, 'dlParamName': 'maxOutputSize', 'type': 'number' },
            { 'tfInputIndex': 3, 'dlParamName': 'iouThreshold', 'type': 'number' },
            { 'tfInputIndex': 4, 'dlParamName': 'scoreThreshold', 'type': 'number' }
        ]
    },
    {
        'tfOpName': 'Where',
        'dlOpName': 'whereAsync',
        'category': 'dynamic',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'condition', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    }
];

},{}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [{
        'tfOpName': 'TopKV2',
        'dlOpName': 'topK',
        'category': 'evaluation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'k', 'type': 'number' },
            { 'tfParamName': 'sorted', 'dlParamName': 'sorted', 'type': 'bool' }
        ]
    }];

},{}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'PlaceholderWithDefault',
        'dlOpName': 'placeholder',
        'category': 'graph',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'default', 'type': 'tensor' },
            { 'tfParamName': 'shape', 'dlParamName': 'shape', 'type': 'shape' },
            { 'tfParamName': 'dtype', 'dlParamName': 'dtype', 'type': 'dtype' }
        ]
    },
    {
        'tfOpName': 'Placeholder',
        'dlOpName': 'placeholder',
        'category': 'graph',
        'params': [
            { 'tfParamName': 'shape', 'dlParamName': 'shape', 'type': 'shape' },
            { 'tfParamName': 'dtype', 'dlParamName': 'dtype', 'type': 'dtype' }
        ]
    },
    { 'tfOpName': 'Const', 'dlOpName': 'const', 'category': 'graph' }, {
        'tfOpName': 'Identity',
        'dlOpName': 'identity',
        'category': 'graph',
        'params': [{ 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }]
    },
    {
        'tfOpName': 'Snapshot',
        'dlOpName': 'snapshot',
        'category': 'graph',
        'params': [{ 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }]
    },
    {
        'tfOpName': 'Rank',
        'dlOpName': 'rank',
        'category': 'graph',
        'params': [{ 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }]
    },
    {
        'tfOpName': 'Size',
        'dlOpName': 'size',
        'category': 'graph',
        'params': [{ 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }]
    },
    {
        'tfOpName': 'Shape',
        'dlOpName': 'shape',
        'category': 'graph',
        'params': [{ 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }]
    },
    {
        'tfOpName': 'ShapeN',
        'dlOpName': 'shapeN',
        'category': 'graph',
        'params': [{
                'tfInputIndex': 0,
                'tfInputParamLength': 0,
                'dlParamName': 'x',
                'type': 'tensors'
            }]
    },
    {
        'tfOpName': 'Print',
        'dlOpName': 'print',
        'category': 'graph',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfInputIndex': 1,
                'tfInputParamLength': 1,
                'dlParamName': 'data',
                'type': 'tensors'
            },
            { 'tfParamName': 'message', 'dlParamName': 'message', 'type': 'string' }, {
                'tfParamName': 'first_n',
                'dlParamName': 'firstN',
                'type': 'number',
                'notSupprted': true
            },
            {
                'tfParamName': 'summarize',
                'dlParamName': 'summarize',
                'type': 'number',
                'defaultValue': 3
            }
        ]
    },
    { 'tfOpName': 'NoOp', 'dlOpName': 'noop', 'category': 'graph', 'params': [] }, {
        'tfOpName': 'StopGradient',
        'dlOpName': 'stopGradient',
        'category': 'graph',
        'params': [{ 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }]
    },
    {
        'tfOpName': 'FakeQuantWithMinMaxVars',
        'dlOpName': 'fakeQuantWithMinMaxVars',
        'category': 'graph',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfParamName': 'min', 'dlParamName': 'min', 'type': 'number' },
            { 'tfParamName': 'max', 'dlParamName': 'max', 'type': 'number' }
        ]
    }
];

},{}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'ResizeBilinear',
        'dlOpName': 'resizeBilinear',
        'category': 'image',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'images', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'size', 'type': 'number[]' }, {
                'tfParamName': 'align_corners',
                'dlParamName': 'alignCorners',
                'type': 'bool'
            },
            {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'ResizeNearestNeighbor',
        'dlOpName': 'resizeNearestNeighbor',
        'category': 'image',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'images', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'size', 'type': 'number[]' }, {
                'tfParamName': 'align_corners',
                'dlParamName': 'alignCorners',
                'type': 'bool'
            },
            {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'CropAndResize',
        'dlOpName': 'cropAndResize',
        'category': 'image',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'image', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'boxes', 'type': 'tensor' },
            { 'tfInputIndex': 2, 'dlParamName': 'boxInd', 'type': 'tensor' },
            { 'tfInputIndex': 3, 'dlParamName': 'cropSize', 'type': 'number[]' },
            { 'tfParamName': 'method', 'dlParamName': 'method', 'type': 'string' }, {
                'tfParamName': 'extrapolation_value',
                'dlParamName': 'extrapolationValue',
                'type': 'number'
            }
        ]
    }
];

},{}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'Equal',
        'dlOpName': 'equal',
        'category': 'logical',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'NotEqual',
        'dlOpName': 'notEqual',
        'category': 'logical',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Greater',
        'dlOpName': 'greater',
        'category': 'logical',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'GreaterEqual',
        'dlOpName': 'greaterEqual',
        'category': 'logical',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Less',
        'dlOpName': 'less',
        'category': 'logical',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'LessEqual',
        'dlOpName': 'lessEqual',
        'category': 'logical',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'LogicalAnd',
        'dlOpName': 'logicalAnd',
        'category': 'logical',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'LogicalNot',
        'dlOpName': 'logicalNot',
        'category': 'logical',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'LogicalOr',
        'dlOpName': 'logicalOr',
        'category': 'logical',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Select',
        'dlOpName': 'where',
        'category': 'logical',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'condition', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 2, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    }
];

},{}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'MatMul',
        'dlOpName': 'matMul',
        'category': 'matrices',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'transpose_a',
                'dlParamName': 'transposeA',
                'type': 'bool',
                'defaultValue': false
            },
            {
                'tfParamName': 'transpose_b',
                'dlParamName': 'transposeB',
                'type': 'bool',
                'defaultValue': false
            },
            {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'BatchMatMul',
        'dlOpName': 'matMul',
        'category': 'matrices',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'a', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'b', 'type': 'tensor' }, {
                'tfParamName': 'adj_x',
                'dlParamName': 'transposeA',
                'type': 'bool',
                'defaultValue': false
            },
            {
                'tfParamName': 'adj_y',
                'dlParamName': 'transposeB',
                'type': 'bool',
                'defaultValue': false
            },
            {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Transpose',
        'dlOpName': 'transpose',
        'category': 'matrices',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'perm', 'type': 'number[]' }, {
                'tfParamName': 'T',
                'dlParamName': 'dtype',
                'type': 'dtype',
                'notSupported': true
            }
        ]
    }
];

},{}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'FusedBatchNorm',
        'dlOpName': 'batchNormalization',
        'category': 'normalization',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'scale', 'type': 'tensor' },
            { 'tfInputIndex': 2, 'dlParamName': 'offset', 'type': 'tensor' },
            { 'tfInputIndex': 3, 'dlParamName': 'mean', 'type': 'tensor' },
            { 'tfInputIndex': 4, 'dlParamName': 'variance', 'type': 'tensor' }, {
                'tfParamName': 'epsilon',
                'dlParamName': 'epsilon',
                'type': 'number',
                'defaultValue': 0.001
            },
            {
                'tfParamName': 'data_format',
                'dlParamName': 'dataFormat',
                'type': 'string',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'FusedBatchNormV2',
        'dlOpName': 'batchNormalization',
        'category': 'normalization',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'scale', 'type': 'tensor' },
            { 'tfInputIndex': 2, 'dlParamName': 'offset', 'type': 'tensor' },
            { 'tfInputIndex': 3, 'dlParamName': 'mean', 'type': 'tensor' },
            { 'tfInputIndex': 4, 'dlParamName': 'variance', 'type': 'tensor' }, {
                'tfParamName': 'epsilon',
                'dlParamName': 'epsilon',
                'type': 'number',
                'defaultValue': 0.001
            },
            {
                'tfParamName': 'data_format',
                'dlParamName': 'dataFormat',
                'type': 'string',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'LRN',
        'dlOpName': 'localResponseNormalization',
        'category': 'normalization',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'depth_radius',
                'dlParamName': 'radius',
                'type': 'number',
                'defaultValue': 5
            },
            {
                'tfParamName': 'bias',
                'dlParamName': 'bias',
                'type': 'number',
                'defaultValue': 1.0
            },
            {
                'tfParamName': 'alpha',
                'dlParamName': 'alpha',
                'type': 'number',
                'defaultValue': 1.0
            },
            {
                'tfParamName': 'beta',
                'dlParamName': 'beta',
                'type': 'number',
                'defaultValue': 0.5
            }
        ]
    },
    {
        'tfOpName': 'Softmax',
        'dlOpName': 'softmax',
        'category': 'normalization',
        'params': [{ 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }]
    }
];

},{}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'Max',
        'dlOpName': 'max',
        'category': 'reduction',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'axis', 'type': 'number[]' },
            { 'tfParamName': 'keep_dims', 'dlParamName': 'keepDims', 'type': 'bool' }
        ]
    },
    {
        'tfOpName': 'Mean',
        'dlOpName': 'mean',
        'category': 'reduction',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'axis', 'type': 'number[]' },
            { 'tfParamName': 'keep_dims', 'dlParamName': 'keepDims', 'type': 'bool' }
        ]
    },
    {
        'tfOpName': 'Min',
        'dlOpName': 'min',
        'category': 'reduction',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'axis', 'type': 'number[]' },
            { 'tfParamName': 'keep_dims', 'dlParamName': 'keepDims', 'type': 'bool' }
        ]
    },
    {
        'tfOpName': 'Sum',
        'dlOpName': 'sum',
        'category': 'reduction',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'axis', 'type': 'number[]' },
            { 'tfParamName': 'keep_dims', 'dlParamName': 'keepDims', 'type': 'bool' }
        ]
    },
    {
        'tfOpName': 'All',
        'dlOpName': 'all',
        'category': 'reduction',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'axis', 'type': 'number[]' },
            { 'tfParamName': 'keep_dims', 'dlParamName': 'keepDims', 'type': 'bool' }
        ]
    },
    {
        'tfOpName': 'Any',
        'dlOpName': 'any',
        'category': 'reduction',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'axis', 'type': 'number[]' },
            { 'tfParamName': 'keep_dims', 'dlParamName': 'keepDims', 'type': 'bool' }
        ]
    },
    {
        'tfOpName': 'ArgMax',
        'dlOpName': 'argMax',
        'category': 'reduction',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'axis', 'type': 'number' }
        ]
    },
    {
        'tfOpName': 'ArgMin',
        'dlOpName': 'argMin',
        'category': 'reduction',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'axis', 'type': 'number' }
        ]
    },
    {
        'tfOpName': 'Prod',
        'dlOpName': 'prod',
        'category': 'reduction',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'axis', 'type': 'number[]' }, {
                'tfParamName': 'keep_dims',
                'dlParamName': 'keepDims',
                'type': 'bool'
            }
        ]
    }
];

},{}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'ConcatV2',
        'dlOpName': 'concat',
        'category': 'slice_join',
        'params': [
            {
                'tfInputIndex': 0,
                'tfInputParamLength': 1,
                'dlParamName': 'tensors',
                'type': 'tensors'
            },
            { 'tfInputIndex': -1, 'dlParamName': 'axis', 'type': 'number' }
        ]
    },
    {
        'tfOpName': 'Concat',
        'dlOpName': 'concat',
        'category': 'slice_join',
        'params': [
            {
                'tfInputIndex': 1,
                'tfInputParamLength': 1,
                'dlParamName': 'tensors',
                'type': 'tensors'
            },
            { 'tfInputIndex': 0, 'dlParamName': 'axis', 'type': 'number' }
        ]
    },
    {
        'tfOpName': 'GatherV2',
        'dlOpName': 'gather',
        'category': 'slice_join',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'indices', 'type': 'tensor' }, {
                'tfParamName': 'axis',
                'dlParamName': 'axis',
                'type': 'number',
                'defaultValue': 0
            }
        ]
    },
    {
        'tfOpName': 'Gather',
        'dlOpName': 'gather',
        'category': 'slice_join',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'indices', 'type': 'tensor' }, {
                'tfParamName': 'axis',
                'dlParamName': 'axis',
                'type': 'number',
                'defaultValue': 0
            },
            {
                'tfParamName': 'validate_indices',
                'dlParamName': 'validateIndices',
                'type': 'bool',
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Reverse',
        'dlOpName': 'reverse',
        'category': 'slice_join',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'axis', 'type': 'number' }
        ]
    },
    {
        'tfOpName': 'ReverseV2',
        'dlOpName': 'reverse',
        'category': 'slice_join',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'axis', 'type': 'number' }
        ]
    },
    {
        'tfOpName': 'Slice',
        'dlOpName': 'slice',
        'category': 'slice_join',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'begin', 'type': 'number[]' },
            { 'tfInputIndex': 2, 'dlParamName': 'size', 'type': 'number[]' }
        ]
    },
    {
        'tfOpName': 'StridedSlice',
        'dlOpName': 'stridedSlice',
        'category': 'slice_join',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'begin', 'type': 'number[]' },
            { 'tfInputIndex': 2, 'dlParamName': 'end', 'type': 'number[]' },
            { 'tfInputIndex': 3, 'dlParamName': 'strides', 'type': 'number[]' }, {
                'tfParamName': 'begin_mask',
                'dlParamName': 'beginMask',
                'type': 'number',
                'defaultValue': 0
            },
            {
                'tfParamName': 'end_mask',
                'dlParamName': 'endMask',
                'type': 'number',
                'defaultValue': 0
            },
            {
                'tfParamName': 'new_axis_mask',
                'dlParamName': 'newAxisMask',
                'type': 'number',
                'defaultValue': 0
            },
            {
                'tfParamName': 'ellipsis_mask',
                'dlParamName': 'ellipsisMask',
                'type': 'number',
                'defaultValue': 0
            },
            {
                'tfParamName': 'shrink_axis_mask',
                'dlParamName': 'shrinkAxisMask',
                'type': 'number',
                'defaultValue': 0
            }
        ]
    },
    {
        'tfOpName': 'Pack',
        'dlOpName': 'stack',
        'category': 'slice_join',
        'params': [
            {
                'tfInputIndex': 0,
                'tfInputParamLength': 0,
                'dlParamName': 'tensors',
                'type': 'tensors'
            },
            {
                'tfParamName': 'axis',
                'dlParamName': 'axis',
                'type': 'number',
                'defaultValue': 0
            }
        ]
    },
    {
        'tfOpName': 'Unpack',
        'dlOpName': 'unstack',
        'category': 'slice_join',
        'params': [
            {
                'tfInputIndex': 0,
                'tfInputParamLength': 0,
                'dlParamName': 'tensor',
                'type': 'tensor'
            },
            {
                'tfParamName': 'axis',
                'dlParamName': 'axis',
                'type': 'number',
                'defaultValue': 0
            },
            {
                'tfParamName': 'num',
                'dlParamName': 'num',
                'type': 'number',
                'defaultValue': 0,
                'notSupported': true
            }
        ]
    },
    {
        'tfOpName': 'Tile',
        'dlOpName': 'tile',
        'category': 'slice_join',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'reps', 'type': 'number[]' }
        ]
    },
    {
        'tfOpName': 'Split',
        'dlOpName': 'split',
        'category': 'slice_join',
        'params': [
            {
                'tfInputIndex': 0,
                'dlParamName': 'axis',
                'type': 'number',
                'defaultValue': 0
            },
            { 'tfInputIndex': 1, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'num_split',
                'dlParamName': 'numOrSizeSplits',
                'type': 'number',
                'defaultValue': 1
            }
        ]
    },
    {
        'tfOpName': 'SplitV',
        'dlOpName': 'split',
        'category': 'slice_join',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'numOrSizeSplits', 'type': 'number[]' },
            {
                'tfInputIndex': 2,
                'dlParamName': 'axis',
                'type': 'number',
                'defaultValue': 0
            }
        ]
    }
];

},{}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json = [
    {
        'tfOpName': 'Cast',
        'dlOpName': 'cast',
        'category': 'transformation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'SrcT',
                'dlParamName': 'sdtype',
                'type': 'dtype',
                'notSupported': true
            },
            { 'tfParamName': 'DstT', 'dlParamName': 'dtype', 'type': 'dtype' }
        ]
    },
    {
        'tfOpName': 'ExpandDims',
        'dlOpName': 'expandDims',
        'category': 'transformation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfInputIndex': 1,
                'tfParamNameDeprecated': 'dim',
                'dlParamName': 'axis',
                'type': 'number'
            }
        ]
    },
    {
        'tfOpName': 'Pad',
        'dlOpName': 'pad',
        'category': 'transformation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'padding', 'type': 'number[]' }, {
                'tfParamName': 'constant_value',
                'dlParamName': 'constantValue',
                'type': 'number',
                'defaultValue': 0
            }
        ]
    },
    {
        'tfOpName': 'PadV2',
        'dlOpName': 'pad',
        'category': 'transformation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'padding', 'type': 'number[]' }, {
                'tfInputIndex': 2,
                'dlParamName': 'constantValue',
                'type': 'number',
                'defaultValue': 0
            }
        ]
    },
    {
        'tfOpName': 'Reshape',
        'dlOpName': 'reshape',
        'category': 'transformation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'shape', 'type': 'number[]' }
        ]
    },
    {
        'tfOpName': 'Squeeze',
        'dlOpName': 'squeeze',
        'category': 'transformation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' }, {
                'tfParamName': 'axis',
                'tfParamNameDeprecated': 'squeeze_dims',
                'dlParamName': 'axis',
                'type': 'number[]'
            }
        ]
    },
    {
        'tfOpName': 'SpaceToBatchND',
        'dlOpName': 'spaceToBatchND',
        'category': 'transformation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'blockShape', 'type': 'number[]' },
            { 'tfInputIndex': 2, 'dlParamName': 'paddings', 'type': 'number[]' }
        ]
    },
    {
        'tfOpName': 'BatchToSpaceND',
        'dlOpName': 'batchToSpaceND',
        'category': 'transformation',
        'params': [
            { 'tfInputIndex': 0, 'dlParamName': 'x', 'type': 'tensor' },
            { 'tfInputIndex': 1, 'dlParamName': 'blockShape', 'type': 'number[]' },
            { 'tfInputIndex': 2, 'dlParamName': 'crops', 'type': 'number[]' }
        ]
    }
];

},{}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var arithmetic = require("./executors/arithmetic_executor");
var basicMath = require("./executors/basic_math_executor");
var control = require("./executors/control_executor");
var convolution = require("./executors/convolution_executor");
var creation = require("./executors/creation_executor");
var dynamic = require("./executors/dynamic_executor");
var evaluation = require("./executors/evaluation_executor");
var graph = require("./executors/graph_executor");
var image = require("./executors/image_executor");
var logical = require("./executors/logical_executor");
var matrices = require("./executors/matrices_executor");
var normalization = require("./executors/normalization_executor");
var reduction = require("./executors/reduction_executor");
var sliceJoin = require("./executors/slice_join_executor");
var transformation = require("./executors/transformation_executor");
function executeOp(node, tensorMap, context) {
    switch (node.category) {
        case 'arithmetic':
            return arithmetic.executeOp(node, tensorMap, context);
        case 'basic_math':
            return basicMath.executeOp(node, tensorMap, context);
        case 'control':
            return control.executeOp(node, tensorMap, context);
        case 'convolution':
            return convolution.executeOp(node, tensorMap, context);
        case 'creation':
            return creation.executeOp(node, tensorMap, context);
        case 'dynamic':
            return dynamic.executeOp(node, tensorMap, context);
        case 'evaluation':
            return evaluation.executeOp(node, tensorMap, context);
        case 'image':
            return image.executeOp(node, tensorMap, context);
        case 'graph':
            return graph.executeOp(node, tensorMap, context);
        case 'logical':
            return logical.executeOp(node, tensorMap, context);
        case 'matrices':
            return matrices.executeOp(node, tensorMap, context);
        case 'normalization':
            return normalization.executeOp(node, tensorMap, context);
        case 'reduction':
            return reduction.executeOp(node, tensorMap, context);
        case 'slice_join':
            return sliceJoin.executeOp(node, tensorMap, context);
        case 'transformation':
            return transformation.executeOp(node, tensorMap, context);
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
}
exports.executeOp = executeOp;

},{"./executors/arithmetic_executor":23,"./executors/basic_math_executor":24,"./executors/control_executor":25,"./executors/convolution_executor":26,"./executors/creation_executor":27,"./executors/dynamic_executor":28,"./executors/evaluation_executor":29,"./executors/graph_executor":30,"./executors/image_executor":31,"./executors/logical_executor":32,"./executors/matrices_executor":33,"./executors/normalization_executor":34,"./executors/reduction_executor":35,"./executors/slice_join_executor":36,"./executors/transformation_executor":37}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var compiled_api_1 = require("../data/compiled_api");
var utils_1 = require("./executors/utils");
var arithmetic = require("./op_list/arithmetic");
var basicMath = require("./op_list/basic_math");
var control = require("./op_list/control");
var convolution = require("./op_list/convolution");
var creation = require("./op_list/creation");
var dynamic = require("./op_list/dynamic");
var evaluation = require("./op_list/evaluation");
var graph = require("./op_list/graph");
var image = require("./op_list/image");
var logical = require("./op_list/logical");
var matrices = require("./op_list/matrices");
var normalization = require("./op_list/normalization");
var reduction = require("./op_list/reduction");
var sliceJoin = require("./op_list/slice_join");
var transformation = require("./op_list/transformation");
var CONTROL_FLOW_OPS = ['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration'];
var DYNAMIC_SHAPE_OPS = ['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'Where'];
var OperationMapper = (function () {
    function OperationMapper() {
        var ops = [
            arithmetic, basicMath, control, convolution, creation, dynamic,
            evaluation, logical, image, graph, matrices, normalization, reduction,
            sliceJoin, transformation
        ];
        var mappersJson = [].concat.apply([], ops.map(function (op) { return op.json; }));
        this.opMappers = mappersJson.reduce(function (map, mapper) {
            map[mapper.tfOpName] = mapper;
            return map;
        }, {});
    }
    Object.defineProperty(OperationMapper, "Instance", {
        get: function () {
            return this._instance || (this._instance = new this());
        },
        enumerable: true,
        configurable: true
    });
    OperationMapper.prototype.isControlFlow = function (node) {
        return CONTROL_FLOW_OPS.some(function (op) { return op === node.op; });
    };
    OperationMapper.prototype.isDynamicShape = function (node) {
        return DYNAMIC_SHAPE_OPS.some(function (op) { return op === node.op; });
    };
    OperationMapper.prototype.transformGraph = function (graph) {
        var _this = this;
        var tfNodes = graph.node;
        var withControlFlow = false;
        var withDynamicShape = false;
        var placeholders = [];
        var weights = [];
        var nodes = tfNodes.reduce(function (map, node) {
            map[node.name] = _this.mapNode(node);
            if (_this.isControlFlow(node))
                withControlFlow = true;
            if (_this.isDynamicShape(node))
                withDynamicShape = true;
            if (node.op === 'Placeholder')
                placeholders.push(map[node.name]);
            if (node.op === 'Const')
                weights.push(map[node.name]);
            return map;
        }, {});
        var inputs = [];
        var outputs = [];
        Object.keys(nodes).forEach(function (key) {
            var node = nodes[key];
            node.inputNames.forEach(function (name) {
                var nodeName = utils_1.getNodeNameAndIndex(name)[0];
                node.inputs.push(nodes[nodeName]);
                nodes[nodeName].children.push(node);
            });
            if (node.inputs.length === 0)
                inputs.push(node);
        });
        Object.keys(nodes).forEach(function (key) {
            var node = nodes[key];
            if (node.children.length === 0)
                outputs.push(node);
        });
        return {
            nodes: nodes,
            inputs: inputs,
            outputs: outputs,
            weights: weights,
            placeholders: placeholders,
            withControlFlow: withControlFlow,
            withDynamicShape: withDynamicShape
        };
    };
    OperationMapper.prototype.mapNode = function (node) {
        var _this = this;
        var mapper = this.opMappers[node.op];
        if (mapper === undefined) {
            throw new Error('Tensorflow Op is not supported: ' + node.op);
        }
        var newNode = {
            name: node.name,
            op: mapper.dlOpName,
            category: mapper.category,
            inputNames: (node.input ||
                []).map(function (input) { return input.startsWith('^') ? input.substr(1) : input; }),
            inputs: [],
            children: [],
            params: {}
        };
        if (!!mapper.params) {
            newNode.params = mapper.params.reduce(function (map, param) {
                var inputIndex = param.tfInputIndex;
                var inputParamLength = param.tfInputParamLength;
                var type = param.type;
                var value = undefined;
                if (inputIndex === undefined) {
                    switch (param.type) {
                        case 'string':
                            value = _this.getStringParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getStringParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'number':
                            value = _this.getNumberParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getNumberParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'number[]':
                            value = _this.getNumericArrayParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getNumericArrayParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'bool':
                            value = _this.getBoolParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getBoolParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'shape':
                            value = _this.getTensorShapeParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getTensorShapeParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'dtype':
                            value = _this.getDtypeParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getDtypeParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'tensor':
                        case 'tensors':
                            break;
                        default:
                            throw new Error("Unsupported param type: " + param.type + " for op: " + node.op);
                    }
                }
                map[param.dlParamName] = { value: value, inputIndex: inputIndex, type: type, inputParamLength: inputParamLength };
                return map;
            }, {});
        }
        return newNode;
    };
    OperationMapper.prototype.getStringParam = function (attrs, name, def, keepCase) {
        if (keepCase === void 0) { keepCase = false; }
        var param = attrs[name];
        if (param !== undefined) {
            var value = String.fromCharCode.apply(null, param.s);
            return keepCase ? value : value.toLowerCase();
        }
        return def;
    };
    OperationMapper.prototype.getBoolParam = function (attrs, name, def) {
        var param = attrs[name];
        return param ? param.b : def;
    };
    OperationMapper.prototype.getNumberParam = function (attrs, name, def) {
        var param = attrs[name];
        var value = (param ? param[param.value] : def);
        return (typeof value === 'number') ? value : value['toInt']();
    };
    OperationMapper.prototype.getDtypeParam = function (attrs, name, def) {
        var param = attrs[name];
        if (param && param.type) {
            switch (param.type) {
                case compiled_api_1.tensorflow.DataType.DT_FLOAT:
                    return 'float32';
                case compiled_api_1.tensorflow.DataType.DT_INT32:
                    return 'int32';
                case compiled_api_1.tensorflow.DataType.DT_BOOL:
                    return 'bool';
                default:
                    return def;
            }
        }
        return def;
    };
    OperationMapper.prototype.getTensorShapeParam = function (attrs, name, def) {
        var param = attrs[name];
        if (param && param.shape) {
            return param.shape.dim.map(function (dim) {
                return (typeof dim.size === 'number') ? dim.size : dim.size['toInt']();
            });
        }
        return def;
    };
    OperationMapper.prototype.getNumericArrayParam = function (attrs, name, def) {
        var param = attrs[name];
        if (param) {
            return ((param.list.f && param.list.f.length ? param.list.f :
                param.list.i))
                .map(function (v) { return (typeof v === 'number') ? v : v['toInt'](); });
        }
        return def;
    };
    return OperationMapper;
}());
exports.OperationMapper = OperationMapper;

},{"../data/compiled_api":17,"./executors/utils":38,"./op_list/arithmetic":39,"./op_list/basic_math":40,"./op_list/control":41,"./op_list/convolution":42,"./op_list/creation":43,"./op_list/dynamic":44,"./op_list/evaluation":45,"./op_list/graph":46,"./op_list/image":47,"./op_list/logical":48,"./op_list/matrices":49,"./op_list/normalization":50,"./op_list/reduction":51,"./op_list/slice_join":52,"./op_list/transformation":53}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.6.4';
exports.version = version;

},{}],57:[function(require,module,exports){
(function (setImmediate){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var delayCallback = typeof requestAnimationFrame !== 'undefined' ?
    requestAnimationFrame :
    setImmediate;
function nextFrame() {
    return new Promise(function (resolve) { return delayCallback(function () { return resolve(); }); });
}
exports.nextFrame = nextFrame;

}).call(this,require("timers").setImmediate)
},{"timers":6}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isMobile() {
    var a = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
        .test(a) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
            .test(a.substr(0, 4));
}
exports.isMobile = isMobile;

},{}],59:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var profiler_1 = require("./profiler");
var tape_1 = require("./tape");
var tensor_1 = require("./tensor");
var tensor_util_1 = require("./tensor_util");
var util = require("./util");
var util_1 = require("./util");
var Engine = (function () {
    function Engine(backend, safeMode, debugMode) {
        this.backend = backend;
        this.safeMode = safeMode;
        this.debugMode = debugMode;
        this.registeredVariables = {};
        this.nextTapeNodeId = 0;
        this.numBytes = 0;
        this.numTensors = 0;
        this.numDataBuffers = 0;
        this.profiling = false;
        this.gradientScopeCount = 0;
        this.customGradientDepth = 0;
        this.keepTensors = new Set();
        this.tensorInfo = new WeakMap();
        this.activeScope = { track: [], name: 'default scope' };
        this.scopeStack = [this.activeScope];
        this.profiler = new profiler_1.Profiler(backend);
        this.activeProfile =
            { newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null };
    }
    Engine.prototype.moveData = function (dataId) {
        this.write(dataId, this.readSync(dataId));
    };
    Engine.prototype.tidy = function (nameOrFn, fn, gradMode) {
        var _this = this;
        if (gradMode === void 0) { gradMode = false; }
        var name = null;
        if (fn == null) {
            if (typeof nameOrFn !== 'function') {
                throw new Error('Please provide a function to tidy()');
            }
            fn = nameOrFn;
        }
        else {
            if (typeof nameOrFn !== 'string' && !(nameOrFn instanceof String)) {
                throw new Error('When calling with two arguments, the first argument ' +
                    'to tidy() must be a string');
            }
            if (typeof fn !== 'function') {
                throw new Error('When calling with two arguments, the 2nd argument ' +
                    'to tidy() must be a function');
            }
            name = nameOrFn;
        }
        var result;
        return this.scopedRun(function () { return _this.startScope(name, gradMode); }, function () { return _this.endScope(result, gradMode); }, function () {
            result = fn();
            if (result instanceof Promise) {
                console.error('Cannot return a Promise inside of tidy.');
            }
            return result;
        });
    };
    Engine.prototype.scopedRun = function (start, end, f) {
        start();
        try {
            var res = f();
            end();
            return res;
        }
        catch (ex) {
            end();
            throw ex;
        }
    };
    Engine.prototype.runKernel = function (forwardFunc, inputs, backwardsFunc) {
        var _this = this;
        var result;
        var saved = [];
        var saveFunc = function (x) {
            saved.push(x);
            return x;
        };
        var scopeName = this.activeScope.name;
        var startingBytecount = this.numBytes;
        var startingNumTensors = this.numTensors;
        this.scopedRun(function () { return _this.customGradientDepth++; }, function () { return _this.customGradientDepth--; }, function () {
            if (!_this.debugMode()) {
                result = forwardFunc(_this.backend, saveFunc);
            }
            else {
                result = _this.profiler.profileKernel(scopeName, function () { return forwardFunc(_this.backend, saveFunc); });
            }
        });
        if (this.shouldRecord()) {
            var tapeNode = {
                id: this.nextTapeNodeId++,
                name: scopeName,
                inputs: inputs,
                outputs: Array.isArray(result) ? result : [result]
            };
            if (backwardsFunc != null) {
                tapeNode.gradient =
                    (function (dy) { return backwardsFunc(dy, saved); });
            }
            this.activeTape.push(tapeNode);
        }
        if (this.profiling) {
            this.activeProfile.kernels.push({
                name: scopeName,
                bytesAdded: this.numBytes - startingBytecount,
                totalBytesSnapshot: this.numBytes,
                tensorsAdded: this.numTensors - startingNumTensors,
                totalTensorsSnapshot: this.numTensors,
                inputShapes: Object.keys(inputs).map(function (key) { return inputs[key].shape; }),
                outputShape: Array.isArray(result) ?
                    result.map(function (item) { return item.shape; }) :
                    result.shape
            });
        }
        return result;
    };
    Engine.prototype.registerTensor = function (a) {
        var refCount = this.tensorInfo.has(a.dataId) ?
            this.tensorInfo.get(a.dataId).refCount :
            0;
        this.numTensors++;
        if (refCount === 0) {
            this.numDataBuffers++;
            if (a.dtype !== 'complex64') {
                this.numBytes +=
                    util.sizeFromShape(a.shape) * util.bytesPerElement(a.dtype);
            }
            this.tensorInfo.set(a.dataId, { backend: this.backend, dtype: a.dtype, shape: a.shape, refCount: 0 });
            this.backend.register(a.dataId, a.shape, a.dtype);
        }
        this.tensorInfo.get(a.dataId).refCount++;
        if (!(a instanceof tensor_1.Variable)) {
            this.track(a);
        }
    };
    Engine.prototype.registerVariable = function (v) {
        if (this.registeredVariables[v.name] != null) {
            throw new Error("Variable with name " + v.name + " was already registered");
        }
        this.registeredVariables[v.name] = v;
    };
    Engine.prototype.disposeTensor = function (a) {
        if (!this.tensorInfo.has(a.dataId)) {
            return;
        }
        if (this.keepTensors.has(a.id)) {
            this.keepTensors.delete(a.id);
        }
        this.numTensors--;
        var refCount = this.tensorInfo.get(a.dataId).refCount;
        if (refCount <= 1) {
            var info = this.tensorInfo.get(a.dataId);
            info.backend.disposeData(a.dataId);
            this.numDataBuffers--;
            if (a.dtype !== 'complex64') {
                this.numBytes -=
                    util.sizeFromShape(a.shape) * util.bytesPerElement(a.dtype);
            }
            this.tensorInfo.delete(a.dataId);
        }
        else {
            this.tensorInfo.get(a.dataId).refCount--;
        }
    };
    Engine.prototype.disposeVariables = function () {
        for (var varName in this.registeredVariables) {
            var v = this.registeredVariables[varName];
            this.disposeTensor(v);
            delete this.registeredVariables[varName];
        }
    };
    Engine.prototype.memory = function () {
        var info = this.backend.memory();
        info.numTensors = this.numTensors;
        info.numDataBuffers = this.numDataBuffers;
        info.numBytes = this.numBytes;
        return info;
    };
    Engine.prototype.profile = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var startBytes, startNumTensors;
            return __generator(this, function (_a) {
                this.profiling = true;
                startBytes = this.numBytes;
                startNumTensors = this.numTensors;
                this.activeProfile.kernels = [];
                this.activeProfile.result = query();
                this.profiling = false;
                this.activeProfile.peakBytes = Math.max.apply(Math, this.activeProfile.kernels.map(function (d) { return d.totalBytesSnapshot; }));
                this.activeProfile.newBytes = this.numBytes - startBytes;
                this.activeProfile.newTensors = this.numTensors - startNumTensors;
                return [2, this.activeProfile];
            });
        });
    };
    Engine.prototype.shouldRecord = function () {
        return this.activeTape != null && this.customGradientDepth === 0;
    };
    Engine.prototype.addTapeNode = function (inputs, result, gradientsFunc) {
        var inputsMap = {};
        inputs.forEach(function (input, idx) {
            inputsMap[idx] = input;
        });
        var gradient = function (dy) {
            var res = gradientsFunc(dy);
            var resMap = {};
            res.forEach(function (r, idx) {
                resMap[idx] = function () { return r; };
            });
            return resMap;
        };
        var tapeNode = {
            id: this.nextTapeNodeId++,
            name: this.activeScope.name,
            inputs: inputsMap,
            outputs: [result],
            gradient: gradient
        };
        this.activeTape.push(tapeNode);
    };
    Engine.prototype.keep = function (result) {
        if (this.scopeStack.length === 1 && this.safeMode) {
            throw new Error('Safe mode is ON. Enclose all tensor operations inside tf.tidy(): ' +
                'tf.tidy(() => {...}) to avoid memory leaks.');
        }
        this.keepTensors.add(result.id);
        return result;
    };
    Engine.prototype.startScope = function (name, gradientsMode) {
        if (gradientsMode === void 0) { gradientsMode = false; }
        if (gradientsMode && this.gradientScopeCount === 0) {
            this.activeTape = [];
        }
        if (gradientsMode) {
            this.gradientScopeCount++;
        }
        var scopeInfo = { track: [], name: 'unnamed scope' };
        if (name) {
            scopeInfo.name = name;
        }
        this.scopeStack.push(scopeInfo);
        this.activeScope = scopeInfo;
    };
    Engine.prototype.endScope = function (result, gradientsMode) {
        var _this = this;
        if (gradientsMode === void 0) { gradientsMode = false; }
        if (gradientsMode) {
            this.gradientScopeCount--;
            if (this.gradientScopeCount === 0) {
                this.activeTape = null;
            }
        }
        var tensorsToKeep = new Set(this.keepTensors);
        var tensorsToTrackInParent = tensor_util_1.getTensorsInContainer(result);
        tensorsToTrackInParent.forEach(function (tensor) { return tensorsToKeep.add(tensor.id); });
        for (var i = 0; i < this.activeScope.track.length; i++) {
            var tensor = this.activeScope.track[i];
            if (tensorsToKeep.has(tensor.id)) {
                continue;
            }
            if (this.activeTape != null) {
                tensorsToTrackInParent.push(tensor);
            }
            else {
                tensor.dispose();
            }
        }
        var oldScope = this.scopeStack.pop();
        this.activeScope = this.scopeStack.length === 0 ?
            { track: [], name: 'default scope' } :
            this.scopeStack[this.scopeStack.length - 1];
        tensorsToTrackInParent.forEach(function (tensor) {
            if (!_this.keepTensors.has(tensor.id) &&
                tensor_util_1.isTensorInList(tensor, oldScope.track)) {
                _this.track(tensor);
            }
        });
    };
    Engine.prototype.gradients = function (f, xs, dy, allowNoGradients) {
        var _this = this;
        if (allowNoGradients === void 0) { allowNoGradients = false; }
        util.assert(xs.length > 0, 'gradients() received an empty list of xs.');
        return this.tidy('gradients', function () {
            var y = f();
            util.assert(y instanceof tensor_1.Tensor, 'The result y returned by f() must be a tensor.');
            var filteredTape = tape_1.getFilteredNodesXToY(_this.activeTape, xs, y);
            if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
                throw new Error('Cannot compute gradient of y=f(x) with respect to x. Make sure ' +
                    'that the f you passed encloses all operations that lead from x ' +
                    'to y.');
            }
            var accumulatedGradientMap = {};
            accumulatedGradientMap[y.id] = (dy == null) ? ones(y.shape) : dy;
            tape_1.backpropagateGradients(accumulatedGradientMap, filteredTape);
            var grads = xs.map(function (x) { return accumulatedGradientMap[x.id]; });
            return { value: y, grads: grads };
        }, true);
    };
    Engine.prototype.customGrad = function (f) {
        var _this = this;
        util.assert(util.isFunction(f), 'The f passed in customGrad(f) must be a function.');
        return function () {
            var inputs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                inputs[_i] = arguments[_i];
            }
            util.assert(inputs.every(function (t) { return t instanceof tensor_1.Tensor; }), 'The args passed in customGrad(f)(x1, x2,...) must all be tensors');
            var gradientsFunc;
            var result;
            _this.scopedRun(function () { return _this.customGradientDepth++; }, function () { return _this.customGradientDepth--; }, function () {
                var gradientsMode = true;
                result = _this.tidy(f.name, function () {
                    var _a = f.apply(void 0, inputs), value = _a.value, gradFunc = _a.gradFunc;
                    util.assert(value instanceof tensor_1.Tensor, 'The function f passed in customGrad(f) must return an ' +
                        'object where `obj.value` is a tensor');
                    util.assert(util.isFunction(gradFunc), 'The function f passed in customGrad(f) must return an ' +
                        'object where `obj.gradFunc` is a function.');
                    gradientsFunc = gradFunc;
                    return value;
                }, gradientsMode);
            });
            if (_this.shouldRecord()) {
                var gradFunc = function (dy) {
                    var res = gradientsFunc(dy);
                    var grads = Array.isArray(res) ? res : [res];
                    util.assert(grads.length === inputs.length, 'The function f passed in customGrad(f) must return an object ' +
                        'where `obj.gradFunc` is a function that returns the same ' +
                        'number of tensors as inputs passed to f(...).');
                    util.assert(grads.every(function (t) { return t instanceof tensor_1.Tensor; }), 'The function f passed in customGrad(f) must return an object ' +
                        'where `obj.gradFunc` is a function that returns a list of ' +
                        'only tensors.');
                    return grads;
                };
                _this.addTapeNode(inputs, result, gradFunc);
            }
            return result;
        };
    };
    Engine.prototype.write = function (dataId, values) {
        var info = this.tensorInfo.get(dataId);
        if (this.backend !== info.backend) {
            info.backend.disposeData(dataId);
            info.backend = this.backend;
            this.backend.register(dataId, info.shape, info.dtype);
        }
        this.backend.write(dataId, values);
    };
    Engine.prototype.readSync = function (dataId) {
        var info = this.tensorInfo.get(dataId);
        return info.backend.readSync(dataId);
    };
    Engine.prototype.read = function (dataId) {
        var info = this.tensorInfo.get(dataId);
        return info.backend.read(dataId);
    };
    Engine.prototype.fromPixels = function (pixels, numChannels) {
        return this.backend.fromPixels(pixels, numChannels);
    };
    Engine.prototype.time = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var start, timingInfo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        start = util_1.now();
                        return [4, this.backend.time(query)];
                    case 1:
                        timingInfo = _a.sent();
                        timingInfo.wallMs = util_1.now() - start;
                        return [2, timingInfo];
                }
            });
        });
    };
    Engine.prototype.track = function (result) {
        if (this.scopeStack.length === 1 && this.safeMode) {
            throw new Error('Safe mode is ON. Enclose all tensor operations inside tf.tidy(): ' +
                'tf.tidy(() => {op();...}); to avoid memory leaks.');
        }
        this.activeScope.track.push(result);
        return result;
    };
    return Engine;
}());
exports.Engine = Engine;
function ones(shape) {
    var values = util_1.makeOnesTypedArray(util_1.sizeFromShape(shape), 'float32');
    return tensor_1.Tensor.make(shape, { values: values });
}

},{"./profiler":193,"./tape":195,"./tensor":196,"./tensor_util":198,"./util":203}],60:[function(require,module,exports){
(function (process){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var device_util = require("./device_util");
var engine_1 = require("./engine");
var environment_util_1 = require("./environment_util");
var tensor_1 = require("./tensor");
var tensor_util_1 = require("./tensor_util");
var EPSILON_FLOAT16 = 1e-3;
var TEST_EPSILON_FLOAT16 = 1e-1;
var EPSILON_FLOAT32 = 1e-7;
var TEST_EPSILON_FLOAT32 = 1e-3;
var Environment = (function () {
    function Environment(features) {
        this.features = {};
        this.registry = {};
        if (features != null) {
            this.features = features;
        }
        if (this.get('DEBUG')) {
            console.warn('Debugging mode is ON. The output of every math call will ' +
                'be downloaded to CPU and checked for NaNs. ' +
                'This significantly impacts performance.');
        }
    }
    Environment.setBackend = function (backendName, safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        if (!(backendName in exports.ENV.registry)) {
            throw new Error("Backend name '" + backendName + "' not found in registry");
        }
        exports.ENV.engine.backend = exports.ENV.findBackend(backendName);
        exports.ENV.backendName = backendName;
    };
    Environment.getBackend = function () {
        exports.ENV.initEngine();
        return exports.ENV.backendName;
    };
    Environment.disposeVariables = function () {
        exports.ENV.engine.disposeVariables();
    };
    Environment.memory = function () {
        return exports.ENV.engine.memory();
    };
    Environment.profile = function (f) {
        return exports.ENV.engine.profile(f);
    };
    Environment.tidy = function (nameOrFn, fn, gradMode) {
        if (gradMode === void 0) { gradMode = false; }
        return exports.ENV.engine.tidy(nameOrFn, fn, gradMode);
    };
    Environment.dispose = function (container) {
        var tensors = tensor_util_1.getTensorsInContainer(container);
        tensors.forEach(function (tensor) { return tensor.dispose(); });
    };
    Environment.keep = function (result) {
        return exports.ENV.engine.keep(result);
    };
    Environment.time = function (f) {
        return exports.ENV.engine.time(f);
    };
    Environment.prototype.get = function (feature) {
        if (feature in this.features) {
            return this.features[feature];
        }
        this.features[feature] = this.evaluateFeature(feature);
        return this.features[feature];
    };
    Environment.prototype.getFeatures = function () {
        return this.features;
    };
    Environment.prototype.set = function (feature, value) {
        this.features[feature] = value;
    };
    Environment.prototype.getBestBackendName = function () {
        var _this = this;
        if (Object.keys(this.registry).length === 0) {
            throw new Error('No backend found in registry.');
        }
        var sortedBackends = Object.keys(this.registry)
            .map(function (name) {
            return { name: name, entry: _this.registry[name] };
        })
            .sort(function (a, b) {
            return b.entry.priority - a.entry.priority;
        });
        return sortedBackends[0].name;
    };
    Environment.prototype.evaluateFeature = function (feature) {
        if (feature === 'DEBUG') {
            return false;
        }
        else if (feature === 'IS_BROWSER') {
            return typeof window !== 'undefined';
        }
        else if (feature === 'IS_NODE') {
            return (typeof process !== 'undefined') &&
                (typeof process.versions.node !== 'undefined');
        }
        else if (feature === 'IS_CHROME') {
            return environment_util_1.isChrome();
        }
        else if (feature === 'WEBGL_CONV_IM2COL') {
            return false;
        }
        else if (feature === 'WEBGL_PAGING_ENABLED') {
            return this.get('IS_BROWSER') && !this.get('PROD');
        }
        else if (feature === 'WEBGL_MAX_TEXTURE_SIZE') {
            return environment_util_1.getWebGLMaxTextureSize(this.get('WEBGL_VERSION'), this.get('IS_BROWSER'));
        }
        else if (feature === 'IS_TEST') {
            return false;
        }
        else if (feature === 'BACKEND') {
            return this.getBestBackendName();
        }
        else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') {
            var webGLVersion = this.get('WEBGL_VERSION');
            if (webGLVersion === 0) {
                return 0;
            }
            return environment_util_1.getWebGLDisjointQueryTimerVersion(webGLVersion, this.get('IS_BROWSER'));
        }
        else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') {
            return this.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 &&
                !device_util.isMobile();
        }
        else if (feature === 'HAS_WEBGL') {
            return this.get('WEBGL_VERSION') > 0;
        }
        else if (feature === 'WEBGL_VERSION') {
            if (environment_util_1.isWebGLVersionEnabled(2, this.get('IS_BROWSER'))) {
                return 2;
            }
            else if (environment_util_1.isWebGLVersionEnabled(1, this.get('IS_BROWSER'))) {
                return 1;
            }
            return 0;
        }
        else if (feature === 'WEBGL_RENDER_FLOAT32_ENABLED') {
            return environment_util_1.isRenderToFloatTextureEnabled(this.get('WEBGL_VERSION'), this.get('IS_BROWSER'));
        }
        else if (feature === 'WEBGL_DOWNLOAD_FLOAT_ENABLED') {
            return environment_util_1.isDownloadFloatTextureEnabled(this.get('WEBGL_VERSION'), this.get('IS_BROWSER'));
        }
        else if (feature === 'WEBGL_FENCE_API_ENABLED') {
            return environment_util_1.isWebGLFenceEnabled(this.get('WEBGL_VERSION'), this.get('IS_BROWSER'));
        }
        else if (feature === 'WEBGL_SIZE_UPLOAD_UNIFORM') {
            var useUniforms = this.get('WEBGL_RENDER_FLOAT32_ENABLED');
            return useUniforms ? 4 : 0;
        }
        else if (feature === 'TEST_EPSILON') {
            return this.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 :
                TEST_EPSILON_FLOAT16;
        }
        else if (feature === 'EPSILON') {
            return this.backend.floatPrecision() === 32 ? EPSILON_FLOAT32 :
                EPSILON_FLOAT16;
        }
        else if (feature === 'PROD') {
            return false;
        }
        else if (feature === 'TENSORLIKE_CHECK_SHAPE_CONSISTENCY') {
            return !this.get('PROD');
        }
        throw new Error("Unknown feature " + feature + ".");
    };
    Environment.prototype.setFeatures = function (features) {
        this.features = Object.assign({}, features);
    };
    Environment.prototype.reset = function () {
        this.features = environment_util_1.getFeaturesFromURL();
        if (this.globalEngine != null) {
            this.globalEngine = null;
        }
    };
    Object.defineProperty(Environment.prototype, "backend", {
        get: function () {
            return this.engine.backend;
        },
        enumerable: true,
        configurable: true
    });
    Environment.prototype.findBackend = function (name) {
        if (!(name in this.registry)) {
            return null;
        }
        return this.registry[name].backend;
    };
    Environment.prototype.registerBackend = function (name, factory, priority, setTensorTrackerFn) {
        var _this = this;
        if (priority === void 0) { priority = 1; }
        if (name in this.registry) {
            console.warn(name + " backend was already registered. Reusing existing backend");
            if (setTensorTrackerFn != null) {
                setTensorTrackerFn(function () { return _this.engine; });
            }
            return false;
        }
        try {
            var backend = factory();
            backend.setDataMover({ moveData: function (dataId) { return _this.engine.moveData(dataId); } });
            this.registry[name] = { backend: backend, priority: priority };
            return true;
        }
        catch (err) {
            console.warn("Registration of backend " + name + " failed");
            console.warn(err.stack || err.message);
            return false;
        }
    };
    Environment.prototype.removeBackend = function (name) {
        if (!(name in this.registry)) {
            throw new Error(name + " backend not found in registry");
        }
        this.registry[name].backend.dispose();
        delete this.registry[name];
    };
    Object.defineProperty(Environment.prototype, "engine", {
        get: function () {
            this.initEngine();
            return this.globalEngine;
        },
        enumerable: true,
        configurable: true
    });
    Environment.prototype.initEngine = function () {
        var _this = this;
        if (this.globalEngine == null) {
            this.backendName = this.get('BACKEND');
            var backend = this.findBackend(this.backendName);
            this.globalEngine =
                new engine_1.Engine(backend, false, function () { return _this.get('DEBUG'); });
        }
    };
    return Environment;
}());
exports.Environment = Environment;
function getGlobalNamespace() {
    var ns;
    if (typeof (window) !== 'undefined') {
        ns = window;
    }
    else if (typeof (process) !== 'undefined') {
        ns = process;
    }
    else {
        throw new Error('Could not find a global object');
    }
    return ns;
}
function getOrMakeEnvironment() {
    var ns = getGlobalNamespace();
    if (ns.ENV == null) {
        ns.ENV = new Environment(environment_util_1.getFeaturesFromURL());
        tensor_1.setTensorTracker(function () { return ns.ENV.engine; });
    }
    return ns.ENV;
}
exports.ENV = getOrMakeEnvironment();

}).call(this,require('_process'))
},{"./device_util":58,"./engine":59,"./environment_util":61,"./tensor":196,"./tensor_util":198,"_process":5}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Type;
(function (Type) {
    Type[Type["NUMBER"] = 0] = "NUMBER";
    Type[Type["BOOLEAN"] = 1] = "BOOLEAN";
    Type[Type["STRING"] = 2] = "STRING";
})(Type = exports.Type || (exports.Type = {}));
exports.URL_PROPERTIES = [
    { name: 'DEBUG', type: Type.BOOLEAN },
    { name: 'IS_BROWSER', type: Type.BOOLEAN },
    { name: 'WEBGL_CONV_IM2COL', type: Type.BOOLEAN },
    { name: 'WEBGL_MAX_TEXTURE_SIZE', type: Type.NUMBER },
    { name: 'WEBGL_PAGING_ENABLED', type: Type.BOOLEAN },
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', type: Type.NUMBER },
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', type: Type.BOOLEAN },
    { name: 'WEBGL_VERSION', type: Type.NUMBER },
    { name: 'WEBGL_RENDER_FLOAT32_ENABLED', type: Type.BOOLEAN },
    { name: 'WEBGL_DOWNLOAD_FLOAT_ENABLED', type: Type.BOOLEAN },
    { name: 'WEBGL_FENCE_API_ENABLED', type: Type.BOOLEAN },
    { name: 'WEBGL_SIZE_UPLOAD_UNIFORM', type: Type.NUMBER },
    { name: 'BACKEND', type: Type.STRING },
    { name: 'EPSILON', type: Type.NUMBER },
    { name: 'PROD', type: Type.BOOLEAN },
    { name: 'TENSORLIKE_CHECK_SHAPE_CONSISTENCY', type: Type.BOOLEAN },
];
function isWebGLVersionEnabled(webGLVersion, isBrowser) {
    var gl;
    try {
        gl = getWebGLRenderingContext(webGLVersion, isBrowser);
    }
    catch (e) {
        return false;
    }
    if (gl != null) {
        loseContext(gl);
        return true;
    }
    return false;
}
exports.isWebGLVersionEnabled = isWebGLVersionEnabled;
var MAX_TEXTURE_SIZE;
function getWebGLMaxTextureSize(webGLVersion, isBrowser) {
    if (MAX_TEXTURE_SIZE == null) {
        var gl = getWebGLRenderingContext(webGLVersion, isBrowser);
        MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    }
    return MAX_TEXTURE_SIZE;
}
exports.getWebGLMaxTextureSize = getWebGLMaxTextureSize;
function getWebGLDisjointQueryTimerVersion(webGLVersion, isBrowser) {
    if (webGLVersion === 0) {
        return 0;
    }
    var queryTimerVersion;
    var gl = getWebGLRenderingContext(webGLVersion, isBrowser);
    if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&
        webGLVersion === 2) {
        queryTimerVersion = 2;
    }
    else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {
        queryTimerVersion = 1;
    }
    else {
        queryTimerVersion = 0;
    }
    if (gl != null) {
        loseContext(gl);
    }
    return queryTimerVersion;
}
exports.getWebGLDisjointQueryTimerVersion = getWebGLDisjointQueryTimerVersion;
function isRenderToFloatTextureEnabled(webGLVersion, isBrowser) {
    if (webGLVersion === 0) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion, isBrowser);
    if (webGLVersion === 1) {
        if (!hasExtension(gl, 'OES_texture_float')) {
            return false;
        }
    }
    else {
        if (!hasExtension(gl, 'EXT_color_buffer_float')) {
            return false;
        }
    }
    var isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl, webGLVersion);
    loseContext(gl);
    return isFrameBufferComplete;
}
exports.isRenderToFloatTextureEnabled = isRenderToFloatTextureEnabled;
function isDownloadFloatTextureEnabled(webGLVersion, isBrowser) {
    if (webGLVersion === 0) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion, isBrowser);
    if (webGLVersion === 1) {
        if (!hasExtension(gl, 'OES_texture_float')) {
            return false;
        }
        if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {
            return false;
        }
    }
    else {
        if (!hasExtension(gl, 'EXT_color_buffer_float')) {
            return false;
        }
    }
    var isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl, webGLVersion);
    loseContext(gl);
    return isFrameBufferComplete;
}
exports.isDownloadFloatTextureEnabled = isDownloadFloatTextureEnabled;
function isWebGLFenceEnabled(webGLVersion, isBrowser) {
    if (webGLVersion !== 2) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion, isBrowser);
    var isEnabled = gl.fenceSync != null;
    loseContext(gl);
    return isEnabled;
}
exports.isWebGLFenceEnabled = isWebGLFenceEnabled;
function isChrome() {
    return typeof navigator !== 'undefined' && navigator != null &&
        navigator.userAgent != null && /Chrome/.test(navigator.userAgent) &&
        /Google Inc/.test(navigator.vendor);
}
exports.isChrome = isChrome;
var TENSORFLOWJS_FLAGS_PREFIX = 'tfjsflags';
function getFeaturesFromURL() {
    var features = {};
    if (typeof window === 'undefined' || typeof window.location === 'undefined') {
        return features;
    }
    var urlParams = getQueryParams(window.location.search);
    if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
        var urlFlags_1 = {};
        var keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(',');
        keyValues.forEach(function (keyValue) {
            var _a = keyValue.split(':'), key = _a[0], value = _a[1];
            urlFlags_1[key] = value;
        });
        exports.URL_PROPERTIES.forEach(function (urlProperty) {
            if (urlProperty.name in urlFlags_1) {
                console.log("Setting feature override from URL " + urlProperty.name + ": " +
                    ("" + urlFlags_1[urlProperty.name]));
                if (urlProperty.type === Type.NUMBER) {
                    features[urlProperty.name] = +urlFlags_1[urlProperty.name];
                }
                else if (urlProperty.type === Type.BOOLEAN) {
                    features[urlProperty.name] = urlFlags_1[urlProperty.name] === 'true';
                }
                else if (urlProperty.type === Type.STRING) {
                    features[urlProperty.name] = urlFlags_1[urlProperty.name];
                }
                else {
                    console.warn("Unknown URL param: " + urlProperty.name + ".");
                }
            }
        });
    }
    return features;
}
exports.getFeaturesFromURL = getFeaturesFromURL;
function hasExtension(gl, extensionName) {
    var ext = gl.getExtension(extensionName);
    return ext != null;
}
function getWebGLRenderingContext(webGLVersion, isBrowser) {
    if (webGLVersion === 0 || !isBrowser) {
        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');
    }
    var tempCanvas = document.createElement('canvas');
    if (webGLVersion === 1) {
        return (tempCanvas.getContext('webgl') ||
            tempCanvas.getContext('experimental-webgl'));
    }
    return tempCanvas.getContext('webgl2');
}
function loseContext(gl) {
    if (gl != null) {
        var loseContextExtension = gl.getExtension('WEBGL_lose_context');
        if (loseContextExtension == null) {
            throw new Error('Extension WEBGL_lose_context not supported on this browser.');
        }
        loseContextExtension.loseContext();
    }
}
function createFloatTextureAndBindToFramebuffer(gl, webGLVersion) {
    var frameBuffer = gl.createFramebuffer();
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    var internalFormat = webGLVersion === 2 ? gl.RGBA32F : gl.RGBA;
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    var isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(frameBuffer);
    return isFrameBufferComplete;
}
function getQueryParams(queryString) {
    var params = {};
    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (s) {
        var t = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            t[_i - 1] = arguments[_i];
        }
        decodeParam(params, t[0], t[1]);
        return t.join('=');
    });
    return params;
}
exports.getQueryParams = getQueryParams;
function decodeParam(params, name, value) {
    params[decodeURIComponent(name)] = decodeURIComponent(value || '');
}

},{}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("./environment");
var gradients_1 = require("./gradients");
exports.customGrad = gradients_1.customGrad;
exports.grad = gradients_1.grad;
exports.grads = gradients_1.grads;
exports.valueAndGrad = gradients_1.valueAndGrad;
exports.valueAndGrads = gradients_1.valueAndGrads;
exports.variableGrads = gradients_1.variableGrads;
exports.tidy = environment_1.Environment.tidy;
exports.keep = environment_1.Environment.keep;
exports.dispose = environment_1.Environment.dispose;
exports.time = environment_1.Environment.time;
exports.profile = environment_1.Environment.profile;

},{"./environment":60,"./gradients":63}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("./environment");
var tensor_1 = require("./tensor");
var util = require("./util");
function gradScope(nameOrScopeFn, scopeFn) {
    return environment_1.ENV.engine.tidy(nameOrScopeFn, scopeFn, true);
}
exports.gradScope = gradScope;
function grad(f) {
    util.assert(util.isFunction(f), 'The f passed in grad(f) must be a function');
    return function (x, dy) {
        util.assert(x instanceof tensor_1.Tensor, 'The x passed in grad(f)(x) must be a tensor');
        util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in grad(f)(x, dy) must be a tensor');
        return environment_1.ENV.engine.tidy(function () {
            var _a = environment_1.ENV.engine.gradients(function () { return f(x); }, [x], dy), value = _a.value, grads = _a.grads;
            if (dy != null) {
                util.assertShapesMatch(value.shape, dy.shape, 'The shape of dy passed in grad(f)(x, dy) must match the shape ' +
                    'returned by f(x)');
            }
            checkGrads(grads);
            return grads[0];
        });
    };
}
exports.grad = grad;
function grads(f) {
    util.assert(util.isFunction(f), 'The f passed in grads(f) must be a function');
    return function (args, dy) {
        util.assert(Array.isArray(args) && args.every(function (arg) { return arg instanceof tensor_1.Tensor; }), 'The args passed in grads(f)(args) must be an array of tensors');
        util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in grads(f)(args, dy) must be a tensor');
        return environment_1.ENV.engine.tidy(function () {
            var _a = environment_1.ENV.engine.gradients(function () { return f.apply(void 0, args); }, args, dy), value = _a.value, grads = _a.grads;
            if (dy != null) {
                util.assertShapesMatch(value.shape, dy.shape, 'The shape of dy passed in grads(f)([x1,...], dy) must ' +
                    'match the shape returned by f([x1,...])');
            }
            checkGrads(grads);
            return grads;
        });
    };
}
exports.grads = grads;
function valueAndGrad(f) {
    util.assert(util.isFunction(f), 'The f passed in valueAndGrad(f) must be a function');
    return function (x, dy) {
        util.assert(x instanceof tensor_1.Tensor, 'The x passed in valueAndGrad(f)(x) must be a tensor');
        util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in valueAndGrad(f)(x, dy) must be a tensor');
        var _a = environment_1.ENV.engine.gradients(function () { return f(x); }, [x], dy), grads = _a.grads, value = _a.value;
        checkGrads(grads);
        return { grad: grads[0], value: value };
    };
}
exports.valueAndGrad = valueAndGrad;
function valueAndGrads(f) {
    util.assert(util.isFunction(f), 'The f passed in valueAndGrads(f) must be a function');
    return function (args, dy) {
        util.assert(Array.isArray(args) && args.every(function (arg) { return arg instanceof tensor_1.Tensor; }), 'The args passed in valueAndGrads(f)(args) must be array of tensors');
        util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in valueAndGrads(f)(args, dy) must be a tensor');
        var res = environment_1.ENV.engine.gradients(function () { return f.apply(void 0, args); }, args, dy);
        if (dy != null) {
            util.assertShapesMatch(res.value.shape, dy.shape, 'The shape of dy passed in valueAndGrads(f)([x1,...], dy) must ' +
                'match the shape returned by f([x1,...])');
        }
        checkGrads(res.grads);
        return res;
    };
}
exports.valueAndGrads = valueAndGrads;
function variableGrads(f, varList) {
    util.assert(util.isFunction(f), 'The f passed in variableGrads(f) must be a function');
    util.assert(varList == null ||
        Array.isArray(varList) && varList.every(function (v) { return v instanceof tensor_1.Variable; }), 'The varList passed in variableGrads(f, varList) must be an array ' +
        'of variables');
    if (varList == null) {
        varList = [];
        for (var varName in environment_1.ENV.engine.registeredVariables) {
            varList.push(environment_1.ENV.engine.registeredVariables[varName]);
        }
    }
    var originalVarCount = varList.length;
    varList = varList.filter(function (variable) { return variable.trainable; });
    util.assert(varList.length > 0, "variableGrads() expects at least one of the input variables to be " +
        ("trainable, but none of the " + originalVarCount + " variables is ") +
        "trainable.");
    var allowNoGradients = true;
    var _a = environment_1.ENV.engine.gradients(f, varList, null, allowNoGradients), value = _a.value, grads = _a.grads;
    util.assert(grads.some(function (g) { return g != null; }), 'Cannot find a connection between any variable and the result of the ' +
        'loss function y=f(x). Please make sure the operations that use ' +
        'variables are inside the function f passed to minimize().');
    util.assert(value.rank === 0, "The f passed in variableGrads(f) must return a scalar, but it " +
        ("returned a rank-" + value.rank + " tensor"));
    var namedGrads = {};
    varList.forEach(function (v, i) {
        if (grads[i] != null) {
            namedGrads[v.name] = grads[i];
        }
    });
    return { value: value, grads: namedGrads };
}
exports.variableGrads = variableGrads;
function customGrad(f) {
    return environment_1.ENV.engine.customGrad(f);
}
exports.customGrad = customGrad;
function checkGrads(grads) {
    var numNullGradients = grads.filter(function (g) { return g == null; }).length;
    if (numNullGradients > 0) {
        throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
    }
}

},{"./environment":60,"./tensor":196,"./util":203}],64:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
require("./kernels/backend_webgl");
require("./kernels/backend_cpu");
var browser_util_1 = require("./browser_util");
exports.nextFrame = browser_util_1.nextFrame;
var environment = require("./environment");
exports.environment = environment;
var environment_1 = require("./environment");
var io = require("./io/io");
exports.io = io;
var serialization = require("./serialization");
exports.serialization = serialization;
var tensor_1 = require("./tensor");
var test_util = require("./test_util");
exports.test_util = test_util;
var util = require("./util");
exports.util = util;
var version_1 = require("./version");
exports.version_core = version_1.version;
var webgl = require("./webgl");
exports.webgl = webgl;
var adadelta_optimizer_1 = require("./optimizers/adadelta_optimizer");
exports.AdadeltaOptimizer = adadelta_optimizer_1.AdadeltaOptimizer;
var adagrad_optimizer_1 = require("./optimizers/adagrad_optimizer");
exports.AdagradOptimizer = adagrad_optimizer_1.AdagradOptimizer;
var adam_optimizer_1 = require("./optimizers/adam_optimizer");
exports.AdamOptimizer = adam_optimizer_1.AdamOptimizer;
var adamax_optimizer_1 = require("./optimizers/adamax_optimizer");
exports.AdamaxOptimizer = adamax_optimizer_1.AdamaxOptimizer;
var momentum_optimizer_1 = require("./optimizers/momentum_optimizer");
exports.MomentumOptimizer = momentum_optimizer_1.MomentumOptimizer;
var optimizer_1 = require("./optimizers/optimizer");
exports.Optimizer = optimizer_1.Optimizer;
var rmsprop_optimizer_1 = require("./optimizers/rmsprop_optimizer");
exports.RMSPropOptimizer = rmsprop_optimizer_1.RMSPropOptimizer;
var sgd_optimizer_1 = require("./optimizers/sgd_optimizer");
exports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;
var tensor_2 = require("./tensor");
exports.Tensor = tensor_2.Tensor;
exports.TensorBuffer = tensor_2.TensorBuffer;
exports.variable = tensor_2.variable;
exports.Variable = tensor_2.Variable;
var types_1 = require("./types");
exports.Rank = types_1.Rank;
__export(require("./ops/ops"));
var loss_ops_1 = require("./ops/loss_ops");
exports.Reduction = loss_ops_1.Reduction;
__export(require("./train"));
__export(require("./globals"));
var environment_2 = require("./environment");
exports.ENV = environment_2.ENV;
exports.Environment = environment_2.Environment;
exports.setBackend = environment_1.Environment.setBackend;
exports.getBackend = environment_1.Environment.getBackend;
exports.disposeVariables = environment_1.Environment.disposeVariables;
exports.memory = environment_1.Environment.memory;
var backend_1 = require("./kernels/backend");
exports.DataStorage = backend_1.DataStorage;
var ops = require("./ops/ops");
tensor_1.setOpHandler(ops);

},{"./browser_util":57,"./environment":60,"./globals":62,"./io/io":68,"./kernels/backend":76,"./kernels/backend_cpu":77,"./kernels/backend_webgl":79,"./ops/loss_ops":156,"./ops/ops":163,"./optimizers/adadelta_optimizer":184,"./optimizers/adagrad_optimizer":185,"./optimizers/adam_optimizer":186,"./optimizers/adamax_optimizer":187,"./optimizers/momentum_optimizer":188,"./optimizers/optimizer":189,"./optimizers/rmsprop_optimizer":191,"./optimizers/sgd_optimizer":192,"./serialization":194,"./tensor":196,"./test_util":200,"./train":201,"./types":202,"./util":203,"./version":204,"./webgl":205}],65:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var io_utils_1 = require("./io_utils");
var router_registry_1 = require("./router_registry");
var DEFAULT_FILE_NAME_PREFIX = 'model';
var DEFAULT_JSON_EXTENSION_NAME = '.json';
var DEFAULT_WEIGHT_DATA_EXTENSION_NAME = '.weights.bin';
var BrowserDownloads = (function () {
    function BrowserDownloads(fileNamePrefix) {
        if (!environment_1.ENV.get('IS_BROWSER')) {
            throw new Error('triggerDownloads() cannot proceed because the current environment ' +
                'is not a browser.');
        }
        if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {
            fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);
        }
        if (fileNamePrefix == null || fileNamePrefix.length === 0) {
            fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;
        }
        this.modelTopologyFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;
        this.weightDataFileName =
            fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;
    }
    BrowserDownloads.prototype.save = function (modelArtifacts) {
        return __awaiter(this, void 0, void 0, function () {
            var weightsURL, weightsManifest, modelTopologyAndWeightManifest, modelTopologyAndWeightManifestURL, jsonAnchor, weightDataAnchor;
            return __generator(this, function (_a) {
                weightsURL = window.URL.createObjectURL(new Blob([modelArtifacts.weightData], { type: 'application/octet-stream' }));
                if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                    throw new Error('DownloadTrigger.save() does not support saving model topology ' +
                        'in binary formats yet.');
                }
                else {
                    weightsManifest = [{
                            paths: ['./' + this.weightDataFileName],
                            weights: modelArtifacts.weightSpecs
                        }];
                    modelTopologyAndWeightManifest = {
                        modelTopology: modelArtifacts.modelTopology,
                        weightsManifest: weightsManifest
                    };
                    modelTopologyAndWeightManifestURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: 'application/json' }));
                    jsonAnchor = this.jsonAnchor == null ? document.createElement('a') :
                        this.jsonAnchor;
                    jsonAnchor.download = this.modelTopologyFileName;
                    jsonAnchor.href = modelTopologyAndWeightManifestURL;
                    jsonAnchor.click();
                    if (modelArtifacts.weightData != null) {
                        weightDataAnchor = this.weightDataAnchor == null ?
                            document.createElement('a') :
                            this.weightDataAnchor;
                        weightDataAnchor.download = this.weightDataFileName;
                        weightDataAnchor.href = weightsURL;
                        weightDataAnchor.click();
                    }
                    return [2, { modelArtifactsInfo: io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts) }];
                }
                return [2];
            });
        });
    };
    BrowserDownloads.URL_SCHEME = 'downloads://';
    return BrowserDownloads;
}());
exports.BrowserDownloads = BrowserDownloads;
var BrowserFiles = (function () {
    function BrowserFiles(files) {
        if (files == null || files.length < 1) {
            throw new Error("When calling browserFiles, at least 1 file is required, " +
                ("but received " + files));
        }
        this.files = files;
    }
    BrowserFiles.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var jsonFile, weightFiles;
            var _this = this;
            return __generator(this, function (_a) {
                jsonFile = this.files[0];
                weightFiles = this.files.slice(1);
                return [2, new Promise(function (resolve, reject) {
                        var jsonReader = new FileReader();
                        jsonReader.onload = function (event) {
                            var modelJSON = JSON.parse(event.target.result);
                            var modelTopology = modelJSON.modelTopology;
                            if (modelTopology == null) {
                                reject(new Error("modelTopology field is missing from file " + jsonFile.name));
                                return;
                            }
                            if (weightFiles.length === 0) {
                                resolve({ modelTopology: modelTopology });
                            }
                            var weightsManifest = modelJSON.weightsManifest;
                            if (weightsManifest == null) {
                                reject(new Error("weightManifest field is missing from file " + jsonFile.name));
                                return;
                            }
                            var pathToFile;
                            try {
                                pathToFile =
                                    _this.checkManifestAndWeightFiles(weightsManifest, weightFiles);
                            }
                            catch (err) {
                                reject(err);
                                return;
                            }
                            var weightSpecs = [];
                            var paths = [];
                            var perFileBuffers = [];
                            weightsManifest.forEach(function (weightsGroup) {
                                weightsGroup.paths.forEach(function (path) {
                                    paths.push(path);
                                    perFileBuffers.push(null);
                                });
                                weightSpecs.push.apply(weightSpecs, weightsGroup.weights);
                            });
                            weightsManifest.forEach(function (weightsGroup) {
                                weightsGroup.paths.forEach(function (path) {
                                    var weightFileReader = new FileReader();
                                    weightFileReader.onload = function (event) {
                                        var weightData = event.target.result;
                                        var index = paths.indexOf(path);
                                        perFileBuffers[index] = weightData;
                                        if (perFileBuffers.indexOf(null) === -1) {
                                            resolve({
                                                modelTopology: modelTopology,
                                                weightSpecs: weightSpecs,
                                                weightData: io_utils_1.concatenateArrayBuffers(perFileBuffers),
                                            });
                                        }
                                    };
                                    weightFileReader.onerror = function (error) {
                                        reject("Failed to weights data from file of path '" + path + "'.");
                                        return;
                                    };
                                    weightFileReader.readAsArrayBuffer(pathToFile[path]);
                                });
                            });
                        };
                        jsonReader.onerror = function (error) {
                            reject("Failed to read model topology and weights manifest JSON " +
                                ("from file '" + jsonFile.name + "'. BrowserFiles supports loading ") +
                                "Keras-style tf.Model artifacts only.");
                            return;
                        };
                        jsonReader.readAsText(jsonFile);
                    })];
            });
        });
    };
    BrowserFiles.prototype.checkManifestAndWeightFiles = function (manifest, files) {
        var basenames = [];
        var fileNames = files.map(function (file) { return io_utils_1.basename(file.name); });
        var pathToFile = {};
        for (var _i = 0, manifest_1 = manifest; _i < manifest_1.length; _i++) {
            var group = manifest_1[_i];
            group.paths.forEach(function (path) {
                var pathBasename = io_utils_1.basename(path);
                if (basenames.indexOf(pathBasename) !== -1) {
                    throw new Error("Duplicate file basename found in weights manifest: " +
                        ("'" + pathBasename + "'"));
                }
                basenames.push(pathBasename);
                if (fileNames.indexOf(pathBasename) === -1) {
                    throw new Error("Weight file with basename '" + pathBasename + "' is not provided.");
                }
                else {
                    pathToFile[path] = files[fileNames.indexOf(pathBasename)];
                }
            });
        }
        if (basenames.length !== files.length) {
            throw new Error("Mismatch in the number of files in weights manifest " +
                ("(" + basenames.length + ") and the number of weight files provided ") +
                ("(" + files.length + ")."));
        }
        return pathToFile;
    };
    return BrowserFiles;
}());
exports.browserDownloadsRouter = function (url) {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        return null;
    }
    else {
        if (!Array.isArray(url) && url.startsWith(BrowserDownloads.URL_SCHEME)) {
            return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));
        }
        else {
            return null;
        }
    }
};
router_registry_1.IORouterRegistry.registerSaveRouter(exports.browserDownloadsRouter);
function browserDownloads(fileNamePrefix) {
    if (fileNamePrefix === void 0) { fileNamePrefix = 'model'; }
    return new BrowserDownloads(fileNamePrefix);
}
exports.browserDownloads = browserDownloads;
function browserFiles(files) {
    return new BrowserFiles(files);
}
exports.browserFiles = browserFiles;

},{"../environment":60,"./io_utils":69,"./router_registry":73}],66:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var io_utils_1 = require("./io_utils");
var router_registry_1 = require("./router_registry");
var weights_loader_1 = require("./weights_loader");
var BrowserHTTPRequest = (function () {
    function BrowserHTTPRequest(path, requestInit) {
        this.DEFAULT_METHOD = 'POST';
        if (typeof fetch === 'undefined') {
            throw new Error('browserHTTPRequest is not supported outside the web browser without a fetch polyfill.');
        }
        util_1.assert(path != null && path.length > 0, 'URL path for browserHTTPRequest must not be null, undefined or ' +
            'empty.');
        if (Array.isArray(path)) {
            util_1.assert(path.length === 2, 'URL paths for browserHTTPRequest must have a length of 2, ' +
                ("(actual length is " + path.length + ")."));
        }
        this.path = path;
        if (requestInit != null && requestInit.body != null) {
            throw new Error('requestInit is expected to have no pre-existing body, but has one.');
        }
        this.requestInit = requestInit || {};
    }
    BrowserHTTPRequest.prototype.save = function (modelArtifacts) {
        return __awaiter(this, void 0, void 0, function () {
            var init, weightsManifest, modelTopologyAndWeightManifest, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                            throw new Error('BrowserHTTPRequest.save() does not support saving model topology ' +
                                'in binary formats yet.');
                        }
                        init = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
                        init.body = new FormData();
                        weightsManifest = [{
                                paths: ['./model.weights.bin'],
                                weights: modelArtifacts.weightSpecs,
                            }];
                        modelTopologyAndWeightManifest = {
                            modelTopology: modelArtifacts.modelTopology,
                            weightsManifest: weightsManifest
                        };
                        init.body.append('model.json', new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: 'application/json' }), 'model.json');
                        if (modelArtifacts.weightData != null) {
                            init.body.append('model.weights.bin', new Blob([modelArtifacts.weightData], { type: 'application/octet-stream' }), 'model.weights.bin');
                        }
                        return [4, fetch(this.path, init)];
                    case 1:
                        response = _a.sent();
                        if (response.status === 200) {
                            return [2, {
                                    modelArtifactsInfo: io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts),
                                    responses: [response],
                                }];
                        }
                        else {
                            throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " +
                                (response.status + "."));
                        }
                        return [2];
                }
            });
        });
    };
    BrowserHTTPRequest.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, Array.isArray(this.path) ? this.loadBinaryModel() :
                        this.loadJSONModel()];
            });
        });
    };
    BrowserHTTPRequest.prototype.loadBinaryTopology = function () {
        return __awaiter(this, void 0, void 0, function () {
            var response, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        return [4, fetch(this.path[0], this.requestInit)];
                    case 1:
                        response = _a.sent();
                        return [4, response.arrayBuffer()];
                    case 2: return [2, _a.sent()];
                    case 3:
                        error_1 = _a.sent();
                        throw new Error(this.path[0] + " not found. " + error_1);
                    case 4: return [2];
                }
            });
        });
    };
    BrowserHTTPRequest.prototype.loadBinaryModel = function () {
        return __awaiter(this, void 0, void 0, function () {
            var graphPromise, manifestPromise, results, modelTopology, weightsManifestResponse, weightsManifest, weightSpecs, weightData, results_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        graphPromise = this.loadBinaryTopology();
                        return [4, fetch(this.path[1], this.requestInit)];
                    case 1:
                        manifestPromise = _a.sent();
                        return [4, Promise.all([graphPromise, manifestPromise])];
                    case 2:
                        results = _a.sent();
                        modelTopology = results[0], weightsManifestResponse = results[1];
                        return [4, weightsManifestResponse.json()];
                    case 3:
                        weightsManifest = _a.sent();
                        if (!(weightsManifest != null)) return [3, 5];
                        return [4, this.loadWeights(weightsManifest)];
                    case 4:
                        results_1 = _a.sent();
                        weightSpecs = results_1[0], weightData = results_1[1];
                        _a.label = 5;
                    case 5: return [2, { modelTopology: modelTopology, weightSpecs: weightSpecs, weightData: weightData }];
                }
            });
        });
    };
    BrowserHTTPRequest.prototype.loadJSONModel = function () {
        return __awaiter(this, void 0, void 0, function () {
            var modelConfigRequest, modelConfig, modelTopology, weightsManifest, weightSpecs, weightData, weightsManifest_1, results;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, fetch(this.path, this.requestInit)];
                    case 1:
                        modelConfigRequest = _a.sent();
                        return [4, modelConfigRequest.json()];
                    case 2:
                        modelConfig = _a.sent();
                        modelTopology = modelConfig['modelTopology'];
                        weightsManifest = modelConfig['weightsManifest'];
                        if (modelTopology == null && weightsManifest == null) {
                            throw new Error("The JSON from HTTP path " + this.path + " contains neither model " +
                                "topology or manifest for weights.");
                        }
                        if (!(weightsManifest != null)) return [3, 4];
                        weightsManifest_1 = modelConfig['weightsManifest'];
                        return [4, this.loadWeights(weightsManifest_1)];
                    case 3:
                        results = _a.sent();
                        weightSpecs = results[0], weightData = results[1];
                        _a.label = 4;
                    case 4: return [2, { modelTopology: modelTopology, weightSpecs: weightSpecs, weightData: weightData }];
                }
            });
        });
    };
    BrowserHTTPRequest.prototype.loadWeights = function (weightsManifest) {
        return __awaiter(this, void 0, void 0, function () {
            var weightPath, weightSpecs, _i, weightsManifest_2, entry, pathPrefix, fetchURLs, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        weightPath = Array.isArray(this.path) ? this.path[1] : this.path;
                        weightSpecs = [];
                        for (_i = 0, weightsManifest_2 = weightsManifest; _i < weightsManifest_2.length; _i++) {
                            entry = weightsManifest_2[_i];
                            weightSpecs.push.apply(weightSpecs, entry.weights);
                        }
                        pathPrefix = weightPath.substring(0, weightPath.lastIndexOf('/'));
                        if (!pathPrefix.endsWith('/')) {
                            pathPrefix = pathPrefix + '/';
                        }
                        fetchURLs = [];
                        weightsManifest.forEach(function (weightsGroup) {
                            weightsGroup.paths.forEach(function (path) {
                                fetchURLs.push(pathPrefix + path);
                            });
                        });
                        _a = [weightSpecs];
                        _b = io_utils_1.concatenateArrayBuffers;
                        return [4, weights_loader_1.loadWeightsAsArrayBuffer(fetchURLs, this.requestInit)];
                    case 1: return [2, _a.concat([
                            _b.apply(void 0, [_c.sent()])
                        ])];
                }
            });
        });
    };
    BrowserHTTPRequest.URL_SCHEME_REGEX = /^https?:\/\//;
    return BrowserHTTPRequest;
}());
exports.BrowserHTTPRequest = BrowserHTTPRequest;
function isHTTPScheme(url) {
    return url.match(BrowserHTTPRequest.URL_SCHEME_REGEX) != null;
}
exports.httpRequestRouter = function (url) {
    if (typeof fetch === 'undefined') {
        return null;
    }
    else {
        var isHTTP = true;
        if (Array.isArray(url)) {
            isHTTP = url.every(function (urlItem) { return isHTTPScheme(urlItem); });
        }
        else {
            isHTTP = isHTTPScheme(url);
        }
        if (isHTTP) {
            return browserHTTPRequest(url);
        }
    }
    return null;
};
router_registry_1.IORouterRegistry.registerSaveRouter(exports.httpRequestRouter);
router_registry_1.IORouterRegistry.registerLoadRouter(exports.httpRequestRouter);
function browserHTTPRequest(path, requestInit) {
    return new BrowserHTTPRequest(path, requestInit);
}
exports.browserHTTPRequest = browserHTTPRequest;

},{"../util":203,"./io_utils":69,"./router_registry":73,"./weights_loader":75}],67:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var io_utils_1 = require("./io_utils");
var model_management_1 = require("./model_management");
var router_registry_1 = require("./router_registry");
var DATABASE_NAME = 'tensorflowjs';
var DATABASE_VERSION = 1;
var MODEL_STORE_NAME = 'models_store';
var INFO_STORE_NAME = 'model_info_store';
function deleteDatabase() {
    return __awaiter(this, void 0, void 0, function () {
        var idbFactory;
        return __generator(this, function (_a) {
            idbFactory = getIndexedDBFactory();
            return [2, new Promise(function (resolve, reject) {
                    var deleteRequest = idbFactory.deleteDatabase(DATABASE_NAME);
                    deleteRequest.onsuccess = function () { return resolve(); };
                    deleteRequest.onerror = function (error) { return reject(error); };
                })];
        });
    });
}
exports.deleteDatabase = deleteDatabase;
function getIndexedDBFactory() {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        throw new Error('Failed to obtain IndexedDB factory because the current environment' +
            'is not a web browser.');
    }
    var theWindow = window;
    var factory = theWindow.indexedDB || theWindow.mozIndexedDB ||
        theWindow.webkitIndexedDB || theWindow.msIndexedDB ||
        theWindow.shimIndexedDB;
    if (factory == null) {
        throw new Error('The current browser does not appear to support IndexedDB.');
    }
    return factory;
}
function setUpDatabase(openRequest) {
    var db = openRequest.result;
    db.createObjectStore(MODEL_STORE_NAME, { keyPath: 'modelPath' });
    db.createObjectStore(INFO_STORE_NAME, { keyPath: 'modelPath' });
}
var BrowserIndexedDB = (function () {
    function BrowserIndexedDB(modelPath) {
        this.indexedDB = getIndexedDBFactory();
        if (modelPath == null || !modelPath) {
            throw new Error('For IndexedDB, modelPath must not be null, undefined or empty.');
        }
        this.modelPath = modelPath;
    }
    BrowserIndexedDB.prototype.save = function (modelArtifacts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                    throw new Error('BrowserLocalStorage.save() does not support saving model topology ' +
                        'in binary formats yet.');
                }
                return [2, this.databaseAction(this.modelPath, modelArtifacts)];
            });
        });
    };
    BrowserIndexedDB.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.databaseAction(this.modelPath)];
            });
        });
    };
    BrowserIndexedDB.prototype.databaseAction = function (modelPath, modelArtifacts) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
            openRequest.onupgradeneeded = function () { return setUpDatabase(openRequest); };
            openRequest.onsuccess = function () {
                var db = openRequest.result;
                if (modelArtifacts == null) {
                    var modelTx = db.transaction(MODEL_STORE_NAME, 'readonly');
                    var modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                    var getRequest_1 = modelStore.get(_this.modelPath);
                    getRequest_1.onsuccess = function () {
                        if (getRequest_1.result == null) {
                            db.close();
                            return reject(new Error("Cannot find model with path '" + _this.modelPath + "' " +
                                "in IndexedDB."));
                        }
                        else {
                            resolve(getRequest_1.result.modelArtifacts);
                        }
                    };
                    getRequest_1.onerror = function (error) {
                        db.close();
                        return reject(getRequest_1.error);
                    };
                    modelTx.oncomplete = function () { return db.close(); };
                }
                else {
                    var modelArtifactsInfo_1 = io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts);
                    var infoTx_1 = db.transaction(INFO_STORE_NAME, 'readwrite');
                    var infoStore_1 = infoTx_1.objectStore(INFO_STORE_NAME);
                    var putInfoRequest_1 = infoStore_1.put({ modelPath: _this.modelPath, modelArtifactsInfo: modelArtifactsInfo_1 });
                    var modelTx_1;
                    putInfoRequest_1.onsuccess = function () {
                        modelTx_1 = db.transaction(MODEL_STORE_NAME, 'readwrite');
                        var modelStore = modelTx_1.objectStore(MODEL_STORE_NAME);
                        var putModelRequest = modelStore.put({
                            modelPath: _this.modelPath,
                            modelArtifacts: modelArtifacts,
                            modelArtifactsInfo: modelArtifactsInfo_1
                        });
                        putModelRequest.onsuccess = function () { return resolve({ modelArtifactsInfo: modelArtifactsInfo_1 }); };
                        putModelRequest.onerror = function (error) {
                            infoStore_1 = infoTx_1.objectStore(INFO_STORE_NAME);
                            var deleteInfoRequest = infoStore_1.delete(_this.modelPath);
                            deleteInfoRequest.onsuccess = function () {
                                db.close();
                                return reject(putModelRequest.error);
                            };
                            deleteInfoRequest.onerror = function (error) {
                                db.close();
                                return reject(putModelRequest.error);
                            };
                        };
                    };
                    putInfoRequest_1.onerror = function (error) {
                        db.close();
                        return reject(putInfoRequest_1.error);
                    };
                    infoTx_1.oncomplete = function () {
                        if (modelTx_1 == null) {
                            db.close();
                        }
                        else {
                            modelTx_1.oncomplete = function () { return db.close(); };
                        }
                    };
                }
            };
            openRequest.onerror = function (error) { return reject(openRequest.error); };
        });
    };
    BrowserIndexedDB.URL_SCHEME = 'indexeddb://';
    return BrowserIndexedDB;
}());
exports.BrowserIndexedDB = BrowserIndexedDB;
exports.indexedDBRouter = function (url) {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        return null;
    }
    else {
        if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {
            return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));
        }
        else {
            return null;
        }
    }
};
router_registry_1.IORouterRegistry.registerSaveRouter(exports.indexedDBRouter);
router_registry_1.IORouterRegistry.registerLoadRouter(exports.indexedDBRouter);
function browserIndexedDB(modelPath) {
    return new BrowserIndexedDB(modelPath);
}
exports.browserIndexedDB = browserIndexedDB;
function maybeStripScheme(key) {
    return key.startsWith(BrowserIndexedDB.URL_SCHEME) ?
        key.slice(BrowserIndexedDB.URL_SCHEME.length) :
        key;
}
var BrowserIndexedDBManager = (function () {
    function BrowserIndexedDBManager() {
        this.indexedDB = getIndexedDBFactory();
    }
    BrowserIndexedDBManager.prototype.listModels = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, new Promise(function (resolve, reject) {
                        var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
                        openRequest.onupgradeneeded = function () { return setUpDatabase(openRequest); };
                        openRequest.onsuccess = function () {
                            var db = openRequest.result;
                            var tx = db.transaction(INFO_STORE_NAME, 'readonly');
                            var store = tx.objectStore(INFO_STORE_NAME);
                            var getAllInfoRequest = store.getAll();
                            getAllInfoRequest.onsuccess = function () {
                                var out = {};
                                for (var _i = 0, _a = getAllInfoRequest.result; _i < _a.length; _i++) {
                                    var item = _a[_i];
                                    out[item.modelPath] = item.modelArtifactsInfo;
                                }
                                resolve(out);
                            };
                            getAllInfoRequest.onerror = function (error) {
                                db.close();
                                return reject(getAllInfoRequest.error);
                            };
                            tx.oncomplete = function () { return db.close(); };
                        };
                        openRequest.onerror = function (error) { return reject(openRequest.error); };
                    })];
            });
        });
    };
    BrowserIndexedDBManager.prototype.removeModel = function (path) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                path = maybeStripScheme(path);
                return [2, new Promise(function (resolve, reject) {
                        var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
                        openRequest.onupgradeneeded = function () { return setUpDatabase(openRequest); };
                        openRequest.onsuccess = function () {
                            var db = openRequest.result;
                            var infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');
                            var infoStore = infoTx.objectStore(INFO_STORE_NAME);
                            var getInfoRequest = infoStore.get(path);
                            var modelTx;
                            getInfoRequest.onsuccess = function () {
                                if (getInfoRequest.result == null) {
                                    db.close();
                                    return reject(new Error("Cannot find model with path '" + path + "' " +
                                        "in IndexedDB."));
                                }
                                else {
                                    var deleteInfoRequest = infoStore.delete(path);
                                    var deleteModelData_1 = function () {
                                        modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');
                                        var modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                                        var deleteModelRequest = modelStore.delete(path);
                                        deleteModelRequest.onsuccess = function () {
                                            return resolve(getInfoRequest.result.modelArtifactsInfo);
                                        };
                                        deleteModelRequest.onerror = function (error) {
                                            return reject(getInfoRequest.error);
                                        };
                                    };
                                    deleteInfoRequest.onsuccess = deleteModelData_1;
                                    deleteInfoRequest.onerror = function (error) {
                                        deleteModelData_1();
                                        db.close();
                                        return reject(getInfoRequest.error);
                                    };
                                }
                            };
                            getInfoRequest.onerror = function (error) {
                                db.close();
                                return reject(getInfoRequest.error);
                            };
                            infoTx.oncomplete = function () {
                                if (modelTx == null) {
                                    db.close();
                                }
                                else {
                                    modelTx.oncomplete = function () { return db.close(); };
                                }
                            };
                        };
                        openRequest.onerror = function (error) { return reject(openRequest.error); };
                    })];
            });
        });
    };
    return BrowserIndexedDBManager;
}());
exports.BrowserIndexedDBManager = BrowserIndexedDBManager;
if (environment_1.ENV.get('IS_BROWSER')) {
    try {
        model_management_1.ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());
    }
    catch (err) {
    }
}

},{"../environment":60,"./io_utils":69,"./model_management":71,"./router_registry":73}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("./indexed_db");
require("./local_storage");
var browser_files_1 = require("./browser_files");
exports.browserFiles = browser_files_1.browserFiles;
var browser_http_1 = require("./browser_http");
exports.browserHTTPRequest = browser_http_1.browserHTTPRequest;
var io_utils_1 = require("./io_utils");
exports.concatenateArrayBuffers = io_utils_1.concatenateArrayBuffers;
exports.decodeWeights = io_utils_1.decodeWeights;
exports.encodeWeights = io_utils_1.encodeWeights;
exports.getModelArtifactsInfoForJSON = io_utils_1.getModelArtifactsInfoForJSON;
var passthrough_1 = require("./passthrough");
exports.fromMemory = passthrough_1.fromMemory;
exports.withSaveHandler = passthrough_1.withSaveHandler;
var router_registry_1 = require("./router_registry");
var weights_loader_1 = require("./weights_loader");
exports.loadWeights = weights_loader_1.loadWeights;
var registerSaveRouter = router_registry_1.IORouterRegistry.registerSaveRouter;
exports.registerSaveRouter = registerSaveRouter;
var registerLoadRouter = router_registry_1.IORouterRegistry.registerLoadRouter;
exports.registerLoadRouter = registerLoadRouter;
var getSaveHandlers = router_registry_1.IORouterRegistry.getSaveHandlers;
exports.getSaveHandlers = getSaveHandlers;
var getLoadHandlers = router_registry_1.IORouterRegistry.getLoadHandlers;
exports.getLoadHandlers = getLoadHandlers;
var model_management_1 = require("./model_management");
exports.copyModel = model_management_1.copyModel;
exports.listModels = model_management_1.listModels;
exports.moveModel = model_management_1.moveModel;
exports.removeModel = model_management_1.removeModel;

},{"./browser_files":65,"./browser_http":66,"./indexed_db":67,"./io_utils":69,"./local_storage":70,"./model_management":71,"./passthrough":72,"./router_registry":73,"./weights_loader":75}],69:[function(require,module,exports){
(function (Buffer){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_ops_1 = require("../ops/tensor_ops");
var util_1 = require("../util");
var types_1 = require("./types");
function encodeWeights(tensors) {
    return __awaiter(this, void 0, void 0, function () {
        var specs, dataPromises, name_1, t, tensorValues;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    specs = [];
                    dataPromises = [];
                    for (name_1 in tensors) {
                        t = tensors[name_1];
                        if (t.dtype !== 'float32' && t.dtype !== 'int32' && t.dtype !== 'bool') {
                            throw new Error("Unsupported dtype in weight '" + name_1 + "': " + t.dtype);
                        }
                        specs.push({ name: name_1, shape: t.shape, dtype: t.dtype });
                        dataPromises.push(t.data());
                    }
                    return [4, Promise.all(dataPromises)];
                case 1:
                    tensorValues = _a.sent();
                    return [2, { data: concatenateTypedArrays(tensorValues), specs: specs }];
            }
        });
    });
}
exports.encodeWeights = encodeWeights;
function decodeWeights(buffer, specs) {
    var out = {};
    var offset = 0;
    var _loop_1 = function (spec) {
        var name_2 = spec.name;
        var dtype = spec.dtype;
        var shape = spec.shape;
        var size = util_1.sizeFromShape(shape);
        var typedArray = void 0;
        if ('quantization' in spec) {
            var quantization_1 = spec.quantization;
            if (quantization_1.dtype !== 'uint8' && quantization_1.dtype !== 'uint16') {
                throw new Error("Weight " + spec.name + " has unknown " +
                    ("quantization dtype " + quantization_1.dtype + ". ") +
                    "Supported quantization dtypes are: 'uint8' and 'uint16'.");
            }
            var quantizationSizeFactor = types_1.DTYPE_VALUE_SIZE_MAP[quantization_1.dtype];
            var byteBuffer = buffer.slice(offset, offset + size * quantizationSizeFactor);
            var quantizedArray = (quantization_1.dtype === 'uint8') ?
                new Uint8Array(byteBuffer) :
                new Uint16Array(byteBuffer);
            if (dtype === 'float32') {
                typedArray = Float32Array.from(quantizedArray, function (v) { return v * quantization_1.scale + quantization_1.min; });
            }
            else if (dtype === 'int32') {
                typedArray = Int32Array.from(quantizedArray, function (v) { return Math.round(v * quantization_1.scale + quantization_1.min); });
            }
            else {
                throw new Error("Unsupported dtype in weight '" + name_2 + "': " + dtype);
            }
            offset += size * quantizationSizeFactor;
        }
        else {
            var dtypeFactor = types_1.DTYPE_VALUE_SIZE_MAP[dtype];
            var byteBuffer = buffer.slice(offset, offset + size * dtypeFactor);
            if (dtype === 'float32') {
                typedArray = new Float32Array(byteBuffer);
            }
            else if (dtype === 'int32') {
                typedArray = new Int32Array(byteBuffer);
            }
            else if (dtype === 'bool') {
                typedArray = new Uint8Array(byteBuffer);
            }
            else {
                throw new Error("Unsupported dtype in weight '" + name_2 + "': " + dtype);
            }
            offset += size * dtypeFactor;
        }
        var value = void 0;
        if (dtype === 'float32') {
            value = tensor_ops_1.tensor(typedArray, shape, 'float32');
        }
        else if (dtype === 'int32') {
            value = tensor_ops_1.tensor(typedArray, shape, 'int32');
        }
        else if (dtype === 'bool') {
            value = tensor_ops_1.tensor(typedArray, shape, 'bool');
        }
        else {
            throw new Error("Unsupported dtype in weight '" + name_2 + "': " + dtype);
        }
        out[name_2] = value;
    };
    for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {
        var spec = specs_1[_i];
        _loop_1(spec);
    }
    return out;
}
exports.decodeWeights = decodeWeights;
function concatenateTypedArrays(xs) {
    if (xs === null) {
        throw new Error("Invalid input value: " + JSON.stringify(xs));
    }
    var totalByteLength = 0;
    var normalizedXs = [];
    xs.forEach(function (x) {
        totalByteLength += x.byteLength;
        normalizedXs.push(x.byteLength === x.buffer.byteLength ? x :
            new x.constructor(x));
        if (!(x instanceof Float32Array || x instanceof Int32Array ||
            x instanceof Uint8Array)) {
            throw new Error("Unsupported TypedArray subtype: " + x.constructor.name);
        }
    });
    var y = new Uint8Array(totalByteLength);
    var offset = 0;
    normalizedXs.forEach(function (x) {
        y.set(new Uint8Array(x.buffer), offset);
        offset += x.byteLength;
    });
    return y.buffer;
}
exports.concatenateTypedArrays = concatenateTypedArrays;
var useNodeBuffer = typeof Buffer !== 'undefined' &&
    (typeof Blob === 'undefined' || typeof atob === 'undefined' ||
        typeof btoa === 'undefined');
function stringByteLength(str) {
    if (useNodeBuffer) {
        return Buffer.byteLength(str);
    }
    return new Blob([str]).size;
}
exports.stringByteLength = stringByteLength;
function arrayBufferToBase64String(buffer) {
    if (useNodeBuffer) {
        return Buffer.from(buffer).toString('base64');
    }
    return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)));
}
exports.arrayBufferToBase64String = arrayBufferToBase64String;
function base64StringToArrayBuffer(str) {
    if (useNodeBuffer) {
        var buf = Buffer.from(str, 'base64');
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    var s = atob(str);
    var buffer = new Uint8Array(s.length);
    for (var i = 0; i < s.length; ++i) {
        buffer.set([s.charCodeAt(i)], i);
    }
    return buffer.buffer;
}
exports.base64StringToArrayBuffer = base64StringToArrayBuffer;
function concatenateArrayBuffers(buffers) {
    var totalByteLength = 0;
    buffers.forEach(function (buffer) {
        totalByteLength += buffer.byteLength;
    });
    var temp = new Uint8Array(totalByteLength);
    var offset = 0;
    buffers.forEach(function (buffer) {
        temp.set(new Uint8Array(buffer), offset);
        offset += buffer.byteLength;
    });
    return temp.buffer;
}
exports.concatenateArrayBuffers = concatenateArrayBuffers;
function basename(path) {
    var SEPARATOR = '/';
    path = path.trim();
    while (path.endsWith(SEPARATOR)) {
        path = path.slice(0, path.length - 1);
    }
    var items = path.split(SEPARATOR);
    return items[items.length - 1];
}
exports.basename = basename;
function getModelArtifactsInfoForJSON(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error('Expected JSON model topology, received ArrayBuffer.');
    }
    return {
        dateSaved: new Date(),
        modelTopologyType: 'JSON',
        modelTopologyBytes: modelArtifacts.modelTopology == null ?
            0 :
            stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),
        weightSpecsBytes: modelArtifacts.weightSpecs == null ?
            0 :
            stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),
        weightDataBytes: modelArtifacts.weightData == null ?
            0 :
            modelArtifacts.weightData.byteLength,
    };
}
exports.getModelArtifactsInfoForJSON = getModelArtifactsInfoForJSON;

}).call(this,require("buffer").Buffer)
},{"../ops/tensor_ops":180,"../util":203,"./types":74,"buffer":3}],70:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util_1 = require("../util");
var io_utils_1 = require("./io_utils");
var model_management_1 = require("./model_management");
var router_registry_1 = require("./router_registry");
var PATH_SEPARATOR = '/';
var PATH_PREFIX = 'tensorflowjs_models';
var INFO_SUFFIX = 'info';
var MODEL_TOPOLOGY_SUFFIX = 'model_topology';
var WEIGHT_SPECS_SUFFIX = 'weight_specs';
var WEIGHT_DATA_SUFFIX = 'weight_data';
function purgeLocalStorageArtifacts() {
    if (!environment_1.ENV.get('IS_BROWSER') || typeof window.localStorage === 'undefined') {
        throw new Error('purgeLocalStorageModels() cannot proceed because local storage is ' +
            'unavailable in the current environment.');
    }
    var LS = window.localStorage;
    var purgedModelPaths = [];
    for (var i = 0; i < LS.length; ++i) {
        var key = LS.key(i);
        var prefix = PATH_PREFIX + PATH_SEPARATOR;
        if (key.startsWith(prefix) && key.length > prefix.length) {
            LS.removeItem(key);
            var modelName = getModelPathFromKey(key);
            if (purgedModelPaths.indexOf(modelName) === -1) {
                purgedModelPaths.push(modelName);
            }
        }
    }
    return purgedModelPaths;
}
exports.purgeLocalStorageArtifacts = purgeLocalStorageArtifacts;
function getModelKeys(path) {
    return {
        info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),
        topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),
        weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),
        weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR)
    };
}
function getModelPathFromKey(key) {
    var items = key.split(PATH_SEPARATOR);
    if (items.length < 3) {
        throw new Error("Invalid key format: " + key);
    }
    return items.slice(1, items.length - 1).join(PATH_SEPARATOR);
}
function maybeStripScheme(key) {
    return key.startsWith(BrowserLocalStorage.URL_SCHEME) ?
        key.slice(BrowserLocalStorage.URL_SCHEME.length) :
        key;
}
var BrowserLocalStorage = (function () {
    function BrowserLocalStorage(modelPath) {
        if (!environment_1.ENV.get('IS_BROWSER') || typeof window.localStorage === 'undefined') {
            throw new Error('The current environment does not support local storage.');
        }
        this.LS = window.localStorage;
        if (modelPath == null || !modelPath) {
            throw new Error('For local storage, modelPath must not be null, undefined or empty.');
        }
        this.modelPath = modelPath;
        this.keys = getModelKeys(this.modelPath);
    }
    BrowserLocalStorage.prototype.save = function (modelArtifacts) {
        return __awaiter(this, void 0, void 0, function () {
            var topology, weightSpecs, modelArtifactsInfo, key;
            return __generator(this, function (_a) {
                if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                    throw new Error('BrowserLocalStorage.save() does not support saving model topology ' +
                        'in binary formats yet.');
                }
                else {
                    topology = JSON.stringify(modelArtifacts.modelTopology);
                    weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
                    modelArtifactsInfo = io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts);
                    try {
                        this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
                        this.LS.setItem(this.keys.topology, topology);
                        this.LS.setItem(this.keys.weightSpecs, weightSpecs);
                        this.LS.setItem(this.keys.weightData, io_utils_1.arrayBufferToBase64String(modelArtifacts.weightData));
                        return [2, { modelArtifactsInfo: modelArtifactsInfo }];
                    }
                    catch (err) {
                        for (key in this.keys) {
                            this.LS.removeItem(this.keys[key]);
                        }
                        throw new Error("Failed to save model '" + this.modelPath + "' to local storage: " +
                            "size quota being exceeded is a possible cause of this failure: " +
                            ("modelTopologyBytes=" + modelArtifactsInfo.modelTopologyBytes + ", ") +
                            ("weightSpecsBytes=" + modelArtifactsInfo.weightSpecsBytes + ", ") +
                            ("weightDataBytes=" + modelArtifactsInfo.weightDataBytes + "."));
                    }
                }
                return [2];
            });
        });
    };
    BrowserLocalStorage.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var info, out, topology, weightSpecs, weightDataBase64;
            return __generator(this, function (_a) {
                info = JSON.parse(this.LS.getItem(this.keys.info));
                if (info == null) {
                    throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
                }
                if (info.modelTopologyType !== 'JSON') {
                    throw new Error('BrowserLocalStorage does not support loading non-JSON model ' +
                        'topology yet.');
                }
                out = {};
                topology = JSON.parse(this.LS.getItem(this.keys.topology));
                if (topology == null) {
                    throw new Error("In local storage, the topology of model '" + this.modelPath + "' " +
                        "is missing.");
                }
                out.modelTopology = topology;
                weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
                if (weightSpecs == null) {
                    throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' " +
                        "are missing.");
                }
                out.weightSpecs = weightSpecs;
                weightDataBase64 = this.LS.getItem(this.keys.weightData);
                if (weightDataBase64 == null) {
                    throw new Error("In local storage, the binary weight values of model " +
                        ("'" + this.modelPath + "' are missing."));
                }
                out.weightData = io_utils_1.base64StringToArrayBuffer(weightDataBase64);
                return [2, out];
            });
        });
    };
    BrowserLocalStorage.URL_SCHEME = 'localstorage://';
    return BrowserLocalStorage;
}());
exports.BrowserLocalStorage = BrowserLocalStorage;
exports.localStorageRouter = function (url) {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        return null;
    }
    else {
        if (!Array.isArray(url) &&
            url.startsWith(BrowserLocalStorage.URL_SCHEME)) {
            return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length));
        }
        else {
            return null;
        }
    }
};
router_registry_1.IORouterRegistry.registerSaveRouter(exports.localStorageRouter);
router_registry_1.IORouterRegistry.registerLoadRouter(exports.localStorageRouter);
function browserLocalStorage(modelPath) {
    return new BrowserLocalStorage(modelPath);
}
exports.browserLocalStorage = browserLocalStorage;
var BrowserLocalStorageManager = (function () {
    function BrowserLocalStorageManager() {
        util_1.assert(environment_1.ENV.get('IS_BROWSER'), 'Current environment is not a web browser');
        util_1.assert(typeof window.localStorage !== 'undefined', 'Current browser does not appear to support localStorage');
        this.LS = window.localStorage;
    }
    BrowserLocalStorageManager.prototype.listModels = function () {
        return __awaiter(this, void 0, void 0, function () {
            var out, prefix, suffix, i, key, modelPath;
            return __generator(this, function (_a) {
                out = {};
                prefix = PATH_PREFIX + PATH_SEPARATOR;
                suffix = PATH_SEPARATOR + INFO_SUFFIX;
                for (i = 0; i < this.LS.length; ++i) {
                    key = this.LS.key(i);
                    if (key.startsWith(prefix) && key.endsWith(suffix)) {
                        modelPath = getModelPathFromKey(key);
                        out[modelPath] = JSON.parse(this.LS.getItem(key));
                    }
                }
                return [2, out];
            });
        });
    };
    BrowserLocalStorageManager.prototype.removeModel = function (path) {
        return __awaiter(this, void 0, void 0, function () {
            var keys, info;
            return __generator(this, function (_a) {
                path = maybeStripScheme(path);
                keys = getModelKeys(path);
                if (this.LS.getItem(keys.info) == null) {
                    throw new Error("Cannot find model at path '" + path + "'");
                }
                info = JSON.parse(this.LS.getItem(keys.info));
                this.LS.removeItem(keys.info);
                this.LS.removeItem(keys.topology);
                this.LS.removeItem(keys.weightSpecs);
                this.LS.removeItem(keys.weightData);
                return [2, info];
            });
        });
    };
    return BrowserLocalStorageManager;
}());
exports.BrowserLocalStorageManager = BrowserLocalStorageManager;
if (environment_1.ENV.get('IS_BROWSER')) {
    try {
        model_management_1.ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());
    }
    catch (err) {
    }
}

},{"../environment":60,"../util":203,"./io_utils":69,"./model_management":71,"./router_registry":73}],71:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var router_registry_1 = require("./router_registry");
var URL_SCHEME_SUFFIX = '://';
var ModelStoreManagerRegistry = (function () {
    function ModelStoreManagerRegistry() {
        this.managers = {};
    }
    ModelStoreManagerRegistry.getInstance = function () {
        if (ModelStoreManagerRegistry.instance == null) {
            ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry();
        }
        return ModelStoreManagerRegistry.instance;
    };
    ModelStoreManagerRegistry.registerManager = function (scheme, manager) {
        util_1.assert(scheme != null, 'scheme must not be undefined or null.');
        if (scheme.endsWith(URL_SCHEME_SUFFIX)) {
            scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX));
        }
        util_1.assert(scheme.length > 0, 'scheme must not be an empty string.');
        var registry = ModelStoreManagerRegistry.getInstance();
        util_1.assert(registry.managers[scheme] == null, "A model store manager is already registered for scheme '" + scheme + "'.");
        registry.managers[scheme] = manager;
    };
    ModelStoreManagerRegistry.getManager = function (scheme) {
        var manager = this.getInstance().managers[scheme];
        if (manager == null) {
            throw new Error("Cannot find model manager for scheme '" + scheme + "'");
        }
        return manager;
    };
    ModelStoreManagerRegistry.getSchemes = function () {
        return Object.keys(this.getInstance().managers);
    };
    return ModelStoreManagerRegistry;
}());
exports.ModelStoreManagerRegistry = ModelStoreManagerRegistry;
function parseURL(url) {
    if (url.indexOf(URL_SCHEME_SUFFIX) === -1) {
        throw new Error("The url string provided does not contain a scheme. " +
            "Supported schemes are: " +
            ("" + ModelStoreManagerRegistry.getSchemes().join(',')));
    }
    return {
        scheme: url.split(URL_SCHEME_SUFFIX)[0],
        path: url.split(URL_SCHEME_SUFFIX)[1],
    };
}
function cloneModelInternal(sourceURL, destURL, deleteSource) {
    if (deleteSource === void 0) { deleteSource = false; }
    return __awaiter(this, void 0, void 0, function () {
        var loadHandlers, loadHandler, saveHandlers, saveHandler, sourceScheme, sourcePath, sameMedium, modelArtifacts, saveResult;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    util_1.assert(sourceURL !== destURL, "Old path and new path are the same: '" + sourceURL + "'");
                    loadHandlers = router_registry_1.IORouterRegistry.getLoadHandlers(sourceURL);
                    util_1.assert(loadHandlers.length > 0, "Copying failed because no load handler is found for source URL " + sourceURL + ".");
                    util_1.assert(loadHandlers.length < 2, "Copying failed because more than one (" + loadHandlers.length + ") " +
                        ("load handlers for source URL " + sourceURL + "."));
                    loadHandler = loadHandlers[0];
                    saveHandlers = router_registry_1.IORouterRegistry.getSaveHandlers(destURL);
                    util_1.assert(saveHandlers.length > 0, "Copying failed because no save handler is found for destination URL " +
                        (destURL + "."));
                    util_1.assert(saveHandlers.length < 2, "Copying failed because more than one (" + loadHandlers.length + ") " +
                        ("save handlers for destination URL " + destURL + "."));
                    saveHandler = saveHandlers[0];
                    sourceScheme = parseURL(sourceURL).scheme;
                    sourcePath = parseURL(sourceURL).path;
                    sameMedium = sourceScheme === parseURL(sourceURL).scheme;
                    return [4, loadHandler.load()];
                case 1:
                    modelArtifacts = _a.sent();
                    if (!(deleteSource && sameMedium)) return [3, 3];
                    return [4, ModelStoreManagerRegistry.getManager(sourceScheme)
                            .removeModel(sourcePath)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3: return [4, saveHandler.save(modelArtifacts)];
                case 4:
                    saveResult = _a.sent();
                    if (!(deleteSource && !sameMedium)) return [3, 6];
                    return [4, ModelStoreManagerRegistry.getManager(sourceScheme)
                            .removeModel(sourcePath)];
                case 5:
                    _a.sent();
                    _a.label = 6;
                case 6: return [2, saveResult.modelArtifactsInfo];
            }
        });
    });
}
function listModels() {
    return __awaiter(this, void 0, void 0, function () {
        var schemes, out, _i, schemes_1, scheme, schemeOut, path, url;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    schemes = ModelStoreManagerRegistry.getSchemes();
                    out = {};
                    _i = 0, schemes_1 = schemes;
                    _a.label = 1;
                case 1:
                    if (!(_i < schemes_1.length)) return [3, 4];
                    scheme = schemes_1[_i];
                    return [4, ModelStoreManagerRegistry.getManager(scheme).listModels()];
                case 2:
                    schemeOut = _a.sent();
                    for (path in schemeOut) {
                        url = scheme + URL_SCHEME_SUFFIX + path;
                        out[url] = schemeOut[path];
                    }
                    _a.label = 3;
                case 3:
                    _i++;
                    return [3, 1];
                case 4: return [2, out];
            }
        });
    });
}
exports.listModels = listModels;
function removeModel(url) {
    return __awaiter(this, void 0, void 0, function () {
        var schemeAndPath, manager;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    schemeAndPath = parseURL(url);
                    manager = ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);
                    return [4, manager.removeModel(schemeAndPath.path)];
                case 1: return [2, _a.sent()];
            }
        });
    });
}
exports.removeModel = removeModel;
function copyModel(sourceURL, destURL) {
    return __awaiter(this, void 0, void 0, function () {
        var deleteSource;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    deleteSource = false;
                    return [4, cloneModelInternal(sourceURL, destURL, deleteSource)];
                case 1: return [2, _a.sent()];
            }
        });
    });
}
exports.copyModel = copyModel;
function moveModel(sourceURL, destURL) {
    return __awaiter(this, void 0, void 0, function () {
        var deleteSource;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    deleteSource = true;
                    return [4, cloneModelInternal(sourceURL, destURL, deleteSource)];
                case 1: return [2, _a.sent()];
            }
        });
    });
}
exports.moveModel = moveModel;

},{"../util":203,"./router_registry":73}],72:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var PassthroughLoader = (function () {
    function PassthroughLoader(modelTopology, weightSpecs, weightData) {
        this.modelTopology = modelTopology;
        this.weightSpecs = weightSpecs;
        this.weightData = weightData;
    }
    PassthroughLoader.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                result = {};
                if (this.modelTopology != null) {
                    result = __assign({ modelTopology: this.modelTopology }, result);
                }
                if (this.weightSpecs != null && this.weightSpecs.length > 0) {
                    result = __assign({ weightSpecs: this.weightSpecs }, result);
                }
                if (this.weightData != null && this.weightData.byteLength > 0) {
                    result = __assign({ weightData: this.weightData }, result);
                }
                return [2, result];
            });
        });
    };
    return PassthroughLoader;
}());
var PassthroughSaver = (function () {
    function PassthroughSaver(saveHandler) {
        this.saveHandler = saveHandler;
    }
    PassthroughSaver.prototype.save = function (modelArtifacts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.saveHandler(modelArtifacts)];
            });
        });
    };
    return PassthroughSaver;
}());
function fromMemory(modelTopology, weightSpecs, weightData) {
    return new PassthroughLoader(modelTopology, weightSpecs, weightData);
}
exports.fromMemory = fromMemory;
function withSaveHandler(saveHandler) {
    return new PassthroughSaver(saveHandler);
}
exports.withSaveHandler = withSaveHandler;

},{}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var IORouterRegistry = (function () {
    function IORouterRegistry() {
        this.saveRouters = [];
        this.loadRouters = [];
    }
    IORouterRegistry.getInstance = function () {
        if (IORouterRegistry.instance == null) {
            IORouterRegistry.instance = new IORouterRegistry();
        }
        return IORouterRegistry.instance;
    };
    IORouterRegistry.registerSaveRouter = function (saveRouter) {
        IORouterRegistry.getInstance().saveRouters.push(saveRouter);
    };
    IORouterRegistry.registerLoadRouter = function (loadRouter) {
        IORouterRegistry.getInstance().loadRouters.push(loadRouter);
    };
    IORouterRegistry.getSaveHandlers = function (url) {
        return IORouterRegistry.getHandlers(url, 'save');
    };
    IORouterRegistry.getLoadHandlers = function (url) {
        return IORouterRegistry.getHandlers(url, 'load');
    };
    IORouterRegistry.getHandlers = function (url, handlerType) {
        var validHandlers = [];
        var routers = handlerType === 'load' ? this.getInstance().loadRouters :
            this.getInstance().saveRouters;
        routers.forEach(function (router) {
            var handler = router(url);
            if (handler !== null) {
                validHandlers.push(handler);
            }
        });
        return validHandlers;
    };
    return IORouterRegistry;
}());
exports.IORouterRegistry = IORouterRegistry;

},{}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DTYPE_VALUE_SIZE_MAP = {
    'float32': 4,
    'int32': 4,
    'uint16': 2,
    'uint8': 1,
    'bool': 1,
};

},{}],75:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var io_utils_1 = require("./io_utils");
var types_1 = require("./types");
function loadWeightsAsArrayBuffer(fetchURLs, requestOptions) {
    return __awaiter(this, void 0, void 0, function () {
        var requests, responses, buffers;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    requests = fetchURLs.map(function (fetchURL) { return fetch(fetchURL, requestOptions); });
                    return [4, Promise.all(requests)];
                case 1:
                    responses = _a.sent();
                    return [4, Promise.all(responses.map(function (response) { return response.arrayBuffer(); }))];
                case 2:
                    buffers = _a.sent();
                    return [2, buffers];
            }
        });
    });
}
exports.loadWeightsAsArrayBuffer = loadWeightsAsArrayBuffer;
function loadWeights(manifest, filePathPrefix, weightNames, requestOptions) {
    if (filePathPrefix === void 0) { filePathPrefix = ''; }
    return __awaiter(this, void 0, void 0, function () {
        var groupIndicesToFetchMap, groupWeightsToFetch, weightsFound, allManifestWeightNames, weightsNotFound, groupIndicesToFetch, fetchUrls, buffers, weightsTensorMap, bufferIndexOffset;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    groupIndicesToFetchMap = manifest.map(function () { return false; });
                    groupWeightsToFetch = {};
                    weightsFound = weightNames != null ? weightNames.map(function () { return false; }) : [];
                    allManifestWeightNames = [];
                    manifest.forEach(function (manifestGroupConfig, groupIndex) {
                        var groupOffset = 0;
                        manifestGroupConfig.weights.forEach(function (weightsEntry) {
                            var rawDtype = ('quantization' in weightsEntry) ?
                                weightsEntry.quantization.dtype :
                                weightsEntry.dtype;
                            var weightsBytes = types_1.DTYPE_VALUE_SIZE_MAP[rawDtype] *
                                util.sizeFromShape(weightsEntry.shape);
                            var enqueueWeightsForFetchingFn = function () {
                                groupIndicesToFetchMap[groupIndex] = true;
                                if (groupWeightsToFetch[groupIndex] == null) {
                                    groupWeightsToFetch[groupIndex] = [];
                                }
                                groupWeightsToFetch[groupIndex].push({
                                    manifestEntry: weightsEntry,
                                    groupOffset: groupOffset,
                                    sizeBytes: weightsBytes
                                });
                            };
                            if (weightNames != null) {
                                weightNames.forEach(function (weightName, weightIndex) {
                                    if (weightName === weightsEntry.name) {
                                        enqueueWeightsForFetchingFn();
                                        weightsFound[weightIndex] = true;
                                    }
                                });
                            }
                            else {
                                enqueueWeightsForFetchingFn();
                            }
                            allManifestWeightNames.push(weightsEntry.name);
                            groupOffset += weightsBytes;
                        });
                    });
                    if (!weightsFound.every(function (found) { return found; })) {
                        weightsNotFound = weightNames.filter(function (weight, i) { return !weightsFound[i]; });
                        throw new Error("Could not find weights in manifest with names: " +
                            (weightsNotFound.join(', ') + ". \n") +
                            "Manifest JSON has weights with names: " +
                            (allManifestWeightNames.join(', ') + "."));
                    }
                    groupIndicesToFetch = groupIndicesToFetchMap.reduce(function (accumulator, shouldFetch, i) {
                        if (shouldFetch) {
                            accumulator.push(i);
                        }
                        return accumulator;
                    }, []);
                    fetchUrls = [];
                    groupIndicesToFetch.forEach(function (i) {
                        manifest[i].paths.forEach(function (filepath) {
                            var fetchUrl = filePathPrefix +
                                (!filePathPrefix.endsWith('/') ? '/' : '') + filepath;
                            fetchUrls.push(fetchUrl);
                        });
                    });
                    return [4, loadWeightsAsArrayBuffer(fetchUrls, requestOptions)];
                case 1:
                    buffers = _a.sent();
                    weightsTensorMap = {};
                    bufferIndexOffset = 0;
                    groupIndicesToFetch.forEach(function (i) {
                        var numBuffers = manifest[i].paths.length;
                        var groupBytes = 0;
                        for (var i_1 = 0; i_1 < numBuffers; i_1++) {
                            groupBytes += buffers[bufferIndexOffset + i_1].byteLength;
                        }
                        var groupBuffer = new ArrayBuffer(groupBytes);
                        var groupByteBuffer = new Uint8Array(groupBuffer);
                        var groupBufferOffset = 0;
                        for (var i_2 = 0; i_2 < numBuffers; i_2++) {
                            var buffer = new Uint8Array(buffers[bufferIndexOffset + i_2]);
                            groupByteBuffer.set(buffer, groupBufferOffset);
                            groupBufferOffset += buffer.byteLength;
                        }
                        var weightsEntries = groupWeightsToFetch[i];
                        weightsEntries.forEach(function (weightsEntry) {
                            var byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
                            var nameToTensorMap = io_utils_1.decodeWeights(byteBuffer, [weightsEntry.manifestEntry]);
                            for (var name_1 in nameToTensorMap) {
                                weightsTensorMap[name_1] = nameToTensorMap[name_1];
                            }
                        });
                        bufferIndexOffset += numBuffers;
                    });
                    return [2, weightsTensorMap];
            }
        });
    });
}
exports.loadWeights = loadWeights;

},{"../util":203,"./io_utils":69,"./types":74}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DataStorage = (function () {
    function DataStorage(dataMover) {
        this.dataMover = dataMover;
        this.data = new WeakMap();
    }
    DataStorage.prototype.get = function (dataId) {
        if (!this.data.has(dataId)) {
            this.dataMover.moveData(dataId);
        }
        return this.data.get(dataId);
    };
    DataStorage.prototype.set = function (dataId, value) {
        this.data.set(dataId, value);
    };
    DataStorage.prototype.has = function (dataId) {
        return this.data.has(dataId);
    };
    DataStorage.prototype.delete = function (dataId) {
        return this.data.delete(dataId);
    };
    return DataStorage;
}());
exports.DataStorage = DataStorage;

},{}],77:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var environment_1 = require("../environment");
var log_1 = require("../log");
var array_ops_util = require("../ops/array_ops_util");
var axis_util = require("../ops/axis_util");
var broadcast_util = require("../ops/broadcast_util");
var concat_util = require("../ops/concat_util");
var erf_util = require("../ops/erf_util");
var gather_nd_util = require("../ops/gather_nd_util");
var ops = require("../ops/ops");
var ops_1 = require("../ops/ops");
var scatter_nd_util = require("../ops/scatter_nd_util");
var selu_util = require("../ops/selu_util");
var slice_util_1 = require("../ops/slice_util");
var tensor_1 = require("../tensor");
var types_1 = require("../types");
var util = require("../util");
var util_1 = require("../util");
var backend_1 = require("./backend");
var backend_util = require("./backend_util");
var complex_util = require("./complex_util");
var non_max_suppression_impl_1 = require("./non_max_suppression_impl");
var split_shared_1 = require("./split_shared");
var topk_impl_1 = require("./topk_impl");
var where_impl_1 = require("./where_impl");
var MathBackendCPU = (function () {
    function MathBackendCPU() {
        this.blockSize = 48;
        this.firstUse = true;
        if (environment_1.ENV.get('IS_BROWSER')) {
            this.canvas = document.createElement('canvas');
        }
    }
    MathBackendCPU.prototype.setDataMover = function (dataMover) {
        this.data = new backend_1.DataStorage(dataMover);
    };
    MathBackendCPU.prototype.register = function (dataId, shape, dtype) {
        if (this.firstUse) {
            this.firstUse = false;
            if (environment_1.ENV.get('IS_NODE')) {
                log_1.warn('\n============================\n' +
                    'Hi there . Looks like you are running TensorFlow.js in ' +
                    'Node.js. To speed things up dramatically, install our node ' +
                    'backend, which binds to TensorFlow C++, by running ' +
                    'npm i @tensorflow/tfjs-node, ' +
                    'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' +
                    'Then call require(\'@tensorflow/tfjs-node\'); (-gpu ' +
                    'suffix for CUDA) at the start of your program. ' +
                    'Visit https://github.com/tensorflow/tfjs-node for more details.' +
                    '\n============================\n');
            }
        }
        if (this.data.has(dataId)) {
            throw new Error("Data buffer is already registered");
        }
        this.data.set(dataId, { dtype: dtype });
    };
    MathBackendCPU.prototype.write = function (dataId, values) {
        if (values == null) {
            throw new Error('MathBackendCPU.write(): values can not be null');
        }
        this.data.get(dataId).values = values;
    };
    MathBackendCPU.prototype.fromPixels = function (pixels, numChannels) {
        if (pixels == null) {
            throw new Error('pixels passed to tf.fromPixels() can not be null');
        }
        var vals;
        if (environment_1.ENV.get('IS_NODE') && pixels.getContext == null) {
            throw new Error('When running in node, pixels must be an HTMLCanvasElement ' +
                'like the one returned by the `canvas` npm package');
        }
        if (pixels.getContext != null) {
            vals = pixels
                .getContext('2d')
                .getImageData(0, 0, pixels.width, pixels.height)
                .data;
        }
        else if (pixels instanceof ImageData) {
            vals = pixels.data;
        }
        else if (pixels instanceof HTMLImageElement ||
            pixels instanceof HTMLVideoElement) {
            if (this.canvas == null) {
                throw new Error('Can\'t read pixels from HTMLImageElement outside ' +
                    'the browser.');
            }
            this.canvas.width = pixels.width;
            this.canvas.height = pixels.height;
            this.canvas.getContext('2d').drawImage(pixels, 0, 0, pixels.width, pixels.height);
            vals = this.canvas.getContext('2d')
                .getImageData(0, 0, pixels.width, pixels.height)
                .data;
        }
        else {
            throw new Error('pixels passed to tf.fromPixels() must be either an ' +
                "HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or " +
                ("ImageData, but was " + pixels.constructor.name));
        }
        var values;
        if (numChannels === 4) {
            values = new Int32Array(vals);
        }
        else {
            var numPixels = pixels.width * pixels.height;
            values = new Int32Array(numPixels * numChannels);
            for (var i = 0; i < numPixels; i++) {
                for (var channel = 0; channel < numChannels; ++channel) {
                    values[i * numChannels + channel] = vals[i * 4 + channel];
                }
            }
        }
        var outShape = [pixels.height, pixels.width, numChannels];
        return ops_1.tensor3d(values, outShape, 'int32');
    };
    MathBackendCPU.prototype.read = function (dataId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.readSync(dataId)];
            });
        });
    };
    MathBackendCPU.prototype.readSync = function (dataId) {
        var _a = this.data.get(dataId), dtype = _a.dtype, complexTensors = _a.complexTensors;
        if (dtype === 'complex64') {
            var realValues = complexTensors.real.dataSync();
            var imagValues = complexTensors.imag.dataSync();
            return complex_util.mergeRealAndImagArrays(realValues, imagValues);
        }
        return this.data.get(dataId).values;
    };
    MathBackendCPU.prototype.disposeData = function (dataId) {
        if (this.data.has(dataId)) {
            var complexTensors = this.data.get(dataId).complexTensors;
            if (complexTensors != null) {
                complexTensors.real.dispose();
                complexTensors.imag.dispose();
            }
            this.data.delete(dataId);
        }
    };
    MathBackendCPU.prototype.time = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            var start, kernelMs;
            return __generator(this, function (_a) {
                start = util_1.now();
                f();
                kernelMs = util_1.now() - start;
                return [2, { kernelMs: kernelMs }];
            });
        });
    };
    MathBackendCPU.prototype.memory = function () {
        return {
            unreliable: true
        };
    };
    MathBackendCPU.prototype.complex = function (real, imag) {
        var result = tensor_1.Tensor.make(real.shape, {}, 'complex64');
        var resultData = this.data.get(result.dataId);
        resultData.complexTensors = {
            real: environment_1.ENV.engine.keep(real.clone()),
            imag: environment_1.ENV.engine.keep(imag.clone())
        };
        return result;
    };
    MathBackendCPU.prototype.real = function (input) {
        var resultData = this.data.get(input.dataId);
        return resultData.complexTensors.real.clone();
    };
    MathBackendCPU.prototype.imag = function (input) {
        var resultData = this.data.get(input.dataId);
        return resultData.complexTensors.imag.clone();
    };
    MathBackendCPU.prototype.assertNotComplex = function (tensor, opName) {
        if (!Array.isArray(tensor)) {
            tensor = [tensor];
        }
        tensor.forEach(function (t) {
            if (t != null) {
                util.assert(t.dtype !== 'complex64', opName + " does not support complex64 tensors.");
            }
        });
    };
    MathBackendCPU.prototype.slice = function (x, begin, size) {
        this.assertNotComplex(x, 'slice');
        var buffer = ops.buffer(size, x.dtype);
        for (var i = 0; i < buffer.size; ++i) {
            var loc = buffer.indexToLoc(i);
            var xLoc = loc.map(function (idx, j) { return idx + begin[j]; });
            buffer.set.apply(buffer, [x.get.apply(x, xLoc)].concat(loc));
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.stridedSlice = function (x, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
        this.assertNotComplex(x, 'stridedSlice');
        var _a = slice_util_1.getStridedSlicedInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask), beginIndex = _a[0], size = _a[1], shrinkAxis = _a[2];
        var shape = size.filter(function (v, index) { return shrinkAxis.indexOf(index) === -1; });
        if (shape.some(function (axis) { return axis === 0; })) {
            return ops.tensor([], shape);
        }
        var buffer = ops.buffer(size, x.dtype);
        for (var i = 0; i < buffer.size; i++) {
            var loc = buffer.indexToLoc(i);
            var newLoc = new Array(loc.length);
            for (var j = 0; j < newLoc.length; j++) {
                newLoc[j] = loc[j] * strides[j] + beginIndex[j];
            }
            buffer.set.apply(buffer, [x.get.apply(x, newLoc)].concat(loc));
        }
        return buffer.toTensor().reshape(shape);
    };
    MathBackendCPU.prototype.reverse = function (x, axis) {
        this.assertNotComplex(x, 'reverse');
        var buffer = ops.buffer(x.shape, x.dtype);
        var xBuffer = x.buffer();
        var _loop_1 = function (i) {
            var outLoc = buffer.indexToLoc(i);
            var inLoc = outLoc.slice();
            axis.forEach(function (ax) { return inLoc[ax] = x.shape[ax] - 1 - inLoc[ax]; });
            buffer.set.apply(buffer, [xBuffer.get.apply(xBuffer, inLoc)].concat(outLoc));
        };
        for (var i = 0; i < buffer.size; i++) {
            _loop_1(i);
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.concat = function (tensors, axis) {
        this.assertNotComplex(tensors, 'concat');
        var tensors2D = tensors.map(function (t) {
            var innerSize = util.sizeFromShape(t.shape.slice(axis));
            return t.as2D(-1, innerSize);
        });
        var outShape = concat_util.computeOutShape(tensors2D.map(function (t) { return t.shape; }), 1);
        var values = ops.buffer(outShape, tensors[0].dtype)
            .values;
        if (tensors2D[0].shape[0] === 1) {
            var offset_1 = 0;
            tensors2D.forEach(function (t) {
                values.set(t.dataSync(), offset_1);
                offset_1 += t.size;
            });
        }
        else {
            var colOffset_1 = 0;
            tensors2D.forEach(function (t) {
                var tVals = t.dataSync();
                var tIdx = 0;
                for (var row = 0; row < t.shape[0]; ++row) {
                    var resIdx = row * outShape[1] + colOffset_1;
                    for (var col = 0; col < t.shape[1]; ++col) {
                        values[resIdx + col] = tVals[tIdx++];
                    }
                }
                colOffset_1 += t.shape[1];
            });
        }
        var finalOutShape = concat_util.computeOutShape(tensors.map(function (t) { return t.shape; }), axis);
        return ops_1.tensor(values, finalOutShape, tensors[0].dtype);
    };
    MathBackendCPU.prototype.neg = function (x) {
        this.assertNotComplex(x, 'neg');
        return this.multiply(ops.scalar(-1), x);
    };
    MathBackendCPU.prototype.add = function (a, b) {
        if (a.dtype === 'complex64' || b.dtype === 'complex64') {
            return this.broadcastedBinaryComplexOp(a.cast('complex64'), b.cast('complex64'), function (aReal, aImag, bReal, bImag) {
                return { real: aReal + bReal, imag: aImag + bImag };
            });
        }
        return this.broadcastedBinaryOp(a, b, types_1.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue + bValue; });
    };
    MathBackendCPU.prototype.addN = function (tensors) {
        this.assertNotComplex(tensors, 'addN');
        var vals = tensors.map(function (t) { return t.dataSync(); });
        var result = ops.buffer(tensors[0].shape, tensors[0].dtype);
        var resultVals = result.values;
        for (var i = 0; i < tensors.length; i++) {
            var currVals = vals[i];
            for (var j = 0; j < resultVals.length; j++) {
                resultVals[j] += currVals[j];
            }
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.subtract = function (a, b) {
        if (a.dtype === 'complex64' || b.dtype === 'complex64') {
            return this.broadcastedBinaryComplexOp(a.cast('complex64'), b.cast('complex64'), function (aReal, aImag, bReal, bImag) {
                return { real: aReal - bReal, imag: aImag - bImag };
            });
        }
        return this.broadcastedBinaryOp(a, b, types_1.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue - bValue; });
    };
    MathBackendCPU.prototype.pow = function (a, b) {
        this.assertNotComplex([a, b], 'pow');
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) { return Math.pow(aValue, bValue); });
    };
    MathBackendCPU.prototype.batchMatMul = function (a, b, transposeA, transposeB) {
        this.assertNotComplex([a, b], 'matMul');
        var sharedDim = transposeA ? a.shape[1] : a.shape[2];
        var leftDim = transposeA ? a.shape[2] : a.shape[1];
        var rightDim = transposeB ? b.shape[1] : b.shape[2];
        var batchDim = a.shape[0];
        var aValues = a.dataSync();
        var bValues = b.dataSync();
        var _a = transposeA ?
            [a.strides[0], 1, a.strides[1]] :
            [a.strides[0], a.strides[1], 1], aBatch = _a[0], aOuterStep = _a[1], aInnerStep = _a[2];
        var _b = transposeB ?
            [1, b.strides[1], b.strides[0]] :
            [b.strides[1], 1, b.strides[0]], bInnerStep = _b[0], bOuterStep = _b[1], bBatch = _b[2];
        var size = leftDim * rightDim;
        var result = new Float32Array(batchDim * size);
        var blockSize = this.blockSize;
        for (var b_1 = 0; b_1 < batchDim; b_1++) {
            for (var i0 = 0; i0 < leftDim; i0 += blockSize) {
                for (var j0 = 0; j0 < rightDim; j0 += blockSize) {
                    for (var k0 = 0; k0 < sharedDim; k0 += blockSize) {
                        var iBlock = Math.min(i0 + blockSize, leftDim);
                        var jBlock = Math.min(j0 + blockSize, rightDim);
                        var kBlock = Math.min(k0 + blockSize, sharedDim);
                        for (var i = i0; i < iBlock; i++) {
                            for (var j = j0; j < jBlock; j++) {
                                var sum = 0.0;
                                for (var k = k0; k < kBlock; k++) {
                                    sum += aValues[b_1 * aBatch + i * aOuterStep + k * aInnerStep] *
                                        bValues[k * bInnerStep + j * bOuterStep + b_1 * bBatch];
                                }
                                result[b_1 * size + (i * rightDim + j)] += sum;
                            }
                        }
                    }
                }
            }
        }
        return ops.tensor3d(result, [batchDim, leftDim, rightDim]);
    };
    MathBackendCPU.prototype.multiply = function (a, b) {
        if (a.dtype === 'complex64' || b.dtype === 'complex64') {
            return this.broadcastedBinaryComplexOp(a.cast('complex64'), b.cast('complex64'), function (aReal, aImag, bReal, bImag) {
                return {
                    real: aReal * bReal - aImag * bImag,
                    imag: aReal * bImag + aImag * bReal
                };
            });
        }
        return this.broadcastedBinaryOp(a, b, types_1.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue * bValue; });
    };
    MathBackendCPU.prototype.realDivide = function (a, b) {
        this.assertNotComplex([a, b], 'realDivide');
        var op = function (a, b) { return a / b; };
        var outputDtype = 'float32';
        return this.broadcastedBinaryOp(a, b, outputDtype, op);
    };
    MathBackendCPU.prototype.floorDiv = function (a, b) {
        this.assertNotComplex([a, b], 'floorDiv');
        var op = function (a, b) { return Math.floor(a / b); };
        var outputDtype = 'int32';
        return this.broadcastedBinaryOp(a, b, outputDtype, op);
    };
    MathBackendCPU.prototype.sum = function (x, axes) {
        this.assertNotComplex(x, 'sum');
        axis_util.assertAxesAreInnerMostDims('sum', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var resultDtype = types_1.upcastType(x.dtype, 'int32');
        var result = ops.zeros(outShape, resultDtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var sum = 0;
            for (var j = 0; j < reduceSize; ++j) {
                sum += aVals[offset + j];
            }
            vals[i] = sum;
        }
        return result;
    };
    MathBackendCPU.prototype.prod = function (x, axes) {
        this.assertNotComplex(x, 'sum');
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var resultDtype = types_1.upcastType(x.dtype, 'int32');
        var result = ops.zeros(outShape, resultDtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var prod = 1;
            for (var j = 0; j < reduceSize; ++j) {
                prod *= aVals[offset + j];
            }
            vals[i] = prod;
        }
        return result;
    };
    MathBackendCPU.prototype.unsortedSegmentSum = function (x, segmentIds, numSegments) {
        this.assertNotComplex(x, 'unsortedSegmentSum');
        var res = [];
        var numIters = x.rank - segmentIds.rank;
        for (var i = 0; i < numIters; ++i) {
            segmentIds = segmentIds.expandDims(i + 1);
        }
        for (var i = 0; i < numSegments; ++i) {
            var segmentId = ops.scalar(i, 'int32');
            var mask = ops.equal(segmentId, segmentIds).asType('float32');
            var sum = mask.mul(x).sum(0);
            res.push(sum);
        }
        return ops.stack(res);
    };
    MathBackendCPU.prototype.argMin = function (x, axis) {
        this.assertNotComplex(x, 'argMin');
        var axes = [axis];
        axis_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[offset];
            var minIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (value < min) {
                    min = value;
                    minIndex = j;
                }
            }
            vals[i] = minIndex;
        }
        return result;
    };
    MathBackendCPU.prototype.argMax = function (x, axis) {
        this.assertNotComplex(x, 'argMax');
        var axes = [axis];
        axis_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            var maxIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (value > max) {
                    max = value;
                    maxIndex = j;
                }
            }
            vals[i] = maxIndex;
        }
        return result;
    };
    MathBackendCPU.prototype.cumsum = function (x, axis, exclusive, reverse) {
        this.assertNotComplex(x, 'cumsum');
        if (axis !== x.rank - 1) {
            throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (x.rank - 1) + " " +
                ("but got axis=" + axis));
        }
        var resultDtype = types_1.upcastType(x.dtype, 'int32');
        var result = ops.zeros(x.shape, resultDtype);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        var finalDim = x.shape[x.rank - 1];
        var indexAdjuster = reverse ?
            function (i, j) { return i + finalDim - j - 1; } :
            function (i, j) { return i + j; };
        for (var i = 0; i < aVals.length; i += finalDim) {
            for (var j = 0; j < finalDim; j++) {
                var idx = indexAdjuster(i, j);
                if (j === 0) {
                    vals[idx] = exclusive ? 0 : aVals[idx];
                }
                else {
                    var prevIdx = indexAdjuster(i, j - 1);
                    vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] :
                        aVals[idx] + vals[prevIdx];
                }
            }
        }
        return result;
    };
    MathBackendCPU.prototype.equal = function (a, b) {
        this.assertNotComplex([a, b], 'equal');
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal === bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.notEqual = function (a, b) {
        this.assertNotComplex([a, b], 'notEqual');
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal !== bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.less = function (a, b) {
        this.assertNotComplex([a, b], 'less');
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal < bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.lessEqual = function (a, b) {
        this.assertNotComplex([a, b], 'lessEqual');
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal <= bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.greater = function (a, b) {
        this.assertNotComplex([a, b], 'greater');
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal > bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.greaterEqual = function (a, b) {
        this.assertNotComplex([a, b], 'greaterEqual');
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal >= bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.logicalNot = function (x) {
        this.assertNotComplex(x, 'logicalNot');
        var values = x.dataSync();
        var newValues = new Int32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = values[i] ? 0 : 1;
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues }, 'bool');
    };
    MathBackendCPU.prototype.logicalAnd = function (a, b) {
        this.assertNotComplex([a, b], 'logicalAnd');
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return aVal && bVal;
        });
    };
    MathBackendCPU.prototype.logicalOr = function (a, b) {
        this.assertNotComplex([a, b], 'logicalOr');
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return aVal || bVal;
        });
    };
    MathBackendCPU.prototype.select = function (condition, a, b) {
        this.assertNotComplex([condition, a, b], 'select');
        var values = condition.dataSync();
        var aValues = a.dataSync();
        var bValues = b.dataSync();
        var result = ops.zeros(a.shape, types_1.upcastType(a.dtype, b.dtype));
        var newValues = result.dataSync();
        var index = 0;
        var offset = condition.rank === 0 || condition.rank > 1 || a.rank === 1 ?
            1 :
            a.shape[1];
        for (var i = 0; i < values.length; i++) {
            for (var j = 0; j < offset; j++) {
                if (values[i] === 1) {
                    newValues[index++] = aValues[i];
                }
                else {
                    newValues[index++] = bValues[i];
                }
            }
        }
        return result;
    };
    MathBackendCPU.prototype.where = function (condition) {
        this.assertNotComplex([condition], 'where');
        var condVals = condition.dataSync();
        return where_impl_1.whereImpl(condition.shape, condVals);
    };
    MathBackendCPU.prototype.topk = function (x, k, sorted) {
        this.assertNotComplex(x, 'topk');
        var xVals = x.dataSync();
        return topk_impl_1.topkImpl(xVals, x.shape, x.dtype, k, sorted);
    };
    MathBackendCPU.prototype.min = function (x, axes) {
        this.assertNotComplex(x, 'min');
        axis_util.assertAxesAreInnerMostDims('min', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, x.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[offset];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (value < min) {
                    min = value;
                }
            }
            vals[i] = min;
        }
        return result;
    };
    MathBackendCPU.prototype.minimum = function (a, b) {
        this.assertNotComplex([a, b], 'minimum');
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) { return Math.min(aVal, bVal); });
    };
    MathBackendCPU.prototype.mod = function (a, b) {
        this.assertNotComplex([a, b], 'mod');
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {
            var rem = aVal % bVal;
            if ((aVal < 0 && bVal < 0) || (aVal >= 0 && bVal >= 0)) {
                return rem;
            }
            else {
                return (rem + bVal) % bVal;
            }
        });
    };
    MathBackendCPU.prototype.max = function (x, axes) {
        this.assertNotComplex(x, 'max');
        axis_util.assertAxesAreInnerMostDims('max', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, x.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (value > max) {
                    max = value;
                }
            }
            vals[i] = max;
        }
        return result;
    };
    MathBackendCPU.prototype.maximum = function (a, b) {
        this.assertNotComplex([a, b], 'maximum');
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) { return Math.max(aVal, bVal); });
    };
    MathBackendCPU.prototype.all = function (x, axes) {
        this.assertNotComplex(x, 'all');
        axis_util.assertAxesAreInnerMostDims('all', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, x.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var all = aVals[offset];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                all = all && value;
            }
            vals[i] = all;
        }
        return result;
    };
    MathBackendCPU.prototype.any = function (x, axes) {
        this.assertNotComplex(x, 'any');
        axis_util.assertAxesAreInnerMostDims('any', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, x.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var anyVal = aVals[offset];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                anyVal = anyVal || value;
            }
            vals[i] = anyVal;
        }
        return result;
    };
    MathBackendCPU.prototype.squaredDifference = function (a, b) {
        this.assertNotComplex([a, b], 'squaredDifference');
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {
            var diff = aVal - bVal;
            return diff * diff;
        });
    };
    MathBackendCPU.prototype.ceil = function (x) {
        this.assertNotComplex(x, 'ceil');
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.ceil(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.floor = function (x) {
        this.assertNotComplex(x, 'floor');
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.floor(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.sign = function (x) {
        this.assertNotComplex(x, 'x');
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            if (values[i] < 0) {
                newValues[i] = -1;
            }
            else if (values[i] > 0) {
                newValues[i] = 1;
            }
            else {
                newValues[i] = 0;
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.round = function (x) {
        this.assertNotComplex(x, 'round');
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var base = Math.floor(values[i]);
            if (values[i] - base < 0.5) {
                newValues[i] = Math.floor(values[i]);
            }
            else if (values[i] - base > 0.5) {
                newValues[i] = Math.ceil(values[i]);
            }
            else {
                if (base % 2.0 === 0.0) {
                    newValues[i] = base;
                }
                else {
                    newValues[i] = base + 1.0;
                }
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.exp = function (x) {
        this.assertNotComplex(x, 'exp');
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.exp(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.expm1 = function (x) {
        this.assertNotComplex(x, 'expm1');
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.expm1(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.log = function (x) {
        this.assertNotComplex(x, 'log');
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.log(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.log1p = function (x) {
        this.assertNotComplex(x, 'log1p');
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.log1p(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.sqrt = function (x) {
        this.assertNotComplex(x, 'sqrt');
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.sqrt(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.rsqrt = function (x) {
        this.assertNotComplex(x, 'rsqrt');
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = 1 / Math.sqrt(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.square = function (x) {
        this.assertNotComplex(x, 'square');
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = value * value;
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.reciprocal = function (x) {
        this.assertNotComplex(x, 'reciprocal');
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = 1 / values[i];
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.relu = function (x) {
        this.assertNotComplex(x, 'relu');
        var res = ops.zeros(x.shape, x.dtype);
        var resVals = res.dataSync();
        var inVals = x.dataSync();
        for (var i = 0; i < inVals.length; ++i) {
            resVals[i] = Math.max(0, inVals[i]);
        }
        return res;
    };
    MathBackendCPU.prototype.elu = function (x) {
        this.assertNotComplex(x, 'elu');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = (Math.exp(v) - 1);
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.eluDer = function (dy, y) {
        this.assertNotComplex([dy, y], 'eluDer');
        var resultValues = new Float32Array(y.size);
        var values = y.dataSync();
        var dyValues = dy.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 1) {
                resultValues[i] = dyValues[i];
            }
            else {
                resultValues[i] = dyValues[i] * (v + 1);
            }
        }
        return tensor_1.Tensor.make(y.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.selu = function (x) {
        this.assertNotComplex(x, 'selu');
        var scaleAlpha = selu_util.SELU_SCALEALPHA;
        var scale = selu_util.SELU_SCALE;
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = scale * v;
            }
            else {
                resultValues[i] = scaleAlpha * (Math.exp(v) - 1);
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.clip = function (x, min, max) {
        this.assertNotComplex(x, 'clip');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            resultValues[i] = v > max ? max : (v < min ? min : v);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.abs = function (x) {
        this.assertNotComplex(x, 'abs');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.abs(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.int = function (x) {
        this.assertNotComplex(x, 'int');
        var resultValues = new Int32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = values[i];
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues }, 'int32');
    };
    MathBackendCPU.prototype.sigmoid = function (x) {
        this.assertNotComplex(x, 'sigmoid');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = 1 / (1 + Math.exp(-values[i]));
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.softplus = function (x) {
        this.assertNotComplex(x, 'softplus');
        var epsilon = 1.1920928955078125e-7;
        var threshold = Math.log(epsilon) + 2.0;
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var tooLarge = values[i] > -threshold;
            var tooSmall = values[i] < threshold;
            var expX = Math.exp(values[i]);
            var result = void 0;
            if (tooSmall) {
                result = expX;
            }
            else if (tooLarge) {
                result = values[i];
            }
            else {
                result = Math.log(1.0 + expX);
            }
            resultValues[i] = result;
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.sin = function (x) {
        this.assertNotComplex(x, 'sin');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sin(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.cos = function (x) {
        this.assertNotComplex(x, 'cos');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cos(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.tan = function (x) {
        this.assertNotComplex(x, 'tan');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.tan(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.asin = function (x) {
        this.assertNotComplex(x, 'asin');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.asin(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.acos = function (x) {
        this.assertNotComplex(x, 'acos');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.acos(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.atan = function (x) {
        this.assertNotComplex(x, 'atan');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.atan(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.atan2 = function (a, b) {
        this.assertNotComplex([a, b], 'atan2');
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) { return Math.atan2(aValue, bValue); });
    };
    MathBackendCPU.prototype.sinh = function (x) {
        this.assertNotComplex(x, 'sinh');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sinh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.cosh = function (x) {
        this.assertNotComplex(x, 'cosh');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cosh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.tanh = function (x) {
        this.assertNotComplex(x, 'tanh');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = util.tanh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.asinh = function (x) {
        this.assertNotComplex(x, 'asinh');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.asinh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.acosh = function (x) {
        this.assertNotComplex(x, 'acosh');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.acosh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.atanh = function (x) {
        this.assertNotComplex(x, 'atanh');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.atanh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.erf = function (x) {
        this.assertNotComplex(x, 'erf');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        var p = erf_util.ERF_P;
        var a1 = erf_util.ERF_A1;
        var a2 = erf_util.ERF_A2;
        var a3 = erf_util.ERF_A3;
        var a4 = erf_util.ERF_A4;
        var a5 = erf_util.ERF_A5;
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            var t = 1.0 / (1.0 + p * v);
            resultValues[i] = 1.0 -
                (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t *
                    Math.exp(-v * v);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.step = function (x, alpha) {
        if (alpha === void 0) { alpha = 0; }
        this.assertNotComplex(x, 'step');
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            if (isNaN(value)) {
                resultValues[i] = NaN;
            }
            else {
                resultValues[i] = value > 0 ? 1 : alpha;
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.conv2d = function (x, filter, convInfo) {
        this.assertNotComplex([x, filter], 'conv2d');
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dilationHeight = convInfo.dilationHeight;
        var dilationWidth = convInfo.dilationWidth;
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var y = ops.buffer(convInfo.outShape, x.dtype);
        var xVals = x.dataSync();
        var wVals = filter.dataSync();
        var yVals = y.values;
        for (var b = 0; b < convInfo.batchSize; ++b) {
            var xOffset1 = b * x.strides[0];
            var yOffset1 = b * y.strides[0];
            for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                var yOffset2 = yOffset1 + yR * y.strides[1];
                var xRCorner = yR * convInfo.strideHeight - padLeft;
                for (var wR = 0; wR < filterHeight; wR++) {
                    var xR = xRCorner + wR * dilationHeight;
                    if (xR < 0 || xR >= convInfo.inHeight) {
                        continue;
                    }
                    var wOffset1 = wR * filter.strides[0];
                    var xOffset2 = xOffset1 + xR * x.strides[1];
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var yOffset3 = yOffset2 + yC * convInfo.outChannels;
                        var xCCorner = yC * convInfo.strideWidth - padTop;
                        for (var wC = 0; wC < filterWidth; wC++) {
                            var xC = xCCorner + wC * dilationWidth;
                            if (xC < 0 || xC >= convInfo.inWidth) {
                                continue;
                            }
                            var wOffset2 = wOffset1 + wC * filter.strides[1];
                            var xOffset3 = xOffset2 + xC * convInfo.inChannels;
                            var wOffset3 = wOffset2;
                            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                                var xVal = xVals[xOffset3 + d1];
                                for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                                    yVals[yOffset3 + d2] += xVal * wVals[wOffset3 + d2];
                                }
                                wOffset3 += convInfo.outChannels;
                            }
                        }
                    }
                }
            }
        }
        return y.toTensor();
    };
    MathBackendCPU.prototype.conv2dDerInput = function (dy, filter, convInfo) {
        this.assertNotComplex([dy, filter], 'conv2dDerInput');
        var dx = ops.buffer(convInfo.inShape, 'float32');
        var dxValues = dx.values;
        var _a = dx.strides, dxS0 = _a[0], dxS1 = _a[1], dxS2 = _a[2];
        var dyValues = dy.dataSync();
        var _b = dy.strides, dyS0 = _b[0], dyS1 = _b[1], dyS2 = _b[2];
        var fltValues = filter.dataSync();
        var _c = filter.strides, fltS0 = _c[0], fltS1 = _c[1], fltS2 = _c[2];
        var batchSize = convInfo.batchSize, filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth, inChannels = convInfo.inChannels, inHeight = convInfo.inHeight, inWidth = convInfo.inWidth, outChannels = convInfo.outChannels, outHeight = convInfo.outHeight, outWidth = convInfo.outWidth, strideHeight = convInfo.strideHeight, strideWidth = convInfo.strideWidth;
        var topPad = filterHeight - 1 - convInfo.padInfo.top;
        var leftPad = filterWidth - 1 - convInfo.padInfo.left;
        for (var b = 0; b < batchSize; ++b) {
            for (var d1 = 0; d1 < inChannels; ++d1) {
                for (var xR = 0; xR < inHeight; ++xR) {
                    var xRCorner = xR - topPad;
                    var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                    var yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
                    for (var xC = 0; xC < inWidth; ++xC) {
                        var xCCorner = xC - leftPad;
                        var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                        var yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
                        var dotProd = 0;
                        for (var yR = xRMin; yR < yRMax; ++yR) {
                            var wR = yR * strideHeight - xRCorner;
                            for (var yC = xCMin; yC < yCMax; ++yC) {
                                var wC = yC * strideWidth - xCCorner;
                                var dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;
                                var fltOffset = fltS0 * (filterHeight - 1 - wR) +
                                    fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
                                for (var d2 = 0; d2 < outChannels; ++d2) {
                                    var pixel = dyValues[dyOffset + d2];
                                    var weight = fltValues[fltOffset + d2];
                                    dotProd += pixel * weight;
                                }
                            }
                        }
                        dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.conv2dDerFilter = function (x, dy, convInfo) {
        this.assertNotComplex([x, dy], 'conv2dDerFilter');
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dW = ops.buffer(convInfo.filterShape, 'float32');
        var leftPad = convInfo.padInfo.left;
        var topPad = convInfo.padInfo.top;
        for (var wR = 0; wR < filterHeight; ++wR) {
            var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
            var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
            for (var wC = 0; wC < filterWidth; ++wC) {
                var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
                for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                    for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                        var dotProd = 0;
                        for (var b = 0; b < convInfo.batchSize; ++b) {
                            for (var yR = yRMin; yR < yRMax; ++yR) {
                                var xR = wR + yR * strideHeight - topPad;
                                for (var yC = yCMin; yC < yCMax; ++yC) {
                                    var xC = wC + yC * strideWidth - leftPad;
                                    dotProd += x.get(b, xR, xC, d1) * dy.get(b, yR, yC, d2);
                                }
                            }
                        }
                        dW.set(dotProd, wR, wC, d1, d2);
                    }
                }
            }
        }
        return dW.toTensor();
    };
    MathBackendCPU.prototype.depthwiseConv2D = function (x, filter, convInfo) {
        this.assertNotComplex([x, filter], 'depthwiseConv2D');
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dilationHeight = convInfo.dilationHeight;
        var dilationWidth = convInfo.dilationWidth;
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var chMul = convInfo.outChannels / convInfo.inChannels;
        var y = ops.buffer(convInfo.outShape, x.dtype);
        var xVals = x.dataSync();
        var wVals = filter.dataSync();
        var yVals = y.values;
        for (var b = 0; b < convInfo.batchSize; ++b) {
            var xOffset1 = b * x.strides[0];
            var yOffset1 = b * y.strides[0];
            for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                var yOffset2 = yOffset1 + yR * y.strides[1];
                var xRCorner = yR * convInfo.strideHeight - padLeft;
                for (var wR = 0; wR < filterHeight; ++wR) {
                    var xR = xRCorner + wR * dilationHeight;
                    if (xR < 0 || xR >= convInfo.inHeight) {
                        continue;
                    }
                    var wOffset1 = wR * filter.strides[0];
                    var xOffset2 = xOffset1 + xR * x.strides[1];
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var yOffset3 = yOffset2 + yC * y.strides[2];
                        var xCCorner = yC * convInfo.strideWidth - padTop;
                        for (var wC = 0; wC < filterWidth; ++wC) {
                            var xC = xCCorner + wC * dilationWidth;
                            if (xC < 0 || xC >= convInfo.inWidth) {
                                continue;
                            }
                            var wOffset2 = wOffset1 + wC * filter.strides[1];
                            var xOffset3 = xOffset2 + xC * convInfo.inChannels;
                            var yOffset4 = yOffset3;
                            var wOffset3 = wOffset2;
                            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                                var xVal = xVals[xOffset3 + d1];
                                for (var q = 0; q < chMul; ++q) {
                                    yVals[yOffset4 + q] += xVal * wVals[wOffset3 + q];
                                }
                                yOffset4 += chMul;
                                wOffset3 += chMul;
                            }
                        }
                    }
                }
            }
        }
        return y.toTensor();
    };
    MathBackendCPU.prototype.depthwiseConv2DDerInput = function (dy, filter, convInfo) {
        this.assertNotComplex([dy, filter], 'depthwiseConv2DDerInput');
        var dx = ops.buffer(convInfo.inShape, 'float32');
        var dxValues = dx.values;
        var _a = dx.strides, dxS0 = _a[0], dxS1 = _a[1], dxS2 = _a[2];
        var dyValues = dy.dataSync();
        var _b = dy.strides, dyS0 = _b[0], dyS1 = _b[1], dyS2 = _b[2];
        var fltValues = filter.dataSync();
        var _c = filter.strides, fltS0 = _c[0], fltS1 = _c[1], fltS2 = _c[2];
        var batchSize = convInfo.batchSize, filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth, inChannels = convInfo.inChannels, inHeight = convInfo.inHeight, inWidth = convInfo.inWidth, outChannels = convInfo.outChannels, outHeight = convInfo.outHeight, outWidth = convInfo.outWidth, strideHeight = convInfo.strideHeight, strideWidth = convInfo.strideWidth;
        var topPad = filterHeight - 1 - convInfo.padInfo.top;
        var leftPad = filterWidth - 1 - convInfo.padInfo.left;
        var chMul = outChannels / inChannels;
        for (var b = 0; b < batchSize; ++b) {
            for (var d1 = 0; d1 < inChannels; ++d1) {
                for (var xR = 0; xR < inHeight; ++xR) {
                    var xRCorner = xR - topPad;
                    var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                    var yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
                    for (var xC = 0; xC < inWidth; ++xC) {
                        var xCCorner = xC - leftPad;
                        var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                        var yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
                        var dotProd = 0;
                        for (var yR = xRMin; yR < yRMax; ++yR) {
                            var wR = yR * strideHeight - xRCorner;
                            for (var yC = xCMin; yC < yCMax; ++yC) {
                                var wC = yC * strideWidth - xCCorner;
                                var dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;
                                var fltOffset = fltS0 * (filterHeight - 1 - wR) +
                                    fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
                                for (var dm = 0; dm < chMul; ++dm) {
                                    var d2 = d1 * chMul + dm;
                                    var pixel = dyValues[dyOffset + d2];
                                    var weight = fltValues[fltOffset + dm];
                                    dotProd += pixel * weight;
                                }
                            }
                        }
                        dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.depthwiseConv2DDerFilter = function (x, dy, convInfo) {
        this.assertNotComplex([x, dy], 'depthwiseConv2DDerFilter');
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dW = ops.buffer(convInfo.filterShape, 'float32');
        var leftPad = convInfo.padInfo.left;
        var topPad = convInfo.padInfo.top;
        var chMul = convInfo.outChannels / convInfo.inChannels;
        for (var wR = 0; wR < filterHeight; ++wR) {
            var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
            var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
            for (var wC = 0; wC < filterWidth; ++wC) {
                var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
                for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                    var d1 = Math.trunc(d2 / chMul);
                    var dm = d2 % chMul;
                    var dotProd = 0;
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var yR = yRMin; yR < yRMax; ++yR) {
                            var xR = wR + yR * strideHeight - topPad;
                            for (var yC = yCMin; yC < yCMax; ++yC) {
                                var xC = wC + yC * strideWidth - leftPad;
                                dotProd += x.get(b, xR, xC, d1) * dy.get(b, yR, yC, d2);
                            }
                        }
                    }
                    dW.set(dotProd, wR, wC, d1, dm);
                }
            }
        }
        return dW.toTensor();
    };
    MathBackendCPU.prototype.tile = function (x, reps) {
        this.assertNotComplex(x, 'tile');
        var newShape = new Array(x.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = x.shape[i] * reps[i];
        }
        var result = ops.buffer(newShape, x.dtype);
        var xBuf = x.buffer();
        for (var i = 0; i < result.values.length; ++i) {
            var newLoc = result.indexToLoc(i);
            var originalLoc = new Array(x.rank);
            for (var i_1 = 0; i_1 < originalLoc.length; i_1++) {
                originalLoc[i_1] = newLoc[i_1] % x.shape[i_1];
            }
            var originalIndex = xBuf.locToIndex(originalLoc);
            result.values[i] = xBuf.values[originalIndex];
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.pad = function (x, paddings, constantValue) {
        this.assertNotComplex(x, 'pad');
        var outShape = paddings.map(function (p, i) { return p[0] + x.shape[i] + p[1]; });
        var start = paddings.map(function (p) { return p[0]; });
        var xBuffer = x.buffer();
        var buffer = ops.buffer(outShape, x.dtype);
        if (constantValue !== 0) {
            buffer.values.fill(constantValue);
        }
        for (var i = 0; i < x.size; i++) {
            var coords = xBuffer.indexToLoc(i);
            var outCoords = coords.map(function (c, i) { return c + start[i]; });
            buffer.set.apply(buffer, [x.get.apply(x, coords)].concat(outCoords));
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.transpose = function (x, perm) {
        this.assertNotComplex(x, 'transpose');
        var newShape = new Array(x.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = x.shape[perm[i]];
        }
        var values = x.dataSync();
        var result = ops_1.buffer(newShape, x.dtype);
        var xBuf = x.buffer();
        for (var i = 0; i < x.size; ++i) {
            var loc = xBuf.indexToLoc(i);
            var newLoc = new Array(loc.length);
            for (var i_2 = 0; i_2 < newLoc.length; i_2++) {
                newLoc[i_2] = loc[perm[i_2]];
            }
            var newIndex = result.locToIndex(newLoc);
            result.values[newIndex] = values[i];
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.gather = function (x, indices, axis) {
        this.assertNotComplex([x, indices], 'gather');
        var newShape = x.shape.slice();
        var indicesValues = indices.dataSync();
        newShape[axis] = indicesValues.length;
        var result = ops_1.buffer(newShape, x.dtype);
        var xBuf = x.buffer();
        for (var i = 0; i < result.size; ++i) {
            var newLoc = result.indexToLoc(i);
            var originalLoc = newLoc.slice();
            originalLoc[axis] = indicesValues[newLoc[axis]];
            var originalIndex = xBuf.locToIndex(originalLoc);
            result.values[i] = xBuf.values[originalIndex];
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.batchToSpaceND = function (x, blockShape, crops) {
        this.assertNotComplex([x], 'batchToSpaceND');
        var prod = blockShape.reduce(function (a, b) { return a * b; });
        var reshaped = array_ops_util.getReshaped(x.shape, blockShape, prod);
        var permuted = array_ops_util.getPermuted(reshaped.length, blockShape.length);
        var reshapedPermuted = array_ops_util.getReshapedPermuted(x.shape, blockShape, prod);
        var sliceBeginCoords = array_ops_util.getSliceBeginCoords(crops, blockShape.length);
        var sliceSize = array_ops_util.getSliceSize(reshapedPermuted, crops, blockShape.length);
        return x.reshape(reshaped)
            .transpose(permuted)
            .reshape(reshapedPermuted)
            .slice(sliceBeginCoords, sliceSize);
    };
    MathBackendCPU.prototype.spaceToBatchND = function (x, blockShape, paddings) {
        this.assertNotComplex([x], 'spaceToBatchND');
        var prod = blockShape.reduce(function (a, b) { return a * b; });
        var completePaddings = [[0, 0]];
        completePaddings.push.apply(completePaddings, paddings);
        for (var i = 1 + blockShape.length; i < x.shape.length; ++i) {
            completePaddings.push([0, 0]);
        }
        var paddedX = x.pad(completePaddings);
        var reshapedPaddedShape = array_ops_util.getReshaped(paddedX.shape, blockShape, prod, false);
        var permutedReshapedPaddedPermutation = array_ops_util.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
        var flattenShape = array_ops_util.getReshapedPermuted(paddedX.shape, blockShape, prod, false);
        return paddedX.reshape(reshapedPaddedShape)
            .transpose(permutedReshapedPaddedPermutation)
            .reshape(flattenShape);
    };
    MathBackendCPU.prototype.pool = function (x, convInfo, poolType) {
        this.assertNotComplex(x, 'pool');
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var y = ops.buffer(convInfo.outShape, 'float32');
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var initialValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :
            Number.POSITIVE_INFINITY);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * strideHeight - padTop;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * strideWidth - padLeft;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        var minMaxValue = initialValue;
                        var avgValue = 0;
                        var count = 0;
                        for (var xR = xRMin; xR < xRMax; ++xR) {
                            for (var xC = xCMin; xC < xCMax; ++xC) {
                                var pixel = x.get(b, xR, xC, d);
                                if ((poolType === 'max' && pixel > minMaxValue)) {
                                    minMaxValue = pixel;
                                }
                                else if (poolType === 'avg') {
                                    avgValue += pixel;
                                    count++;
                                }
                            }
                            if (isNaN(minMaxValue)) {
                                break;
                            }
                        }
                        y.set(poolType === 'avg' ? avgValue / count : minMaxValue, b, yR, yC, d);
                    }
                }
            }
        }
        return y.toTensor();
    };
    MathBackendCPU.prototype.maxPool = function (x, convInfo) {
        return this.pool(x, convInfo, 'max');
    };
    MathBackendCPU.prototype.maxPoolPositions = function (x, convInfo) {
        var maxPositions = ops.buffer(convInfo.outShape, 'int32');
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * strideHeight - padTop;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * strideWidth - padLeft;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        var maxValue = Number.NEGATIVE_INFINITY;
                        var maxPosition = -1;
                        for (var xR = xRMin; xR < xRMax; ++xR) {
                            var wR = xR - xRCorner;
                            for (var xC = xCMin; xC < xCMax; ++xC) {
                                var wC = xC - xCCorner;
                                var pixel = x.get(b, xR, xC, d);
                                if (pixel > maxValue) {
                                    maxValue = pixel;
                                    maxPosition = wR * filterWidth + wC;
                                }
                            }
                        }
                        maxPositions.set(maxPosition, b, yR, yC, d);
                    }
                }
            }
        }
        return maxPositions.toTensor();
    };
    MathBackendCPU.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {
        this.assertNotComplex([x, y], 'maxPoolBackprop');
        var maxPositions = this.maxPoolPositions(x, convInfo);
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var dx = ops.buffer(x.shape, 'float32');
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {
                    for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {
                        var dyRCorner = dxR - padTop;
                        var dyCCorner = dxC - padLeft;
                        var dotProd = 0;
                        for (var wR = 0; wR < filterHeight; ++wR) {
                            var dyR = (dyRCorner + wR) / strideHeight;
                            if (dyR < 0 || dyR >= convInfo.outHeight ||
                                Math.floor(dyR) !== dyR) {
                                continue;
                            }
                            for (var wC = 0; wC < filterWidth; ++wC) {
                                var dyC = (dyCCorner + wC) / strideWidth;
                                if (dyC < 0 || dyC >= convInfo.outWidth ||
                                    Math.floor(dyC) !== dyC) {
                                    continue;
                                }
                                var maxPos = filterHeight * filterWidth - 1 -
                                    maxPositions.get(b, dyR, dyC, d);
                                var curPos = wR * filterWidth + wC;
                                var mask = maxPos === curPos ? 1 : 0;
                                if (mask === 0) {
                                    continue;
                                }
                                var pixel = dy.get(b, dyR, dyC, d);
                                dotProd += pixel * mask;
                            }
                        }
                        dx.set(dotProd, b, dxR, dxC, d);
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.avgPoolBackprop = function (dy, x, convInfo) {
        this.assertNotComplex([dy, x], 'avgPoolBackprop');
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var dx = ops.buffer(x.shape, 'float32');
        var avgMultiplier = 1 / (filterHeight * filterWidth);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {
                    for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {
                        var dyRCorner = dxR - padTop;
                        var dyCCorner = dxC - padLeft;
                        var dotProd = 0;
                        for (var wR = 0; wR < filterHeight; ++wR) {
                            var dyR = (dyRCorner + wR) / strideHeight;
                            if (dyR < 0 || dyR >= convInfo.outHeight ||
                                Math.floor(dyR) !== dyR) {
                                continue;
                            }
                            for (var wC = 0; wC < filterWidth; ++wC) {
                                var dyC = (dyCCorner + wC) / strideWidth;
                                if (dyC < 0 || dyC >= convInfo.outWidth ||
                                    Math.floor(dyC) !== dyC) {
                                    continue;
                                }
                                var pixel = dy.get(b, dyR, dyC, d);
                                dotProd += pixel;
                            }
                        }
                        dx.set(dotProd * avgMultiplier, b, dxR, dxC, d);
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.cast = function (x, dtype) {
        return backend_util.castTensor(x, dtype, this);
    };
    MathBackendCPU.prototype.reshape = function (x, shape) {
        return backend_util.reshapeTensor(x, shape);
    };
    MathBackendCPU.prototype.avgPool = function (x, convInfo) {
        this.assertNotComplex(x, 'avgPool');
        return this.pool(x, convInfo, 'avg').toFloat();
    };
    MathBackendCPU.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
        this.assertNotComplex(x, 'resizeBilinear');
        var _a = x.shape, batch = _a[0], oldHeight = _a[1], oldWidth = _a[2], numChannels = _a[3];
        var xValues = x.dataSync();
        var result = new Float32Array(util.sizeFromShape([batch, newHeight, newWidth, numChannels]));
        var effectiveInputSize = [
            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,
            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth
        ];
        var effectiveOutputSize = [
            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,
            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth
        ];
        var outputIdx = 0;
        var effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];
        var effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];
        for (var b = 0; b < batch; b++) {
            for (var r = 0; r < newHeight; r++) {
                var sourceFracRow = effectiveRowSizeRatio * r;
                var sourceRowFloor = Math.floor(sourceFracRow);
                var rowFrac = sourceFracRow - sourceRowFloor;
                var sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));
                var topRowOffset = b * x.strides[0] + sourceRowFloor * x.strides[1];
                var botRowOffset = b * x.strides[0] + sourceRowCeil * x.strides[1];
                for (var c = 0; c < newWidth; c++) {
                    var sourceFracCol = effectiveColSizeRatio * c;
                    var sourceColFloor = Math.floor(sourceFracCol);
                    var colFrac = sourceFracCol - sourceColFloor;
                    var sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));
                    var topLeftOffest = topRowOffset + sourceColFloor * x.strides[2];
                    var botLeftOffset = botRowOffset + sourceColFloor * x.strides[2];
                    var topRightOffset = topRowOffset + +sourceColCeil * x.strides[2];
                    var botRightOffest = botRowOffset + sourceColCeil * x.strides[2];
                    for (var d = 0; d < numChannels; d++) {
                        var topLeft = xValues[topLeftOffest + d];
                        var bottomLeft = xValues[botLeftOffset + d];
                        var topRight = xValues[topRightOffset + d];
                        var bottomRight = xValues[botRightOffest + d];
                        var top_1 = topLeft + (topRight - topLeft) * colFrac;
                        var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                        var newValue = top_1 + (bottom - top_1) * rowFrac;
                        result[outputIdx++] = newValue;
                    }
                }
            }
        }
        return ops.tensor(result, [batch, newHeight, newWidth, numChannels]);
    };
    MathBackendCPU.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {
        this.assertNotComplex([dy, x], 'resizeBilinearBackprop');
        var _a = x.shape, batch = _a[0], xHeight = _a[1], xWidth = _a[2], depth = _a[3];
        var _b = dy.shape, yHeight = _b[1], yWidth = _b[2];
        var output = new Float32Array(batch * xHeight * xWidth * depth);
        var effectiveXSize = [
            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,
            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth
        ];
        var effectiveYSize = [
            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,
            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth
        ];
        var heightScale = effectiveXSize[0] / effectiveYSize[0];
        var widthScale = effectiveXSize[1] / effectiveYSize[1];
        var dyValues = dy.dataSync();
        var offset = 0;
        for (var b = 0; b < batch; b++) {
            var bOffset = b * x.strides[0];
            for (var r = 0; r < yHeight; r++) {
                var dxR = r * heightScale;
                var topDxRIndex = Math.floor(dxR);
                var bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);
                var topDxROffset = bOffset + topDxRIndex * x.strides[1];
                var bottomDxROffset = bOffset + bottomDxRIndex * x.strides[1];
                var dxRLerp = dxR - topDxRIndex;
                var inverseDxRLerp = 1.0 - dxRLerp;
                for (var c = 0; c < yWidth; c++) {
                    var dxC = c * widthScale;
                    var leftDxCIndex = Math.floor(dxC);
                    var rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);
                    var dxCLerp = dxC - leftDxCIndex;
                    var inverseDxCLerp = 1.0 - dxCLerp;
                    var topLeftRCOffset = topDxROffset + leftDxCIndex * x.strides[2];
                    var topRightRCOffset = topDxROffset + rightDxCIndex * x.strides[2];
                    var bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * x.strides[2];
                    var bottomRightRCOffset = bottomDxROffset + rightDxCIndex * x.strides[2];
                    var inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;
                    var inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;
                    var dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;
                    var dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;
                    for (var d = 0; d < depth; d++) {
                        var dyVal = dyValues[offset++];
                        output[topLeftRCOffset + d] +=
                            dyVal * inverseDxRLerpTimesInverseDxCLerp;
                        output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;
                        output[bottomLeftRCOffset + d] +=
                            dyVal * dxRLerpTimesInverseDxCLerp;
                        output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;
                    }
                }
            }
        }
        return ops.tensor4d(output, [batch, xWidth, xHeight, depth], x.dtype);
    };
    MathBackendCPU.prototype.resizeNearestNeighbor = function (x, newHeight, newWidth, alignCorners) {
        this.assertNotComplex(x, 'resizeNearestNeighbor');
        var _a = x.shape, batch = _a[0], oldHeight = _a[1], oldWidth = _a[2], numChannels = _a[3];
        var output = ops.buffer([batch, newHeight, newWidth, numChannels], x.dtype);
        var effectiveInputSize = [
            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,
            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth
        ];
        var effectiveOutputSize = [
            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,
            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth
        ];
        for (var b = 0; b < batch; b++) {
            for (var r = 0; r < newHeight; r++) {
                for (var c = 0; c < newWidth; c++) {
                    for (var d = 0; d < numChannels; d++) {
                        var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
                        var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
                        var sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) :
                            Math.floor(sourceFracRow));
                        var sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) :
                            Math.floor(sourceFracCol));
                        var newValue = x.get(b, sourceNearestRow, sourceNearestCol, d);
                        output.set(newValue, b, r, c, d);
                    }
                }
            }
        }
        return output.toTensor();
    };
    MathBackendCPU.prototype.resizeNearestNeighborBackprop = function (dy, x, alignCorners) {
        this.assertNotComplex([dy, x], 'resizeNearestNeighborBackprop');
        var _a = x.shape, batch = _a[0], xHeight = _a[1], xWidth = _a[2], depth = _a[3];
        var _b = dy.shape, yHeight = _b[1], yWidth = _b[2];
        var output = ops.buffer([batch, xHeight, xWidth, depth], x.dtype);
        var effectiveXSize = [
            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,
            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth
        ];
        var effectiveYSize = [
            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,
            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth
        ];
        var heightScale = effectiveXSize[0] / effectiveYSize[0];
        var widthScale = effectiveXSize[1] / effectiveYSize[1];
        var invHeightScale = 1 / heightScale;
        var invWidthScale = 1 / widthScale;
        var winHeight = (Math.ceil(invHeightScale) * 2) + 2;
        var winWidth = (Math.ceil(invWidthScale) * 2) + 2;
        for (var b = 0; b < batch; b++) {
            for (var r = 0; r < xHeight; r++) {
                for (var c = 0; c < xWidth; c++) {
                    var startRLerp = Math.floor(r * invHeightScale);
                    var startDyR = Math.floor(startRLerp - (winHeight / 2));
                    var startCLerp = Math.floor(c * invWidthScale);
                    var startDyC = Math.floor(startCLerp - (winWidth / 2));
                    for (var d = 0; d < depth; d++) {
                        var accum = 0;
                        for (var dyROffset = 0; dyROffset < winHeight; dyROffset++) {
                            var dyR = dyROffset + startDyR;
                            if (dyR < 0 || dyR >= yHeight) {
                                continue;
                            }
                            for (var dyCOffSet = 0; dyCOffSet < winWidth; dyCOffSet++) {
                                var dyC = dyCOffSet + startDyC;
                                if (dyC < 0 || dyC >= yWidth) {
                                    continue;
                                }
                                var sourceFracRow = effectiveXSize[0] * (dyR / effectiveYSize[0]);
                                var sourceFracCol = effectiveXSize[1] * (dyC / effectiveYSize[1]);
                                var sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) :
                                    Math.floor(sourceFracRow));
                                var sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) :
                                    Math.floor(sourceFracCol));
                                if (r === sourceNearestRow && c === sourceNearestCol) {
                                    accum += dy.get(b, dyR, dyC, d);
                                }
                            }
                        }
                        output.set(accum, b, r, c, d);
                    }
                }
            }
        }
        return output.toTensor();
    };
    MathBackendCPU.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
        this.assertNotComplex([x, mean, variance, scale, offset], 'batchNormalization');
        var xVals = x.dataSync();
        var mVals = mean.dataSync();
        var varVals = variance.dataSync();
        var sVals = scale ? scale.dataSync() : new Float32Array([1]);
        var offVals = offset ? offset.dataSync() : new Float32Array([0]);
        var outVals = new Float32Array(xVals.length);
        var offValsLength = offVals.length;
        var sValsLength = sVals.length;
        var varValsLength = varVals.length;
        var mValsLength = mVals.length;
        var offi = 0;
        var mi = 0;
        var si = 0;
        var vi = 0;
        for (var i = 0; i < xVals.length; ++i) {
            outVals[i] = offVals[offi++] +
                (xVals[i] - mVals[mi++]) * sVals[si++] /
                    Math.sqrt(varVals[vi++] + varianceEpsilon);
            if (offi >= offValsLength) {
                offi = 0;
            }
            if (mi >= mValsLength) {
                mi = 0;
            }
            if (si >= sValsLength) {
                si = 0;
            }
            if (vi >= varValsLength) {
                vi = 0;
            }
        }
        return ops_1.tensor4d(outVals, x.shape);
    };
    MathBackendCPU.prototype.localResponseNormalization4D = function (x, depthRadius, bias, alpha, beta) {
        this.assertNotComplex(x, 'localResponseNormalization4D');
        var channels = x.shape[3];
        var maxD = channels - 1;
        var xValues = x.dataSync();
        var size = util.sizeFromShape(x.shape);
        var result = new Float32Array(size);
        function sumAcrossChannels(offset) {
            var currentChannel = offset % channels;
            var beginSumOffset = offset - currentChannel + Math.max(0, currentChannel - depthRadius);
            var endSumOffset = offset - currentChannel +
                Math.min(currentChannel + depthRadius, maxD);
            var sum = 0.0;
            for (; beginSumOffset <= endSumOffset; beginSumOffset++) {
                var z = xValues[beginSumOffset];
                sum += z * z;
            }
            return sum;
        }
        for (var offset = 0; offset < size; offset++) {
            var sum = sumAcrossChannels(offset);
            var val = xValues[offset] * Math.pow(bias + alpha * sum, -beta);
            result[offset] = val;
        }
        return ops.tensor4d(result, x.shape);
    };
    MathBackendCPU.prototype.LRNGrad = function (dy, inputImage, outputImage, depthRadius, bias, alpha, beta) {
        this.assertNotComplex(dy, 'LRNGrad');
        var channels = dy.shape[3];
        var dyValues = dy.dataSync();
        var inputImageValues = inputImage.dataSync();
        var outputImageValues = outputImage.dataSync();
        var result = new Float32Array(util.sizeFromShape(dy.shape));
        var size = util.sizeFromShape(dy.shape);
        for (var offset = 0; offset < size; offset++) {
            var currentChannel = offset % channels;
            var depthBegin = (offset - currentChannel) + Math.max(0, currentChannel - depthRadius);
            var depthEnd = (offset - currentChannel) +
                Math.min(channels, currentChannel + depthRadius + 1);
            var norm = 0;
            for (var k = depthBegin; k < depthEnd; k++) {
                norm += Math.pow(inputImageValues[k], 2);
            }
            norm = alpha * norm + bias;
            for (var k = depthBegin; k < depthEnd; k++) {
                var dyi = -2 * alpha * beta * inputImageValues[k] *
                    outputImageValues[offset] / norm;
                if (offset === k) {
                    dyi += Math.pow(norm, -beta);
                }
                dyi *= dyValues[offset];
                result[k] += dyi;
            }
        }
        return ops.tensor4d(result, dy.shape);
    };
    MathBackendCPU.prototype.multinomial = function (logits, normalized, numSamples, seed) {
        this.assertNotComplex(logits, 'multinomial');
        var probabilities = normalized ? logits : ops.softmax(logits);
        var batchSize = probabilities.shape[0];
        var numEvents = probabilities.shape[1];
        var res = ops.zeros([batchSize, numSamples], 'int32');
        var resVals = res.dataSync();
        var probVals = probabilities.dataSync();
        for (var b = 0; b < batchSize; ++b) {
            var offset = b * numEvents;
            var cdf = new Float32Array(numEvents - 1);
            cdf[0] = probVals[offset];
            for (var event_1 = 1; event_1 < cdf.length; ++event_1) {
                cdf[event_1] = cdf[event_1 - 1] + probVals[offset + event_1];
            }
            var random = seedrandom.alea(seed.toString());
            var outOffset = b * numSamples;
            for (var sampleId = 0; sampleId < numSamples; ++sampleId) {
                var r = random();
                resVals[outOffset + sampleId] = cdf.length;
                for (var event_2 = 0; event_2 < cdf.length; event_2++) {
                    if (r < cdf[event_2]) {
                        resVals[outOffset + sampleId] = event_2;
                        break;
                    }
                }
            }
        }
        return res;
    };
    MathBackendCPU.prototype.oneHot = function (indices, depth, onValue, offValue) {
        this.assertNotComplex(indices, 'oneHot');
        var res = new Float32Array(indices.size * depth);
        res.fill(offValue);
        for (var event_3 = 0; event_3 < indices.size; ++event_3) {
            if (indices.get(event_3) >= 0 && indices.get(event_3) < depth) {
                res[event_3 * depth + indices.get(event_3)] = onValue;
            }
        }
        return ops.tensor2d(res, [indices.size, depth], 'int32');
    };
    MathBackendCPU.prototype.nonMaxSuppression = function (boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
        this.assertNotComplex(boxes, 'nonMaxSuppression');
        var boxesVals = boxes.dataSync();
        var scoresVals = scores.dataSync();
        return non_max_suppression_impl_1.nonMaxSuppressionImpl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
    };
    MathBackendCPU.prototype.fft = function (input) {
        util.assert(input.shape.length > 0, 'input must have at least one rank.');
        var n = input.shape[0];
        if (this.is_exponent_of_2(n)) {
            return this.fftRadix2(input, n);
        }
        else {
            var data = input.dataSync();
            var rawOutput = this.fourierTransformByMatmul(data, n);
            var output = complex_util.splitRealAndImagArrays(rawOutput);
            return ops.complex(output.real, output.imag).as1D();
        }
    };
    MathBackendCPU.prototype.is_exponent_of_2 = function (size) {
        return (size & size - 1) === 0;
    };
    MathBackendCPU.prototype.fftRadix2 = function (input, size) {
        if (size === 1) {
            return input;
        }
        var data = input.dataSync();
        var half = size / 2;
        var evenComplex = complex_util.complexWithEvenIndex(data);
        var evenTensor = ops.complex(evenComplex.real, evenComplex.imag).as1D();
        var oddComplex = complex_util.complexWithOddIndex(data);
        var oddTensor = ops.complex(oddComplex.real, oddComplex.imag).as1D();
        evenTensor = this.fftRadix2(evenTensor, half);
        oddTensor = this.fftRadix2(oddTensor, half);
        var e = complex_util.exponents(size);
        var exponent = ops.complex(e.real, e.imag).mul(oddTensor);
        var addPart = evenTensor.add(exponent);
        var subPart = evenTensor.sub(exponent);
        var realTensor = ops.real(addPart).concat(ops.real(subPart));
        var imagTensor = ops.imag(addPart).concat(ops.imag(subPart));
        return ops.complex(realTensor, imagTensor).as1D();
    };
    MathBackendCPU.prototype.fourierTransformByMatmul = function (data, size) {
        var ret = new Float32Array(size * 2);
        for (var r = 0; r < size; r++) {
            var real = 0.0;
            var imag = 0.0;
            for (var c = 0; c < size; c++) {
                var e = complex_util.exponent(r * c, size);
                var term = complex_util.getComplexWithIndex(data, c);
                real += term.real * e.real - term.imag * e.imag;
                imag += term.real * e.imag + term.imag * e.real;
            }
            complex_util.assignToTypedArray(ret, real, imag, r);
        }
        return ret;
    };
    MathBackendCPU.prototype.depthToSpace = function (x, blockSize, dataFormat) {
        util.assert(dataFormat === 'NHWC', "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + dataFormat);
        util.assert(blockSize > 1, "blockSize should be > 1 for depthToSpace, but was: " + blockSize);
        var batchSize = x.shape[0];
        var inputHeight = x.shape[1];
        var inputWidth = x.shape[2];
        var inputDepth = x.shape[3];
        var outputHeight = inputHeight * blockSize;
        var outputWidth = inputWidth * blockSize;
        var outputDepth = inputDepth / (blockSize * blockSize);
        var xValues = x.dataSync();
        var result = new Float32Array(batchSize * outputHeight * outputWidth * outputDepth);
        var outputIdx = 0;
        for (var b = 0; b < batchSize; ++b) {
            for (var h = 0; h < outputHeight; ++h) {
                var inH = Math.floor(h / blockSize);
                var offsetH = (h % blockSize);
                for (var w = 0; w < outputWidth; ++w) {
                    var inW = Math.floor(w / blockSize);
                    var offsetW = (w % blockSize);
                    var offsetD = (offsetH * blockSize + offsetW) * outputDepth;
                    for (var d = 0; d < outputDepth; ++d) {
                        var inD = d + offsetD;
                        var inputIdx = inD + inputDepth * (inW + inputWidth * (inH + inputHeight * b));
                        result[outputIdx++] = xValues[inputIdx];
                    }
                }
            }
        }
        return ops.tensor4d(result, [batchSize, outputHeight, outputWidth, outputDepth]);
    };
    MathBackendCPU.prototype.broadcastedBinaryOp = function (a, b, dtype, op) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var result = ops.buffer(newShape, dtype);
        var aVals = a.dataSync();
        var bVals = b.dataSync();
        var aBroadcastDims = broadcast_util.getBroadcastDims(a.shape, newShape);
        var bBroadcastDims = broadcast_util.getBroadcastDims(b.shape, newShape);
        var resVals = result.values;
        if (aBroadcastDims.length + bBroadcastDims.length === 0) {
            for (var i = 0; i < resVals.length; ++i) {
                resVals[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);
            }
        }
        else {
            var aBuf = a.buffer();
            var bBuf = b.buffer();
            var _loop_2 = function (i) {
                var loc = result.indexToLoc(i);
                var aLoc = loc.slice(-a.rank);
                aBroadcastDims.forEach(function (d) { return aLoc[d] = 0; });
                var aIndex = aBuf.locToIndex(aLoc);
                var bLoc = loc.slice(-b.rank);
                bBroadcastDims.forEach(function (d) { return bLoc[d] = 0; });
                var bIndex = bBuf.locToIndex(bLoc);
                resVals[i] = op(aVals[aIndex], bVals[bIndex]);
            };
            for (var i = 0; i < resVals.length; ++i) {
                _loop_2(i);
            }
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.broadcastedBinaryComplexOp = function (a, b, op) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var realResult = ops.buffer(newShape, 'float32');
        var imagResult = ops.buffer(newShape, 'float32');
        var aVals = a.dataSync();
        var bVals = b.dataSync();
        var aBroadcastDims = broadcast_util.getBroadcastDims(a.shape, newShape);
        var bBroadcastDims = broadcast_util.getBroadcastDims(b.shape, newShape);
        var realVals = realResult.values;
        var imagVals = imagResult.values;
        if (aBroadcastDims.length + bBroadcastDims.length === 0) {
            for (var i = 0; i < realVals.length; i++) {
                var aIdx = i % aVals.length;
                var bIdx = i % bVals.length;
                var result = op(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);
                realVals[i] = result.real;
                imagVals[i] = result.imag;
            }
        }
        else {
            var aRealBuf = this.data.get(a.dataId).complexTensors.real.buffer();
            var bRealBuf = this.data.get(b.dataId).complexTensors.real.buffer();
            var _loop_3 = function (i) {
                var loc = realResult.indexToLoc(i);
                var aLoc = loc.slice(-a.rank);
                aBroadcastDims.forEach(function (d) { return aLoc[d] = 0; });
                var aIndex = aRealBuf.locToIndex(aLoc);
                var bLoc = loc.slice(-b.rank);
                bBroadcastDims.forEach(function (d) { return bLoc[d] = 0; });
                var bIndex = bRealBuf.locToIndex(bLoc);
                var opResult = op(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);
                realVals[i] = opResult.real;
                imagVals[i] = opResult.imag;
            };
            for (var i = 0; i < realVals.length; i++) {
                _loop_3(i);
            }
        }
        return this.complex(realResult.toTensor(), imagResult.toTensor());
    };
    MathBackendCPU.prototype.split = function (x, sizeSplits, axis) {
        return split_shared_1.split(x, sizeSplits, axis);
    };
    MathBackendCPU.prototype.dispose = function () { };
    MathBackendCPU.prototype.floatPrecision = function () {
        return 32;
    };
    MathBackendCPU.prototype.cropAndResize = function (images, boxes, boxIndex, cropSize, method, extrapolationValue) {
        var _a = images.shape, batch = _a[0], imageHeight = _a[1], imageWidth = _a[2], numChannels = _a[3];
        var numBoxes = boxes.shape[0];
        var cropHeight = cropSize[0], cropWidth = cropSize[1];
        var output = ops.buffer([numBoxes, cropHeight, cropWidth, numChannels]);
        var boxVals = boxes.dataSync();
        var boxIndVals = boxIndex.dataSync();
        var imageVals = images.dataSync();
        var inStride = images.strides;
        var outStride = output.strides;
        for (var b = 0; b < numBoxes; b++) {
            var startInd = b * 4;
            var y1 = boxVals[startInd];
            var x1 = boxVals[startInd + 1];
            var y2 = boxVals[startInd + 2];
            var x2 = boxVals[startInd + 3];
            var bInd = boxIndVals[b];
            if (bInd >= batch) {
                continue;
            }
            var heightScale = (cropHeight > 1) ?
                (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) :
                0;
            var widthScale = (cropWidth > 1) ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;
            for (var y = 0; y < cropHeight; y++) {
                var yInd = (cropHeight > 1) ?
                    y1 * (imageHeight - 1) + y * (heightScale) :
                    0.5 * (y1 + y2) * (imageHeight - 1);
                if (yInd < 0 || yInd > imageHeight - 1) {
                    for (var x = 0; x < cropWidth; x++) {
                        for (var c = 0; c < numChannels; c++) {
                            var ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                            output.values[ind] = extrapolationValue;
                        }
                    }
                    continue;
                }
                if (method === 'bilinear') {
                    var topInd = Math.floor(yInd);
                    var bottomInd = Math.ceil(yInd);
                    var yLerp = yInd - topInd;
                    for (var x = 0; x < cropWidth; x++) {
                        var xInd = (cropWidth > 1) ?
                            x1 * (imageWidth - 1) + x * widthScale :
                            0.5 * (x1 + x2) * (imageWidth - 1);
                        if (xInd < 0 || xInd > imageWidth - 1) {
                            for (var c = 0; c < numChannels; c++) {
                                var ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                                output.values[ind] = extrapolationValue;
                            }
                            continue;
                        }
                        var leftInd = Math.floor(xInd);
                        var rightInd = Math.ceil(xInd);
                        var xLerp = xInd - leftInd;
                        for (var c = 0; c < numChannels; c++) {
                            var ind = c + leftInd * inStride[2] + topInd * inStride[1] +
                                bInd * inStride[0];
                            var topLeft = imageVals[ind];
                            ind = c + rightInd * inStride[2] + topInd * inStride[1] +
                                bInd * inStride[0];
                            var topRight = imageVals[ind];
                            ind = c + leftInd * inStride[2] + bottomInd * inStride[1] +
                                bInd * inStride[0];
                            var bottomLeft = imageVals[ind];
                            ind = c + rightInd * inStride[2] + bottomInd * inStride[1] +
                                bInd * inStride[0];
                            var bottomRight = imageVals[ind];
                            var top_2 = topLeft + (topRight - topLeft) * xLerp;
                            var bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;
                            ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                            output.values[ind] = top_2 + ((bottom - top_2) * yLerp);
                        }
                    }
                }
                else {
                    for (var x = 0; x < cropWidth; ++x) {
                        var xInd = (cropWidth > 1) ?
                            x1 * (imageWidth - 1) + x * widthScale :
                            0.5 * (x1 + x2) * (imageWidth - 1);
                        if (xInd < 0 || xInd > imageWidth - 1) {
                            for (var c = 0; c < numChannels; c++) {
                                var ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                                output.values[ind] = extrapolationValue;
                            }
                            continue;
                        }
                        var closestX = Math.round(xInd);
                        var closestY = Math.round(yInd);
                        for (var c = 0; c < numChannels; c++) {
                            var inInd = c + closestX * inStride[2] +
                                closestY * inStride[1] + bInd * inStride[0];
                            var outInd = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                            output.values[outInd] = imageVals[inInd];
                        }
                    }
                }
            }
        }
        return output.toTensor();
    };
    MathBackendCPU.prototype.gatherND = function (x, indices) {
        var indicesShape = indices.shape;
        var sliceRank = indicesShape[indicesShape.length - 1];
        var _a = gather_nd_util.prepareAndValidate(x, indices), resultShape = _a[0], numSlices = _a[1], sliceSize = _a[2], strides = _a[3];
        if (numSlices === 0) {
            return ops_1.tensor([], resultShape, x.dtype);
        }
        var buffer = new tensor_1.TensorBuffer([numSlices, sliceSize], x.dtype);
        var indicesData = indices.dataSync();
        var xData = x.dataSync();
        for (var i = 0; i < numSlices; i++) {
            var index = [];
            var flattenIndex = 0;
            for (var j = 0; j < sliceRank; j++) {
                var dim = indicesData[i * sliceRank + j];
                flattenIndex += dim * strides[j];
                index.push(dim);
            }
            if (flattenIndex < 0 || flattenIndex >= x.size / sliceSize) {
                throw new Error("Invalid indices: " + index + " does not index into " + x.shape);
            }
            for (var k = 0; k < sliceSize; k++) {
                buffer.values[i * sliceSize + k] = xData[flattenIndex * sliceSize + k];
            }
        }
        return buffer.toTensor().reshape(resultShape);
    };
    MathBackendCPU.prototype.scatterND = function (indices, updates, shape) {
        var _a = scatter_nd_util.prepareAndValidate(updates, indices, shape), sliceRank = _a[0], numUpdates = _a[1], sliceSize = _a[2], strides = _a[3], outputSize = _a[4];
        var flattenShape = [outputSize / sliceSize, sliceSize];
        var indicesData = indices.dataSync();
        var updatesData = updates.dataSync();
        if (outputSize === 0) {
            return ops_1.tensor([], shape, updates.dtype);
        }
        var buffer = new tensor_1.TensorBuffer(flattenShape, updates.dtype);
        for (var i = 0; i < numUpdates; i++) {
            var index = [];
            var flattenIndex = 0;
            for (var j = 0; j < sliceRank; j++) {
                var dim = indicesData[i * sliceRank + j];
                index.push(dim);
                flattenIndex += dim * strides[j];
            }
            if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {
                throw new Error("Invalid indices: " + index + " does not index into " + shape);
            }
            for (var k = 0; k < sliceSize; k++) {
                buffer.values[flattenIndex * sliceSize + k] +=
                    updatesData[i * sliceSize + k];
            }
        }
        return buffer.toTensor().reshape(shape);
    };
    return MathBackendCPU;
}());
exports.MathBackendCPU = MathBackendCPU;
environment_1.ENV.registerBackend('cpu', function () { return new MathBackendCPU(); }, 1, tensor_1.setTensorTracker);

},{"../environment":60,"../log":137,"../ops/array_ops_util":139,"../ops/axis_util":140,"../ops/broadcast_util":143,"../ops/concat_util":147,"../ops/erf_util":150,"../ops/gather_nd_util":152,"../ops/ops":163,"../ops/scatter_nd_util":171,"../ops/selu_util":174,"../ops/slice_util":176,"../tensor":196,"../types":202,"../util":203,"./backend":76,"./backend_util":78,"./complex_util":80,"./non_max_suppression_impl":81,"./split_shared":82,"./topk_impl":83,"./where_impl":136,"seedrandom":1320}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_ops_1 = require("../ops/tensor_ops");
var tensor_1 = require("../tensor");
var util_1 = require("../util");
function castTensor(x, dtype, backend) {
    if (dtype === 'complex64') {
        if (x.dtype === 'complex64') {
            return x.clone();
        }
        var zerosTensor = tensor_ops_1.zeros(x.shape);
        var floatX = x.toFloat();
        var result = backend.complex(floatX, zerosTensor);
        zerosTensor.dispose();
        floatX.dispose();
        return result;
    }
    if (!util_1.hasEncodingLoss(x.dtype, dtype)) {
        return tensor_1.Tensor.make(x.shape, { dataId: x.dataId }, dtype);
    }
    if (x.dtype === 'complex64') {
        var real = backend.real(x);
        var result = real.cast(dtype);
        real.dispose();
        return result;
    }
    if (dtype === 'int32') {
        return backend.int(x);
    }
    else if (dtype === 'bool') {
        var zero = tensor_ops_1.scalar(0, x.dtype);
        var result = backend.notEqual(x, zero);
        zero.dispose();
        return result;
    }
    else {
        throw new Error("Error in Cast: unknown dtype argument (" + dtype + ")");
    }
}
exports.castTensor = castTensor;
function reshapeTensor(x, shape) {
    return tensor_1.Tensor.make(shape, { dataId: x.dataId }, x.dtype);
}
exports.reshapeTensor = reshapeTensor;

},{"../ops/tensor_ops":180,"../tensor":196,"../util":203}],79:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var log_1 = require("../log");
var array_ops_util = require("../ops/array_ops_util");
var axis_util = require("../ops/axis_util");
var concat_util_1 = require("../ops/concat_util");
var gather_nd_util = require("../ops/gather_nd_util");
var reduce_util = require("../ops/reduce_util");
var scatter_nd_util = require("../ops/scatter_nd_util");
var segment_util = require("../ops/segment_util");
var slice_util_1 = require("../ops/slice_util");
var softmax_1 = require("../ops/softmax");
var tensor_ops_1 = require("../ops/tensor_ops");
var tensor_1 = require("../tensor");
var types_1 = require("../types");
var util = require("../util");
var util_1 = require("../util");
var backend_1 = require("./backend");
var backend_util = require("./backend_util");
var complex_util_1 = require("./complex_util");
var non_max_suppression_impl_1 = require("./non_max_suppression_impl");
var split_shared_1 = require("./split_shared");
var topk_impl_1 = require("./topk_impl");
var argminmax_gpu_1 = require("./webgl/argminmax_gpu");
var avg_pool_backprop_gpu_1 = require("./webgl/avg_pool_backprop_gpu");
var batchnorm_gpu_1 = require("./webgl/batchnorm_gpu");
var binaryop_complex_gpu = require("./webgl/binaryop_complex_gpu");
var binaryop_complex_gpu_1 = require("./webgl/binaryop_complex_gpu");
var binaryop_gpu = require("./webgl/binaryop_gpu");
var binaryop_gpu_1 = require("./webgl/binaryop_gpu");
var clip_gpu_1 = require("./webgl/clip_gpu");
var concat_gpu_1 = require("./webgl/concat_gpu");
var conv_backprop_gpu_1 = require("./webgl/conv_backprop_gpu");
var conv_backprop_gpu_depthwise_1 = require("./webgl/conv_backprop_gpu_depthwise");
var conv_gpu_1 = require("./webgl/conv_gpu");
var conv_gpu_depthwise_1 = require("./webgl/conv_gpu_depthwise");
var crop_and_resize_gpu_1 = require("./webgl/crop_and_resize_gpu");
var cumsum_gpu_1 = require("./webgl/cumsum_gpu");
var depth_to_space_gpu_1 = require("./webgl/depth_to_space_gpu");
var encode_float_gpu_1 = require("./webgl/encode_float_gpu");
var fft_gpu = require("./webgl/fft_gpu");
var fft_gpu_1 = require("./webgl/fft_gpu");
var from_pixels_gpu_1 = require("./webgl/from_pixels_gpu");
var gather_gpu_1 = require("./webgl/gather_gpu");
var gather_nd_gpu_1 = require("./webgl/gather_nd_gpu");
var gpgpu_context_1 = require("./webgl/gpgpu_context");
var gpgpu_math = require("./webgl/gpgpu_math");
var gpgpu_util = require("./webgl/gpgpu_util");
var im2col_gpu_1 = require("./webgl/im2col_gpu");
var lrn_gpu_1 = require("./webgl/lrn_gpu");
var lrn_grad_gpu_1 = require("./webgl/lrn_grad_gpu");
var max_pool_backprop_gpu_1 = require("./webgl/max_pool_backprop_gpu");
var mulmat_gpu_1 = require("./webgl/mulmat_gpu");
var mulmat_packed_gpu_1 = require("./webgl/mulmat_packed_gpu");
var multinomial_gpu_1 = require("./webgl/multinomial_gpu");
var onehot_gpu_1 = require("./webgl/onehot_gpu");
var pack_gpu_1 = require("./webgl/pack_gpu");
var pad_gpu_1 = require("./webgl/pad_gpu");
var pool_gpu_1 = require("./webgl/pool_gpu");
var reduce_gpu_1 = require("./webgl/reduce_gpu");
var resize_bilinear_backprop_gpu_1 = require("./webgl/resize_bilinear_backprop_gpu");
var resize_bilinear_gpu_1 = require("./webgl/resize_bilinear_gpu");
var resize_nearest_neighbor_backprop_gpu_1 = require("./webgl/resize_nearest_neighbor_backprop_gpu");
var resize_nearest_neighbor_gpu_1 = require("./webgl/resize_nearest_neighbor_gpu");
var reverse_gpu_1 = require("./webgl/reverse_gpu");
var scatter_nd_gpu_1 = require("./webgl/scatter_nd_gpu");
var segment_gpu_1 = require("./webgl/segment_gpu");
var select_gpu_1 = require("./webgl/select_gpu");
var slice_gpu_1 = require("./webgl/slice_gpu");
var strided_slice_gpu_1 = require("./webgl/strided_slice_gpu");
var tex_util_1 = require("./webgl/tex_util");
var texture_manager_1 = require("./webgl/texture_manager");
var tile_gpu_1 = require("./webgl/tile_gpu");
var transpose_gpu_1 = require("./webgl/transpose_gpu");
var unary_op = require("./webgl/unaryop_gpu");
var unaryop_gpu_1 = require("./webgl/unaryop_gpu");
var unpack_gpu_1 = require("./webgl/unpack_gpu");
var webgl_util = require("./webgl/webgl_util");
var where_impl_1 = require("./where_impl");
var BEFORE_PAGING_CONSTANT = 300;
exports.SIZE_UPLOAD_UNIFORM = 4;
var MathBackendWebGL = (function () {
    function MathBackendWebGL(gpgpu, delayedStorage) {
        if (delayedStorage === void 0) { delayedStorage = true; }
        this.gpgpu = gpgpu;
        this.delayedStorage = delayedStorage;
        this.pendingRead = new WeakMap();
        this.pendingDisposal = new WeakSet();
        this.lruDataGPU = [];
        this.numBytesInGPU = 0;
        this.uploadWaitMs = 0;
        this.downloadWaitMs = 0;
        this.binaryCache = {};
        this.disposed = false;
        if (environment_1.ENV.get('WEBGL_VERSION') < 1) {
            throw new Error('WebGL is not supported on this device');
        }
        if (environment_1.ENV.get('IS_BROWSER')) {
            this.canvas = document.createElement('canvas');
        }
        if (gpgpu == null) {
            this.gpgpu = new gpgpu_context_1.GPGPUContext(gpgpu_util.createWebGLContext(this.canvas));
            this.gpgpuCreatedLocally = true;
        }
        else {
            this.gpgpuCreatedLocally = false;
        }
        if (environment_1.ENV.get('WEBGL_PAGING_ENABLED')) {
            this.NUM_BYTES_BEFORE_PAGING =
                (window.screen.height * window.screen.width *
                    window.devicePixelRatio) *
                    BEFORE_PAGING_CONSTANT;
        }
        this.textureManager = new texture_manager_1.TextureManager(this.gpgpu);
    }
    MathBackendWebGL.prototype.register = function (dataId, shape, dtype) {
        if (this.texData.has(dataId)) {
            throw new Error('Data buffer is already registered');
        }
        this.texData.set(dataId, {
            shape: shape,
            dtype: dtype,
            values: null,
            texture: null,
            complexTensors: null,
            texShape: null,
            usage: tex_util_1.TextureUsage.RENDER
        });
    };
    MathBackendWebGL.prototype.setDataMover = function (dataMover) {
        this.texData = new backend_1.DataStorage(dataMover);
    };
    MathBackendWebGL.prototype.fromPixels = function (pixels, numChannels) {
        if (pixels == null) {
            throw new Error('pixels passed to tf.fromPixels() can not be null');
        }
        var texShape = [pixels.height, pixels.width];
        var outShape = [pixels.height, pixels.width, numChannels];
        if (!(pixels instanceof HTMLVideoElement) &&
            !(pixels instanceof HTMLImageElement) &&
            !(pixels instanceof HTMLCanvasElement) &&
            !(pixels instanceof ImageData)) {
            throw new Error('pixels passed to tf.fromPixels() must be either an ' +
                "HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or " +
                ("ImageData, but was " + pixels.constructor.name));
        }
        if (pixels instanceof HTMLVideoElement) {
            if (this.fromPixelsCanvas == null) {
                if (!environment_1.ENV.get('IS_BROWSER')) {
                    throw new Error('Can\'t read pixels from HTMLImageElement outside the browser.');
                }
                if (document.readyState !== 'complete') {
                    throw new Error('The DOM is not ready yet. Please call tf.fromPixels() ' +
                        'once the DOM is ready. One way to do that is to add an event ' +
                        'listener for `DOMContentLoaded` on the document object');
                }
                this.fromPixelsCanvas = document.createElement('canvas');
            }
            this.fromPixelsCanvas.width = pixels.width;
            this.fromPixelsCanvas.height = pixels.height;
            this.fromPixelsCanvas.getContext('2d').drawImage(pixels, 0, 0, pixels.width, pixels.height);
            pixels = this.fromPixelsCanvas;
        }
        var tempPixelHandle = this.makeTensorHandle(texShape, 'int32');
        this.texData.get(tempPixelHandle.dataId).usage = tex_util_1.TextureUsage.PIXELS;
        this.gpgpu.uploadPixelDataToTexture(this.getTexture(tempPixelHandle.dataId), pixels);
        var program = new from_pixels_gpu_1.FromPixelsProgram(outShape);
        var res = this.compileAndRun(program, [tempPixelHandle]);
        this.disposeData(tempPixelHandle.dataId);
        return res;
    };
    MathBackendWebGL.prototype.makeTensorHandle = function (shape, dtype) {
        var dataId = {};
        this.register(dataId, shape, dtype);
        return { dataId: dataId, shape: shape, dtype: dtype };
    };
    MathBackendWebGL.prototype.write = function (dataId, values) {
        if (values == null) {
            throw new Error('MathBackendWebGL.write(): values can not be null');
        }
        var texData = this.texData.get(dataId);
        var texture = texData.texture, texShape = texData.texShape, usage = texData.usage, dtype = texData.dtype;
        if (dtype === 'complex64') {
            throw new Error("Cannot write to a complex64 dtype. " +
                "Please use tf.complex(real, imag).");
        }
        if (texture != null) {
            this.releaseTexture(dataId, texture, texShape, usage);
            texData.texture = null;
            texData.texShape = null;
        }
        texData.usage = tex_util_1.TextureUsage.UPLOAD;
        texData.values = values;
        if (!this.delayedStorage) {
            this.uploadToGPU(dataId);
        }
    };
    MathBackendWebGL.prototype.readSync = function (dataId) {
        var texData = this.texData.get(dataId);
        var values = texData.values, dtype = texData.dtype, complexTensors = texData.complexTensors;
        if (values != null) {
            this.cacheOnCPU(dataId);
            return values;
        }
        var shouldTimeProgram = this.activeTimers != null;
        var start;
        if (shouldTimeProgram) {
            start = performance.now();
        }
        var result;
        if (dtype === 'complex64') {
            var realValues = complexTensors.real.dataSync();
            var imagValues = complexTensors.imag.dataSync();
            result = complex_util_1.mergeRealAndImagArrays(realValues, imagValues);
        }
        else {
            result = this.getValuesFromTexture(dataId);
        }
        if (shouldTimeProgram) {
            this.downloadWaitMs += performance.now() - start;
        }
        this.cacheOnCPU(dataId, result);
        return texData.values;
    };
    MathBackendWebGL.prototype.read = function (dataId) {
        return __awaiter(this, void 0, void 0, function () {
            var subscribers_1, texData, texture, values, texShape, bufferOrTexture, vals, subscribers;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.pendingRead.has(dataId)) {
                            subscribers_1 = this.pendingRead.get(dataId);
                            return [2, new Promise(function (resolve) { return subscribers_1.push(resolve); })];
                        }
                        texData = this.texData.get(dataId);
                        texture = texData.texture, values = texData.values, texShape = texData.texShape;
                        if (values != null) {
                            this.cacheOnCPU(dataId);
                            return [2, values];
                        }
                        this.pendingRead.set(dataId, []);
                        if (!environment_1.ENV.get('WEBGL_DOWNLOAD_FLOAT_ENABLED') &&
                            environment_1.ENV.get('WEBGL_VERSION') === 2) {
                            throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and " +
                                "WEBGL_VERSION=2 not yet supported.");
                        }
                        bufferOrTexture = this.gpgpu.maybeCreateBufferFromTexture(texture, texShape[0], texShape[1]);
                        return [4, this.gpgpu.createAndWaitForFence()];
                    case 1:
                        _a.sent();
                        if (bufferOrTexture instanceof WebGLTexture) {
                            vals = this.getValuesFromTexture(dataId);
                        }
                        else {
                            vals = this.gpgpu.downloadFloat32MatrixFromBuffer(bufferOrTexture, texShape[0], texShape[1]);
                        }
                        this.cacheOnCPU(dataId, vals);
                        subscribers = this.pendingRead.get(dataId);
                        this.pendingRead.delete(dataId);
                        subscribers.forEach(function (resolve) { return resolve(vals); });
                        if (this.pendingDisposal.has(dataId)) {
                            this.pendingDisposal.delete(dataId);
                            this.disposeData(dataId);
                        }
                        return [2, vals];
                }
            });
        });
    };
    MathBackendWebGL.prototype.getValuesFromTexture = function (dataId) {
        var _a = this.texData.get(dataId), shape = _a.shape, dtype = _a.dtype, texture = _a.texture, texShape = _a.texShape;
        if (environment_1.ENV.get('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {
            if (this.texData.get(dataId).usage === tex_util_1.TextureUsage.PACK) {
                return this.gpgpu.downloadMatrixFromPackedTexture(texture, shape, texShape[0], texShape[1]);
            }
            else {
                return this.gpgpu.downloadFloat32MatrixFromOutputTexture(texture, texShape[0], texShape[1]);
            }
        }
        var tmpTarget = this.makeTensorHandle(shape, 'float32');
        tmpTarget.size = util_1.sizeFromShape(shape);
        this.texData.get(tmpTarget.dataId).usage = tex_util_1.TextureUsage.DOWNLOAD;
        var program = new encode_float_gpu_1.EncodeFloatProgram(shape);
        var pageToCpu = false;
        this.compileAndRun(program, [{ shape: shape, dtype: dtype, dataId: dataId }], tmpTarget, null, pageToCpu);
        var tmpData = this.texData.get(tmpTarget.dataId);
        var vals = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture, tmpData.texShape[0], tmpData.texShape[1]);
        this.disposeData(tmpTarget.dataId);
        return vals;
    };
    MathBackendWebGL.prototype.time = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            var oldActiveTimers, newActiveTimers, outerMostTime, flattenedActiveTimers, kernelMs, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        oldActiveTimers = this.activeTimers;
                        newActiveTimers = [];
                        outerMostTime = false;
                        if (this.programTimersStack == null) {
                            this.programTimersStack = newActiveTimers;
                            outerMostTime = true;
                        }
                        else {
                            this.activeTimers.push(newActiveTimers);
                        }
                        this.activeTimers = newActiveTimers;
                        f();
                        flattenedActiveTimers = util.flatten(this.activeTimers);
                        this.activeTimers = oldActiveTimers;
                        if (outerMostTime) {
                            this.programTimersStack = null;
                        }
                        return [4, Promise.all(flattenedActiveTimers).then(function (results) {
                                var sum = 0;
                                results.forEach(function (result) { return sum += result; });
                                return sum;
                            })];
                    case 1:
                        kernelMs = _a.sent();
                        res = {
                            uploadWaitMs: this.uploadWaitMs,
                            downloadWaitMs: this.downloadWaitMs,
                            kernelMs: kernelMs,
                            wallMs: null
                        };
                        this.uploadWaitMs = 0;
                        this.downloadWaitMs = 0;
                        return [2, res];
                }
            });
        });
    };
    MathBackendWebGL.prototype.memory = function () {
        return { unreliable: false, numBytesInGPU: this.numBytesInGPU };
    };
    MathBackendWebGL.prototype.startTimer = function () {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
            return this.gpgpu.beginQuery();
        }
        return { startMs: performance.now(), endMs: null };
    };
    MathBackendWebGL.prototype.endTimer = function (query) {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
            this.gpgpu.endQuery();
            return query;
        }
        query.endMs = performance.now();
        return query;
    };
    MathBackendWebGL.prototype.getQueryTime = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var timerQuery;
            return __generator(this, function (_a) {
                if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
                    return [2, this.gpgpu.waitForQueryAndGetTime(query)];
                }
                timerQuery = query;
                return [2, timerQuery.endMs - timerQuery.startMs];
            });
        });
    };
    MathBackendWebGL.prototype.disposeData = function (dataId) {
        if (this.pendingDisposal.has(dataId)) {
            return;
        }
        if (this.pendingRead.has(dataId)) {
            this.pendingDisposal.add(dataId);
            return;
        }
        if (this.texData.has(dataId)) {
            var _a = this.texData.get(dataId), texture = _a.texture, texShape = _a.texShape, usage = _a.usage, complexTensors = _a.complexTensors;
            if (texture != null) {
                this.releaseTexture(dataId, texture, texShape, usage);
            }
            if (complexTensors != null) {
                complexTensors.real.dispose();
                complexTensors.imag.dispose();
            }
            this.texData.delete(dataId);
        }
    };
    MathBackendWebGL.prototype.getTexture = function (dataId) {
        this.uploadToGPU(dataId);
        return this.texData.get(dataId).texture;
    };
    MathBackendWebGL.prototype.getGPGPUContext = function () {
        return this.gpgpu;
    };
    MathBackendWebGL.prototype.getCanvas = function () {
        return this.canvas;
    };
    MathBackendWebGL.prototype.complex = function (real, imag) {
        var result = this.makeOutputArray(real.shape, 'complex64');
        var resultData = this.texData.get(result.dataId);
        resultData.complexTensors = {
            real: environment_1.ENV.engine.keep(real.clone()),
            imag: environment_1.ENV.engine.keep(imag.clone())
        };
        return result;
    };
    MathBackendWebGL.prototype.real = function (input) {
        var resultData = this.texData.get(input.dataId);
        return resultData.complexTensors.real.clone();
    };
    MathBackendWebGL.prototype.imag = function (input) {
        var resultData = this.texData.get(input.dataId);
        return resultData.complexTensors.imag.clone();
    };
    MathBackendWebGL.prototype.slice = function (x, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [x], null, customSetup);
    };
    MathBackendWebGL.prototype.stridedSlice = function (x, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
        var _a = slice_util_1.getStridedSlicedInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask), beginIndex = _a[0], size = _a[1], shrinkAxis = _a[2];
        var shape = size.filter(function (v, index) { return shrinkAxis.indexOf(index) === -1; });
        if (shape.some(function (axis) { return axis === 0; })) {
            return tensor_ops_1.tensor([], shape);
        }
        var program = new strided_slice_gpu_1.StridedSliceProgram(beginIndex, strides, size, shrinkAxis);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.reverse = function (x, axis) {
        var program = new reverse_gpu_1.ReverseProgram(x.shape, axis);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.concat2Tensors = function (a, b, axis) {
        var outShape = concat_util_1.computeOutShape([a.shape, b.shape], axis);
        var a2D = a.as2D(-1, util_1.sizeFromShape(a.shape.slice(axis)));
        var b2D = b.as2D(-1, util_1.sizeFromShape(b.shape.slice(axis)));
        var program = new concat_gpu_1.ConcatProgram(a2D.shape, b2D.shape);
        var res = this.compileAndRun(program, [a2D, b2D]);
        return res.reshape(outShape);
    };
    MathBackendWebGL.prototype.concat = function (tensors, axis) {
        if (tensors.length === 1) {
            return tensors[0];
        }
        var result = tensors[0];
        for (var i = 1; i < tensors.length; ++i) {
            result = this.concat2Tensors(result, tensors[i], axis);
        }
        return result;
    };
    MathBackendWebGL.prototype.neg = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.NEG);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.batchMatMul = function (a, b, transposeA, transposeB) {
        var outerShapeA = transposeA ? a.shape[2] : a.shape[1];
        var outerShapeB = transposeB ? b.shape[1] : b.shape[2];
        if (a.shape[0] === 1 && b.shape[0] === 1) {
            var aSqueezed = a.as2D(a.shape[1], a.shape[2]);
            var bSqueezed = b.as2D(b.shape[1], b.shape[2]);
            var packProgramA = new pack_gpu_1.PackProgram(aSqueezed.shape);
            var packedA = this.compileAndRun(packProgramA, [aSqueezed], this.makePackedTensor(aSqueezed.shape));
            var packProgramB = new pack_gpu_1.PackProgram(bSqueezed.shape);
            var packedB = this.compileAndRun(packProgramB, [bSqueezed], this.makePackedTensor(bSqueezed.shape));
            var program = new mulmat_packed_gpu_1.MatMulPackedProgram(packedA.shape, packedB.shape, [outerShapeA, outerShapeB], transposeA, transposeB);
            var result = this.compileAndRun(program, [packedA, packedB], this.makePackedTensor(program.outputShape));
            var unpackProgram = new unpack_gpu_1.UnpackProgram(result.shape);
            var unpacked = this.compileAndRun(unpackProgram, [result]);
            packedA.dispose();
            packedB.dispose();
            result.dispose();
            return unpacked.reshape([1, result.shape[0], result.shape[1]]);
        }
        else {
            return this.compileAndRun(new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, transposeA, transposeB), [a, b]);
        }
    };
    MathBackendWebGL.prototype.multiply = function (a, b) {
        if (a.dtype === 'complex64') {
            var aData = this.texData.get(a.dataId);
            var bData = this.texData.get(b.dataId);
            var realProgram = new binaryop_complex_gpu_1.BinaryOpComplexProgram(binaryop_complex_gpu.COMPLEX_MULTIPLY.REAL, a.shape, b.shape);
            var imagProgram = new binaryop_complex_gpu_1.BinaryOpComplexProgram(binaryop_complex_gpu.COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);
            var inputs = [
                this.makeComplexComponentTensorHandle(a, aData.complexTensors.real),
                this.makeComplexComponentTensorHandle(a, aData.complexTensors.imag),
                this.makeComplexComponentTensorHandle(b, bData.complexTensors.real),
                this.makeComplexComponentTensorHandle(b, bData.complexTensors.imag)
            ];
            var real = this.compileAndRun(realProgram, inputs);
            var imag = this.compileAndRun(imagProgram, inputs);
            var complex = this.complex(real, imag);
            real.dispose();
            imag.dispose();
            return complex;
        }
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, a.dtype);
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    MathBackendWebGL.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {
        var program = new lrn_gpu_1.LRNProgram(x.shape, radius, bias, alpha, beta);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.LRNGrad = function (dy, inputImage, outputImage, depthRadius, bias, alpha, beta) {
        var program = new lrn_grad_gpu_1.LRNGradProgram(inputImage.shape, depthRadius, bias, alpha, beta);
        return this.compileAndRun(program, [inputImage, outputImage, dy]);
    };
    MathBackendWebGL.prototype.tile = function (x, reps) {
        var program = new tile_gpu_1.TileProgram(x.shape, reps);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.pad = function (x, paddings, constantValue) {
        var program = new pad_gpu_1.PadProgram(x.shape, paddings, constantValue);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.transpose = function (x, perm) {
        var program = new transpose_gpu_1.TransposeProgram(x.shape, perm);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.gather = function (x, indices, axis) {
        var program = new gather_gpu_1.GatherProgram(x.shape, indices.size, axis);
        return this.compileAndRun(program, [x, indices]);
    };
    MathBackendWebGL.prototype.batchToSpaceND = function (x, blockShape, crops) {
        util.assert(x.rank <= 4, 'batchToSpaceND for rank > 4 with a WebGL backend not implemented yet');
        var prod = blockShape.reduce(function (a, b) { return a * b; });
        var reshaped = array_ops_util.getReshaped(x.shape, blockShape, prod);
        var permuted = array_ops_util.getPermuted(reshaped.length, blockShape.length);
        var reshapedPermuted = array_ops_util.getReshapedPermuted(x.shape, blockShape, prod);
        var sliceBeginCoords = array_ops_util.getSliceBeginCoords(crops, blockShape.length);
        var sliceSize = array_ops_util.getSliceSize(reshapedPermuted, crops, blockShape.length);
        return x.reshape(reshaped)
            .transpose(permuted)
            .reshape(reshapedPermuted)
            .slice(sliceBeginCoords, sliceSize);
    };
    MathBackendWebGL.prototype.spaceToBatchND = function (x, blockShape, paddings) {
        util.assert(x.rank <= 4, 'spaceToBatchND for rank > 4 with a WebGL backend not implemented yet');
        var prod = blockShape.reduce(function (a, b) { return a * b; });
        var completePaddings = [[0, 0]];
        completePaddings.push.apply(completePaddings, paddings);
        for (var i = 1 + blockShape.length; i < x.shape.length; ++i) {
            completePaddings.push([0, 0]);
        }
        var paddedX = x.pad(completePaddings);
        var reshapedPaddedShape = array_ops_util.getReshaped(paddedX.shape, blockShape, prod, false);
        var permutedReshapedPaddedPermutation = array_ops_util.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
        var flattenShape = array_ops_util.getReshapedPermuted(paddedX.shape, blockShape, prod, false);
        return paddedX.reshape(reshapedPaddedShape)
            .transpose(permutedReshapedPaddedPermutation)
            .reshape(flattenShape);
    };
    MathBackendWebGL.prototype.reduce = function (x, reduceType, dtype) {
        var batchSize = x.shape[0];
        var inSize = x.shape[1];
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new reduce_gpu_1.ReduceProgram(reduceInfo, reduceType);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray([rows, cols], dtype);
        this.compileAndRun(program, [x], output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.reduce(output, reduceType, dtype);
    };
    MathBackendWebGL.prototype.argReduce = function (x, reduceType, bestIndicesA) {
        if (bestIndicesA === void 0) { bestIndicesA = null; }
        var batchSize = x.shape[0];
        var inSize = x.shape[1];
        if (bestIndicesA != null) {
            batchSize = bestIndicesA.shape[0];
            inSize = bestIndicesA.shape[1];
        }
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray([rows, cols], 'int32');
        var inputs = [x];
        if (bestIndicesA != null) {
            inputs.push(bestIndicesA);
        }
        this.compileAndRun(program, inputs, output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.argReduce(x, reduceType, output);
    };
    MathBackendWebGL.prototype.sum = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        var outputDType = types_1.sumOutType(x.dtype);
        return this.reduce(a2D, 'sum', outputDType).reshape(outShape);
    };
    MathBackendWebGL.prototype.prod = function (x, axes) {
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        var outputDType = types_1.sumOutType(x.dtype);
        return this.reduce(a2D, 'prod', outputDType).reshape(outShape);
    };
    MathBackendWebGL.prototype.unsortedSegmentSum = function (x, segmentIds, numSegments) {
        var axis = 0;
        var permutation = axis_util.getAxesPermutation([axis], x.rank);
        var permutedX = x;
        if (permutation != null) {
            permutedX = x.transpose(permutation);
            axis = axis_util.getInnerMostAxes(1, x.rank)[0];
        }
        var outShape = segment_util.computeOutShape(permutedX.shape, axis, numSegments);
        var inSize = util.sizeFromShape([permutedX.shape[axis]]);
        var a2D = permutedX.as2D(-1, inSize);
        var outputDType = types_1.sumOutType(x.dtype);
        var result = this.segOpCompute(a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments)
            .reshape(outShape);
        if (permutation != null) {
            result = result.transpose(axis_util.getUndoAxesPermutation(permutation));
        }
        return result;
    };
    MathBackendWebGL.prototype.segOpCompute = function (x, segOpType, segmentIds, dtype, numSegments) {
        var batchSize = x.shape[0];
        var inSize = x.shape[1];
        var windowSize = segment_util.segOpComputeOptimalWindowSize(inSize, numSegments);
        var segOpInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize, numSegments: numSegments };
        var program = new segment_gpu_1.SegmentOpProgram(segOpInfo, segOpType);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray([rows, cols], dtype);
        this.compileAndRun(program, [x, segmentIds], output);
        if (output.shape[1] === numSegments) {
            return output;
        }
        segmentIds = tensor_ops_1.range(0, numSegments).tile([inSize / windowSize]);
        return this.segOpCompute(output, segOpType, segmentIds, dtype, numSegments);
    };
    MathBackendWebGL.prototype.argMin = function (x, axis) {
        var axes = [axis];
        axis_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.argReduce(a2D, 'min').reshape(outShape);
    };
    MathBackendWebGL.prototype.argMax = function (x, axis) {
        var axes = [axis];
        axis_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.argReduce(a2D, 'max').reshape(outShape);
    };
    MathBackendWebGL.prototype.cumsum = function (x, axis, exclusive, reverse) {
        if (axis !== x.rank - 1) {
            throw new Error("WebGL cumsum shader expects an inner-most axis=" + (x.rank - 1) + " " +
                ("but got axis=" + axis));
        }
        var program = new cumsum_gpu_1.CumSumProgram(x.shape, exclusive, reverse);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.equal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.notEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.NOT_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.less = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.lessEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.greater = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.greaterEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.logicalNot = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOGICAL_NOT);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.logicalAnd = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_AND, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.logicalOr = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_OR, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.select = function (condition, a, b) {
        var program = new select_gpu_1.SelectProgram(condition.rank, a.shape, a.rank);
        var output = this.makeOutputArray(program.outputShape, types_1.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [condition, a, b], output);
    };
    MathBackendWebGL.prototype.where = function (condition) {
        log_1.warn('tf.where() in webgl locks the UI thread. ' +
            'Call tf.whereAsync() instead');
        var condVals = condition.dataSync();
        return where_impl_1.whereImpl(condition.shape, condVals);
    };
    MathBackendWebGL.prototype.topk = function (x, k, sorted) {
        var xVals = x.dataSync();
        return topk_impl_1.topkImpl(xVals, x.shape, x.dtype, k, sorted);
    };
    MathBackendWebGL.prototype.min = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.minimum = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MIN, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.mod = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MOD, a.shape, b.shape);
        var customSetup = program.getCustomSetupFunc();
        return this.compileAndRun(program, [a, b], null, customSetup);
    };
    MathBackendWebGL.prototype.max = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, 'max', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.maximum = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MAX, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.all = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('all', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, 'all', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.any = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('any', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, 'any', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.squaredDifference = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SQUARED_DIFFERENCE, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.realDivide = function (a, b) {
        var op = binaryop_gpu.DIV;
        var outputDtype = 'float32';
        var program = new binaryop_gpu_1.BinaryOpProgram(op, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, outputDtype);
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.floorDiv = function (a, b) {
        var op = binaryop_gpu.INT_DIV;
        var outputDtype = 'int32';
        var program = new binaryop_gpu_1.BinaryOpProgram(op, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, outputDtype);
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.add = function (a, b) {
        if (a.dtype === 'complex64' && b.dtype === 'complex64') {
            return this.complexSeparableBinaryOp(a, b, binaryop_gpu.ADD);
        }
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types_1.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.complexSeparableBinaryOp = function (a, b, op) {
        var _this = this;
        var aData = this.texData.get(a.dataId);
        var bData = this.texData.get(b.dataId);
        var _a = [
            [aData.complexTensors.real, bData.complexTensors.real],
            [aData.complexTensors.imag, bData.complexTensors.imag]
        ].map(function (complexParts) {
            var aPart = complexParts[0], bPart = complexParts[1];
            var program = new binaryop_gpu_1.BinaryOpProgram(op, a.shape, b.shape);
            var output = _this.makeOutputArray(program.outputShape, types_1.upcastType(aPart.dtype, bPart.dtype));
            var aHandle = _this.makeComplexComponentTensorHandle(a, aPart);
            var bHandle = _this.makeComplexComponentTensorHandle(b, bPart);
            return _this.compileAndRun(program, [aHandle, bHandle], output);
        }), real = _a[0], imag = _a[1];
        var complex = this.complex(real, imag);
        real.dispose();
        imag.dispose();
        return complex;
    };
    MathBackendWebGL.prototype.makeComplexComponentTensorHandle = function (complexTensor, complexPart) {
        return {
            dataId: complexPart.dataId,
            dtype: complexPart.dtype,
            shape: complexTensor.shape
        };
    };
    MathBackendWebGL.prototype.addN = function (tensors) {
        var res = tensors[0];
        for (var i = 1; i < tensors.length; i++) {
            res = this.add(res, tensors[i]);
        }
        return res;
    };
    MathBackendWebGL.prototype.subtract = function (a, b) {
        if (a.dtype === 'complex64' && b.dtype === 'complex64') {
            return this.complexSeparableBinaryOp(a, b, binaryop_gpu.SUB);
        }
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types_1.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.pow = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.POW, a.shape, b.shape);
        var customSetup = program.getCustomSetupFunc();
        var output = this.makeOutputArray(program.outputShape, types_1.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output, customSetup);
    };
    MathBackendWebGL.prototype.ceil = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.CEIL);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.floor = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.FLOOR);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sign = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIGN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.round = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ROUND);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.exp = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.EXP);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.expm1 = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.EXPM1);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.log = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOG);
        var customSetup = program.getCustomSetupFunc();
        return this.compileAndRun(program, [x], null, customSetup);
    };
    MathBackendWebGL.prototype.log1p = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOG1P);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sqrt = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQRT);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.rsqrt = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RSQRT);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.square = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQUARE);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.reciprocal = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RECIPROCAL);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.relu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.elu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.eluDer = function (dy, y) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ELU_DER, dy.shape, y.shape);
        return this.compileAndRun(program, [dy, y]);
    };
    MathBackendWebGL.prototype.selu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.int = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TO_INT);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.clip = function (x, min, max) {
        var program = new clip_gpu_1.ClipProgram(x.shape, min, max);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.abs = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ABS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sigmoid = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIGMOID);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.softplus = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SOFTPLUS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sin = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.cos = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tan = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TAN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.asin = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ASIN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.acos = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ACOS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.atan = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ATAN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.atan2 = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ATAN2, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.sinh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SINH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.cosh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COSH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tanh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TANH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.asinh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ASINH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.acosh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ACOSH);
        var customSetup = program.getCustomSetupFunc();
        return this.compileAndRun(program, [x], null, customSetup);
    };
    MathBackendWebGL.prototype.atanh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ATANH);
        var customSetup = program.getCustomSetupFunc();
        return this.compileAndRun(program, [x], null, customSetup);
    };
    MathBackendWebGL.prototype.erf = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ERF);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.step = function (x, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.STEP(alpha));
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.conv2dWithIm2Row = function (x, filter, convInfo) {
        var filterWidth = convInfo.filterWidth, filterHeight = convInfo.filterHeight, inChannels = convInfo.inChannels, outWidth = convInfo.outWidth, outHeight = convInfo.outHeight;
        var sharedDim = filterWidth * filterHeight * inChannels;
        var numCols = outHeight * outWidth;
        var x2ColShape = [sharedDim, numCols];
        var xSqueezed = x.squeeze([0]);
        var w2Row = filter.reshape([sharedDim, -1]);
        var im2ColProgram = new im2col_gpu_1.Im2ColProgram(x2ColShape, xSqueezed.shape, convInfo);
        var im2Col = this.compileAndRun(im2ColProgram, [xSqueezed], this.makePackedTensor(x2ColShape));
        var packedW2RowProgram = new pack_gpu_1.PackProgram(w2Row.shape);
        var packedW2Row = this.compileAndRun(packedW2RowProgram, [w2Row], this.makePackedTensor(w2Row.shape));
        var matmulProgram = new mulmat_packed_gpu_1.MatMulPackedProgram(im2Col.shape, packedW2Row.shape, [numCols, convInfo.outChannels], true, false);
        var product = this.compileAndRun(matmulProgram, [im2Col, packedW2Row], this.makePackedTensor(matmulProgram.outputShape));
        var unpackProgram = new unpack_gpu_1.UnpackProgram(product.shape);
        var unpacked = this.compileAndRun(unpackProgram, [product]);
        im2Col.dispose();
        packedW2Row.dispose();
        product.dispose();
        return unpacked.reshape([1, outHeight, outWidth, convInfo.outChannels]);
    };
    MathBackendWebGL.prototype.conv2d = function (x, filter, convInfo) {
        if (environment_1.ENV.get('WEBGL_CONV_IM2COL') && x.shape[0] === 1) {
            return this.conv2dWithIm2Row(x, filter, convInfo);
        }
        var program = new conv_gpu_1.Conv2DProgram(convInfo);
        return this.compileAndRun(program, [x, filter]);
    };
    MathBackendWebGL.prototype.conv2dDerInput = function (dy, filter, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
    };
    MathBackendWebGL.prototype.conv2dDerFilter = function (x, dy, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerFilterProgram(convInfo);
        return this.compileAndRun(program, [x, dy]);
    };
    MathBackendWebGL.prototype.depthwiseConv2D = function (x, filter, convInfo) {
        var program = new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);
        return this.compileAndRun(program, [x, filter]);
    };
    MathBackendWebGL.prototype.depthwiseConv2DDerInput = function (dy, filter, convInfo) {
        var program = new conv_backprop_gpu_depthwise_1.DepthwiseConv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
    };
    MathBackendWebGL.prototype.depthwiseConv2DDerFilter = function (x, dy, convInfo) {
        var program = new conv_backprop_gpu_depthwise_1.DepthwiseConv2DDerFilterProgram(convInfo);
        return this.compileAndRun(program, [x, dy]);
    };
    MathBackendWebGL.prototype.maxPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'max', false);
        var output = this.makeOutputArray(program.outputShape, x.dtype);
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.avgPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'avg', false);
        var output = this.makeOutputArray(program.outputShape, 'float32');
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {
        var getPositions = true;
        var maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, 'max', getPositions);
        var maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);
        var maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);
        var output = this.makeOutputArray(maxPoolBackPropProgram.outputShape, x.dtype);
        var result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions], output);
        maxPoolPositions.dispose();
        return result;
    };
    MathBackendWebGL.prototype.avgPoolBackprop = function (dy, x, convInfo) {
        var avgPoolBackpropProgram = new avg_pool_backprop_gpu_1.AvgPool2DBackpropProgram(convInfo);
        var output = this.makeOutputArray(avgPoolBackpropProgram.outputShape, x.dtype);
        return this.compileAndRun(avgPoolBackpropProgram, [dy], output);
    };
    MathBackendWebGL.prototype.cast = function (x, dtype) {
        return backend_util.castTensor(x, dtype, this);
    };
    MathBackendWebGL.prototype.reshape = function (x, shape) {
        return backend_util.reshapeTensor(x, shape);
    };
    MathBackendWebGL.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
        var program = new resize_bilinear_gpu_1.ResizeBilinearProgram(x.shape, newHeight, newWidth, alignCorners);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {
        var program = new resize_bilinear_backprop_gpu_1.ResizeBilinearBackpropProgram(dy, x, alignCorners);
        return this.compileAndRun(program, [dy]);
    };
    MathBackendWebGL.prototype.resizeNearestNeighbor = function (x, newHeight, newWidth, alignCorners) {
        var program = new resize_nearest_neighbor_gpu_1.ResizeNearestNeighborProgram(x.shape, newHeight, newWidth, alignCorners);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.resizeNearestNeighborBackprop = function (dy, x, alignCorners) {
        var program = new resize_nearest_neighbor_backprop_gpu_1.ResizeNearestNeigborBackpropProgram(dy, x, alignCorners);
        return this.compileAndRun(program, [dy]);
    };
    MathBackendWebGL.prototype.multinomial = function (logits, normalized, numSamples, seed) {
        var probs = normalized ? logits : softmax_1.softmax(logits);
        var batchSize = probs.shape[0];
        var numOutcomes = probs.shape[1];
        var program = new multinomial_gpu_1.MultinomialProgram(batchSize, numOutcomes, numSamples);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        var customSetup = program.getCustomSetupFunc(seed);
        return this.compileAndRun(program, [probs], output, customSetup);
    };
    MathBackendWebGL.prototype.oneHot = function (indices, depth, onValue, offValue) {
        var program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);
        return this.compileAndRun(program, [indices]);
    };
    MathBackendWebGL.prototype.nonMaxSuppression = function (boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
        log_1.warn('tf.nonMaxSuppression() in webgl locks the UI thread. ' +
            'Call tf.nonMaxSuppressionAsync() instead');
        var boxesVals = boxes.dataSync();
        var scoresVals = scores.dataSync();
        return non_max_suppression_impl_1.nonMaxSuppressionImpl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
    };
    MathBackendWebGL.prototype.cropAndResize = function (image, boxes, boxIndex, cropSize, method, extrapolationValue) {
        var program = new crop_and_resize_gpu_1.CropAndResizeProgram(image.shape, boxes.shape, cropSize, method, extrapolationValue);
        return this.compileAndRun(program, [image, boxes, boxIndex]);
    };
    MathBackendWebGL.prototype.depthToSpace = function (x, blockSize, dataFormat) {
        util.assert(blockSize > 1, "blockSize should be > 1 for depthToSpace, but was: " + blockSize);
        var batchSize = x.shape[0];
        var inputHeight = (dataFormat === 'NHWC') ? x.shape[1] : x.shape[2];
        var inputWidth = (dataFormat === 'NHWC') ? x.shape[2] : x.shape[3];
        var inputDepth = (dataFormat === 'NHWC') ? x.shape[3] : x.shape[1];
        var outputHeight = inputHeight * blockSize;
        var outputWidth = inputWidth * blockSize;
        var outputDepth = inputDepth / (blockSize * blockSize);
        var outputShape = (dataFormat === 'NHWC') ?
            [batchSize, outputHeight, outputWidth, outputDepth] :
            [batchSize, outputDepth, outputHeight, outputWidth];
        var program = new depth_to_space_gpu_1.DepthToSpaceProgram(outputShape, blockSize, dataFormat);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.split = function (x, sizeSplits, axis) {
        return split_shared_1.split(x, sizeSplits, axis);
    };
    MathBackendWebGL.prototype.scatterND = function (indices, updates, shape) {
        var _a = scatter_nd_util.prepareAndValidate(updates, indices, shape), sliceDim = _a[0], numUpdates = _a[1], sliceSize = _a[2], strides = _a[3], outputSize = _a[4];
        var flattenShape = [outputSize / sliceSize, sliceSize];
        var flattenIndices = indices.reshape([numUpdates, sliceDim]);
        var flattenX = updates.reshape([numUpdates, sliceSize]);
        if (outputSize === 0) {
            return backend_util.reshapeTensor(tensor_ops_1.tensor([]), shape);
        }
        var program = new scatter_nd_gpu_1.ScatterNDProgram(numUpdates, sliceDim, strides, flattenShape);
        return this.compileAndRun(program, [flattenX, flattenIndices])
            .reshape(shape);
    };
    MathBackendWebGL.prototype.fft = function (x) {
        var xData = this.texData.get(x.dataId);
        var realProgram = new fft_gpu_1.FFTProgram(fft_gpu.COMPLEX_FFT.REAL, x.shape);
        var imagProgram = new fft_gpu_1.FFTProgram(fft_gpu.COMPLEX_FFT.IMAG, x.shape);
        var inputs = [
            this.makeComplexComponentTensorHandle(x, xData.complexTensors.real),
            this.makeComplexComponentTensorHandle(x, xData.complexTensors.imag),
        ];
        var real = this.compileAndRun(realProgram, inputs);
        var imag = this.compileAndRun(imagProgram, inputs);
        var complex = this.complex(real, imag).as1D();
        real.dispose();
        imag.dispose();
        return complex;
    };
    MathBackendWebGL.prototype.gatherND = function (x, indices) {
        var indicesShape = indices.shape;
        var sliceRank = indicesShape[indicesShape.length - 1];
        var _a = gather_nd_util.prepareAndValidate(x, indices), resultShape = _a[0], numSlices = _a[1], sliceSize = _a[2], strides = _a[3];
        var flattenIndices = indices.reshape([numSlices, sliceRank]);
        var flattenX = x.reshape([x.size / sliceSize, sliceSize]);
        var program = new gather_nd_gpu_1.GatherNDProgram(sliceRank, strides, [numSlices, sliceSize]);
        return this.compileAndRun(program, [flattenX, flattenIndices])
            .reshape(resultShape);
    };
    MathBackendWebGL.prototype.makeOutputArray = function (shape, dtype) {
        return tensor_1.Tensor.make(shape, {}, dtype);
    };
    MathBackendWebGL.prototype.makePackedTensor = function (shape) {
        var packedTensor = tensor_1.Tensor.make(shape, {});
        this.texData.get(packedTensor.dataId).usage = tex_util_1.TextureUsage.PACK;
        return packedTensor;
    };
    MathBackendWebGL.prototype.compileAndRun = function (program, inputs, output, customSetup, pageToCpu) {
        var _this = this;
        if (pageToCpu === void 0) { pageToCpu = true; }
        if (output == null) {
            output =
                this.makeOutputArray(program.outputShape, inputs[0].dtype);
        }
        if (output.size === 0) {
            this.texData.get(output.dataId).values =
                util_1.getTypedArrayFromDType(output.dtype, 0);
            return output;
        }
        var inputsData = inputs.map(function (input) {
            if (input.dtype === 'complex64') {
                throw new Error("GPGPUProgram does not support complex64 input. For complex64 " +
                    "dtypes, please separate the program into real and imaginary " +
                    "parts.");
            }
            var texData = _this.texData.get(input.dataId);
            if (texData.texture == null &&
                util.sizeFromShape(input.shape) <=
                    environment_1.ENV.get('WEBGL_SIZE_UPLOAD_UNIFORM')) {
                return {
                    shape: input.shape,
                    texData: null,
                    isUniform: true,
                    uniformValues: _this.readSync(input.dataId)
                };
            }
            _this.uploadToGPU(input.dataId);
            return { shape: input.shape, texData: texData, isUniform: false };
        });
        this.uploadToGPU(output.dataId);
        var outputData = {
            shape: output.shape,
            texData: this.texData.get(output.dataId),
            isUniform: false
        };
        var key = gpgpu_math.makeShaderKey(program, inputsData, outputData);
        var binary = this.getAndSaveBinary(key, function () {
            return gpgpu_math.compileProgram(_this.gpgpu, program, inputsData, outputData);
        });
        var shouldTimeProgram = this.activeTimers != null;
        var query;
        if (shouldTimeProgram) {
            query = this.startTimer();
        }
        gpgpu_math.runProgram(binary, inputsData, outputData, customSetup);
        if (environment_1.ENV.get('WEBGL_PAGING_ENABLED') && pageToCpu &&
            this.numBytesInGPU > this.NUM_BYTES_BEFORE_PAGING) {
            var numBytesToPage = this.numBytesInGPU - this.NUM_BYTES_BEFORE_PAGING;
            while (numBytesToPage > 0 && this.lruDataGPU.length > 0) {
                var dataId = this.lruDataGPU.shift();
                var _a = this.texData.get(dataId), shape = _a.shape, dtype = _a.dtype;
                numBytesToPage -= this.computeBytes(shape, dtype);
                this.read(dataId);
            }
        }
        if (shouldTimeProgram) {
            query = this.endTimer(query);
            this.activeTimers.push(this.getQueryTime(query));
        }
        return output;
    };
    MathBackendWebGL.prototype.getAndSaveBinary = function (key, getBinary) {
        if (!(key in this.binaryCache)) {
            this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
    };
    MathBackendWebGL.prototype.getTextureManager = function () {
        return this.textureManager;
    };
    MathBackendWebGL.prototype.dispose = function () {
        if (this.disposed) {
            return;
        }
        for (var key in this.binaryCache) {
            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
        }
        this.textureManager.dispose();
        this.canvas.remove();
        if (this.fromPixelsCanvas != null) {
            this.fromPixelsCanvas.remove();
        }
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.dispose();
        }
        this.disposed = true;
    };
    MathBackendWebGL.prototype.floatPrecision = function () {
        var _this = this;
        return globals_1.tidy(function () {
            if (_this.abs(tensor_ops_1.scalar(1e-8)).get() > 0) {
                return 32;
            }
            return 16;
        });
    };
    MathBackendWebGL.prototype.uploadToGPU = function (dataId) {
        var texData = this.texData.get(dataId);
        var shape = texData.shape, values = texData.values, texture = texData.texture, dtype = texData.dtype, usage = texData.usage;
        if (texture != null) {
            if (environment_1.ENV.get('WEBGL_PAGING_ENABLED')) {
                var index = this.lruDataGPU.indexOf(dataId);
                if (index >= 0) {
                    this.lruDataGPU.splice(this.lruDataGPU.indexOf(dataId), 1);
                    this.lruDataGPU.push(dataId);
                }
            }
            return;
        }
        var shouldTimeProgram = this.activeTimers != null;
        var start;
        if (shouldTimeProgram) {
            start = performance.now();
        }
        var texShape = webgl_util.getTextureShapeFromLogicalShape(shape, usage);
        texData.texShape = texShape;
        var newTexture = this.acquireTexture(dataId, texShape, usage);
        texData.texture = newTexture;
        if (values != null) {
            this.gpgpu.uploadMatrixToTexture(newTexture, texShape[0], texShape[1], typedArrayToFloat32(values, dtype));
            texData.values = null;
            if (shouldTimeProgram) {
                this.uploadWaitMs += performance.now() - start;
            }
        }
    };
    MathBackendWebGL.prototype.cacheOnCPU = function (dataId, float32Values) {
        var dontKeepCopyOnGPU = this.delayedStorage;
        var texData = this.texData.get(dataId);
        var texture = texData.texture, texShape = texData.texShape, dtype = texData.dtype, usage = texData.usage;
        if (dontKeepCopyOnGPU && texture != null) {
            this.releaseTexture(dataId, texture, texShape, usage);
            texData.texture = null;
            texData.texShape = null;
        }
        texData.usage = tex_util_1.TextureUsage.UPLOAD;
        if (float32Values != null) {
            texData.values = float32ToTypedArray(float32Values, dtype);
        }
    };
    MathBackendWebGL.prototype.releaseTexture = function (dataId, texture, texShape, texType) {
        var _a = this.texData.get(dataId), shape = _a.shape, dtype = _a.dtype;
        if (environment_1.ENV.get('WEBGL_PAGING_ENABLED')) {
            var idx = this.lruDataGPU.indexOf(dataId);
            if (idx >= 0) {
                this.lruDataGPU.splice(idx, 1);
            }
        }
        this.numBytesInGPU -= this.computeBytes(shape, dtype);
        this.textureManager.releaseTexture(texture, texShape, texType);
    };
    MathBackendWebGL.prototype.acquireTexture = function (dataId, texShape, texType) {
        var _a = this.texData.get(dataId), shape = _a.shape, dtype = _a.dtype;
        if (environment_1.ENV.get('WEBGL_PAGING_ENABLED')) {
            this.lruDataGPU.push(dataId);
        }
        this.numBytesInGPU += this.computeBytes(shape, dtype);
        return this.textureManager.acquireTexture(texShape, texType);
    };
    MathBackendWebGL.prototype.computeBytes = function (shape, dtype) {
        return util.sizeFromShape(shape) * util.bytesPerElement(dtype);
    };
    return MathBackendWebGL;
}());
exports.MathBackendWebGL = MathBackendWebGL;
if (environment_1.ENV.get('IS_BROWSER')) {
    environment_1.ENV.registerBackend('webgl', function () { return new MathBackendWebGL(); }, 2, tensor_1.setTensorTracker);
}
function float32ToTypedArray(a, dtype) {
    if (dtype === 'float32' || dtype === 'complex64') {
        return a;
    }
    else if (dtype === 'int32' || dtype === 'bool') {
        var result = (dtype === 'int32') ? new Int32Array(a.length) :
            new Uint8Array(a.length);
        for (var i = 0; i < result.length; ++i) {
            result[i] = Math.round(a[i]);
        }
        return result;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
function typedArrayToFloat32(a, dtype) {
    return (a instanceof Float32Array) ? a : new Float32Array(a);
}

},{"../environment":60,"../globals":62,"../log":137,"../ops/array_ops_util":139,"../ops/axis_util":140,"../ops/concat_util":147,"../ops/gather_nd_util":152,"../ops/reduce_util":166,"../ops/scatter_nd_util":171,"../ops/segment_util":173,"../ops/slice_util":176,"../ops/softmax":177,"../ops/tensor_ops":180,"../tensor":196,"../types":202,"../util":203,"./backend":76,"./backend_util":78,"./complex_util":80,"./non_max_suppression_impl":81,"./split_shared":82,"./topk_impl":83,"./webgl/argminmax_gpu":84,"./webgl/avg_pool_backprop_gpu":85,"./webgl/batchnorm_gpu":86,"./webgl/binaryop_complex_gpu":87,"./webgl/binaryop_gpu":88,"./webgl/clip_gpu":89,"./webgl/concat_gpu":90,"./webgl/conv_backprop_gpu":91,"./webgl/conv_backprop_gpu_depthwise":92,"./webgl/conv_gpu":93,"./webgl/conv_gpu_depthwise":94,"./webgl/crop_and_resize_gpu":95,"./webgl/cumsum_gpu":96,"./webgl/depth_to_space_gpu":97,"./webgl/encode_float_gpu":98,"./webgl/fft_gpu":99,"./webgl/from_pixels_gpu":100,"./webgl/gather_gpu":101,"./webgl/gather_nd_gpu":102,"./webgl/gpgpu_context":103,"./webgl/gpgpu_math":104,"./webgl/gpgpu_util":105,"./webgl/im2col_gpu":106,"./webgl/lrn_gpu":107,"./webgl/lrn_grad_gpu":108,"./webgl/max_pool_backprop_gpu":109,"./webgl/mulmat_gpu":110,"./webgl/mulmat_packed_gpu":111,"./webgl/multinomial_gpu":112,"./webgl/onehot_gpu":113,"./webgl/pack_gpu":114,"./webgl/pad_gpu":115,"./webgl/pool_gpu":116,"./webgl/reduce_gpu":117,"./webgl/resize_bilinear_backprop_gpu":118,"./webgl/resize_bilinear_gpu":119,"./webgl/resize_nearest_neighbor_backprop_gpu":120,"./webgl/resize_nearest_neighbor_gpu":121,"./webgl/reverse_gpu":122,"./webgl/scatter_nd_gpu":123,"./webgl/segment_gpu":124,"./webgl/select_gpu":125,"./webgl/slice_gpu":127,"./webgl/strided_slice_gpu":128,"./webgl/tex_util":129,"./webgl/texture_manager":130,"./webgl/tile_gpu":131,"./webgl/transpose_gpu":132,"./webgl/unaryop_gpu":133,"./webgl/unpack_gpu":134,"./webgl/webgl_util":135,"./where_impl":136}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function mergeRealAndImagArrays(real, imag) {
    if (real.length !== imag.length) {
        throw new Error("Cannot merge real and imag arrays of different lengths. real:" +
            (real.length + ", imag: " + imag.length + "."));
    }
    var result = new Float32Array(real.length * 2);
    for (var i = 0; i < result.length; i += 2) {
        result[i] = real[i / 2];
        result[i + 1] = imag[i / 2];
    }
    return result;
}
exports.mergeRealAndImagArrays = mergeRealAndImagArrays;
function splitRealAndImagArrays(complex) {
    var real = new Float32Array(complex.length / 2);
    var imag = new Float32Array(complex.length / 2);
    for (var i = 0; i < complex.length; i += 2) {
        real[i / 2] = complex[i];
        imag[i / 2] = complex[i + 1];
    }
    return { real: real, imag: imag };
}
exports.splitRealAndImagArrays = splitRealAndImagArrays;
function complexWithEvenIndex(complex) {
    var len = Math.ceil(complex.length / 4);
    var real = new Float32Array(len);
    var imag = new Float32Array(len);
    for (var i = 0; i < complex.length; i += 4) {
        real[Math.floor(i / 4)] = complex[i];
        imag[Math.floor(i / 4)] = complex[i + 1];
    }
    return { real: real, imag: imag };
}
exports.complexWithEvenIndex = complexWithEvenIndex;
function complexWithOddIndex(complex) {
    var len = Math.floor(complex.length / 4);
    var real = new Float32Array(len);
    var imag = new Float32Array(len);
    for (var i = 2; i < complex.length; i += 4) {
        real[Math.floor(i / 4)] = complex[i];
        imag[Math.floor(i / 4)] = complex[i + 1];
    }
    return { real: real, imag: imag };
}
exports.complexWithOddIndex = complexWithOddIndex;
function getComplexWithIndex(complex, index) {
    var real = complex[index * 2];
    var imag = complex[index * 2 + 1];
    return { real: real, imag: imag };
}
exports.getComplexWithIndex = getComplexWithIndex;
function assignToTypedArray(data, real, imag, index) {
    data[index * 2] = real;
    data[index * 2 + 1] = imag;
}
exports.assignToTypedArray = assignToTypedArray;
function exponents(n) {
    var real = new Float32Array(n / 2);
    var imag = new Float32Array(n / 2);
    for (var i = 0; i < Math.ceil(n / 2); i++) {
        var x = -2 * Math.PI * (i / n);
        real[i] = Math.cos(x);
        imag[i] = Math.sin(x);
    }
    return { real: real, imag: imag };
}
exports.exponents = exponents;
function exponent(k, n) {
    var x = -2 * Math.PI * (k / n);
    var real = Math.cos(x);
    var imag = Math.sin(x);
    return { real: real, imag: imag };
}
exports.exponent = exponent;

},{}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_ops_1 = require("../ops/tensor_ops");
function nonMaxSuppressionImpl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
    var candidates = Array.from(scores)
        .map(function (score, boxIndex) { return ({ score: score, boxIndex: boxIndex }); })
        .filter(function (c) { return c.score > scoreThreshold; })
        .sort(function (c1, c2) { return c2.score - c1.score; });
    var selected = [];
    for (var i = 0; i < candidates.length; i++) {
        var _a = candidates[i], score = _a.score, boxIndex = _a.boxIndex;
        if (score < scoreThreshold) {
            break;
        }
        var ignoreCandidate = false;
        for (var j = selected.length - 1; j >= 0; --j) {
            var iou = intersectionOverUnion(boxes, boxIndex, selected[j]);
            if (iou >= iouThreshold) {
                ignoreCandidate = true;
                break;
            }
        }
        if (!ignoreCandidate) {
            selected.push(boxIndex);
            if (selected.length >= maxOutputSize) {
                break;
            }
        }
    }
    return tensor_ops_1.tensor1d(selected, 'int32');
}
exports.nonMaxSuppressionImpl = nonMaxSuppressionImpl;
function intersectionOverUnion(boxes, i, j) {
    var iCoord = boxes.subarray(i * 4, i * 4 + 4);
    var jCoord = boxes.subarray(j * 4, j * 4 + 4);
    var yminI = Math.min(iCoord[0], iCoord[2]);
    var xminI = Math.min(iCoord[1], iCoord[3]);
    var ymaxI = Math.max(iCoord[0], iCoord[2]);
    var xmaxI = Math.max(iCoord[1], iCoord[3]);
    var yminJ = Math.min(jCoord[0], jCoord[2]);
    var xminJ = Math.min(jCoord[1], jCoord[3]);
    var ymaxJ = Math.max(jCoord[0], jCoord[2]);
    var xmaxJ = Math.max(jCoord[1], jCoord[3]);
    var areaI = (ymaxI - yminI) * (xmaxI - xminI);
    var areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
    if (areaI <= 0 || areaJ <= 0) {
        return 0.0;
    }
    var intersectionYmin = Math.max(yminI, yminJ);
    var intersectionXmin = Math.max(xminI, xminJ);
    var intersectionYmax = Math.min(ymaxI, ymaxJ);
    var intersectionXmax = Math.min(xmaxI, xmaxJ);
    var intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) *
        Math.max(intersectionXmax - intersectionXmin, 0.0);
    return intersectionArea / (areaI + areaJ - intersectionArea);
}

},{"../ops/tensor_ops":180}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function split(x, sizeSplits, axis) {
    var begin = Array(x.rank).fill(0);
    var size = x.shape.slice();
    return sizeSplits.map(function (s) {
        size[axis] = s;
        var slice = x.slice(begin, size);
        begin[axis] += s;
        return slice;
    });
}
exports.split = split;

},{}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_ops_1 = require("../ops/tensor_ops");
var util_1 = require("../util");
function topkImpl(x, xShape, xDtype, k, sorted) {
    var lastDim = xShape[xShape.length - 1];
    var _a = [x.length / lastDim, lastDim], batch = _a[0], size = _a[1];
    var allTopKVals = util_1.getTypedArrayFromDType(xDtype, batch * k);
    var allTopKIndices = util_1.getTypedArrayFromDType('int32', batch * k);
    for (var b = 0; b < batch; b++) {
        var offset = b * size;
        var vals = x.subarray(offset, offset + size);
        var valAndInd = [];
        for (var i = 0; i < vals.length; i++) {
            valAndInd.push({ value: vals[i], index: i });
        }
        valAndInd.sort(function (a, b) { return b.value - a.value; });
        var outOffset = b * k;
        var topKVals = allTopKVals.subarray(outOffset, outOffset + k);
        var topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);
        for (var i = 0; i < k; i++) {
            topKVals[i] = valAndInd[i].value;
            topKIndices[i] = valAndInd[i].index;
        }
    }
    var outputShape = xShape.slice();
    outputShape[outputShape.length - 1] = k;
    return [
        tensor_ops_1.tensor(allTopKVals, outputShape, xDtype),
        tensor_ops_1.tensor(allTopKIndices, outputShape, 'int32')
    ];
}
exports.topkImpl = topkImpl;

},{"../ops/tensor_ops":180,"../util":203}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgMinMaxProgram = (function () {
    function ArgMinMaxProgram(reduceInfo, op, firstPass) {
        this.variableNames = ['A'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        if (!firstPass) {
            this.variableNames.push('bestIndicesA');
        }
        this.outputShape = [batchSize, outSize];
        var compOp = (op === 'max') ? '>' : '<';
        var indexSnippet = firstPass ?
            'inOffset + i;' :
            'round(getBestIndicesA(batch, inOffset + i));';
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + windowSize + "; i++) {\n          int inIdx = " + indexSnippet + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + compOp + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
    }
    return ArgMinMaxProgram;
}());
exports.ArgMinMaxProgram = ArgMinMaxProgram;

},{}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AvgPool2DBackpropProgram = (function () {
    function AvgPool2DBackpropProgram(convInfo) {
        this.variableNames = ['dy'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var avgMultiplier = 1 / (filterHeight * filterWidth);
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float avgMultiplier = float(" + avgMultiplier + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return AvgPool2DBackpropProgram;
}());
exports.AvgPool2DBackpropProgram = AvgPool2DBackpropProgram;

},{}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../../ops/broadcast_util");
var BatchNormProgram = (function () {
    function BatchNormProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.outputShape = [];
        this.supportsBroadcasting = true;
        this.variableNames = ['x', 'mean', 'variance'];
        broadcast_util.assertAndGetBroadcastShape(xShape, meanShape);
        broadcast_util.assertAndGetBroadcastShape(xShape, varianceShape);
        var offsetSnippet = '0.0';
        if (offsetShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, offsetShape);
            this.variableNames.push('offset');
            offsetSnippet = 'getOffsetAtOutCoords()';
        }
        var scaleSnippet = '1.0';
        if (scaleShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, scaleShape);
            this.variableNames.push('scale');
            scaleSnippet = 'getScaleAtOutCoords()';
        }
        this.outputShape = xShape;
        this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + offsetSnippet + ";\n        float scale = " + scaleSnippet + ";\n        float inv = scale * inversesqrt(variance + float(" + varianceEpsilon + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ";
    }
    return BatchNormProgram;
}());
exports.BatchNormProgram = BatchNormProgram;

},{"../../ops/broadcast_util":143}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../../ops/broadcast_util");
exports.COMPLEX_MULTIPLY = {
    REAL: 'return areal * breal - aimag * bimag;',
    IMAG: 'return areal * bimag + aimag * breal;'
};
var BinaryOpComplexProgram = (function () {
    function BinaryOpComplexProgram(op, aShape, bShape) {
        this.variableNames = ['AReal', 'AImag', 'BReal', 'BImag'];
        this.supportsBroadcasting = true;
        this.outputShape =
            broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + op + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ";
    }
    return BinaryOpComplexProgram;
}());
exports.BinaryOpComplexProgram = BinaryOpComplexProgram;

},{"../../ops/broadcast_util":143}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../../ops/broadcast_util");
var CHECK_NAN_SNIPPET = "\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n";
exports.ADD = 'return a + b;';
exports.SUB = 'return a - b;';
exports.MUL = 'return a * b;';
exports.DIV = "if (a == b) return 1.0;\n  return a / b;";
exports.INT_DIV = "\n  float resultSign = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  int result = ia / ib;\n  int amodb = ia - ib * result;\n\n  if (resultSign < 0.0 && amodb != 0) {\n    result -= 1;\n  }\n  return float(result);\n";
exports.POW = "\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nreturn (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n";
exports.SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';
exports.EQUAL = "return float(a == b);";
exports.NOT_EQUAL = "return float(a != b);";
exports.LESS = "return float(a < b);";
exports.LESS_EQUAL = "return float(a <= b);";
exports.GREATER = "return float(a > b);";
exports.GREATER_EQUAL = "return float(a >= b);";
exports.LOGICAL_AND = "return float(a >= 1.0 && b >= 1.0);";
exports.LOGICAL_OR = "return float(a >= 1.0 || b >= 1.0);";
exports.MAX = CHECK_NAN_SNIPPET + "\n  return max(a, b);\n";
exports.MIN = CHECK_NAN_SNIPPET + "\n  return min(a, b);\n";
exports.MOD = "if (b == 0.0) return NAN;\n  return mod(a, b);";
exports.ATAN2 = CHECK_NAN_SNIPPET + "\n  return atan(a, b);\n";
exports.ELU_DER = "return (b >= 1.0) ? a : a * (b + 1.0);";
var BinaryOpProgram = (function () {
    function BinaryOpProgram(op, aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.supportsBroadcasting = true;
        this.outputShape =
            broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = "\n      uniform float NAN;\n      float binaryOperation(float a, float b) {\n        " + op + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
    }
    BinaryOpProgram.prototype.getCustomSetupFunc = function () {
        var _this = this;
        return function (gpgpu, webGLProgram) {
            if (_this.startLoc == null) {
                _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'NAN');
                if (_this.startLoc == null) {
                    return;
                }
            }
            gpgpu.gl.uniform1f(_this.startLoc, NaN);
        };
    };
    return BinaryOpProgram;
}());
exports.BinaryOpProgram = BinaryOpProgram;

},{"../../ops/broadcast_util":143}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ClipProgram = (function () {
    function ClipProgram(aShape, min, max) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        this.userCode = "\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, float(" + min + "), float(" + max + ")));\n      }\n    ";
    }
    return ClipProgram;
}());
exports.ClipProgram = ClipProgram;

},{}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_util = require("../../ops/concat_util");
var ConcatProgram = (function () {
    function ConcatProgram(aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.outputShape = [];
        this.outputShape =
            concat_util.computeOutShape([aShape, bShape], 1);
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        float value = 0.0;\n        if (yC < " + aShape[1] + ") {\n          value = getA(yR, yC);\n        } else {\n          yC -= " + aShape[1] + ";\n          value = getB(yR, yC);\n        }\n\n        setOutput(value);\n      }\n    ";
    }
    return ConcatProgram;
}());
exports.ConcatProgram = ConcatProgram;

},{"../../ops/concat_util":147}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Conv2DDerFilterProgram = (function () {
    function Conv2DDerFilterProgram(convInfo) {
        this.variableNames = ['x', 'dy'];
        this.outputShape = convInfo.filterShape;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + convInfo.batchSize + "; b++) {\n          for (int yR = 0; yR < " + convInfo.outHeight + "; yR++) {\n            int xR = wR + yR * " + strideHeight + " - " + padTop + ";\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + convInfo.outWidth + "; yC++) {\n              int xC = wC + yC * " + strideWidth + " - " + padLeft + ";\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerFilterProgram;
}());
exports.Conv2DDerFilterProgram = Conv2DDerFilterProgram;
var Conv2DDerInputProgram = (function () {
    function Conv2DDerInputProgram(convInfo) {
        this.variableNames = ['dy', 'W'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + filterHeight + " - 1 - wR;\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + filterWidth + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + convInfo.outChannels + "; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerInputProgram;
}());
exports.Conv2DDerInputProgram = Conv2DDerInputProgram;

},{}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DepthwiseConv2DDerFilterProgram = (function () {
    function DepthwiseConv2DDerFilterProgram(convInfo) {
        this.variableNames = ['x', 'dy'];
        this.outputShape = convInfo.filterShape;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + channelMul + " + dm;\n\n        float dotProd = 0.0;\n\n        // TODO: Vec4 over the batch size\n        for (int b = 0; b < " + convInfo.batchSize + "; b++) {\n          for (int yR = 0; yR < " + convInfo.outHeight + "; yR++) {\n            int xR = wR + yR * " + strideHeight + " - " + padTop + ";\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + convInfo.outWidth + "; yC++) {\n              int xC = wC + yC * " + strideWidth + " - " + padLeft + ";\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DDerFilterProgram;
}());
exports.DepthwiseConv2DDerFilterProgram = DepthwiseConv2DDerFilterProgram;
var DepthwiseConv2DDerInputProgram = (function () {
    function DepthwiseConv2DDerInputProgram(convInfo) {
        this.variableNames = ['dy', 'W'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + filterHeight + " - 1 - wR;\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + filterWidth + " - 1 - wC;\n\n            // TODO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + channelMul + "; dm++) {\n              int d2 = d1 * " + channelMul + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DDerInputProgram;
}());
exports.DepthwiseConv2DDerInputProgram = DepthwiseConv2DDerInputProgram;

},{}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Conv2DProgram = (function () {
    function Conv2DProgram(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var dilationHeight = convInfo.dilationHeight;
        var dilationWidth = convInfo.dilationWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
        var inputDepthVec4Remainder = convInfo.inChannels % 4;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR * " + dilationHeight + ";\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC * " + dilationWidth + ";\n\n            if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + inputDepthNearestVec4 + "; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if (" + (inputDepthVec4Remainder === 1) + ") {\n              dotProd +=\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + ") *\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2);\n            } else if (" + (inputDepthVec4Remainder === 2) + ") {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if (" + (inputDepthVec4Remainder === 3) + ") {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DProgram;
}());
exports.Conv2DProgram = Conv2DProgram;

},{}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DepthwiseConv2DProgram = (function () {
    function DepthwiseConv2DProgram(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        var xNumRows = convInfo.inHeight;
        var xNumCols = convInfo.inWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var dilationHeight = convInfo.dilationHeight;
        var dilationWidth = convInfo.dilationWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + channelMul + ";\n        int q = d2 - d1 * " + channelMul + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR * " + dilationHeight + ";\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC * " + dilationWidth + ";\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DProgram;
}());
exports.DepthwiseConv2DProgram = DepthwiseConv2DProgram;

},{}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CropAndResizeProgram = (function () {
    function CropAndResizeProgram(imageShape, boxShape, cropSize, method, extrapolationValue) {
        this.variableNames = ['Image', 'Boxes', 'BoxInd'];
        this.outputShape = [];
        var batch = imageShape[0], imageHeight = imageShape[1], imageWidth = imageShape[2], depth = imageShape[3];
        var numBoxes = boxShape[0];
        var cropHeight = cropSize[0], cropWidth = cropSize[1];
        this.outputShape = [numBoxes, cropHeight, cropWidth, depth];
        var methodId = method === 'bilinear' ? 1 : 0;
        var _a = [imageHeight - 1 + ".0", imageWidth - 1 + ".0"], inputHeightFloat = _a[0], inputWidthFloat = _a[1];
        var _b = cropHeight > 1 ?
            [
                "" + (imageHeight - 1) / (cropHeight - 1),
                '(y2-y1) * height_ratio',
                "y1*" + inputHeightFloat + " + float(y)*(height_scale)",
            ] :
            [
                '0.0',
                '0.0',
                "0.5 * (y1+y2) * " + inputHeightFloat,
            ], heightRatio = _b[0], heightScale = _b[1], inY = _b[2];
        var _c = cropWidth > 1 ?
            [
                "" + (imageWidth - 1) / (cropWidth - 1),
                '(x2-x1) * width_ratio',
                "x1*" + inputWidthFloat + " + float(x)*(width_scale)",
            ] :
            [
                '0.0',
                '0.0',
                "0.5 * (x1+x2) * " + inputWidthFloat,
            ], widthRatio = _c[0], widthScale = _c[1], inX = _c[2];
        this.userCode = "\n      const float height_ratio = float(" + heightRatio + ");\n      const float width_ratio = float(" + widthRatio + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + batch + ") {\n          return;\n        }\n\n        float height_scale = " + heightScale + ";\n        float width_scale = " + widthScale + ";\n\n        float in_y = " + inY + ";\n        if( in_y < 0.0 || in_y > " + inputHeightFloat + " ) {\n          setOutput(float(" + extrapolationValue + "));\n          return;\n        }\n        float in_x = " + inX + ";\n        if( in_x < 0.0 || in_x > " + inputWidthFloat + " ) {\n          setOutput(float(" + extrapolationValue + "));\n          return;\n        }\n\n        vec2 sourceFracIndexRC = vec2(in_y,in_x);\n        if(" + methodId + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n          ivec2 sourceCeilRC = ivec2(ceil(sourceFracIndexRC));\n\n          float topLeft = getImage(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          float bottomLeft = getImage(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          float topRight = getImage(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          float bottomRight = getImage(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n          float top = topLeft + (topRight - topLeft) * fracRC.y;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          float newValue = top + (bottom - top) * fracRC.x;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestRC = ivec2(floor(\n            sourceFracIndexRC + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestRC.x, sourceNearestRC.y, d);\n          setOutput(newValue);\n        }\n      }\n    ";
    }
    return CropAndResizeProgram;
}());
exports.CropAndResizeProgram = CropAndResizeProgram;

},{}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var CumSumProgram = (function () {
    function CumSumProgram(shape, exclusive, reverse) {
        this.variableNames = ['x'];
        this.outputShape = shape;
        var rank = shape.length;
        var finalDim = shape[shape.length - 1];
        var comparator = reverse ? '<' : '>';
        this.userCode = "\n      int getIndex(int i) {\n        " + (reverse ? "return " + finalDim + " -i - 1;" : 'return i;') + "\n      }\n\n      void main() {\n        " + shader_compiler_1.getCoordsDataType(rank) + " coords = getOutputCoords();\n        int end = " + getFinalCoord(rank, 'coords') + ";\n        float val = 0.0;\n        for (int i = " + finalDim + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + comparator + " end) {\n            continue;\n          }\n          if (idx == end && " + exclusive + ") {\n            continue;\n          }\n          " + getFinalCoord(rank, 'coords') + " = idx;\n          val += getX(" + getCoords(rank, 'coords') + ");\n        }\n        setOutput(val);\n      }\n    ";
    }
    return CumSumProgram;
}());
exports.CumSumProgram = CumSumProgram;
function getCoords(rank, name) {
    if (rank === 1) {
        return "" + name;
    }
    else if (rank === 2) {
        return name + ".x, " + name + ".y";
    }
    else if (rank === 3) {
        return name + ".x, " + name + ".y, " + name + ".z";
    }
    else if (rank === 4) {
        return name + ".x, " + name + ".y, " + name + ".z, " + name + ".w";
    }
    else {
        throw Error("Cumulative sum for rank " + rank + " is not yet supported");
    }
}
function getFinalCoord(rank, name) {
    if (rank === 1) {
        return "" + name;
    }
    else if (rank === 2) {
        return name + ".y";
    }
    else if (rank === 3) {
        return name + ".z";
    }
    else if (rank === 4) {
        return name + ".w";
    }
    else {
        throw Error("Cumulative sum for rank " + rank + " is not yet supported");
    }
}

},{"./shader_compiler":126}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DepthToSpaceProgram = (function () {
    function DepthToSpaceProgram(outputShape, blockSize, dataFormat) {
        this.variableNames = ['x'];
        this.outputShape = [];
        this.outputShape = outputShape;
        this.blockSize = blockSize;
        this.dataFormat = dataFormat;
        this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + blockSize + ";\n      int offset_h = imod(h, " + blockSize + ");\n      int in_w = w / " + blockSize + ";\n      int offset_w = imod(w, " + blockSize + ");\n      int offset_d = (offset_h * " + blockSize + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  ";
    }
    DepthToSpaceProgram.prototype.getHeightCoordString = function () {
        if (this.dataFormat === 'NHWC') {
            return "coords[1]";
        }
        else {
            return "coords[2]";
        }
    };
    DepthToSpaceProgram.prototype.getWidthCoordString = function () {
        if (this.dataFormat === 'NHWC') {
            return "coords[2]";
        }
        else {
            return "coords[3]";
        }
    };
    DepthToSpaceProgram.prototype.getDepthCoordString = function () {
        if (this.dataFormat === 'NHWC') {
            return "coords[3]";
        }
        else {
            return "coords[1]";
        }
    };
    DepthToSpaceProgram.prototype.getOutputDepthSize = function () {
        if (this.dataFormat === 'NHWC') {
            return this.outputShape[3];
        }
        else {
            return this.outputShape[1];
        }
    };
    DepthToSpaceProgram.prototype.getInputSamplingString = function () {
        if (this.dataFormat === 'NHWC') {
            return "getX(b, in_h, in_w, in_d)";
        }
        else {
            return "getX(b, in_d, in_h, in_w)";
        }
    };
    return DepthToSpaceProgram;
}());
exports.DepthToSpaceProgram = DepthToSpaceProgram;

},{}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EncodeFloatProgram = (function () {
    function EncodeFloatProgram(outputShape) {
        this.variableNames = ['A'];
        this.outputShape = outputShape;
        this.userCode = "\n      const float FLOAT_MAX = 1.70141184e38;\n      const float FLOAT_MIN = 1.17549435e-38;\n\n      lowp vec4 encode_float(highp float v) {\n        if (isNaN(v)) {\n          return vec4(255, 255, 255, 255);\n        }\n\n        highp float av = abs(v);\n\n        if(av < FLOAT_MIN) {\n          return vec4(0.0, 0.0, 0.0, 0.0);\n        } else if(v > FLOAT_MAX) {\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n        } else if(v < -FLOAT_MAX) {\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n        }\n\n        highp vec4 c = vec4(0,0,0,0);\n\n        highp float e = floor(log2(av));\n        highp float m = exp2(fract(log2(av))) - 1.0;\n\n        c[2] = floor(128.0 * m);\n        m -= c[2] / 128.0;\n        c[1] = floor(32768.0 * m);\n        m -= c[1] / 32768.0;\n        c[0] = floor(8388608.0 * m);\n\n        highp float ebias = e + 127.0;\n        c[3] = floor(ebias / 2.0);\n        ebias -= c[3] * 2.0;\n        c[2] += floor(ebias) * 128.0;\n\n        c[3] += 128.0 * step(0.0, -v);\n\n        return c / 255.0;\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        gl_FragColor = encode_float(x);\n      }\n    ";
    }
    return EncodeFloatProgram;
}());
exports.EncodeFloatProgram = EncodeFloatProgram;

},{}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.COMPLEX_FFT = {
    REAL: 'return real * expR - imag * expI;',
    IMAG: 'return real * expI + imag * expR;'
};
var FFTProgram = (function () {
    function FFTProgram(op, inputShape) {
        this.variableNames = ['real', 'imag'];
        var size = inputShape[0];
        this.outputShape = [size];
        this.userCode = "\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + op + "\n      }\n\n      float mulMatDFT(int row) {\n        // TODO: Gather constants in one place?\n        const float PI = 3.1415926535897932384626433832795;\n        float result = 0.0;\n\n        for (int i = 0; i < " + size + "; i++) {\n          float x = -2.0 * PI * float(row * i) / float(" + size + ");\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(i);\n          float imag = getImag(i);\n\n          result += unaryOpComplex(real, expR, imag, expI);\n        }\n\n        return result;\n      }\n\n      void main() {\n        int row = getOutputCoords();\n        setOutput(mulMatDFT(row));\n      }\n    ";
    }
    return FFTProgram;
}());
exports.FFTProgram = FFTProgram;

},{}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FromPixelsProgram = (function () {
    function FromPixelsProgram(outputShape) {
        this.variableNames = ['A'];
        var height = outputShape[0], width = outputShape[1];
        this.outputShape = outputShape;
        this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + width + ".0, " + height + ".0);\n\n        vec4 values = texture2D(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
    }
    return FromPixelsProgram;
}());
exports.FromPixelsProgram = FromPixelsProgram;

},{}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var GatherProgram = (function () {
    function GatherProgram(aShape, indicesLength, axis) {
        this.variableNames = ['A', 'indices'];
        var outputShape = aShape.slice();
        outputShape[axis] = indicesLength;
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getSourceCoords(aShape, axis);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
    }
    return GatherProgram;
}());
exports.GatherProgram = GatherProgram;
function getSourceCoords(aShape, axis) {
    var rank = aShape.length;
    if (rank > 4) {
        throw Error("Gather for rank " + rank + " is not yet supported");
    }
    if (rank === 1) {
        return "int(getIndices(resRC))";
    }
    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var sourceCoords = [];
    for (var i = 0; i < aShape.length; i++) {
        if (i === axis) {
            sourceCoords.push("int(getIndices(" + currentCoords[i] + "))");
        }
        else {
            sourceCoords.push("" + currentCoords[i]);
        }
    }
    return sourceCoords.join();
}

},{"./shader_compiler":126}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var GatherNDProgram = (function () {
    function GatherNDProgram(sliceDim, strides, shape) {
        this.sliceDim = sliceDim;
        this.strides = strides;
        this.variableNames = ['x', 'indices'];
        this.outputShape = shape;
        var stridesType = shader_compiler_1.getCoordsDataType(strides.length);
        var dtype = shader_compiler_1.getCoordsDataType(shape.length);
        var strideString = this.sliceDim > 1 ? 'strides[j]' : 'strides';
        this.userCode = "\n        " + stridesType + " strides = " + stridesType + "(" + this.strides + ");\n         void main() {\n          " + dtype + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + strideString + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ";
    }
    return GatherNDProgram;
}());
exports.GatherNDProgram = GatherNDProgram;

},{"./shader_compiler":126}],103:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var gpgpu_util = require("./gpgpu_util");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
var GPGPUContext = (function () {
    function GPGPUContext(gl) {
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.autoDebugValidate = false;
        this.vertexAttrsAreBound = false;
        this.itemsToPoll = [];
        if (gl != null) {
            this.gl = gl;
        }
        else {
            this.gl = gpgpu_util.createWebGLContext();
        }
        if (environment_1.ENV.get('WEBGL_VERSION') === 1) {
            this.textureFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'OES_texture_float');
            this.colorBufferFloatExtension =
                this.gl.getExtension('WEBGL_color_buffer_float');
            if (!environment_1.ENV.get('WEBGL_RENDER_FLOAT32_ENABLED')) {
                this.textureHalfFloatExtension =
                    webgl_util.getExtensionOrThrow(this.gl, 'OES_texture_half_float');
                this.colorBufferHalfFloatExtension =
                    this.gl.getExtension('EXT_color_buffer_half_float');
            }
        }
        else {
            this.colorBufferFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'EXT_color_buffer_float');
        }
        this.loseContextExtension =
            webgl_util.getExtensionOrThrow(this.gl, 'WEBGL_lose_context');
        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);
        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);
        this.framebuffer = webgl_util.createFramebuffer(this.gl);
        this.textureConfig =
            gpgpu_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);
    }
    GPGPUContext.prototype.dispose = function () {
        var _this = this;
        if (this.disposed) {
            return;
        }
        if (this.program != null) {
            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +
                ' This is probably a resource leak, delete the program with ' +
                'GPGPUContext.deleteProgram before disposing.');
        }
        if (this.outputTexture != null) {
            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +
                'texture.  This is probably a resource leak, delete the output ' +
                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +
                'disposing.');
        }
        var gl = this.gl;
        webgl_util.callAndCheck(gl, function () { return gl.finish(); });
        webgl_util.callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteFramebuffer(_this.framebuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.vertexBuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.indexBuffer); });
        this.loseContextExtension.loseContext();
        this.disposed = true;
    };
    GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {
        this.autoDebugValidate = enabled;
        webgl_util.enableDebugWebGLErrorChecking(enabled);
    };
    GPGPUContext.prototype.createFloat32MatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);
    };
    GPGPUContext.prototype.createFloat16MatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);
    };
    GPGPUContext.prototype.createUnsignedBytesMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);
    };
    GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {
        this.throwIfDisposed();
        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);
    };
    GPGPUContext.prototype.createFloat16PackedMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
    };
    GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
    };
    GPGPUContext.prototype.deleteMatrixTexture = function (texture) {
        var _this = this;
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
            this.outputTexture = null;
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteTexture(texture); });
    };
    GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        var numChannels = webgl_util.getNumChannels();
        return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels, this.textureConfig);
    };
    GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix, this.textureConfig);
    };
    GPGPUContext.prototype.downloadFloat32MatrixFromOutputTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadFloat32MatrixFromOutputTexture(_this.gl, rows, columns, _this.textureConfig); });
    };
    GPGPUContext.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(_this.gl, rows, columns, _this.textureConfig); });
    };
    GPGPUContext.prototype.downloadFloat32MatrixFromBuffer = function (buffer, rows, columns) {
        return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, rows, columns, this.textureConfig);
    };
    GPGPUContext.prototype.maybeCreateBufferFromTexture = function (texture, rows, columns) {
        this.bindTextureToFrameBuffer(texture);
        var result = gpgpu_util.maybeCreateBufferFromOutputTexture(this.gl, texture, rows, columns, this.textureConfig);
        this.unbindTextureToFrameBuffer();
        return result;
    };
    GPGPUContext.prototype.createAndWaitForFence = function () {
        var fenceContext = this.createFence(this.gl);
        return this.pollFence(fenceContext);
    };
    GPGPUContext.prototype.createFence = function (gl) {
        var _this = this;
        var query;
        var isFencePassed;
        if (environment_1.ENV.get('WEBGL_FENCE_API_ENABLED')) {
            var gl2_1 = gl;
            var sync_1 = gl2_1.fenceSync(gl2_1.SYNC_GPU_COMMANDS_COMPLETE, 0);
            gl.flush();
            isFencePassed = function () {
                var status = gl2_1.clientWaitSync(sync_1, 0, 0);
                return status === gl2_1.ALREADY_SIGNALED ||
                    status === gl2_1.CONDITION_SATISFIED;
            };
            query = sync_1;
        }
        else if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
            query = this.beginQuery();
            this.endQuery();
            isFencePassed = function () { return _this.isQueryAvailable(query, environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')); };
        }
        else {
            isFencePassed = function () { return true; };
        }
        return { query: query, isFencePassed: isFencePassed };
    };
    GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, shape, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, shape[0], shape[1], rows, columns, _this.textureConfig); });
    };
    GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {
        this.throwIfDisposed();
        var gl = this.gl;
        var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);
        var vertexShader = gpgpu_util.createVertexShader(gl);
        var program = webgl_util.createProgram(gl);
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, vertexShader); });
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, fragmentShader); });
        webgl_util.linkProgram(gl, program);
        if (this.autoDebugValidate) {
            webgl_util.validateProgram(gl, program);
        }
        if (!this.vertexAttrsAreBound) {
            this.setProgram(program);
            this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);
        }
        return program;
    };
    GPGPUContext.prototype.deleteProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        if (program === this.program) {
            this.program = null;
        }
        if (program != null) {
            webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteProgram(program); });
        }
    };
    GPGPUContext.prototype.setProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        this.program = program;
        if ((this.program != null) && this.autoDebugValidate) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.useProgram(program); });
    };
    GPGPUContext.prototype.getUniformLocation = function (program, uniformName, shouldThrow) {
        if (shouldThrow === void 0) { shouldThrow = true; }
        this.throwIfDisposed();
        if (shouldThrow) {
            return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);
        }
        else {
            return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);
        }
    };
    GPGPUContext.prototype.getAttributeLocation = function (program, attribute) {
        var _this = this;
        this.throwIfDisposed();
        return webgl_util.callAndCheck(this.gl, function () { return _this.gl.getAttribLocation(program, attribute); });
    };
    GPGPUContext.prototype.getUniformLocationNoThrow = function (program, uniformName) {
        this.throwIfDisposed();
        return this.gl.getUniformLocation(program, uniformName);
    };
    GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformLocation, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformLocation, textureUnit);
    };
    GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');
    };
    GPGPUContext.prototype.debugValidate = function () {
        if (this.program != null) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.validateFramebuffer(this.gl);
    };
    GPGPUContext.prototype.executeProgram = function () {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        var gl = this.gl;
        if (this.autoDebugValidate) {
            this.debugValidate();
        }
        webgl_util.callAndCheck(gl, function () { return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); });
    };
    GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.finish(); });
    };
    GPGPUContext.prototype.getQueryTimerExtension = function () {
        if (this.disjointQueryTimerExtension == null) {
            this.disjointQueryTimerExtension =
                webgl_util.getExtensionOrThrow(this.gl, environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?
                    'EXT_disjoint_timer_query_webgl2' :
                    'EXT_disjoint_timer_query');
        }
        return this.disjointQueryTimerExtension;
    };
    GPGPUContext.prototype.getQueryTimerExtensionWebGL2 = function () {
        return this.getQueryTimerExtension();
    };
    GPGPUContext.prototype.getQueryTimerExtensionWebGL1 = function () {
        return this.getQueryTimerExtension();
    };
    GPGPUContext.prototype.beginQuery = function () {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {
            var gl2 = this.gl;
            var ext_1 = this.getQueryTimerExtensionWebGL2();
            var query_1 = gl2.createQuery();
            gl2.beginQuery(ext_1.TIME_ELAPSED_EXT, query_1);
            return query_1;
        }
        var ext = this.getQueryTimerExtensionWebGL1();
        var query = ext.createQueryEXT();
        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
        return query;
    };
    GPGPUContext.prototype.endQuery = function () {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {
            var gl2 = this.gl;
            var ext_2 = this.getQueryTimerExtensionWebGL2();
            gl2.endQuery(ext_2.TIME_ELAPSED_EXT);
            return;
        }
        var ext = this.getQueryTimerExtensionWebGL1();
        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
    };
    GPGPUContext.prototype.waitForQueryAndGetTime = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, util.repeatedTry(function () { return _this.isQueryAvailable(query, environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')); })];
                    case 1:
                        _a.sent();
                        return [2, this.getQueryTime(query, environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'))];
                }
            });
        });
    };
    GPGPUContext.prototype.getQueryTime = function (query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
            return null;
        }
        if (queryTimerVersion === 2) {
            var gl2 = this.gl;
            var timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
            return timeElapsedNanos / 1000000;
        }
        else {
            var ext = this.getQueryTimerExtensionWebGL1();
            var timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
            return timeElapsedNanos / 1000000;
        }
    };
    GPGPUContext.prototype.isQueryAvailable = function (query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
            return true;
        }
        if (queryTimerVersion === 2) {
            var gl2 = this.gl;
            var ext = this.getQueryTimerExtensionWebGL2();
            var available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
            if (this.disjoint == null) {
                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
            }
            return available && !this.disjoint;
        }
        else {
            var ext = this.getQueryTimerExtensionWebGL1();
            var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
            if (this.disjoint == null) {
                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
            }
            return available && !this.disjoint;
        }
    };
    GPGPUContext.prototype.pollFence = function (fenceContext) {
        var _this = this;
        return new Promise(function (resolve) {
            _this.addItemToPoll(function () { return fenceContext.isFencePassed(); }, function () { return resolve(); });
        });
    };
    GPGPUContext.prototype.pollItems = function () {
        var index = binSearchLastTrue(this.itemsToPoll.map(function (x) { return x.isDoneFn; }));
        for (var i = 0; i <= index; ++i) {
            var resolveFn = this.itemsToPoll[i].resolveFn;
            resolveFn();
        }
        this.itemsToPoll = this.itemsToPoll.slice(index + 1);
    };
    GPGPUContext.prototype.addItemToPoll = function (isDoneFn, resolveFn) {
        var _this = this;
        this.itemsToPoll.push({ isDoneFn: isDoneFn, resolveFn: resolveFn });
        if (this.itemsToPoll.length > 1) {
            return;
        }
        util.repeatedTry(function () {
            _this.pollItems();
            return _this.itemsToPoll.length === 0;
        });
    };
    GPGPUContext.prototype.bindTextureToFrameBuffer = function (texture) {
        this.throwIfDisposed();
        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(this.gl);
        }
    };
    GPGPUContext.prototype.unbindTextureToFrameBuffer = function () {
        if (this.outputTexture != null) {
            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
            if (this.autoDebugValidate) {
                webgl_util.validateFramebuffer(this.gl);
            }
        }
        else {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {
        this.bindTextureToFrameBuffer(texture);
        var result = downloadAndDecode();
        this.unbindTextureToFrameBuffer();
        return result;
    };
    GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        var gl = this.gl;
        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(gl);
        }
        this.outputTexture = outputMatrixTextureMaybePacked;
        webgl_util.callAndCheck(gl, function () { return gl.viewport(0, 0, width, height); });
        webgl_util.callAndCheck(gl, function () { return gl.scissor(0, 0, width, height); });
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.scissor(x, y, width, height); });
    };
    GPGPUContext.prototype.throwIfDisposed = function () {
        if (this.disposed) {
            throw new Error('Attempted to use disposed GPGPUContext.');
        }
    };
    GPGPUContext.prototype.throwIfNoProgram = function () {
        if (this.program == null) {
            throw new Error('No GPU program is currently set.');
        }
    };
    return GPGPUContext;
}());
exports.GPGPUContext = GPGPUContext;
function binSearchLastTrue(arr) {
    var start = 0;
    var end = arr.length - 1;
    var best = -1;
    while (start <= end) {
        var mid = (start + end) >> 1;
        var isDone = arr[mid]();
        if (isDone) {
            best = mid;
            start = mid + 1;
        }
        else {
            end = mid - 1;
        }
    }
    return best;
}
exports.binSearchLastTrue = binSearchLastTrue;

},{"../../environment":60,"../../util":203,"./gpgpu_util":105,"./tex_util":129,"./webgl_util":135}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var shader_compiler = require("./shader_compiler");
var tex_util_1 = require("./tex_util");
function compileProgram(gpgpu, program, inputs, output) {
    var userCode = program.userCode;
    var inputInfos = inputs.map(function (input, i) {
        var shapeInfo = {
            logicalShape: input.shape,
            texShape: input.isUniform ? null : input.texData.texShape,
            isUniform: input.isUniform,
            isPacked: input.isUniform ? false :
                input.texData.usage === tex_util_1.TextureUsage.PACK
        };
        return { name: program.variableNames[i], shapeInfo: shapeInfo };
    });
    var inShapeInfos = inputInfos.map(function (x) { return x.shapeInfo; });
    var outShapeInfo = {
        logicalShape: output.shape,
        texShape: output.texData.texShape,
        isUniform: false,
        isPacked: output.texData.usage === tex_util_1.TextureUsage.PACK
    };
    var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);
    var webGLProgram = gpgpu.createProgram(source);
    var uniformLocations = {};
    for (var i = 0; i < program.variableNames.length; i++) {
        var uniformName = program.variableNames[i];
        var shouldThrow = false;
        uniformLocations[uniformName] =
            gpgpu.getUniformLocation(webGLProgram, uniformName, shouldThrow);
    }
    return {
        program: program,
        source: source,
        webGLProgram: webGLProgram,
        uniformLocations: uniformLocations,
        gpgpu: gpgpu,
        inShapeInfos: inShapeInfos,
        outShapeInfo: outShapeInfo
    };
}
exports.compileProgram = compileProgram;
function validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) {
        throw Error("Binary was compiled with " + shapeInfos.length + " inputs, but " +
            ("was executed with " + inputs.length + " inputs"));
    }
    shapeInfos.forEach(function (s, i) {
        var shapeA = s.logicalShape;
        var input = inputs[i];
        var shapeB = input.shape;
        if (!util.arraysEqual(shapeA, shapeB)) {
            throw Error("Binary was compiled with different shapes than " +
                ("the current args. Shapes " + shapeA + " and " + shapeB + " must match"));
        }
        if (s.isUniform && input.isUniform) {
            return;
        }
        var texShapeA = s.texShape;
        var texShapeB = input.isUniform ? null : input.texData.texShape;
        if (!util.arraysEqual(texShapeA, texShapeB)) {
            throw Error("Binary was compiled with different texture shapes than the" +
                (" current args. Shape " + texShapeA + " and " + texShapeB + " must match"));
        }
    });
}
function runProgram(binary, inputs, output, customSetup) {
    validateBinaryAndProgram(binary.inShapeInfos, inputs);
    validateBinaryAndProgram([binary.outShapeInfo], [output]);
    var outTex = output.texData.texture;
    var outTexShape = output.texData.texShape;
    var gpgpu = binary.gpgpu;
    if (output.texData.usage === tex_util_1.TextureUsage.PACK) {
        gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    }
    else {
        gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    }
    gpgpu.setProgram(binary.webGLProgram);
    inputs.forEach(function (input, i) {
        var variableName = binary.program.variableNames[i];
        var variableUniformLocation = binary.uniformLocations[variableName];
        if (variableUniformLocation != null) {
            if (input.isUniform) {
                if (util.sizeFromShape(input.shape) === 1) {
                    gpgpu.gl.uniform1f(variableUniformLocation, input.uniformValues[0]);
                }
                else {
                    var vals = input.uniformValues;
                    if (!(vals instanceof Float32Array)) {
                        vals = new Float32Array(vals);
                    }
                    gpgpu.gl.uniform1fv(variableUniformLocation, vals);
                }
                return;
            }
            var tex = input.texData.texture;
            gpgpu.setInputMatrixTexture(tex, variableUniformLocation, i);
        }
    });
    if (customSetup != null) {
        customSetup(gpgpu, binary.webGLProgram);
    }
    gpgpu.executeProgram();
}
exports.runProgram = runProgram;
function makeShaderKey(program, inputs, output) {
    var keyInputs = '';
    inputs.concat(output).forEach(function (x) {
        keyInputs += x.shape + "_" + (x.isUniform ? 'uniform' : x.texData.texShape);
    });
    var keyUserCode = program.userCode;
    var keyBroadcast = (program.supportsBroadcasting === true).toString();
    var key = program.constructor.name;
    key += '_' + keyBroadcast + '_' + keyInputs + '_' + keyUserCode;
    return key;
}
exports.makeShaderKey = makeShaderKey;

},{"../../util":203,"./shader_compiler":126,"./tex_util":129}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
function getWebGLContextAttributes() {
    return {
        alpha: false,
        antialias: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        depth: false,
        stencil: false,
        failIfMajorPerformanceCaveat: true
    };
}
exports.getWebGLContextAttributes = getWebGLContextAttributes;
function createWebGLContext(canvas) {
    var attributes = getWebGLContextAttributes();
    var gl;
    if (canvas != null) {
        gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);
    }
    else {
        gl = webgl_util.createWebGLRenderingContext(attributes);
    }
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DEPTH_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.STENCIL_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.BLEND); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DITHER); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.POLYGON_OFFSET_FILL); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.SAMPLE_COVERAGE); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.SCISSOR_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.CULL_FACE); });
    webgl_util.callAndCheck(gl, function () { return gl.cullFace(gl.BACK); });
    return gl;
}
exports.createWebGLContext = createWebGLContext;
function createVertexShader(gl) {
    var vertexShaderSource = "\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";
    return webgl_util.createVertexShader(gl, vertexShaderSource);
}
exports.createVertexShader = createVertexShader;
function createVertexBuffer(gl) {
    var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return webgl_util.createStaticVertexBuffer(gl, vertexArray);
}
exports.createVertexBuffer = createVertexBuffer;
function createIndexBuffer(gl) {
    var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);
}
exports.createIndexBuffer = createIndexBuffer;
function getTextureConfig(gl, textureHalfFloatExtension) {
    var glany = gl;
    var internalFormatFloat;
    var internalFormatHalfFloat;
    var internalFormatPackedFloat;
    var textureFormatFloat;
    var downloadTextureFormat;
    var downloadUnpackNumChannels;
    var defaultNumChannels;
    var textureTypeHalfFloat;
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        internalFormatFloat = glany.R32F;
        internalFormatHalfFloat = glany.R16F;
        internalFormatPackedFloat = glany.RGBA32F;
        textureFormatFloat = glany.RED;
        downloadUnpackNumChannels = 4;
        defaultNumChannels = 1;
        textureTypeHalfFloat = glany.HALF_FLOAT;
    }
    else {
        internalFormatFloat = gl.RGBA;
        internalFormatHalfFloat = gl.RGBA;
        internalFormatPackedFloat = glany.RGBA;
        textureFormatFloat = gl.RGBA;
        downloadUnpackNumChannels = 4;
        defaultNumChannels = 4;
        textureTypeHalfFloat = textureHalfFloatExtension != null ?
            textureHalfFloatExtension.HALF_FLOAT_OES :
            null;
    }
    downloadTextureFormat = gl.RGBA;
    return {
        internalFormatFloat: internalFormatFloat,
        internalFormatHalfFloat: internalFormatHalfFloat,
        internalFormatPackedFloat: internalFormatPackedFloat,
        textureFormatFloat: textureFormatFloat,
        downloadTextureFormat: downloadTextureFormat,
        downloadUnpackNumChannels: downloadUnpackNumChannels,
        defaultNumChannels: defaultNumChannels,
        textureTypeHalfFloat: textureTypeHalfFloat
    };
}
exports.getTextureConfig = getTextureConfig;
function createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {
    webgl_util.validateTextureSize(width, height);
    var texture = webgl_util.createTexture(gl);
    var tex2d = gl.TEXTURE_2D;
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(tex2d, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
    return texture;
}
function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    return createAndConfigureTexture(gl, width, height, textureConfig.internalFormatFloat, textureConfig.textureFormatFloat, gl.FLOAT);
}
exports.createFloat32MatrixTexture = createFloat32MatrixTexture;
function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    return createAndConfigureTexture(gl, width, height, textureConfig.internalFormatFloat, textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);
}
exports.createFloat16MatrixTexture = createFloat16MatrixTexture;
function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    return createAndConfigureTexture(gl, width, height, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE);
}
exports.createUnsignedBytesMatrixTexture = createUnsignedBytesMatrixTexture;
function createPackedMatrixTexture(gl, rows, columns, textureConfig) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    return createAndConfigureTexture(gl, width, height, textureConfig.internalFormatPackedFloat, gl.RGBA, gl.FLOAT);
}
exports.createPackedMatrixTexture = createPackedMatrixTexture;
function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    return createAndConfigureTexture(gl, width, height, textureConfig.internalFormatHalfFloat, gl.RGBA, textureConfig.textureTypeHalfFloat);
}
exports.createFloat16PackedMatrixTexture = createFloat16PackedMatrixTexture;
function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
    var posOffset = 0;
    var uvOffset = 3 * 4;
    var stride = (3 * 4) + (2 * 4);
    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); });
    var success = webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);
    return success &&
        webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);
}
exports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;
function uploadPixelDataToTexture(gl, texture, pixels) {
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.uploadPixelDataToTexture = uploadPixelDataToTexture;
function uploadDataToTexture(gl, texture, width, height, data, textureFormat) {
    webgl_util.validateTextureSize(width, height);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, gl.FLOAT, data); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
function uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels, textureConfig) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var unpackedArray;
    if (textureConfig.defaultNumChannels === 1) {
        unpackedArray = matrix;
    }
    else {
        unpackedArray =
            new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, numChannels));
        tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, numChannels);
    }
    uploadDataToTexture(gl, texture, w, h, unpackedArray, textureConfig.textureFormatFloat);
}
exports.uploadMatrixToTexture = uploadMatrixToTexture;
function uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix, textureConfig) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);
    uploadDataToTexture(gl, texture, w, h, packedRGBA, gl.RGBA);
}
exports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;
function maybeCreateBufferFromOutputTexture(gl, texture, rows, columns, textureConfig) {
    var bufferOrTexture = texture;
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        var gl2_1 = gl;
        var buffer_1 = gl2_1.createBuffer();
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl2_1.PIXEL_PACK_BUFFER, buffer_1); });
        var bytesPerFloat = 4;
        var bufferSizeBytes_1 = bytesPerFloat *
            tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, textureConfig.downloadUnpackNumChannels);
        webgl_util.callAndCheck(gl, function () { return gl.bufferData(gl2_1.PIXEL_PACK_BUFFER, bufferSizeBytes_1, gl.STATIC_DRAW); });
        webgl_util.callAndCheck(gl, function () { return gl2_1.readPixels(0, 0, columns, rows, gl.RGBA, gl.FLOAT, 0); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl2_1.PIXEL_PACK_BUFFER, null); });
        bufferOrTexture = buffer_1;
    }
    return bufferOrTexture;
}
exports.maybeCreateBufferFromOutputTexture = maybeCreateBufferFromOutputTexture;
function downloadFloat32MatrixFromBuffer(gl, buffer, rows, columns, textureConfig) {
    var gl2 = gl;
    var downloadTarget = new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, textureConfig.downloadUnpackNumChannels));
    gl2.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl2.getBufferSubData(gl.ARRAY_BUFFER, 0, downloadTarget);
    gl2.bindBuffer(gl.ARRAY_BUFFER, null);
    var matrix = new Float32Array(rows * columns);
    tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, textureConfig.downloadUnpackNumChannels);
    return matrix;
}
exports.downloadFloat32MatrixFromBuffer = downloadFloat32MatrixFromBuffer;
function downloadFloat32MatrixFromOutputTexture(gl, rows, columns, textureConfig) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var downloadTarget = new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, textureConfig.downloadUnpackNumChannels));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.FLOAT, downloadTarget); });
    var matrix = new Float32Array(rows * columns);
    tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, textureConfig.downloadUnpackNumChannels);
    return matrix;
}
exports.downloadFloat32MatrixFromOutputTexture = downloadFloat32MatrixFromOutputTexture;
function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var numChannels = 4;
    var downloadTarget = new Uint8Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget); });
    return new Float32Array(downloadTarget.buffer);
}
exports.downloadByteEncodedFloatMatrixFromOutputTexture = downloadByteEncodedFloatMatrixFromOutputTexture;
function downloadMatrixFromPackedOutputTexture(gl, logicalRows, logicalCols, physicalRows, physicalCols, textureConfig) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(physicalRows, physicalCols), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, packedRGBA); });
    var matrix = new Float32Array(logicalRows * logicalCols);
    return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, logicalRows, logicalCols, matrix);
}
exports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;

},{"../../environment":60,"./tex_util":129,"./webgl_util":135}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Im2ColProgram = (function () {
    function Im2ColProgram(outputShape, inputShape, convInfo) {
        this.variableNames = ['A'];
        this.outputShape = outputShape;
        var filterWidth = convInfo.filterWidth, inChannels = convInfo.inChannels, strideWidth = convInfo.strideWidth, strideHeight = convInfo.strideHeight, padInfo = convInfo.padInfo, outWidth = convInfo.outWidth, dilationWidth = convInfo.dilationWidth, dilationHeight = convInfo.dilationHeight;
        var left = padInfo.left, top = padInfo.top;
        var itemsPerBlockRow = inChannels * filterWidth;
        this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            int blockIndex = rc.y + col;\n            int pos = rc.x + row;\n\n            if(blockIndex >= " + outputShape[1] + " || pos >= " + outputShape[0] + ") continue;\n\n            int offsetY = int(blockIndex / (" + outWidth + ")) * " + strideHeight + " - " + top + ";\n            int d0 = offsetY + " + dilationHeight + " * (pos / " + itemsPerBlockRow + ");\n\n            if(d0 >= " + inputShape[0] + " || d0 < 0) continue;\n\n            int offsetX = int(mod(float(blockIndex), " + outWidth + ".) * " + strideWidth + ". - " + left + ".);\n            int d1 = offsetX + " + dilationWidth + " * (int(mod(float(pos), " + itemsPerBlockRow + ".) / " + inChannels + ".));\n\n            if(d1 >= " + inputShape[1] + " || d1 < 0) continue;\n\n            result[row * 2 + col] = getA(d0, d1, int(mod(float(pos), " + inChannels + ".)));\n          }\n        }\n\n        gl_FragColor = result;\n      }\n    ";
    }
    return Im2ColProgram;
}());
exports.Im2ColProgram = Im2ColProgram;

},{}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LRNProgram = (function () {
    function LRNProgram(xShape, radius, bias, alpha, beta) {
        this.variableNames = ['x'];
        this.outputShape = [];
        var rad = radius;
        var maxD = xShape[3] - 1;
        this.outputShape = xShape;
        var powOperator;
        var basis = "float(" + bias + ") + float(" + alpha + ") * sum";
        if (beta === 0.5) {
            powOperator = "inversesqrt(" + basis + ")";
        }
        else if (beta === 1.0) {
            powOperator = "1.0/(" + basis + ")";
        }
        else {
            powOperator = "exp(log(" + basis + ") * float(-" + beta + "));";
        }
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + rad + "; j <= " + rad + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + maxD + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + powOperator + ";\n        setOutput(val);\n      }\n    ";
    }
    return LRNProgram;
}());
exports.LRNProgram = LRNProgram;

},{}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LRNGradProgram = (function () {
    function LRNGradProgram(inputShape, depthRadius, bias, alpha, beta) {
        this.variableNames = ['inputImage', 'outputImage', 'dy'];
        this.outputShape = [];
        this.outputShape = inputShape;
        this.depth = inputShape[3];
        this.depthRadius = depthRadius;
        this.bias = bias;
        this.alpha = alpha;
        this.beta = beta;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + depthRadius + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + depthRadius + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + alpha + ") * norm + float(" + bias + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + alpha + ")\n                * float(" + beta + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + beta + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ";
    }
    return LRNGradProgram;
}());
exports.LRNGradProgram = LRNGradProgram;

},{}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MaxPool2DBackpropProgram = (function () {
    function MaxPool2DBackpropProgram(convInfo) {
        this.variableNames = ['dy', 'maxPos'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var lastIndex = filterHeight * filterWidth - 1;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + lastIndex + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + filterWidth + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return MaxPool2DBackpropProgram;
}());
exports.MaxPool2DBackpropProgram = MaxPool2DBackpropProgram;

},{}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MatMulProgram = (function () {
    function MatMulProgram(aShape, bShape, transposeA, transposeB) {
        if (transposeA === void 0) { transposeA = false; }
        if (transposeB === void 0) { transposeB = false; }
        this.variableNames = ['matrixA', 'matrixB'];
        var batchSize = aShape[0];
        var outerShapeA = transposeA ? aShape[2] : aShape[1];
        var outerShapeB = transposeB ? bShape[1] : bShape[2];
        var sharedDim = transposeA ? aShape[1] : aShape[2];
        this.outputShape = [batchSize, outerShapeA, outerShapeB];
        var aSnippetFromOffset = function (vec4Offset, indexVar) {
            return transposeA ? "batch, " + indexVar + " + " + vec4Offset + ", aRow" :
                "batch, aRow, " + indexVar + " + " + vec4Offset;
        };
        var bSnippetFromOffset = function (vec4Offset, indexVar) {
            return transposeB ? "batch, bCol, " + indexVar + " + " + vec4Offset :
                "batch, " + indexVar + " + " + vec4Offset + ", bCol";
        };
        var sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;
        var sharedDimVec4Remainder = sharedDim % 4;
        this.userCode = " float dotARowBCol(int batch, int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < " + sharedDimNearestVec4 + "; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(" + aSnippetFromOffset(0, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(1, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(2, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(3, 'i') + ")\n        );\n        vec4 b = vec4(\n          getMatrixB(" + bSnippetFromOffset(0, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(1, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(2, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(3, 'i') + ")\n        );\n\n        result += dot(a, b);\n      }\n\n      if (" + (sharedDimVec4Remainder === 1) + ") {\n        result += getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + ") *\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + ");\n      } else if (" + (sharedDimVec4Remainder === 2) + ") {\n        vec2 a = vec2(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        vec2 b = vec2(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      } else if (" + (sharedDimVec4Remainder === 3) + ") {\n        vec3 a = vec3(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        vec3 b = vec3(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec3 resBRC = getOutputCoords();\n      setOutput(dotARowBCol(resBRC.x, resBRC.y, resBRC.z));\n    }\n    ";
    }
    return MatMulProgram;
}());
exports.MatMulProgram = MatMulProgram;

},{}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MatMulPackedProgram = (function () {
    function MatMulPackedProgram(aShape, bShape, outputShape, transposeA, transposeB) {
        if (transposeA === void 0) { transposeA = false; }
        if (transposeB === void 0) { transposeB = false; }
        this.variableNames = ['matrixA', 'matrixB'];
        this.outputShape = outputShape;
        var sharedDim = transposeA ? aShape[0] : aShape[1];
        var sharedDimensionPacked = Math.ceil(sharedDim / 2);
        var aSample = transposeA ? 'i * 2, rc.x' : 'rc.x, i * 2';
        var bSample = transposeB ? 'rc.y, i * 2' : 'i * 2, rc.y';
        var aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];
        var bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];
        this.userCode = "\n      const float sharedDimension = " + sharedDimensionPacked + ".0;\n\n      vec4 dot2x2ARowBCol(ivec2 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + sharedDimensionPacked + "; i++) {\n          vec4 a = getMatrixA(" + aSample + ");\n          vec4 b = getMatrixB(" + bSample + ");\n\n          result += (" + aSwizzle[0] + " * " + bSwizzle[0] + ") + (" + aSwizzle[1] + " * " + bSwizzle[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n        gl_FragColor = dot2x2ARowBCol(rc);\n      }\n    ";
    }
    return MatMulPackedProgram;
}());
exports.MatMulPackedProgram = MatMulPackedProgram;

},{}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MultinomialProgram = (function () {
    function MultinomialProgram(batchSize, numOutcomes, numSamples) {
        this.variableNames = ['probs'];
        this.outputShape = [batchSize, numSamples];
        this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (numOutcomes - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (numOutcomes - 1) + "));\n      }\n    ";
    }
    MultinomialProgram.prototype.getCustomSetupFunc = function (seed) {
        var _this = this;
        return function (gpgpu, webGLProgram) {
            if (_this.seedLoc == null) {
                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
            }
            gpgpu.gl.uniform1f(_this.seedLoc, seed);
        };
    };
    return MultinomialProgram;
}());
exports.MultinomialProgram = MultinomialProgram;

},{}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var OneHotProgram = (function () {
    function OneHotProgram(numIndices, depth, onValue, offValue) {
        this.variableNames = ['indices'];
        this.outputShape = [numIndices, depth];
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + offValue + "), float(" + onValue + "),\n                      float(index == coords.y)));\n      }\n    ";
    }
    return OneHotProgram;
}());
exports.OneHotProgram = OneHotProgram;

},{}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PackProgram = (function () {
    function PackProgram(outputShape) {
        this.variableNames = ['A'];
        this.outputShape = outputShape;
        this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        int r = rc.x;\n        int c = rc.y;\n\n        if(r >= " + outputShape[0] + " || c >= " + outputShape[1] + ") {\n          gl_FragColor = vec4(0);\n        } else {\n          int rp1 = r + 1;\n          int cp1 = c + 1;\n\n          bool cEdge = cp1 >= " + outputShape[1] + ";\n          bool rEdge = rp1 >= " + outputShape[0] + ";\n\n          gl_FragColor = vec4(\n              getA(r, c),\n              cEdge ? 0. : getA(r, cp1),\n              rEdge ? 0. : getA(rp1, c),\n              rEdge || cEdge ? 0. : getA(rp1, cp1)\n            );\n        }\n      }\n    ";
    }
    return PackProgram;
}());
exports.PackProgram = PackProgram;

},{}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var PadProgram = (function () {
    function PadProgram(xShape, paddings, constantValue) {
        this.variableNames = ['x'];
        this.outputShape = paddings.map(function (p, i) { return p[0] + xShape[i] + p[1]; });
        var rank = xShape.length;
        var type = shader_compiler_1.getCoordsDataType(rank);
        var start = paddings.map(function (p) { return p[0]; }).join(',');
        var end = paddings.map(function (p, i) { return p[0] + xShape[i]; }).join(',');
        var unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);
        if (rank === 1) {
            this.userCode = "\n        int start = " + start + ";\n        int end = " + end + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + constantValue + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
            return;
        }
        this.userCode = "\n      " + type + " start = " + type + "(" + start + ");\n      " + type + " end = " + type + "(" + end + ");\n\n      void main() {\n        " + type + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + constantValue + "));\n        } else {\n          " + type + " coords = outC - start;\n          setOutput(getX(" + unpackedCoords + "));\n        }\n      }\n    ";
    }
    return PadProgram;
}());
exports.PadProgram = PadProgram;

},{"./shader_compiler":126}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Pool2DProgram = (function () {
    function Pool2DProgram(convInfo, poolType, computePositions) {
        this.variableNames = ['x'];
        if (poolType === 'avg' && computePositions) {
            throw new Error('Cannot compute positions for average pool.');
        }
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        var isAvgPool = poolType === 'avg';
        var initializationValue = '0.0';
        if (!isAvgPool) {
            initializationValue = '-1.0 / 0.0';
        }
        if (computePositions) {
            var compareOp_1 = '>=';
            this.userCode = "\n        const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n        const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + filterHeight + "; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + filterWidth + "; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value " + compareOp_1 + " currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + filterWidth + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
            return;
        }
        var compareOp = 'max';
        var returnValue = poolType + "(" + poolType + "(" + poolType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (poolType === 'avg') {
            returnValue = "avgValue / count";
        }
        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        var filterWidthVec4Remainder = filterWidth % 4;
        var updateSnippet = "\n      if (" + isAvgPool + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidthNearestVec4 + "; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              getValue(batch, xR, xC + 3, d)\n            );\n\n            " + updateSnippet + "\n          }\n\n          int xC = xCCorner + " + filterWidthNearestVec4 + ";\n          if (" + (filterWidthVec4Remainder === 1) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 3) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          }\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return Pool2DProgram;
}());
exports.Pool2DProgram = Pool2DProgram;

},{}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReduceProgram = (function () {
    function ReduceProgram(reduceInfo, reduceType) {
        this.variableNames = ['x'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        this.outputShape = [batchSize, outSize];
        var initializationValue = '0.0';
        var compareOp = "";
        if (reduceType === 'prod') {
            initializationValue = '1.0';
        }
        else if (reduceType === 'min') {
            initializationValue = '1.0 / 0.0';
            compareOp = "min";
        }
        else if (reduceType === 'max') {
            initializationValue = '-1.0 / 0.0';
            compareOp = "max";
        }
        var returnValue = reduceType + "(" + reduceType + "(" + reduceType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (reduceType === 'sum') {
            returnValue = "sumValue";
        }
        else if (reduceType === 'prod') {
            returnValue = "prodValue";
        }
        else if (reduceType === 'all') {
            returnValue = "allValue";
        }
        else if (reduceType === 'any') {
            returnValue = "anyValue";
        }
        var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        var windowSizeVec4Remainder = windowSize % 4;
        var updateSnippet = "\n      if (" + (reduceType === 'sum') + ") {\n        sumValue += dot(values, ones);\n      } else if (" + (reduceType === 'prod') + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        var vecType = "vec4";
        if (reduceType === 'all') {
            initializationValue = '1.0';
            updateSnippet = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ";
            vecType = "bvec4";
        }
        else if (reduceType === 'any') {
            initializationValue = '0.0';
            updateSnippet = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ";
            vecType = "bvec4";
        }
        var checkOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkOutOfBounds = "\n        if (inIdx < 0 || inIdx >= " + inSize + ") {\n          return initializationValue;\n        }\n      ";
        }
        this.userCode = "\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + checkOutOfBounds + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + windowSizeNearestVec4 + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + vecType + " values = " + vecType + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + updateSnippet + "\n        }\n\n        int inIdx = inOffset + " + windowSizeNearestVec4 + ";\n        if (" + (windowSizeVec4Remainder === 1) + ") {\n          " + vecType + " values = " + vecType + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 2) + ") {\n          " + vecType + " values = " + vecType + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 3) + ") {\n          " + vecType + " values = " + vecType + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + updateSnippet + "\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return ReduceProgram;
}());
exports.ReduceProgram = ReduceProgram;

},{}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeBilinearBackpropProgram = (function () {
    function ResizeBilinearBackpropProgram(dy, x, alignCorners) {
        this.variableNames = ['dy'];
        this.outputShape = [];
        this.outputShape = x.shape;
        var _a = x.shape, xHeight = _a[1], xWidth = _a[2];
        var _b = dy.shape, yHeight = _b[1], yWidth = _b[2];
        var effectiveXSize = [
            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,
            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth
        ];
        var effectiveYSize = [
            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,
            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth
        ];
        var heightScale = effectiveXSize[0] / effectiveYSize[0];
        var widthScale = effectiveXSize[1] / effectiveYSize[1];
        var invHeightScale = 1 / heightScale;
        var invWidthScale = 1 / widthScale;
        var winHeight = (Math.ceil(invHeightScale) * 2) + 2;
        var winWidth = (Math.ceil(invWidthScale) * 2) + 2;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + heightScale + ");\n        const float widthScale = float(" + widthScale + ");\n\n        const float invHeightScale = float(" + invHeightScale + ");\n        const float invWidthScale = float(" + invWidthScale + ");\n\n        const int winHeight = int(" + winHeight + ");\n        const int winWidth = int(" + winWidth + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + yHeight + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + yWidth + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (xHeight - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (xWidth - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
    }
    return ResizeBilinearBackpropProgram;
}());
exports.ResizeBilinearBackpropProgram = ResizeBilinearBackpropProgram;

},{}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeBilinearProgram = (function () {
    function ResizeBilinearProgram(inputShape, newHeight, newWidth, alignCorners) {
        this.variableNames = ['A'];
        this.outputShape = [];
        var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2], depth = inputShape[3];
        this.outputShape = [batch, newHeight, newWidth, depth];
        var effectiveInSize = [
            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,
            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth
        ];
        var effectiveOutSize = [
            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,
            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth
        ];
        this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInSize[0] / effectiveOutSize[0] + ",\n          " + effectiveInSize[1] / effectiveOutSize[1] + ");\n      const vec2 inputShapeRC = vec2(" + oldHeight + ".0, " + oldWidth + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
    }
    return ResizeBilinearProgram;
}());
exports.ResizeBilinearProgram = ResizeBilinearProgram;

},{}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeNearestNeigborBackpropProgram = (function () {
    function ResizeNearestNeigborBackpropProgram(dy, x, alignCorners) {
        this.variableNames = ['dy'];
        this.outputShape = [];
        this.outputShape = x.shape;
        var _a = x.shape, xHeight = _a[1], xWidth = _a[2];
        var _b = dy.shape, yHeight = _b[1], yWidth = _b[2];
        var effectiveXSize = [
            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,
            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth
        ];
        var effectiveYSize = [
            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,
            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth
        ];
        var heightScale = effectiveXSize[0] / effectiveYSize[0];
        var widthScale = effectiveXSize[1] / effectiveYSize[1];
        var invHeightScale = 1 / heightScale;
        var invWidthScale = 1 / widthScale;
        var winHeight = (Math.ceil(invHeightScale) * 2) + 2;
        var winWidth = (Math.ceil(invWidthScale) * 2) + 2;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + heightScale + ");\n        const float widthScale = float(" + widthScale + ");\n\n        const float invHeightScale = float(" + invHeightScale + ");\n        const float invWidthScale = float(" + invWidthScale + ");\n\n        const int winHeight = int(" + winHeight + ");\n        const int winWidth = int(" + winWidth + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + yHeight + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + yWidth + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + effectiveXSize[0] + ") *\n                (float(dyR) / float(" + effectiveYSize[0] + "));\n\n            float sourceFracCol =\n                float(" + effectiveXSize[1] + ") *\n                  (float(dyC) / float(" + effectiveYSize[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + xHeight + ") - 1),\n                " + alignCorners + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + xWidth + ") - 1),\n                " + alignCorners + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
    }
    return ResizeNearestNeigborBackpropProgram;
}());
exports.ResizeNearestNeigborBackpropProgram = ResizeNearestNeigborBackpropProgram;

},{}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeNearestNeighborProgram = (function () {
    function ResizeNearestNeighborProgram(inputShape, newHeight, newWidth, alignCorners) {
        this.variableNames = ['A'];
        this.outputShape = [];
        var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2], depth = inputShape[3];
        this.outputShape = [batch, newHeight, newWidth, depth];
        var effectiveInSize = [
            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,
            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth
        ];
        var effectiveOutSize = [
            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,
            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth
        ];
        var roundBase = alignCorners ? '0.5' : '0.0';
        this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInSize[0] / effectiveOutSize[0] + ",\n          " + effectiveInSize[1] / effectiveOutSize[1] + ");\n      const vec2 inputShapeRC = vec2(" + oldHeight + ".0, " + oldWidth + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + roundBase + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ";
    }
    return ResizeNearestNeighborProgram;
}());
exports.ResizeNearestNeighborProgram = ResizeNearestNeighborProgram;

},{}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var ReverseProgram = (function () {
    function ReverseProgram(xShape, axis) {
        this.variableNames = ['x'];
        var rank = xShape.length;
        if (rank > 4) {
            throw new Error("WebGL backend: Reverse of rank-" + rank + " tensor is not yet supported");
        }
        this.outputShape = xShape;
        if (rank === 1) {
            this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + xShape[0] + " - coord - 1));\n        }\n      ";
            return;
        }
        var getInCoord = function (i) {
            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
                return xShape[i] + " - coords[" + i + "] - 1";
            }
            return "coords[" + i + "]";
        };
        var inCoords = xShape.map(function (_, i) { return getInCoord(i); }).join(',');
        var type = shader_compiler_1.getCoordsDataType(rank);
        this.userCode = "\n      void main() {\n        " + type + " coords = getOutputCoords();\n        setOutput(getX(" + inCoords + "));\n      }\n    ";
    }
    return ReverseProgram;
}());
exports.ReverseProgram = ReverseProgram;

},{"./shader_compiler":126}],123:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var ScatterNDProgram = (function () {
    function ScatterNDProgram(updateSize, sliceDim, strides, shape) {
        this.updateSize = updateSize;
        this.sliceDim = sliceDim;
        this.strides = strides;
        this.variableNames = ['updates', 'indices'];
        this.outputShape = shape;
        var stridesType = shader_compiler_1.getCoordsDataType(strides.length);
        var dtype = shader_compiler_1.getCoordsDataType(shape.length);
        var strideString = this.sliceDim > 1 ? 'strides[j]' : 'strides';
        this.userCode = "\n        " + stridesType + " strides = " + stridesType + "(" + this.strides + ");\n\n        void main() {\n          " + dtype + " coords = getOutputCoords();\n          float sum = 0.0;\n          for (int i = 0; i < " + this.updateSize + "; i++) {\n            int flattenIndex = 0;\n            for (int j = 0; j < " + this.sliceDim + "; j++) {\n              int index = round(getIndices(i, j));\n              flattenIndex += index * " + strideString + ";\n            }\n            if (flattenIndex == coords[0]) {\n              sum += getUpdates(i, coords[1]);\n            }\n          }\n          setOutput(sum);\n        }\n      ";
    }
    return ScatterNDProgram;
}());
exports.ScatterNDProgram = ScatterNDProgram;

},{"./shader_compiler":126}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SegmentOpProgram = (function () {
    function SegmentOpProgram(segOpInfo, segOpType) {
        this.variableNames = ['x', 'segmentIds'];
        var windowSize = segOpInfo.windowSize;
        var batchSize = segOpInfo.batchSize;
        var inSize = segOpInfo.inSize;
        var numSegments = segOpInfo.numSegments;
        var outSize = numSegments * Math.ceil(inSize / windowSize);
        this.outputShape = [batchSize, outSize];
        var initializationValue = '0.0';
        var returnValue = "sumValue";
        var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        var windowSizeVec4Remainder = windowSize % 4;
        var updateSnippet = "\n        sumValue += dot(values, filter);\n    ";
        var checkValueOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkValueOutOfBounds = "\n        if (inIdx < 0 || inIdx >= " + inSize + ") {\n          return initializationValue;\n        }\n      ";
        }
        var checkSegmentIdOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkSegmentIdOutOfBounds = "\n        if (inIdx < 0 || inIdx >= " + inSize + ") {\n          return -1.0;\n        }\n      ";
        }
        this.userCode = "\n      const float initializationValue = " + initializationValue + ";\n\n      float getValue(int batch, int inIdx) {\n        " + checkValueOutOfBounds + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + checkSegmentIdOutOfBounds + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + numSegments + ")) * float(" + windowSize + "));\n        int currentSeg = int(mod(float(outIdx), float(" + numSegments + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + windowSizeNearestVec4 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + updateSnippet + "\n        }\n\n        int inIdx = inOffset + " + windowSizeNearestVec4 + ";\n        if (" + (windowSizeVec4Remainder === 1) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + updateSnippet + "\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return SegmentOpProgram;
}());
exports.SegmentOpProgram = SegmentOpProgram;

},{}],125:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var SelectProgram = (function () {
    function SelectProgram(cRank, shape, rank) {
        this.variableNames = ['c', 'a', 'b'];
        this.outputShape = shape;
        var cCoords;
        var abCoords;
        if (rank > 4) {
            throw Error("Where for rank " + rank + " is not yet supported");
        }
        if (rank === 1) {
            abCoords = "resRC";
            cCoords = "resRC";
        }
        else {
            var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
            var cCoordVars = [];
            var abCoordVars = [];
            for (var i = 0; i < shape.length; i++) {
                abCoordVars.push("" + currentCoords[i]);
                if (i < cRank) {
                    cCoordVars.push("" + currentCoords[i]);
                }
            }
            cCoords = cCoordVars.join();
            abCoords = abCoordVars.join();
        }
        var dtype = shader_compiler_1.getCoordsDataType(rank);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        float cVal = getC(" + cCoords + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + abCoords + "));\n        } else {\n          setOutput(getB(" + abCoords + "));\n        }\n      }\n    ";
    }
    return SelectProgram;
}());
exports.SelectProgram = SelectProgram;

},{"./shader_compiler":126}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../../ops/broadcast_util");
var util = require("../../util");
function makeShader(inputsInfo, outputShape, userCode, broadcast) {
    var inputPrefixSnippet = inputsInfo.map(function (x) {
        var size = util.sizeFromShape(x.shapeInfo.logicalShape);
        if (x.shapeInfo.isUniform) {
            return "uniform float " + x.name + (size > 1 ? "[" + size + "]" : '') + ";";
        }
        return "uniform sampler2D " + x.name + ";";
    });
    inputPrefixSnippet = inputPrefixSnippet.join('\n');
    var inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })
        .join('\n');
    var outTexShape = outputShape.texShape;
    var outputSamplingSnippet;
    if (outputShape.isPacked) {
        outputSamplingSnippet =
            getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
    }
    else {
        outputSamplingSnippet =
            getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
    }
    var source = [
        SHADER_PREFIX, FLOAT_TEXTURE_SAMPLE_SNIPPET,
        FLOAT_TEXTURE_SETOUTPUT_SNIPPET, inputPrefixSnippet, outputSamplingSnippet,
        inputSamplingSnippet, userCode
    ].join('\n');
    return source;
}
exports.makeShader = makeShader;
function getSamplerFromInInfo(inInfo) {
    var shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
        case 0:
            return getSamplerScalar(inInfo);
        case 1:
            return getSampler1D(inInfo);
        case 2:
            return getSampler2D(inInfo);
        case 3:
            return getSampler3D(inInfo);
        case 4:
            return getSampler4D(inInfo);
        case 5:
            return getSampler5D(inInfo);
        case 6:
            return getSampler6D(inInfo);
        default:
            throw new Error(shape.length + "-D input sampling" +
                " is not yet supported");
    }
}
function getPackedSamplerFromInInfo(inInfo) {
    var shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
        case 2:
            return getPackedSampler2D(inInfo);
        default:
            throw new Error("Packed " + shape.length + "-D input sampling" +
                " is not yet supported");
    }
}
function getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {
    var res = getSamplerFlat(inInfo);
    if (inInfo.shapeInfo.isPacked) {
        res += getPackedSamplerFromInInfo(inInfo);
    }
    else {
        res += getSamplerFromInInfo(inInfo);
    }
    if (broadcast ||
        util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {
        res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast);
    }
    return res;
}
function getPackedOutputSamplingSnippet(outShape, outTexShape) {
    switch (outShape.length) {
        case 0:
            return getOutputScalarCoords();
        case 2:
            return getOutputPacked2DCoords(outShape, outTexShape);
        default:
            throw new Error(outShape.length + "-D output packed sampling is not yet supported");
    }
}
function getOutputSamplingSnippet(outShape, outTexShape) {
    switch (outShape.length) {
        case 0:
            return getOutputScalarCoords();
        case 1:
            return getOutput1DCoords(outShape, outTexShape);
        case 2:
            return getOutput2DCoords(outShape, outTexShape);
        case 3:
            return getOutput3DCoords(outShape, outTexShape);
        case 4:
            return getOutput4DCoords(outShape, outTexShape);
        case 5:
            return getOutput5DCoords(outShape, outTexShape);
        case 6:
            return getOutput6DCoords(outShape, outTexShape);
        default:
            throw new Error(outShape.length + "-D output sampling is not yet supported");
    }
}
var SAMPLE_1D_SNIPPET = "\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_2D_SNIPPET = "\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_3D_SNIPPET = "\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_4D_SNIPPET = "\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_5D_SNIPPET = "\nvec2 UVfrom5D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int stride3, int row, int col, int depth,\n    int depth2, int depth3) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 +\n              depth * stride2 + depth2 * stride3 + depth3;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_6D_SNIPPET = "\nvec2 UVfrom6D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int stride3, int stride4,\n    int row, int col, int depth, int depth2, int depth3, int depth4) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2 *\n    stride3 + depth3 * stride4 + depth4;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var FLOAT_TEXTURE_SAMPLE_SNIPPET = "\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\n    return texture2D(textureSampler, uv).r;\n  }\n";
var FLOAT_TEXTURE_SETOUTPUT_SNIPPET = "\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n";
var SHADER_PREFIX = "\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  struct ivec5\n  {\n    int x;\n    int y;\n    int z;\n    int w;\n    int u;\n  };\n\n  struct ivec6\n  {\n    int x;\n    int y;\n    int z;\n    int w;\n    int u;\n    int v;\n  };\n\n  bool isNaN(float val) {\n    return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  //Based on the work of Dave Hoskins\n  //https://www.shadertoy.com/view/4djSRW\n  #define HASHSCALE1 443.8975\n  float random(float seed){\n    vec2 p = resultUV * seed;\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n  }\n\n  " + SAMPLE_1D_SNIPPET + "\n  " + SAMPLE_2D_SNIPPET + "\n  " + SAMPLE_3D_SNIPPET + "\n  " + SAMPLE_4D_SNIPPET + "\n  " + SAMPLE_5D_SNIPPET + "\n  " + SAMPLE_6D_SNIPPET + "\n";
function getOutputScalarCoords() {
    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
}
function getOutput1DCoords(shape, texShape) {
    if (texShape[0] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + texShape[1] + ".0);\n      }\n    ";
    }
    if (texShape[1] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + texShape[0] + ".0);\n      }\n    ";
    }
    return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      return resTexRC.x * " + texShape[1] + " + resTexRC.y;\n    }\n  ";
}
function getOutput3DCoords(shape, texShape) {
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n      int c = index / " + stride1 + ";\n      int d = index - c * " + stride1 + ";\n      return ivec3(r, c, d);\n    }\n  ";
}
function getOutput4DCoords(shape, texShape) {
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      int d2 = index - d * " + stride2 + ";\n\n      return ivec4(r, c, d, d2);\n    }\n  ";
}
function getOutput5DCoords(shape, texShape) {
    var stride3 = shape[4];
    var stride2 = shape[3] * stride3;
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + texShape[0] + ",\n                             " + texShape[1] + "));\n\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      index -= d * " + stride2 + ";\n\n      int d2 = index  / " + stride3 + ";\n      int d3 = index - d2 * " + stride3 + ";\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";
}
function getOutput6DCoords(shape, texShape) {
    var stride4 = shape[5];
    var stride3 = shape[4] * stride4;
    var stride2 = shape[3] * stride3;
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      index -= d * " + stride2 + ";\n\n      int d2 = index / " + stride3 + ";\n      index -= d2 * " + stride3 + ";\n\n      int d3 = index / " + stride4 + ";\n      int d4 = index - d3 * " + stride4 + ";\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";
}
function getOutputPacked2DCoords(shape, texShape) {
    var packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    if (util.arraysEqual(shape, texShape)) {
        return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + packedTexShape[0] + ", " + packedTexShape[1] + "));\n      }\n    ";
    }
    var texelsInLogicalRow = Math.ceil(shape[1] / 2);
    return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + packedTexShape[0] + ", " + packedTexShape[1] + "));\n\n      int index = resTexRC.x * " + packedTexShape[1] + " + resTexRC.y;\n      int r = 2 * (index / " + texelsInLogicalRow + ");\n      int c = imod(index, " + texelsInLogicalRow + ") * 2;\n\n      return ivec2(r, c);\n    }\n  ";
}
function getOutput2DCoords(shape, texShape) {
    if (util.arraysEqual(shape, texShape)) {
        return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + texShape[0] + ", " + texShape[1] + "));\n      }\n    ";
    }
    if (shape[1] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
    }
    if (shape[0] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
    }
    return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + shape[1] + ";\n      int c = index - r * " + shape[1] + ";\n      return ivec2(r, c);\n    }\n  ";
}
function getSamplerScalar(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    if (inputInfo.shapeInfo.isUniform) {
        return "float " + funcName + "() {return " + texName + ";}";
    }
    return "\n    float " + funcName + "() {\n      return sampleTexture(" + texName + ", halfCR);\n    }\n  ";
}
function getSampler1D(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "(int index) {\n      return " + funcName + "Flat(index);\n    }\n  ";
}
function getPackedSampler2D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texShape = inputInfo.shapeInfo.texShape;
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    if (texShape != null && util.arraysEqual(shape, texShape)) {
        return "\n      vec4 " + funcName + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n\n        return texture2D(" + texName + ", uv);\n      }\n    ";
    }
    var packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    var valuesPerRow = Math.ceil(shape[1] / 2);
    return "\n    vec4 " + funcName + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + valuesPerRow + ", " + packedTexShape[0] + ", " + packedTexShape[1] + ", row, col);\n      return texture2D(" + texName + ", uv);\n    }\n  ";
}
function getSampler2D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texShape = inputInfo.shapeInfo.texShape;
    if (texShape != null && util.arraysEqual(shape, texShape)) {
        var texNumR_1 = texShape[0];
        var texNumC_1 = texShape[1];
        return "\n    float " + funcName + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + texNumC_1 + ".0, " + texNumR_1 + ".0);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
    }
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    var squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        var params = ['row', 'col'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (inputInfo.shapeInfo.isUniform) {
        return "\n      float " + funcName + "(int row, int col) {\n        float index = dot(vec2(row, col), vec2(" + shape[1] + ", 1));\n        return " + funcName + "Flat(round(index));\n      }\n    ";
    }
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    if (texNumC === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      float index = dot(vec2(row, col), vec2(" + shape[1] + ", 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + texNumR + ".0);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
    }
    if (texNumR === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      float index = dot(vec2(row, col), vec2(" + shape[1] + ", 1));\n      vec2 uv = vec2((index + 0.5) / " + texNumC + ".0, 0.5);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
    }
    return "\n  float " + funcName + "(int row, int col) {\n    vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n    return sampleTexture(" + texName + ", uv);\n  }\n";
}
function getSampler3D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    var squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        var params = ['row', 'col', 'depth'];
        return "\n        " + getSamplerFromInInfo(newInputInfo) + "\n        float " + funcName + "(int row, int col, int depth) {\n          return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n        }\n      ";
    }
    if (inputInfo.shapeInfo.isUniform) {
        return "\n      float " + funcName + "(int row, int col, int depth) {\n        float index = dot(vec3(row, col, depth),\n                          vec3(" + stride0 + ", " + stride1 + ", 1));\n        return " + funcName + "Flat(round(index));\n      }\n    ";
    }
    var texShape = inputInfo.shapeInfo.texShape;
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    if (texNumC === stride0) {
        return "\n        float " + funcName + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + stride1 + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sampleTexture(" + texName + ", uv);\n        }\n      ";
    }
    if (texNumC === stride1) {
        return "\n    float " + funcName + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + shape[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
    }
    return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            " + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ", row, col, depth);\n        return sampleTexture(" + texName + ", uv);\n      }\n  ";
}
function getSampler4D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    if (newShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, newShape);
        var params = ['row', 'col', 'depth', 'depth2'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (inputInfo.shapeInfo.isUniform) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        float index = dot(vec4(row, col, depth, depth2),\n                          vec4(" + stride0 + ", " + stride1 + ", " + stride2 + ", 1));\n        return " + funcName + "Flat(round(index));\n      }\n    ";
    }
    var texShape = inputInfo.shapeInfo.texShape;
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    if (texNumC === stride0) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2), vec3(" + stride1 + ", " + stride2 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    if (texNumC === stride2) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + shape[1] * shape[2] + ", " + shape[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", row, col, depth, depth2);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
}
function getSampler5D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var stride3 = shape[4];
    var stride2 = shape[3] * stride3;
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    if (newShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, newShape);
        var params = ['row', 'col', 'depth', 'depth2', 'depth3'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (inputInfo.shapeInfo.isUniform) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + stride0 + ", " + stride1 + ", " + stride2 + ", " + stride3 + ")) +\n          depth3;\n        return " + funcName + "Flat(index);\n      }\n    ";
    }
    var texShape = inputInfo.shapeInfo.texShape;
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    if (texNumC === stride0) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(\n          vec4(col, depth, depth2, depth3),\n          vec4(" + stride1 + ", " + stride2 + ", " + stride3 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    if (texNumC === stride3) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + shape[1] * shape[2] * shape[3] + ", " + shape[2] * shape[3] + ",\n            " + shape[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n      vec2 uv = UVfrom5D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", " + stride3 + ", row, col, depth, depth2, depth3);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
}
function getSampler6D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var stride4 = shape[5];
    var stride3 = shape[4] * stride4;
    var stride2 = shape[3] * stride3;
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    if (newShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, newShape);
        var params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (inputInfo.shapeInfo.isUniform) {
        return "\n      float " + funcName + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + stride0 + ", " + stride1 + ", " + stride2 + ", " + stride3 + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + stride4 + ", 1));\n        return " + funcName + "Flat(index);\n      }\n    ";
    }
    var texShape = inputInfo.shapeInfo.texShape;
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    if (texNumC === stride0) {
        return "\n      float " + funcName + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(\n          vec4(col, depth, depth2, depth3),\n          vec4(" + stride1 + ", " + stride2 + ", " + stride3 + ", " + stride4 + ")) + depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    if (texNumC === stride4) {
        return "\n      float " + funcName + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + shape[1] * shape[2] * shape[3] * shape[4] + ",\n               " + shape[2] * shape[3] * shape[4] + ",\n               " + shape[3] * shape[4] + ",\n               " + shape[4] + ")) + depth3;\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      vec2 uv = UVfrom6D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", " + stride3 + ", " + stride4 + "\n          ,row, col, depth, depth2, depth3, depth4);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
}
function getSamplerFlat(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) + 'Flat';
    var inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);
    if (inputInfo.shapeInfo.isUniform) {
        if (inSize === 1) {
            return "float " + funcName + "(int index) {return " + texName + ";}";
        }
        return "\n      float " + funcName + "(int index) {\n        for (int i = 0; i < " + inSize + "; i++) {\n          if (i == index) {\n            return " + texName + "[i];\n          }\n        }\n      }\n    ";
    }
    var texShape = inputInfo.shapeInfo.texShape;
    var tNumR = texShape[0];
    var tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        return sampleTexture(" + texName + ", halfCR);\n      }\n    ";
    }
    if (tNumC === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / " + tNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    if (tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / " + tNumC + ".0, 0.5);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int index) {\n      vec2 uv = UVfrom1D(" + tNumR + ", " + tNumC + ", index);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
}
function getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName) {
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var type = 'int';
    if (outRank === 2) {
        type = 'ivec2';
    }
    else if (outRank === 3) {
        type = 'ivec3';
    }
    else if (outRank === 4) {
        type = 'ivec4';
    }
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var rankDiff = outRank - inRank;
    var coordsSnippet;
    if (inRank === 0) {
        coordsSnippet = '';
    }
    else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = 'coords = 0;';
    }
    else {
        coordsSnippet =
            broadcastDims.map(function (d) { return "coords[" + (d + rankDiff) + "] = 0;"; }).join('\n');
    }
    var unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = 'coords';
    }
    else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape
            .map(function (s, i) { return "coords[" + (i + rankDiff) + "]"; })
            .join(', ');
    }
    return "\n    float " + funcName + "() {\n      " + type + " coords = getOutputCoords();\n      " + coordsSnippet + "\n      return get" + texFuncSnippet + "(" + unpackedCoordsSnippet + ");\n    }\n  ";
}
function getSamplerAtOutputCoords(inputInfo, outShapeInfo, supportsBroadcasting) {
    var texName = inputInfo.name;
    var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    var funcName = 'get' + texFuncSnippet + 'AtOutCoords';
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var doBroadcast = supportsBroadcasting && ((outRank > inRank) || broadcastDims.length > 0);
    var broadcastOverOuter = broadcast_util.broadcastDimsAreOuter(broadcastDims);
    var isUniform = inputInfo.shapeInfo.isUniform;
    if (doBroadcast && !broadcastOverOuter) {
        return getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName);
    }
    var inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);
    var broadcastSnippet = '';
    if (doBroadcast && broadcastOverOuter) {
        broadcastSnippet = "\n        int mainPart = index / " + inSize + ";\n        index -= mainPart * " + inSize + ";\n      ";
    }
    var outTexShape = outShapeInfo.texShape;
    if (isUniform) {
        if (inSize === 1) {
            return "float " + funcName + "() {return " + texName + ";}";
        }
        return "\n      float " + funcName + "() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                              vec2(" + outTexShape[0] + ", " + outTexShape[1] + "));\n        int index = resTexRC.x * " + outTexShape[1] + " + resTexRC.y;\n        " + broadcastSnippet + "\n        return get" + texFuncSnippet + "Flat(index);\n      }\n    ";
    }
    var inTexShape = inputInfo.shapeInfo.texShape;
    if (util.arraysEqual(inTexShape, outTexShape)) {
        return "\n      float " + funcName + "() {\n        return sampleTexture(" + texName + ", resultUV);\n      }\n    ";
    }
    return "\n    float " + funcName + "() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + outTexShape[0] + ", " + outTexShape[1] + "));\n      int index = resTexRC.x * " + outTexShape[1] + " + resTexRC.y;\n      " + broadcastSnippet + "\n      int texR = index / " + inTexShape[1] + ";\n      int texC = index - texR * " + inTexShape[1] + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(" + inTexShape[1] + ".0, " + inTexShape[0] + ".0);\n\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
}
function getCoordsDataType(rank) {
    if (rank <= 1) {
        return 'int';
    }
    else if (rank === 2) {
        return 'ivec2';
    }
    else if (rank === 3) {
        return 'ivec3';
    }
    else if (rank === 4) {
        return 'ivec4';
    }
    else if (rank === 5) {
        return 'ivec5';
    }
    else if (rank === 6) {
        return 'ivec6';
    }
    else {
        throw Error("GPU for rank " + rank + " is not yet supported");
    }
}
exports.getCoordsDataType = getCoordsDataType;
function squeezeInputInfo(inInfo, squeezedShape) {
    var newInputInfo = JSON.parse(JSON.stringify(inInfo));
    newInputInfo.shapeInfo.logicalShape = squeezedShape;
    return newInputInfo;
}
function getSqueezedParams(params, keptDims) {
    return keptDims.map(function (d) { return params[d]; }).join(', ');
}

},{"../../ops/broadcast_util":143,"../../util":203}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var SliceProgram = (function () {
    function SliceProgram(destSize) {
        this.variableNames = ['source'];
        this.outputShape = destSize;
        this.rank = destSize.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getCoords(this.rank);
        this.userCode = "\n      uniform " + dtype + " start;\n\n      void main() {\n        " + dtype + " sourceLoc = start + getOutputCoords();\n        setOutput(getSource(" + sourceCoords + "));\n      }\n    ";
    }
    SliceProgram.prototype.getCustomSetupFunc = function (start) {
        var _this = this;
        if (start.length !== this.rank) {
            throw Error("The rank (" + this.rank + ") of the program must match the " +
                ("length of start (" + start.length + ")"));
        }
        return function (gpgpu, webGLProgram) {
            if (_this.startLoc == null) {
                _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');
                if (_this.startLoc == null) {
                    return;
                }
            }
            if (_this.rank === 1) {
                gpgpu.gl.uniform1i(_this.startLoc, start[0]);
            }
            else if (_this.rank === 2) {
                gpgpu.gl.uniform2i(_this.startLoc, start[0], start[1]);
            }
            else if (_this.rank === 3) {
                gpgpu.gl.uniform3i(_this.startLoc, start[0], start[1], start[2]);
            }
            else if (_this.rank === 4) {
                gpgpu.gl.uniform4i(_this.startLoc, start[0], start[1], start[2], start[3]);
            }
            else {
                throw Error("Slicing for rank " + _this.rank + " is not yet supported");
            }
        };
    };
    return SliceProgram;
}());
exports.SliceProgram = SliceProgram;
function getCoords(rank) {
    if (rank === 1) {
        return 'sourceLoc';
    }
    else if (rank === 2) {
        return 'sourceLoc.x, sourceLoc.y';
    }
    else if (rank === 3) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z';
    }
    else if (rank === 4) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w';
    }
    else {
        throw Error("Slicing for rank " + rank + " is not yet supported");
    }
}

},{"./shader_compiler":126}],128:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var StridedSliceProgram = (function () {
    function StridedSliceProgram(begin, strides, size, shrinkAxis) {
        this.variableNames = ['x'];
        var shape = size.filter(function (v, index) { return shrinkAxis.indexOf(index) === -1; });
        this.outputShape = shape;
        var rank = size.length;
        var inputDtype = shader_compiler_1.getCoordsDataType(size.length);
        var dtype = shader_compiler_1.getCoordsDataType(shape.length);
        var newCoords = '';
        if (rank === 1) {
            newCoords = 'coords * strides + begin';
        }
        else {
            var outputAxis_1 = 0;
            newCoords =
                size.map(function (_, i) {
                    if (shrinkAxis.indexOf(i) === -1) {
                        outputAxis_1++;
                        return shape.length === 1 ?
                            "coords * strides[" + i + "] + begin[" + i + "]" :
                            "coords[" + (outputAxis_1 - 1) + "] * strides[" + i + "] + begin[" + i + "]";
                    }
                    else {
                        return "begin[" + i + "]";
                    }
                })
                    .join(',');
        }
        this.userCode = "\n      " + inputDtype + " begin = " + inputDtype + "(" + begin + ");\n      " + inputDtype + " strides = " + inputDtype + "(" + strides + ");\n\n      void main() {\n        " + dtype + " coords = getOutputCoords();\n        setOutput(getX(" + newCoords + "));\n      }\n    ";
    }
    return StridedSliceProgram;
}());
exports.StridedSliceProgram = StridedSliceProgram;

},{"./shader_compiler":126}],129:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextureUsage;
(function (TextureUsage) {
    TextureUsage[TextureUsage["RENDER"] = 0] = "RENDER";
    TextureUsage[TextureUsage["UPLOAD"] = 1] = "UPLOAD";
    TextureUsage[TextureUsage["PIXELS"] = 2] = "PIXELS";
    TextureUsage[TextureUsage["DOWNLOAD"] = 3] = "DOWNLOAD";
    TextureUsage[TextureUsage["PACK"] = 4] = "PACK";
})(TextureUsage = exports.TextureUsage || (exports.TextureUsage = {}));
var PhysicalTextureType;
(function (PhysicalTextureType) {
    PhysicalTextureType[PhysicalTextureType["UNPACKED_FLOAT16"] = 0] = "UNPACKED_FLOAT16";
    PhysicalTextureType[PhysicalTextureType["UNPACKED_FLOAT32"] = 1] = "UNPACKED_FLOAT32";
    PhysicalTextureType[PhysicalTextureType["PACKED_4X1_UNSIGNED_BYTE"] = 2] = "PACKED_4X1_UNSIGNED_BYTE";
    PhysicalTextureType[PhysicalTextureType["PACKED_2X2_FLOAT32"] = 3] = "PACKED_2X2_FLOAT32";
    PhysicalTextureType[PhysicalTextureType["PACKED_2X2_FLOAT16"] = 4] = "PACKED_2X2_FLOAT16";
})(PhysicalTextureType = exports.PhysicalTextureType || (exports.PhysicalTextureType = {}));
function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
}
exports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;
function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
}
exports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;
function getColorMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns * 4, rows];
}
exports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;
function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
    if (unpackedSize % channelsPerTexture !== 0) {
        throw new Error("unpackedSize (" + unpackedSize + ") must be a multiple of " +
            ("" + channelsPerTexture));
    }
    return unpackedSize / channelsPerTexture;
}
exports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;
function encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {
    var requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);
    if (unpackedArray.length < requiredSize) {
        throw new Error("unpackedArray length (" + unpackedArray.length + ") must be >= " +
            ("" + requiredSize));
    }
    var dst = 0;
    for (var src = 0; src < matrix.length; ++src) {
        unpackedArray[dst] = matrix[src];
        dst += channelsPerTexture;
    }
}
exports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;
function decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {
    var requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += channelsPerTexture) {
        matrix[dst++] = unpackedArray[src];
    }
}
exports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;
function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {
    var requiredSize = unpackedArray.length * channels / 4;
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += 4) {
        for (var c = 0; c < channels; c++) {
            matrix[dst++] = unpackedArray[src + c];
        }
    }
}
exports.decodeMatrixFromUnpackedColorRGBAArray = decodeMatrixFromUnpackedColorRGBAArray;
function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [Math.ceil(columns / 2), Math.ceil(rows / 2)];
}
exports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;
function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    return w * h * 4;
}
exports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;
function encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {
    var requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);
    if (packedRGBA.length < requiredSize) {
        throw new Error("packedRGBA length (" + packedRGBA.length + ") must be >= " + requiredSize);
    }
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    {
        var dstStride = (oddWidth ? 4 : 0);
        var oneRow = columns;
        var dst = 0;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            var matrixSrcRow = (blockY * 2 * columns);
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                var matrixSrcCol = blockX * 2;
                var src = matrixSrcRow + matrixSrcCol;
                packedRGBA[dst] = matrix[src];
                packedRGBA[dst + 1] = matrix[src + 1];
                packedRGBA[dst + 2] = matrix[src + oneRow];
                packedRGBA[dst + 3] = matrix[src + oneRow + 1];
                dst += 4;
            }
            dst += dstStride;
        }
    }
    if (oddWidth) {
        var src = columns - 1;
        var dst = (textureWidth - 1) * 4;
        var srcStride = 2 * columns;
        var dstStride = textureWidth * 4;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            packedRGBA[dst] = matrix[src];
            packedRGBA[dst + 2] = matrix[src + columns];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (rows - 1) * columns;
        var dst = (textureHeight - 1) * textureWidth * 4;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            packedRGBA[dst++] = matrix[src++];
            packedRGBA[dst++] = matrix[src++];
            dst += 2;
        }
    }
    if (oddWidth && oddHeight) {
        packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1];
    }
    return packedRGBA;
}
exports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;
function decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {
    var requiredSize = rows * columns;
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    {
        var srcStride = oddWidth ? 4 : 0;
        var dstStride = columns + (oddWidth ? 1 : 0);
        var src = 0;
        var dstRow1 = 0;
        var dstRow2 = columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
            }
            src += srcStride;
            dstRow1 += dstStride;
            dstRow2 += dstStride;
        }
    }
    if (oddWidth) {
        var src = (textureWidth - 1) * 4;
        var dst = columns - 1;
        var srcStride = textureWidth * 4;
        var dstStride = 2 * columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            matrix[dst] = packedRGBA[src];
            matrix[dst + columns] = packedRGBA[src + 2];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (textureHeight - 1) * textureWidth * 4;
        var dst = (rows - 1) * columns;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            matrix[dst++] = packedRGBA[src++];
            matrix[dst++] = packedRGBA[src++];
            src += 2;
        }
        if (oddWidth) {
            matrix[dst] = packedRGBA[src];
        }
    }
    return matrix;
}
exports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA;

},{}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var tex_util_1 = require("./tex_util");
var TextureManager = (function () {
    function TextureManager(gpgpu) {
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this.freeTextures = {};
        this.logEnabled = false;
        this.usedTextures = {};
    }
    TextureManager.prototype.acquireTexture = function (shapeRC, usage) {
        var physicalTexType = getPhysicalFromLogicalTextureType(usage);
        var shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        if (!(shapeKey in this.usedTextures)) {
            this.usedTextures[shapeKey] = [];
        }
        if (this.freeTextures[shapeKey].length > 0) {
            this.numFreeTextures--;
            this.numUsedTextures++;
            this.log();
            var newTexture_1 = this.freeTextures[shapeKey].shift();
            this.usedTextures[shapeKey].push(newTexture_1);
            return newTexture_1;
        }
        this.numUsedTextures++;
        this.log();
        var newTexture;
        if (physicalTexType === tex_util_1.PhysicalTextureType.PACKED_2X2_FLOAT32) {
            newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);
        }
        else if (physicalTexType === tex_util_1.PhysicalTextureType.PACKED_2X2_FLOAT16) {
            newTexture =
                this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);
        }
        else if (physicalTexType === tex_util_1.PhysicalTextureType.UNPACKED_FLOAT32) {
            newTexture =
                this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);
        }
        else if (physicalTexType === tex_util_1.PhysicalTextureType.UNPACKED_FLOAT16) {
            newTexture =
                this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);
        }
        else if (physicalTexType === tex_util_1.PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {
            newTexture =
                this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);
        }
        this.usedTextures[shapeKey].push(newTexture);
        return newTexture;
    };
    TextureManager.prototype.releaseTexture = function (texture, shape, logicalTexType) {
        if (this.freeTextures == null) {
            return;
        }
        var physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType);
        var shapeKey = getKeyFromTextureShape(shape, physicalTexType);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        this.freeTextures[shapeKey].push(texture);
        this.numFreeTextures++;
        this.numUsedTextures--;
        var texList = this.usedTextures[shapeKey];
        var texIndex = texList.indexOf(texture);
        if (texIndex < 0) {
            throw new Error('Cannot release a texture that was never provided by this ' +
                'texture manager');
        }
        texList.splice(texIndex, 1);
        this.log();
    };
    TextureManager.prototype.log = function () {
        if (!this.logEnabled) {
            return;
        }
        var total = this.numFreeTextures + this.numUsedTextures;
        console.log('Free/Used', this.numFreeTextures + " / " + this.numUsedTextures, "(" + total + ")");
    };
    TextureManager.prototype.getNumUsedTextures = function () {
        return this.numUsedTextures;
    };
    TextureManager.prototype.getNumFreeTextures = function () {
        return this.numFreeTextures;
    };
    TextureManager.prototype.dispose = function () {
        var _this = this;
        if (this.freeTextures == null) {
            return;
        }
        for (var texShape in this.freeTextures) {
            this.freeTextures[texShape].forEach(function (tex) {
                _this.gpgpu.deleteMatrixTexture(tex);
            });
        }
        for (var texShape in this.usedTextures) {
            this.usedTextures[texShape].forEach(function (tex) {
                _this.gpgpu.deleteMatrixTexture(tex);
            });
        }
        this.freeTextures = null;
        this.usedTextures = null;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
    };
    return TextureManager;
}());
exports.TextureManager = TextureManager;
function getPhysicalFromLogicalTextureType(logicalTexType) {
    if (logicalTexType === tex_util_1.TextureUsage.DOWNLOAD ||
        logicalTexType === tex_util_1.TextureUsage.PIXELS) {
        return tex_util_1.PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;
    }
    else if (logicalTexType === tex_util_1.TextureUsage.UPLOAD) {
        return tex_util_1.PhysicalTextureType.UNPACKED_FLOAT32;
    }
    else if (logicalTexType === tex_util_1.TextureUsage.RENDER) {
        return environment_1.ENV.get('WEBGL_RENDER_FLOAT32_ENABLED') ?
            tex_util_1.PhysicalTextureType.UNPACKED_FLOAT32 :
            tex_util_1.PhysicalTextureType.UNPACKED_FLOAT16;
    }
    else if (logicalTexType === tex_util_1.TextureUsage.PACK) {
        return environment_1.ENV.get('WEBGL_RENDER_FLOAT32_ENABLED') ?
            tex_util_1.PhysicalTextureType.PACKED_2X2_FLOAT32 :
            tex_util_1.PhysicalTextureType.PACKED_2X2_FLOAT16;
    }
    throw new Error("Unknown logical texture type " + logicalTexType);
}
function getKeyFromTextureShape(shapeRowsCol, physicalTexType) {
    return shapeRowsCol[0] + "_" + shapeRowsCol[1] + "_" + physicalTexType;
}

},{"../../environment":60,"./tex_util":129}],131:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TileProgram = (function () {
    function TileProgram(aShape, reps) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[i] * reps[i];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getSourceCoords(aShape);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
    }
    return TileProgram;
}());
exports.TileProgram = TileProgram;
function getSourceCoords(aShape) {
    var rank = aShape.length;
    if (rank > 5) {
        throw Error("Tile for rank " + rank + " is not yet supported");
    }
    if (rank === 1) {
        return "imod(resRC, " + aShape[0] + ")";
    }
    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];
    var sourceCoords = [];
    for (var i = 0; i < aShape.length; i++) {
        sourceCoords.push("imod(" + currentCoords[i] + ", " + aShape[i] + ")");
    }
    return sourceCoords.join();
}

},{"./shader_compiler":126}],132:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TransposeProgram = (function () {
    function TransposeProgram(aShape, newDim) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var switched = getSwitchedCoords(newDim);
        this.userCode = "\n    void main() {\n      " + dtype + " resRC = getOutputCoords();\n      setOutput(getA(" + switched + "));\n    }\n    ";
    }
    return TransposeProgram;
}());
exports.TransposeProgram = TransposeProgram;
function getSwitchedCoords(newDim) {
    var rank = newDim.length;
    if (rank > 6) {
        throw Error("Transpose for rank " + rank + " is not yet supported");
    }
    var originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u', 'resRC.v'];
    var switchedCoords = new Array(rank);
    for (var i = 0; i < newDim.length; i++) {
        switchedCoords[newDim[i]] = originalOrder[i];
    }
    return switchedCoords.join();
}

},{"./shader_compiler":126}],133:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var erf_util = require("../../ops/erf_util");
var selu_util = require("../../ops/selu_util");
var UnaryOpProgram = (function () {
    function UnaryOpProgram(aShape, opSnippet) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        this.userCode = "\n      uniform float NAN;\n      float unaryOperation(float x) {\n        " + opSnippet + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
    }
    UnaryOpProgram.prototype.getCustomSetupFunc = function () {
        var _this = this;
        return function (gpgpu, webGLProgram) {
            if (_this.startLoc == null) {
                _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'NAN');
                if (_this.startLoc == null) {
                    return;
                }
            }
            gpgpu.gl.uniform1f(_this.startLoc, NaN);
        };
    };
    return UnaryOpProgram;
}());
exports.UnaryOpProgram = UnaryOpProgram;
var CHECK_NAN_SNIPPET = "if (isNaN(x)) return x;";
exports.ABS = "return abs(x);";
exports.RELU = CHECK_NAN_SNIPPET + "\n  return (x < 0.0) ? 0.0 : x;\n";
exports.ELU = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
exports.SELU = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + selu_util.SELU_SCALEALPHA + ";\n  float scale = " + selu_util.SELU_SCALE + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";
function STEP(alpha) {
    if (alpha === void 0) { alpha = 0.0; }
    return CHECK_NAN_SNIPPET + ("\n    return x > 0.0 ? 1.0 : float(" + alpha + ");\n  ");
}
exports.STEP = STEP;
exports.NEG = "return -x;";
exports.CEIL = "return ceil(x);";
exports.FLOOR = "return floor(x);";
exports.SIGN = "\n  if (isNaN(x)) { return 0.0; }\n  return sign(x);\n";
exports.ROUND = "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n";
exports.EXP = "return exp(x);";
exports.EXPM1 = "return exp(x) - 1.0;";
exports.LOG = "if (x < 0.0) return NAN;\n  return log(x);";
exports.LOG1P = "return log(1.0 + x);";
exports.SQRT = "return sqrt(x);";
exports.RSQRT = "return inversesqrt(x);";
exports.SIGMOID = "return 1.0 / (1.0 + exp(-1.0 * x));";
exports.SOFTPLUS = "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n";
exports.SIN = CHECK_NAN_SNIPPET + "\n  return sin(x);\n";
exports.COS = CHECK_NAN_SNIPPET + "\n  return cos(x);\n";
exports.TAN = "return tan(x);";
exports.ASIN = "return asin(x);";
exports.ACOS = "return acos(x);";
exports.ATAN = CHECK_NAN_SNIPPET + "\n  return atan(x);\n";
exports.SINH = "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n";
exports.COSH = "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n";
exports.TANH = "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n";
exports.ASINH = "return log(x + sqrt(x * x + 1.0));";
exports.ACOSH = CHECK_NAN_SNIPPET + "\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));";
exports.ATANH = CHECK_NAN_SNIPPET + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;";
exports.ERF = "\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  float p = " + erf_util.ERF_P + ";\n  float a1 = " + erf_util.ERF_A1 + ";\n  float a2 = " + erf_util.ERF_A2 + ";\n  float a3 = " + erf_util.ERF_A3 + ";\n  float a4 = " + erf_util.ERF_A4 + ";\n  float a5 = " + erf_util.ERF_A5 + ";\n\n  float t = 1.0 / (1.0 + p * x);\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\n";
exports.SQUARE = "return x * x;";
exports.RECIPROCAL = "return 1.0 / x;";
exports.LOGICAL_NOT = "return float(!(x >= 1.0));";
exports.TO_INT = "return float(int(x));";

},{"../../ops/erf_util":150,"../../ops/selu_util":174}],134:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnpackProgram = (function () {
    function UnpackProgram(outputShape) {
        this.variableNames = ['A'];
        this.outputShape = outputShape;
        this.userCode = "\n      const vec2 onePixel = 1. / vec2(" + outputShape[1] + ", " + outputShape[0] + ");\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n        vec2 modCoord = mod(vec2(rc.y, rc.x), 2.);\n        vec4 packedInput = getA(rc.x, rc.y);\n\n        setOutput(\n          modCoord.x == 0. ?\n            (modCoord.y == 0. ? packedInput.r : packedInput.b) :\n            (modCoord.y == 0. ? packedInput.g : packedInput.a)\n        );\n      }\n    ";
    }
    return UnpackProgram;
}());
exports.UnpackProgram = UnpackProgram;

},{}],135:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var tex_util_1 = require("../webgl/tex_util");
function createWebGLRenderingContext(attributes) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return createWebGLRenderingContextFromCanvas(canvas, attributes);
}
exports.createWebGLRenderingContext = createWebGLRenderingContext;
function createWebGLRenderingContextFromCanvas(canvas, attributes) {
    var gl;
    var webglVersion = environment_1.ENV.get('WEBGL_VERSION');
    if (webglVersion === 2) {
        gl = canvas.getContext('webgl2', attributes);
    }
    else if (webglVersion === 1) {
        gl = (canvas.getContext('webgl', attributes) ||
            canvas.getContext('experimental-webgl', attributes));
    }
    if (webglVersion === 0 || gl == null) {
        throw new Error('This browser does not support WebGL.');
    }
    return gl;
}
exports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;
function callAndCheck(gl, func) {
    var returnValue = func();
    checkWebGLError(gl);
    return returnValue;
}
exports.callAndCheck = callAndCheck;
var webGLDebugErrorCheckingEnabled = false;
function enableDebugWebGLErrorChecking(enabled) {
    webGLDebugErrorCheckingEnabled = enabled;
}
exports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;
function checkWebGLError(gl) {
    if (webGLDebugErrorCheckingEnabled) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));
        }
    }
}
exports.checkWebGLError = checkWebGLError;
function getWebGLErrorMessage(gl, status) {
    switch (status) {
        case gl.NO_ERROR:
            return 'NO_ERROR';
        case gl.INVALID_ENUM:
            return 'INVALID_ENUM';
        case gl.INVALID_VALUE:
            return 'INVALID_VALUE';
        case gl.INVALID_OPERATION:
            return 'INVALID_OPERATION';
        case gl.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
        case gl.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
        case gl.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
        default:
            return "Unknown error code " + status;
    }
}
exports.getWebGLErrorMessage = getWebGLErrorMessage;
function getExtensionOrThrow(gl, extensionName) {
    return throwIfNull(gl, function () { return gl.getExtension(extensionName); }, 'Extension "' + extensionName + '" not supported on this browser.');
}
exports.getExtensionOrThrow = getExtensionOrThrow;
function createVertexShader(gl, vertexShaderSource) {
    var vertexShader = throwIfNull(gl, function () { return gl.createShader(gl.VERTEX_SHADER); }, 'Unable to create vertex WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(vertexShader, vertexShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(vertexShader); });
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error('Failed to compile vertex shader.');
    }
    return vertexShader;
}
exports.createVertexShader = createVertexShader;
function createFragmentShader(gl, fragmentShaderSource) {
    var fragmentShader = throwIfNull(gl, function () { return gl.createShader(gl.FRAGMENT_SHADER); }, 'Unable to create fragment WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(fragmentShader, fragmentShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(fragmentShader); });
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
        throw new Error('Failed to compile fragment shader.');
    }
    return fragmentShader;
}
exports.createFragmentShader = createFragmentShader;
var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
    var lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
    if (lineNumberRegexResult == null) {
        console.log("Couldn't parse line number in error: " + shaderInfoLog);
        console.log(shaderSource);
        return;
    }
    var lineNumber = +lineNumberRegexResult[1];
    var shaderLines = shaderSource.split('\n');
    var pad = shaderLines.length.toString().length + 2;
    var linesWithLineNumbers = shaderLines.map(function (line, lineNumber) {
        return util.rightPad((lineNumber + 1).toString(), pad) + line;
    });
    var maxLineLength = 0;
    for (var i = 0; i < linesWithLineNumbers.length; i++) {
        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
    }
    var beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
    var errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
    var afterErrorLines = linesWithLineNumbers.slice(lineNumber);
    console.log(beforeErrorLines.join('\n'));
    console.log(shaderInfoLog.split('\n')[0]);
    console.log("%c " + util.rightPad(errorLine[0], maxLineLength), 'border:1px solid red; background-color:#e3d2d2; color:#a61717');
    console.log(afterErrorLines.join('\n'));
}
function createProgram(gl) {
    return throwIfNull(gl, function () { return gl.createProgram(); }, 'Unable to create WebGLProgram.');
}
exports.createProgram = createProgram;
function linkProgram(gl, program) {
    callAndCheck(gl, function () { return gl.linkProgram(program); });
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Failed to link vertex and fragment shaders.');
    }
}
exports.linkProgram = linkProgram;
function validateProgram(gl, program) {
    callAndCheck(gl, function () { return gl.validateProgram(program); });
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Shader program validation failed.');
    }
}
exports.validateProgram = validateProgram;
function createStaticVertexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticVertexBuffer = createStaticVertexBuffer;
function createStaticIndexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticIndexBuffer = createStaticIndexBuffer;
function getNumChannels() {
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        return 1;
    }
    return 4;
}
exports.getNumChannels = getNumChannels;
function createTexture(gl) {
    return throwIfNull(gl, function () { return gl.createTexture(); }, 'Unable to create WebGLTexture.');
}
exports.createTexture = createTexture;
function validateTextureSize(width, height) {
    var maxTextureSize = environment_1.ENV.get('WEBGL_MAX_TEXTURE_SIZE');
    if ((width <= 0) || (height <= 0)) {
        var requested = "[" + width + "x" + height + "]";
        throw new Error('Requested texture size ' + requested + ' is invalid.');
    }
    if ((width > maxTextureSize) || (height > maxTextureSize)) {
        var requested = "[" + width + "x" + height + "]";
        var max = "[" + maxTextureSize + "x" + maxTextureSize + "]";
        throw new Error('Requested texture size ' + requested +
            ' greater than WebGL maximum on this browser / GPU ' + max + '.');
    }
}
exports.validateTextureSize = validateTextureSize;
function createFramebuffer(gl) {
    return throwIfNull(gl, function () { return gl.createFramebuffer(); }, 'Unable to create WebGLFramebuffer.');
}
exports.createFramebuffer = createFramebuffer;
function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
    var loc = gl.getAttribLocation(program, attribute);
    if (loc === -1) {
        return false;
    }
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes); });
    callAndCheck(gl, function () { return gl.enableVertexAttribArray(loc); });
    return true;
}
exports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;
function bindTextureUnit(gl, texture, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
}
exports.bindTextureUnit = bindTextureUnit;
function unbindTextureUnit(gl, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.unbindTextureUnit = unbindTextureUnit;
function getProgramUniformLocationOrThrow(gl, program, uniformName) {
    return throwIfNull(gl, function () { return gl.getUniformLocation(program, uniformName); }, 'uniform "' + uniformName + '" not present in program.');
}
exports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;
function getProgramUniformLocation(gl, program, uniformName) {
    return gl.getUniformLocation(program, uniformName);
}
exports.getProgramUniformLocation = getProgramUniformLocation;
function bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerLocation, textureUnit) {
    callAndCheck(gl, function () { return bindTextureUnit(gl, texture, textureUnit); });
    callAndCheck(gl, function () { return gl.uniform1i(uniformSamplerLocation, textureUnit); });
}
exports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;
function bindCanvasToFramebuffer(gl) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
    callAndCheck(gl, function () { return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); });
    callAndCheck(gl, function () { return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height); });
}
exports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;
function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); });
}
exports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;
function unbindColorTextureFromFramebuffer(gl, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); });
}
exports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;
function validateFramebuffer(gl) {
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));
    }
}
exports.validateFramebuffer = validateFramebuffer;
function getFramebufferErrorMessage(gl, status) {
    switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';
        case gl.FRAMEBUFFER_UNSUPPORTED:
            return 'FRAMEBUFFER_UNSUPPORTED';
        default:
            return "unknown error " + status;
    }
}
exports.getFramebufferErrorMessage = getFramebufferErrorMessage;
function throwIfNull(gl, returnTOrNull, failureMessage) {
    var tOrNull = callAndCheck(gl, function () { return returnTOrNull(); });
    if (tOrNull == null) {
        throw new Error(failureMessage);
    }
    return tOrNull;
}
function validateTextureUnit(gl, textureUnit) {
    var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    var glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        var textureUnitRange = "[gl.TEXTURE0, gl.TEXTURE" + maxTextureUnit + "]";
        throw new Error("textureUnit must be in " + textureUnitRange + ".");
    }
}
function getTextureShapeFromLogicalShape(logShape, usage) {
    if (usage === void 0) { usage = tex_util_1.TextureUsage.UPLOAD; }
    var maxTexSize = environment_1.ENV.get('WEBGL_MAX_TEXTURE_SIZE');
    if (usage === tex_util_1.TextureUsage.PACK) {
        maxTexSize = maxTexSize * 2;
        logShape = logShape.map(function (d, i) { return i >= logShape.length - 2 ?
            util.nearestLargerEven(logShape[i]) :
            logShape[i]; });
    }
    if (logShape.length !== 2) {
        var squeezeResult = util.squeezeShape(logShape);
        logShape = squeezeResult.newShape;
    }
    var size = util.sizeFromShape(logShape);
    if (logShape.length <= 1 && size <= maxTexSize) {
        return [size, 1];
    }
    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&
        logShape[1] <= maxTexSize) {
        return logShape;
    }
    else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&
        logShape[2] <= maxTexSize) {
        return [logShape[0] * logShape[1], logShape[2]];
    }
    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2]];
    }
    else if (logShape.length === 4 &&
        logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&
        logShape[3] <= maxTexSize) {
        return [logShape[0] * logShape[1] * logShape[2], logShape[3]];
    }
    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
    }
    else {
        return util.sizeToSquarishShape(size);
    }
}
exports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape;

},{"../../environment":60,"../../util":203,"../webgl/tex_util":129}],136:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var array_ops_1 = require("../ops/array_ops");
function whereImpl(condShape, condVals) {
    var indices = [];
    for (var i = 0; i < condVals.length; i++) {
        if (condVals[i]) {
            indices.push(i);
        }
    }
    var inBuffer = array_ops_1.buffer(condShape, 'int32');
    var out = array_ops_1.buffer([indices.length, condShape.length], 'int32');
    for (var i = 0; i < indices.length; i++) {
        var loc = inBuffer.indexToLoc(indices[i]);
        var offset = i * condShape.length;
        out.values.set(loc, offset);
    }
    return out.toTensor();
}
exports.whereImpl = whereImpl;

},{"../ops/array_ops":138}],137:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("./environment");
function warn() {
    var msg = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        msg[_i] = arguments[_i];
    }
    if (!environment_1.ENV.get('IS_TEST')) {
        console.warn.apply(console, msg);
    }
}
exports.warn = warn;
function log() {
    var msg = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        msg[_i] = arguments[_i];
    }
    if (!environment_1.ENV.get('IS_TEST')) {
        console.log.apply(console, msg);
    }
}
exports.log = log;

},{"./environment":60}],138:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_1 = require("../tensor");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var axis_util_1 = require("./axis_util");
var concat_split_1 = require("./concat_split");
var operation_1 = require("./operation");
var rand_1 = require("./rand");
var tensor_ops_1 = require("./tensor_ops");
function clone_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'clone');
    var der = function (dy) {
        return { $x: function () { return dy.toFloat(); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) {
        return tensor_1.Tensor.make($x.shape, { dataId: $x.dataId }, $x.dtype);
    }, { $x: $x }, der);
}
function eye_(numRows, numColumns, batchShape, dtype) {
    if (dtype === void 0) { dtype = 'float32'; }
    if (numColumns == null) {
        numColumns = numRows;
    }
    var buff = buffer([numRows, numColumns], dtype);
    var n = numRows <= numColumns ? numRows : numColumns;
    for (var i = 0; i < n; ++i) {
        buff.set(1, i, i);
    }
    var out = buff.toTensor().as2D(numRows, numColumns);
    if (batchShape == null) {
        return out;
    }
    else {
        if (batchShape.length === 1) {
            return exports.tile(exports.expandDims(out, 0), [batchShape[0], 1, 1]);
        }
        else if (batchShape.length === 2) {
            return exports.tile(exports.expandDims(exports.expandDims(out, 0), 0), [batchShape[0], batchShape[1], 1, 1]);
        }
        else if (batchShape.length === 3) {
            return exports.tile(exports.expandDims(exports.expandDims(exports.expandDims(out, 0), 0), 0), [batchShape[0], batchShape[1], batchShape[2], 1, 1]);
        }
        else {
            throw new Error("eye() currently supports only 1D and 2D " +
                ("batchShapes, but received " + batchShape.length + "D."));
        }
    }
}
function randomNormal_(shape, mean, stdDev, dtype, seed) {
    if (mean === void 0) { mean = 0; }
    if (stdDev === void 0) { stdDev = 1; }
    if (dtype != null && dtype === 'bool') {
        throw new Error("Unsupported data type " + dtype);
    }
    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, false, seed);
    var res = buffer(shape, dtype);
    for (var i = 0; i < res.values.length; i++) {
        res.values[i] = randGauss.nextValue();
    }
    return res.toTensor();
}
function truncatedNormal_(shape, mean, stdDev, dtype, seed) {
    if (mean === void 0) { mean = 0; }
    if (stdDev === void 0) { stdDev = 1; }
    if (dtype != null && dtype === 'bool') {
        throw new Error("Unsupported data type " + dtype);
    }
    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, true, seed);
    var res = buffer(shape, dtype);
    for (var i = 0; i < res.values.length; i++) {
        res.values[i] = randGauss.nextValue();
    }
    return res.toTensor();
}
function randomUniform_(shape, minval, maxval, dtype) {
    if (minval === void 0) { minval = 0; }
    if (maxval === void 0) { maxval = 1; }
    if (dtype === void 0) { dtype = 'float32'; }
    var res = buffer(shape, dtype);
    for (var i = 0; i < res.values.length; i++) {
        res.values[i] = util.randUniform(minval, maxval);
    }
    return res.toTensor();
}
function rand_(shape, randFunction, dtype) {
    var size = util.sizeFromShape(shape);
    var values = null;
    if (dtype == null || dtype === 'float32') {
        values = new Float32Array(size);
    }
    else if (dtype === 'int32') {
        values = new Int32Array(size);
    }
    else if (dtype === 'bool') {
        values = new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
    for (var i = 0; i < size; i++) {
        values[i] = randFunction();
    }
    return tensor_1.Tensor.make(shape, { values: values }, dtype);
}
function multinomial_(logits, numSamples, seed, normalized) {
    if (normalized === void 0) { normalized = false; }
    var $logits = tensor_util_env_1.convertToTensor(logits, 'logits', 'multinomial');
    var numOutcomes = $logits.size;
    var origRank = $logits.rank;
    if (numOutcomes < 2) {
        throw new Error("Error in multinomial: you need at least 2 outcomes, but got " +
            (numOutcomes + "."));
    }
    if (origRank > 2) {
        throw new Error("Rank of probabilities must be 1 or 2, but is " + origRank);
    }
    seed = seed || Math.random();
    var logits2D = origRank === 1 ? $logits.as2D(1, -1) : $logits;
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.multinomial(logits2D, normalized, numSamples, seed); }, { logits2D: logits2D });
    return origRank === 1 ? res.as1D() : res;
}
function oneHot_(indices, depth, onValue, offValue) {
    if (onValue === void 0) { onValue = 1; }
    if (offValue === void 0) { offValue = 0; }
    var $indices = tensor_util_env_1.convertToTensor(indices, 'indices', 'oneHot', 'int32');
    util.assert($indices.dtype === 'int32', 'Indices must be of dtype `int32`');
    if (depth < 2) {
        throw new Error("Error in oneHot: depth must be >=2, but it is " + depth);
    }
    var grad = function (dy) {
        return { $indices: function () { return tensor_ops_1.zerosLike($indices); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.oneHot($indices, depth, onValue, offValue); }, { $indices: $indices }, grad);
}
function fromPixels_(pixels, numChannels) {
    if (numChannels === void 0) { numChannels = 3; }
    if (numChannels > 4) {
        throw new Error('Cannot construct Tensor with more than 4 channels from pixels.');
    }
    return environment_1.ENV.engine.fromPixels(pixels, numChannels);
}
function toPixels(img, canvas) {
    return __awaiter(this, void 0, void 0, function () {
        var $img, _a, height, width, depth, minTensor, maxTensor, min, max, data, multiplier, bytes, i, r, g, b, a, j, ctx, imageData;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    $img = tensor_util_env_1.convertToTensor(img, 'img', 'toPixels', 'int32');
                    if ($img.rank !== 2 && $img.rank !== 3) {
                        throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + $img.rank + ".");
                    }
                    _a = $img.shape.slice(0, 2), height = _a[0], width = _a[1];
                    depth = $img.rank === 2 ? 1 : $img.shape[2];
                    if (depth > 4 || depth === 2) {
                        throw new Error("toPixels only supports depth of size " +
                            ("1, 3 or 4 but got " + depth));
                    }
                    minTensor = $img.min();
                    maxTensor = $img.max();
                    return [4, minTensor.data()];
                case 1:
                    min = (_b.sent())[0];
                    return [4, maxTensor.data()];
                case 2:
                    max = (_b.sent())[0];
                    minTensor.dispose();
                    maxTensor.dispose();
                    if ($img.dtype === 'float32') {
                        if (min < 0 || max > 1) {
                            throw new Error("Tensor values for a float32 Tensor must be in the " +
                                ("range [0 - 1] but got range [" + min + " - " + max + "]."));
                        }
                    }
                    else if ($img.dtype === 'int32') {
                        if (min < 0 || max > 255) {
                            throw new Error("Tensor values for a int32 Tensor must be in the " +
                                ("range [0 - 255] but got range [" + min + " - " + max + "]."));
                        }
                    }
                    else {
                        throw new Error("Unsupported type for toPixels: " + $img.dtype + "." +
                            " Please use float32 or int32 tensors.");
                    }
                    return [4, $img.data()];
                case 3:
                    data = _b.sent();
                    multiplier = $img.dtype === 'float32' ? 255 : 1;
                    bytes = new Uint8ClampedArray(width * height * 4);
                    for (i = 0; i < height * width; ++i) {
                        r = void 0, g = void 0, b = void 0, a = void 0;
                        if (depth === 1) {
                            r = data[i] * multiplier;
                            g = data[i] * multiplier;
                            b = data[i] * multiplier;
                            a = 255;
                        }
                        else if (depth === 3) {
                            r = data[i * 3] * multiplier;
                            g = data[i * 3 + 1] * multiplier;
                            b = data[i * 3 + 2] * multiplier;
                            a = 255;
                        }
                        else if (depth === 4) {
                            r = data[i * 4] * multiplier;
                            g = data[i * 4 + 1] * multiplier;
                            b = data[i * 4 + 2] * multiplier;
                            a = data[i * 4 + 3] * multiplier;
                        }
                        j = i * 4;
                        bytes[j + 0] = Math.round(r);
                        bytes[j + 1] = Math.round(g);
                        bytes[j + 2] = Math.round(b);
                        bytes[j + 3] = Math.round(a);
                    }
                    if (canvas != null) {
                        canvas.width = width;
                        canvas.height = height;
                        ctx = canvas.getContext('2d');
                        imageData = new ImageData(bytes, width, height);
                        ctx.putImageData(imageData, 0, 0);
                    }
                    if ($img !== img) {
                        $img.dispose();
                    }
                    return [2, bytes];
            }
        });
    });
}
exports.toPixels = toPixels;
function reshape_(x, shape) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'reshape');
    shape = util.inferFromImplicitShape(shape, $x.size);
    util.assert($x.size === util.sizeFromShape(shape), 'new shape and old shape must have the same number of elements.');
    var grad = function (dy) {
        return { $x: function () { return dy.reshape($x.shape); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.reshape($x, shape); }, { $x: $x }, grad);
}
function squeeze_(x, axis) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'squeeze');
    return exports.reshape($x, util.squeezeShape($x.shape, axis).newShape);
}
function cast_(x, dtype) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'cast');
    var grad = function (dy) {
        return { $x: function () { return dy.clone(); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.cast($x, dtype); }, { $x: $x }, grad);
}
function tile_(x, reps) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'tile');
    util.assert($x.rank === reps.length, "Error in transpose: rank of input " + $x.rank + " " +
        ("must match length of reps " + reps + "."));
    var grad = function (dy) {
        var derX = function () {
            var xGrad = tensor_ops_1.zerosLike($x);
            if ($x.rank === 1) {
                for (var i = 0; i < reps[0]; ++i) {
                    xGrad = xGrad.add(dy.slice([i * $x.shape[0]], [$x.shape[0]]));
                }
            }
            else if ($x.rank === 2) {
                for (var i = 0; i < reps[0]; ++i) {
                    for (var j = 0; j < reps[1]; ++j) {
                        xGrad = xGrad.add(dy.slice([i * $x.shape[0], j * $x.shape[1]], [$x.shape[0], $x.shape[1]]));
                    }
                }
            }
            else if ($x.rank === 3) {
                for (var i = 0; i < reps[0]; ++i) {
                    for (var j = 0; j < reps[1]; ++j) {
                        for (var k = 0; k < reps[2]; ++k) {
                            xGrad = xGrad.add(dy.slice([i * $x.shape[0], j * $x.shape[1], k * $x.shape[2]], [$x.shape[0], $x.shape[1], $x.shape[2]]));
                        }
                    }
                }
            }
            else if ($x.rank === 4) {
                for (var i = 0; i < reps[0]; ++i) {
                    for (var j = 0; j < reps[1]; ++j) {
                        for (var k = 0; k < reps[2]; ++k) {
                            for (var l = 0; l < reps[3]; ++l) {
                                xGrad = xGrad.add(dy.slice([
                                    i * $x.shape[0], j * $x.shape[1], k * $x.shape[2],
                                    l * $x.shape[3]
                                ], [$x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]));
                            }
                        }
                    }
                }
            }
            else {
                throw new Error("Gradient for tile operation is not implemented for rank-" +
                    ($x.rank + " tensors yet."));
            }
            return xGrad;
        };
        return { $x: derX };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.tile($x, reps); }, { $x: $x }, grad);
}
function pad1d_(x, paddings, constantValue) {
    if (constantValue === void 0) { constantValue = 0; }
    util.assert(paddings.length === 2, 'Invalid number of paddings. Must be length of 2.');
    return exports.pad(x, [paddings], constantValue);
}
function pad2d_(x, paddings, constantValue) {
    if (constantValue === void 0) { constantValue = 0; }
    util.assert(paddings.length === 2 && paddings[0].length === 2 &&
        paddings[1].length === 2, 'Invalid number of paddings. Must be length of 2 each.');
    return exports.pad(x, paddings, constantValue);
}
function pad3d_(x, paddings, constantValue) {
    if (constantValue === void 0) { constantValue = 0; }
    util.assert(paddings.length === 3 && paddings[0].length === 2 &&
        paddings[1].length === 2 && paddings[2].length === 2, 'Invalid number of paddings. Must be length of 2 each.');
    return exports.pad(x, paddings, constantValue);
}
function pad4d_(x, paddings, constantValue) {
    if (constantValue === void 0) { constantValue = 0; }
    util.assert(paddings.length === 4 && paddings[0].length === 2 &&
        paddings[1].length === 2 && paddings[2].length === 2 &&
        paddings[3].length === 2, 'Invalid number of paddings. Must be length of 2 each.');
    return exports.pad(x, paddings, constantValue);
}
function pad_(x, paddings, constantValue) {
    if (constantValue === void 0) { constantValue = 0; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'pad');
    if ($x.rank === 0) {
        throw new Error('pad(scalar) is not defined. Pass non-scalar to pad');
    }
    var begin = paddings.map(function (p) { return p[0]; });
    var grad = function (dy) {
        return { $x: function () { return dy.slice(begin, $x.shape); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.pad($x, paddings, constantValue); }, { $x: $x }, grad);
}
function stack_(tensors, axis) {
    if (axis === void 0) { axis = 0; }
    var $tensors = tensor_util_env_1.convertToTensorArray(tensors, 'tensors', 'stack');
    util.assert($tensors.length >= 1, 'Pass at least one tensor to tf.stack');
    if ($tensors.length === 1) {
        return $tensors[0].expandDims(axis);
    }
    var rank = $tensors[0].rank;
    var shape = $tensors[0].shape;
    var dtype = $tensors[0].dtype;
    util.assert(axis <= rank, 'Axis must be <= rank of the tensor');
    $tensors.forEach(function (t) {
        util.assertShapesMatch(shape, t.shape, 'All tensors passed to stack must have matching shapes');
    });
    $tensors.forEach(function (t) {
        util.assert(dtype === t.dtype, 'All tensors passed to stack must have matching dtypes');
    });
    var expandedTensors = $tensors.map(function (t) { return t.expandDims(axis); });
    return concat_split_1.concat(expandedTensors, axis);
}
function batchToSpaceND_(x, blockShape, crops) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'batchToSpaceND');
    var prod = blockShape.reduce(function (a, b) { return a * b; });
    util.assert($x.rank >= 1 + blockShape.length, "input rank is " + $x.rank + " but should be > than blockShape.length " + blockShape.length);
    util.assert(crops.length === blockShape.length, "crops.length is " + crops.length + " but should be equal to blockShape.length  " + blockShape.length);
    util.assert($x.shape[0] % prod === 0, "input tensor batch is " + $x.shape[0] + " but is not divisible by the product of " +
        ("the elements of blockShape " + blockShape.join(' * ') + " === " + prod));
    var grad = function (dy) {
        return { $x: function () { return dy.spaceToBatchND(blockShape, crops); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.batchToSpaceND($x, blockShape, crops); }, { $x: $x }, grad);
}
function spaceToBatchND_(x, blockShape, paddings) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'spaceToBatchND');
    util.assert($x.rank >= 1 + blockShape.length, "input rank " + $x.rank + " should be > than [blockShape] " + blockShape.length);
    util.assert(paddings.length === blockShape.length, "paddings.shape[0] " + paddings.length + " must be equal to [blockShape] " + blockShape.length);
    util.assert($x.shape.reduce(function (a, b, i) {
        if (i > 0 && i <= blockShape.length) {
            return a &&
                ((b + paddings[i - 1][0] + paddings[i - 1][1]) %
                    blockShape[i - 1] ===
                    0);
        }
        return a;
    }, true), "input spatial dimensions " + $x.shape.slice(1) + " with paddings " + paddings.toString() + " must be divisible by blockShapes " + blockShape.toString());
    var grad = function (dy) {
        return { $x: function () { return dy.batchToSpaceND(blockShape, paddings); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.spaceToBatchND($x, blockShape, paddings); }, { $x: $x }, grad);
}
function unstack_(x, axis) {
    if (axis === void 0) { axis = 0; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'unstack');
    var num = $x.shape[axis];
    var outputShape = Array($x.rank - 1).fill(0);
    var outIndex = 0;
    for (var i = 0; i < $x.rank; i++) {
        if (i !== axis) {
            outputShape[outIndex] = $x.shape[i];
            outIndex++;
        }
    }
    var splitSizes;
    splitSizes = Array(num).fill(1);
    var begin = Array($x.rank).fill(0);
    var size = $x.shape.slice();
    return splitSizes.map(function (s) {
        size[axis] = s;
        var slice = $x.slice(begin, size);
        begin[axis] += s;
        return slice.reshape(outputShape);
    });
}
function cumsum_(x, axis, exclusive, reverse) {
    if (axis === void 0) { axis = 0; }
    if (exclusive === void 0) { exclusive = false; }
    if (reverse === void 0) { reverse = false; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'cumsum');
    axis = axis | 0;
    var permutation = axis_util_1.getAxesPermutation([axis], $x.rank);
    var permutedX = $x;
    if (permutation != null) {
        permutedX = $x.transpose(permutation);
    }
    var permutedAxis = axis_util_1.getInnerMostAxes(1, $x.rank)[0];
    var grad = function (dy) {
        return { permutedX: function () { return dy.cumsum(axis, exclusive, !reverse); } };
    };
    var value = environment_1.ENV.engine.runKernel(function (backend) { return backend.cumsum(permutedX, permutedAxis, exclusive, reverse); }, { permutedX: permutedX }, grad);
    if (permutation != null) {
        value = value.transpose(permutation);
    }
    return value;
}
function expandDims_(x, axis) {
    if (axis === void 0) { axis = 0; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'expandDims');
    util.assert(axis <= $x.rank, 'Axis must be <= rank of the tensor');
    var newShape = $x.shape.slice();
    if (axis < 0) {
        util.assert(-($x.rank + 1) <= axis, "Axis must be in the interval [" + -($x.rank + 1) + ", " + $x.rank + "]");
        axis = $x.rank + axis + 1;
    }
    newShape.splice(axis, 0, 1);
    return exports.reshape($x, newShape);
}
function depthToSpace_(x, blockSize, dataFormat) {
    if (dataFormat === void 0) { dataFormat = 'NHWC'; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'depthToSpace');
    var inputHeight = (dataFormat === 'NHWC') ? $x.shape[1] : $x.shape[2];
    var inputWidth = (dataFormat === 'NHWC') ? $x.shape[2] : $x.shape[3];
    var inputDepth = (dataFormat === 'NHWC') ? $x.shape[3] : $x.shape[1];
    util.assert(inputHeight * blockSize >= 0, "Negative dimension size caused by overflow when multiplying\n      " + inputHeight + " and " + blockSize + "  for depthToSpace with input shape\n      " + $x.shape);
    util.assert(inputWidth * blockSize >= 0, "Negative dimension size caused by overflow when multiplying\n      " + inputWidth + " and " + blockSize + " for depthToSpace with input shape\n          " + $x.shape);
    util.assert((inputDepth % (blockSize * blockSize) === 0), "Dimension size must be evenly divisible by " + blockSize * blockSize + " but is " + inputDepth + " for depthToSpace with input shape " + $x.shape);
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.depthToSpace($x, blockSize, dataFormat); }, { $x: $x });
}
function buffer(shape, dtype, values) {
    if (dtype === void 0) { dtype = 'float32'; }
    return new tensor_1.TensorBuffer(shape, dtype, values);
}
exports.buffer = buffer;
function print(x, verbose) {
    if (verbose === void 0) { verbose = false; }
    console.log(x.toString(verbose));
}
exports.print = print;
exports.batchToSpaceND = operation_1.op({ batchToSpaceND_: batchToSpaceND_ });
exports.cast = operation_1.op({ cast_: cast_ });
exports.clone = operation_1.op({ clone_: clone_ });
exports.cumsum = operation_1.op({ cumsum_: cumsum_ });
exports.depthToSpace = operation_1.op({ depthToSpace_: depthToSpace_ });
exports.expandDims = operation_1.op({ expandDims_: expandDims_ });
exports.eye = operation_1.op({ eye_: eye_ });
exports.fromPixels = operation_1.op({ fromPixels_: fromPixels_ });
exports.multinomial = operation_1.op({ multinomial_: multinomial_ });
exports.oneHot = operation_1.op({ oneHot_: oneHot_ });
exports.pad = operation_1.op({ pad_: pad_ });
exports.pad1d = operation_1.op({ pad1d_: pad1d_ });
exports.pad2d = operation_1.op({ pad2d_: pad2d_ });
exports.pad3d = operation_1.op({ pad3d_: pad3d_ });
exports.pad4d = operation_1.op({ pad4d_: pad4d_ });
exports.rand = operation_1.op({ rand_: rand_ });
exports.randomNormal = operation_1.op({ randomNormal_: randomNormal_ });
exports.randomUniform = operation_1.op({ randomUniform_: randomUniform_ });
exports.reshape = operation_1.op({ reshape_: reshape_ });
exports.spaceToBatchND = operation_1.op({ spaceToBatchND_: spaceToBatchND_ });
exports.squeeze = operation_1.op({ squeeze_: squeeze_ });
exports.stack = operation_1.op({ stack_: stack_ });
exports.tile = operation_1.op({ tile_: tile_ });
exports.truncatedNormal = operation_1.op({ truncatedNormal_: truncatedNormal_ });
exports.unstack = operation_1.op({ unstack_: unstack_ });

},{"../environment":60,"../tensor":196,"../tensor_util_env":199,"../util":203,"./axis_util":140,"./concat_split":146,"./operation":162,"./rand":165,"./tensor_ops":180}],139:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getReshaped(inputShape, blockShape, prod, batchToSpace) {
    if (batchToSpace === void 0) { batchToSpace = true; }
    var reshaped = [];
    if (batchToSpace) {
        reshaped = reshaped.concat(blockShape.slice(0));
        reshaped.push(inputShape[0] / prod);
        reshaped = reshaped.concat(inputShape.slice(1));
    }
    else {
        reshaped = reshaped.concat(inputShape[0]);
        var spatialLength = blockShape.length;
        for (var i = 0; i < spatialLength; ++i) {
            reshaped =
                reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);
        }
        reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));
    }
    return reshaped;
}
exports.getReshaped = getReshaped;
function getPermuted(reshapedRank, blockShapeRank, batchToSpace) {
    if (batchToSpace === void 0) { batchToSpace = true; }
    var permuted = [];
    if (batchToSpace) {
        permuted.push(blockShapeRank);
        for (var i = blockShapeRank + 1; i < reshapedRank; ++i) {
            if (i <= 2 * blockShapeRank) {
                permuted.push(i);
                permuted.push(i - (blockShapeRank + 1));
            }
            else {
                permuted.push(i);
            }
        }
    }
    else {
        var permutedBeforeBatch = [];
        var permutedAfterBatch = [];
        for (var i = 1; i < reshapedRank; ++i) {
            if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {
                permutedAfterBatch.push(i);
            }
            else {
                permutedBeforeBatch.push(i);
            }
        }
        permuted.push.apply(permuted, permutedBeforeBatch);
        permuted.push(0);
        permuted.push.apply(permuted, permutedAfterBatch);
    }
    return permuted;
}
exports.getPermuted = getPermuted;
function getReshapedPermuted(inputShape, blockShape, prod, batchToSpace) {
    if (batchToSpace === void 0) { batchToSpace = true; }
    var reshapedPermuted = [];
    if (batchToSpace) {
        reshapedPermuted.push(inputShape[0] / prod);
    }
    else {
        reshapedPermuted.push(inputShape[0] * prod);
    }
    for (var i = 1; i < inputShape.length; ++i) {
        if (i <= blockShape.length) {
            if (batchToSpace) {
                reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);
            }
            else {
                reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);
            }
        }
        else {
            reshapedPermuted.push(inputShape[i]);
        }
    }
    return reshapedPermuted;
}
exports.getReshapedPermuted = getReshapedPermuted;
function getSliceBeginCoords(crops, blockShape) {
    var sliceBeginCoords = [0];
    for (var i = 0; i < blockShape; ++i) {
        sliceBeginCoords.push(crops[i][0]);
    }
    return sliceBeginCoords;
}
exports.getSliceBeginCoords = getSliceBeginCoords;
function getSliceSize(uncroppedShape, crops, blockShape) {
    var sliceSize = uncroppedShape.slice(0, 1);
    for (var i = 0; i < blockShape; ++i) {
        sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);
    }
    return sliceSize;
}
exports.getSliceSize = getSliceSize;

},{}],140:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function axesAreInnerMostDims(axes, rank) {
    for (var i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
            return false;
        }
    }
    return true;
}
exports.axesAreInnerMostDims = axesAreInnerMostDims;
function combineLocations(outputLoc, reduceLoc, axes) {
    var rank = outputLoc.length + reduceLoc.length;
    var loc = [];
    var outIdx = 0;
    var reduceIdx = 0;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            loc.push(outputLoc[outIdx++]);
        }
        else {
            loc.push(reduceLoc[reduceIdx++]);
        }
    }
    return loc;
}
exports.combineLocations = combineLocations;
function computeOutAndReduceShapes(aShape, axes) {
    var outShape = [];
    var rank = aShape.length;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            outShape.push(aShape[dim]);
        }
    }
    var reduceShape = axes.map(function (dim) { return aShape[dim]; });
    return [outShape, reduceShape];
}
exports.computeOutAndReduceShapes = computeOutAndReduceShapes;
function expandShapeToKeepDim(shape, axes) {
    var reduceSubShape = axes.map(function (x) { return 1; });
    return combineLocations(shape, reduceSubShape, axes);
}
exports.expandShapeToKeepDim = expandShapeToKeepDim;
function parseAxisParam(axis, shape) {
    var rank = shape.length;
    axis = axis == null ? shape.map(function (s, i) { return i; }) : [].concat(axis);
    util.assert(axis.every(function (ax) { return ax >= -rank && ax < rank; }), "All values in axis param must be in range [-" + rank + ", " + rank + ") but " +
        ("got axis " + axis));
    util.assert(axis.every(function (ax) { return util.isInt(ax); }), "All values in axis param must be integers but " +
        ("got axis " + axis));
    return axis.map(function (a) { return a < 0 ? rank + a : a; });
}
exports.parseAxisParam = parseAxisParam;
function assertAxesAreInnerMostDims(msg, axes, rank) {
    util.assert(axesAreInnerMostDims(axes, rank), msg + " supports only inner-most axes for now. " +
        ("Got axes " + axes + " and rank-" + rank + " input."));
}
exports.assertAxesAreInnerMostDims = assertAxesAreInnerMostDims;
function getAxesPermutation(axes, rank) {
    if (axesAreInnerMostDims(axes, rank)) {
        return null;
    }
    var result = [];
    for (var i = 0; i < rank; ++i) {
        if (axes.indexOf(i) === -1) {
            result.push(i);
        }
    }
    axes.forEach(function (axis) { return result.push(axis); });
    return result;
}
exports.getAxesPermutation = getAxesPermutation;
function getUndoAxesPermutation(axes) {
    return axes.map(function (axis, i) { return [i, axis]; })
        .sort(function (a, b) { return a[1] - b[1]; })
        .map(function (x) { return x[0]; });
}
exports.getUndoAxesPermutation = getUndoAxesPermutation;
function getInnerMostAxes(numAxes, rank) {
    var res = [];
    for (var i = rank - numAxes; i < rank; ++i) {
        res.push(i);
    }
    return res;
}
exports.getInnerMostAxes = getInnerMostAxes;

},{"../util":203}],141:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var array_ops_1 = require("./array_ops");
var broadcast_util_1 = require("./broadcast_util");
var operation_1 = require("./operation");
var tensor_ops_1 = require("./tensor_ops");
var unary_ops_1 = require("./unary_ops");
function batchNormalization2d_(x, mean, variance, varianceEpsilon, scale, offset) {
    if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'batchNormalization');
    var $mean = tensor_util_env_1.convertToTensor(mean, 'mean', 'batchNormalization');
    var $variance = tensor_util_env_1.convertToTensor(variance, 'variance', 'batchNormalization');
    var $scale;
    if (scale != null) {
        $scale = tensor_util_env_1.convertToTensor(scale, 'scale', 'batchNormalization');
    }
    var $offset;
    if (offset != null) {
        $offset = tensor_util_env_1.convertToTensor(offset, 'offset', 'batchNormalization');
    }
    util.assert($x.rank === 2, "Error in batchNormalization3D: x must be rank 3 but got rank " +
        ($x.rank + "."));
    util.assert($mean.rank === 2 || $mean.rank === 1, "Error in batchNormalization2D: mean must be rank 2 or rank 1 but " +
        ("got rank " + $mean.rank + "."));
    util.assert($variance.rank === 2 || $variance.rank === 1, "Error in batchNormalization2D: variance must be rank 2 or rank 1 " +
        ("but got rank " + $variance.rank + "."));
    if ($scale != null) {
        util.assert($scale.rank === 2 || $scale.rank === 1, "Error in batchNormalization2D: scale must be rank 2 or rank 1 " +
            ("but got rank " + $scale.rank + "."));
    }
    if ($offset != null) {
        util.assert($offset.rank === 2 || $offset.rank === 1, "Error in batchNormalization2D: offset must be rank 2 or rank 1 " +
            ("but got rank " + $offset.rank + "."));
    }
    return exports.batchNormalization($x, $mean, $variance, varianceEpsilon, $scale, $offset);
}
function batchNormalization3d_(x, mean, variance, varianceEpsilon, scale, offset) {
    if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'batchNormalization');
    var $mean = tensor_util_env_1.convertToTensor(mean, 'mean', 'batchNormalization');
    var $variance = tensor_util_env_1.convertToTensor(variance, 'variance', 'batchNormalization');
    var $scale;
    if (scale != null) {
        $scale = tensor_util_env_1.convertToTensor(scale, 'scale', 'batchNormalization');
    }
    var $offset;
    if (offset != null) {
        $offset = tensor_util_env_1.convertToTensor(offset, 'offset', 'batchNormalization');
    }
    util.assert($x.rank === 3, "Error in batchNormalization3D: x must be rank 3 but got rank " +
        ($x.rank + "."));
    util.assert($mean.rank === 3 || $mean.rank === 1, "Error in batchNormalization3D: mean must be rank 3 or rank 1 but " +
        ("got rank " + $mean.rank + "."));
    util.assert($variance.rank === 3 || $variance.rank === 1, "Error in batchNormalization3D: variance must be rank 3 or rank 1 " +
        ("but got rank " + $variance.rank + "."));
    if ($scale != null) {
        util.assert($scale.rank === 3 || $scale.rank === 1, "Error in batchNormalization3D: scale must be rank 3 or rank 1 " +
            ("but got rank " + $scale.rank + "."));
    }
    if ($offset != null) {
        util.assert($offset.rank === 3 || $offset.rank === 1, "Error in batchNormalization3D: offset must be rank 3 or rank 1 " +
            ("but got rank " + $offset.rank + "."));
    }
    return exports.batchNormalization($x, $mean, $variance, varianceEpsilon, $scale, $offset);
}
function batchNormalization4d_(x, mean, variance, varianceEpsilon, scale, offset) {
    if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'batchNormalization');
    var $mean = tensor_util_env_1.convertToTensor(mean, 'mean', 'batchNormalization');
    var $variance = tensor_util_env_1.convertToTensor(variance, 'variance', 'batchNormalization');
    var $scale;
    if (scale != null) {
        $scale = tensor_util_env_1.convertToTensor(scale, 'scale', 'batchNormalization');
    }
    var $offset;
    if (offset != null) {
        $offset = tensor_util_env_1.convertToTensor(offset, 'offset', 'batchNormalization');
    }
    util.assert($x.rank === 4, "Error in batchNormalization4D: x must be rank 4 but got rank " +
        ($x.rank + "."));
    util.assert($mean.rank === 4 || $mean.rank === 1, "Error in batchNormalization4D: mean must be rank 4 or rank 1 but " +
        ("got rank " + $mean.rank + "."));
    util.assert($variance.rank === 4 || $variance.rank === 1, "Error in batchNormalization4D: variance must be rank 4 or rank 1 " +
        ("but got rank " + $variance.rank + "."));
    if ($scale != null) {
        util.assert($scale.rank === 4 || $scale.rank === 1, "Error in batchNormalization4D: scale must be rank 4 or rank 1 " +
            ("but got rank " + $scale.rank + "."));
    }
    if ($offset != null) {
        util.assert($offset.rank === 4 || $offset.rank === 1, "Error in batchNormalization4D: offset must be rank 4 or rank 1 " +
            ("but got rank " + $offset.rank + "."));
    }
    return exports.batchNormalization($x, $mean, $variance, varianceEpsilon, $scale, $offset);
}
function batchNormalization_(x, mean, variance, varianceEpsilon, scale, offset) {
    if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'batchNormalization');
    var $mean = tensor_util_env_1.convertToTensor(mean, 'mean', 'batchNormalization');
    var $variance = tensor_util_env_1.convertToTensor(variance, 'variance', 'batchNormalization');
    var $scale;
    if (scale != null) {
        $scale = tensor_util_env_1.convertToTensor(scale, 'scale', 'batchNormalization');
    }
    var $offset;
    if (offset != null) {
        $offset = tensor_util_env_1.convertToTensor(offset, 'offset', 'batchNormalization');
    }
    util.assert($mean.rank === $variance.rank, 'Batch normalization gradient requires mean and variance to have ' +
        'equal ranks.');
    util.assert($offset == null || $mean.rank === $offset.rank, 'Batch normalization gradient requires mean and offset to have ' +
        'equal ranks.');
    util.assert($scale == null || $mean.rank === $scale.rank, 'Batch normalization gradient requires mean and scale to have ' +
        'equal ranks.');
    var x4D;
    if ($x.rank === 0 || $x.rank === 1) {
        x4D = $x.as4D(1, 1, 1, $x.size);
    }
    else if ($x.rank === 2) {
        x4D = $x.as4D(1, 1, $x.shape[0], $x.shape[1]);
    }
    else if ($x.rank === 3) {
        x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);
    }
    else {
        x4D = $x;
    }
    var der = function (dy) {
        var scaleValue = $scale == null ? tensor_ops_1.scalar(1) : $scale;
        var reductionAxes = broadcast_util_1.getReductionAxes($mean.shape, x4D.shape);
        var tileShape = [];
        if ($mean.rank === 1) {
            for (var i = 0; i < x4D.shape.length - 1; ++i) {
                tileShape.push(x4D.shape[i]);
            }
            tileShape.push(1);
        }
        var xMinusMean = $x.sub($mean);
        var dyTimesScaleValue = dy.mul(scaleValue);
        var oneOverSqrtVariance = unary_ops_1.rsqrt($variance.add(tensor_ops_1.scalar(varianceEpsilon)));
        var minusHalfRCube = oneOverSqrtVariance.mul(oneOverSqrtVariance)
            .mul(oneOverSqrtVariance)
            .mul(tensor_ops_1.scalar(-0.5));
        var derX = function () {
            if ($mean.rank === 1) {
                return dy
                    .mul(array_ops_1.tile(oneOverSqrtVariance.as4D(1, 1, 1, $mean.shape[0]), tileShape))
                    .mul(scaleValue)
                    .reshape($x.shape);
            }
            else {
                return dy.mul(oneOverSqrtVariance).mul(scaleValue).reshape($x.shape);
            }
        };
        var derMean = function () {
            var meanDer = oneOverSqrtVariance.mul(tensor_ops_1.scalar(-1)).mul(dyTimesScaleValue);
            if ($mean.rank === 1) {
                meanDer = meanDer.sum(reductionAxes);
            }
            return meanDer.reshape($mean.shape);
        };
        var derVariance = function () {
            var varianceDer = minusHalfRCube.mul(xMinusMean).mul(dyTimesScaleValue);
            if ($mean.rank === 1) {
                varianceDer = varianceDer.sum(reductionAxes);
            }
            return varianceDer.reshape($mean.shape);
        };
        var derScale = function () {
            var xMinusMean2TimesRsqrt = xMinusMean.mul(oneOverSqrtVariance);
            var scaleDer = dy.mul(xMinusMean2TimesRsqrt);
            if ($mean.rank === 1) {
                scaleDer = scaleDer.sum(reductionAxes);
            }
            return scaleDer.reshape($mean.shape);
        };
        var derOffset = function () {
            var offsetDer = dy;
            if ($mean.rank === 1) {
                offsetDer = offsetDer.sum(reductionAxes);
            }
            return offsetDer.reshape($mean.shape);
        };
        return {
            $x: derX,
            $mean: derMean,
            $variance: derVariance,
            $scale: derScale,
            $offset: derOffset
        };
    };
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.batchNormalization(x4D, batchnormReshape4D($mean), batchnormReshape4D($variance), varianceEpsilon, batchnormReshape4D($scale), batchnormReshape4D($offset)); }, { $x: $x, $mean: $mean, $variance: $variance, $scale: $scale, $offset: $offset }, der);
    return res.reshape($x.shape);
}
function batchnormReshape4D(x) {
    if (x == null) {
        return null;
    }
    if (x.rank === 0) {
        return x.as1D();
    }
    else if (x.rank === 1) {
        return x;
    }
    else if (x.rank === 2) {
        return x.as4D(1, 1, x.shape[0], x.shape[1]);
    }
    else if (x.rank === 3) {
        return x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
    }
    return x;
}
exports.batchNormalization2d = operation_1.op({ batchNormalization2d_: batchNormalization2d_ });
exports.batchNormalization3d = operation_1.op({ batchNormalization3d_: batchNormalization3d_ });
exports.batchNormalization4d = operation_1.op({ batchNormalization4d_: batchNormalization4d_ });
exports.batchNormalization = operation_1.op({ batchNormalization_: batchNormalization_ });

},{"../environment":60,"../tensor_util_env":199,"../util":203,"./array_ops":138,"./broadcast_util":143,"./operation":162,"./tensor_ops":180,"./unary_ops":183}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_1 = require("../tensor_util");
var tensor_util_env_1 = require("../tensor_util_env");
var types_1 = require("../types");
var util = require("../util");
var broadcast_util = require("./broadcast_util");
var operation_1 = require("./operation");
var tensor_ops_1 = require("./tensor_ops");
var unary_ops_1 = require("./unary_ops");
function add_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'add');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'add');
    tensor_util_1.assertTypesMatch($a, $b);
    var outShape = broadcast_util.assertAndGetBroadcastShape($a.shape, $b.shape);
    var der = function (dy) {
        var derA = function () {
            var res = dy;
            var reduceAxes = broadcast_util.getReductionAxes($a.shape, outShape);
            if (reduceAxes.length > 0) {
                res = res.sum(reduceAxes);
            }
            return res.reshape($a.shape);
        };
        var derB = function () {
            var res = dy;
            var reduceAxes = broadcast_util.getReductionAxes($b.shape, outShape);
            if (reduceAxes.length > 0) {
                res = res.sum(reduceAxes);
            }
            return res.reshape($b.shape);
        };
        return { $a: derA, $b: derB };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.add($a, $b); }, { $a: $a, $b: $b }, der);
}
function addN_(tensors) {
    util.assert(Array.isArray(tensors), function () { return 'The argument passed to tf.addN() must be a list of tensors'; });
    util.assert(tensors.length >= 1, function () { return "Must pass at least one tensor to tf.addN(), but got " +
        ("" + tensors.length); });
    var $tensors = tensors.map(function (t, i) { return tensor_util_env_1.convertToTensor(t, "tensors" + i, 'addN'); });
    var firstTensor = $tensors[0];
    $tensors.forEach(function (t) {
        if (t.dtype !== firstTensor.dtype) {
            throw new Error('All tensors passed to tf.addN() must have the same dtype');
        }
    });
    $tensors.forEach(function (t) {
        if (!util.arraysEqual(t.shape, firstTensor.shape)) {
            throw new Error('All tensors passed to tf.addN() must have the same shape');
        }
    });
    var der = function (dy) {
        var ders = {};
        $tensors.forEach(function (t, i) {
            ders[i] = function () { return dy.clone(); };
        });
        return ders;
    };
    var inputs = $tensors;
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.addN($tensors); }, inputs, der);
}
function addStrict_(a, b) {
    util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');
    return a.add(b);
}
function sub_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'sub');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'sub');
    tensor_util_1.assertTypesMatch($a, $b);
    var outShape = broadcast_util.assertAndGetBroadcastShape($a.shape, $b.shape);
    var der = function (dy) {
        var derA = function () {
            var res = dy;
            var reduceAxes = broadcast_util.getReductionAxes($a.shape, outShape);
            if (reduceAxes.length > 0) {
                res = res.sum(reduceAxes);
            }
            return res.reshape($a.shape);
        };
        var derB = function () {
            var res = dy;
            var reduceAxes = broadcast_util.getReductionAxes($b.shape, outShape);
            if (reduceAxes.length > 0) {
                res = res.sum(reduceAxes);
            }
            return res.neg().reshape($b.shape);
        };
        return { $a: derA, $b: derB };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.subtract($a, $b); }, { $a: $a, $b: $b }, der);
}
function subStrict_(a, b) {
    util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');
    return a.sub(b);
}
function pow_(base, exp) {
    var $base = tensor_util_env_1.convertToTensor(base, 'base', 'pow');
    var $exp = tensor_util_env_1.convertToTensor(exp, 'exp', 'pow');
    var outShape = broadcast_util.assertAndGetBroadcastShape($base.shape, $exp.shape);
    base = $base.cast(types_1.upcastType($base.dtype, $exp.dtype));
    exp = $exp.cast(types_1.upcastType($base.dtype, $exp.dtype));
    var grad = function (dy, saved) {
        var y = saved[0];
        var derBase = function () {
            var res = dy.mul($exp.toFloat().mul(y.div($base)));
            var reduceAxes = broadcast_util.getReductionAxes($base.shape, outShape);
            if (reduceAxes.length > 0) {
                res = res.sum(reduceAxes);
            }
            return res.reshape($base.shape);
        };
        var derExp = function () {
            var res = dy.mul(y.mul($base.log()).toFloat());
            var reduceAxes = broadcast_util.getReductionAxes($exp.shape, outShape);
            if (reduceAxes.length > 0) {
                res = res.sum(reduceAxes);
            }
            return res.reshape($exp.shape);
        };
        return { $base: derBase, $exp: derExp };
    };
    return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.pow($base, $exp)); }, { $base: $base, $exp: $exp }, grad);
}
function powStrict_(base, exp) {
    util.assertShapesMatch(base.shape, exp.shape, 'Error in powStrict: ');
    return base.pow(exp);
}
function mul_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'mul');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'mul');
    tensor_util_1.assertTypesMatch($a, $b);
    var outShape = broadcast_util.assertAndGetBroadcastShape($a.shape, $b.shape);
    var der = function (dy) {
        var derA = function () {
            var res = dy.mul($b.toFloat());
            var reduceAxes = broadcast_util.getReductionAxes($a.shape, outShape);
            if (reduceAxes.length > 0) {
                return res.sum(reduceAxes).reshape($a.shape);
            }
            return res;
        };
        var derB = function () {
            var res = dy.mul($a.toFloat());
            var reduceAxes = broadcast_util.getReductionAxes($b.shape, outShape);
            if (reduceAxes.length > 0) {
                return res.sum(reduceAxes).reshape($b.shape);
            }
            return res;
        };
        return { $a: derA, $b: derB };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.multiply($a, $b); }, { $a: $a, $b: $b }, der);
}
function mulStrict_(a, b) {
    util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');
    return a.mul(b);
}
function div_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'div');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'div');
    tensor_util_1.assertTypesMatch($a, $b);
    var forwardFunc;
    if ($a.dtype === 'int32' && $b.dtype === 'int32') {
        return exports.floorDiv($a, $b);
    }
    else {
        forwardFunc = function (backend) { return backend.realDivide($a, $b); };
    }
    var outShape = broadcast_util.assertAndGetBroadcastShape($a.shape, $b.shape);
    var der = function (dy) {
        var derA = function () {
            var res = dy.div($b.toFloat());
            var reduceAxes = broadcast_util.getReductionAxes($a.shape, outShape);
            if (reduceAxes.length > 0) {
                return res.sum(reduceAxes).reshape($a.shape);
            }
            return res;
        };
        var derB = function () {
            var res = dy.mul($a.toFloat());
            var reduceAxes = broadcast_util.getReductionAxes($b.shape, outShape);
            if (reduceAxes.length > 0) {
                res = res.sum(reduceAxes).reshape($b.shape);
            }
            var tmp = $b.square();
            return res.div(tmp.toFloat()).neg();
        };
        return { $a: derA, $b: derB };
    };
    return environment_1.ENV.engine.runKernel(forwardFunc, { $a: $a, $b: $b }, der);
}
function floorDiv_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'floorDiv');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'floorDiv');
    tensor_util_1.assertTypesMatch($a, $b);
    var forwardFunc = function (backend) { return backend.floorDiv($a, $b); };
    var outShape = broadcast_util.assertAndGetBroadcastShape($a.shape, $b.shape);
    var der = function (dy) {
        var derA = function () {
            var res = dy.div($b.toFloat());
            var reduceAxes = broadcast_util.getReductionAxes($a.shape, outShape);
            if (reduceAxes.length > 0) {
                return res.sum(reduceAxes).reshape($a.shape);
            }
            return res;
        };
        var derB = function () {
            var res = dy.mul($a.toFloat());
            var reduceAxes = broadcast_util.getReductionAxes($b.shape, outShape);
            if (reduceAxes.length > 0) {
                res = res.sum(reduceAxes).reshape($b.shape);
            }
            var tmp = $b.square();
            return res.div(tmp.toFloat()).neg();
        };
        return { $a: derA, $b: derB };
    };
    return environment_1.ENV.engine.runKernel(forwardFunc, { $a: $a, $b: $b }, der);
}
function divStrict_(a, b) {
    util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');
    return a.div(b);
}
function mod_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'mod');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'mod');
    tensor_util_1.assertTypesMatch($a, $b);
    var outShape = broadcast_util.assertAndGetBroadcastShape($a.shape, $b.shape);
    var der = function (dy) {
        var derA = function () {
            var reduceAxes = broadcast_util.getReductionAxes($a.shape, outShape);
            if (reduceAxes.length > 0) {
                return dy.sum(reduceAxes).reshape($a.shape);
            }
            return dy;
        };
        var derB = function () {
            var res = dy.mul($a.div($b).floor().neg());
            var reduceAxes = broadcast_util.getReductionAxes($b.shape, outShape);
            if (reduceAxes.length > 0) {
                return res.sum(reduceAxes).reshape($b.shape);
            }
            return res;
        };
        return { $a: derA, $b: derB };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.mod($a, $b); }, { $a: $a, $b: $b }, der);
}
function modStrict_(a, b) {
    util.assertShapesMatch(a.shape, b.shape, 'Error in modStrict: ');
    return a.mod(b);
}
function minimum_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'minimum');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'minimum');
    tensor_util_1.assertTypesMatch($a, $b);
    if ($a.dtype === 'bool') {
        $a = $a.toInt();
    }
    if ($b.dtype === 'bool') {
        $b = $b.toInt();
    }
    broadcast_util.assertAndGetBroadcastShape($a.shape, $b.shape);
    var der = function (dy) {
        var derA = function () { return dy.mul($a.lessEqual($b).toFloat()); };
        var derB = function () { return dy.mul($a.greater($b).toFloat()); };
        return { $a: derA, $b: derB };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.minimum($a, $b); }, { $a: $a, $b: $b }, der);
}
function minimumStrict_(a, b) {
    util.assertShapesMatch(a.shape, b.shape, 'Error in minimumStrict: ');
    return a.minimum(b);
}
function maximum_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'maximum');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'maximum');
    tensor_util_1.assertTypesMatch($a, $b);
    if ($a.dtype === 'bool') {
        $a = $a.toInt();
    }
    if ($b.dtype === 'bool') {
        $b = $b.toInt();
    }
    broadcast_util.assertAndGetBroadcastShape($a.shape, $b.shape);
    var der = function (dy) {
        var derA = function () { return dy.mul($a.greaterEqual($b).toFloat()); };
        var derB = function () { return dy.mul($a.less($b).toFloat()); };
        return { $a: derA, $b: derB };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.maximum($a, $b); }, { $a: $a, $b: $b }, der);
}
function maximumStrict_(a, b) {
    util.assertShapesMatch(a.shape, b.shape, 'Error in maximumStrict: ');
    return a.maximum(b);
}
function squaredDifference_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'squaredDifference');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'squaredDifference');
    tensor_util_1.assertTypesMatch($a, $b);
    broadcast_util.assertAndGetBroadcastShape($a.shape, $b.shape);
    var der = function (dy) {
        var two = tensor_ops_1.scalar(2);
        var derA = function () { return dy.mul($a.sub($b).mul(two)); };
        var derB = function () { return dy.mul($b.sub($a).mul(two)); };
        return { $a: derA, $b: derB };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.squaredDifference($a, $b); }, { $a: $a, $b: $b }, der);
}
function squaredDifferenceStrict_(a, b) {
    util.assertShapesMatch(a.shape, b.shape, 'Error in squaredDifferenceStrict: ');
    return a.squaredDifference(b);
}
function atan2_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'atan2');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'atan2');
    tensor_util_1.assertTypesMatch($a, $b);
    var outShape = broadcast_util.assertAndGetBroadcastShape($a.shape, $b.shape);
    var der = function (dy) {
        var derA = function () {
            var d = exports.add($a.square(), $b.square());
            var res = dy.mul($b.div(d));
            var reduceAxes = broadcast_util.getReductionAxes($a.shape, outShape);
            if (reduceAxes.length > 0) {
                res = res.sum(reduceAxes);
            }
            return res.reshape($a.shape);
        };
        var derB = function () {
            var d = exports.add($a.square(), $b.square());
            var res = unary_ops_1.neg(dy.mul($a.div(d)));
            var reduceAxes = broadcast_util.getReductionAxes($b.shape, outShape);
            if (reduceAxes.length > 0) {
                res = res.sum(reduceAxes);
            }
            return res.reshape($b.shape);
        };
        return { $a: derA, $b: derB };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.atan2($a, $b); }, { $a: $a, $b: $b }, der);
}
exports.add = operation_1.op({ add_: add_ });
exports.addN = operation_1.op({ addN_: addN_ });
exports.addStrict = operation_1.op({ addStrict_: addStrict_ });
exports.atan2 = operation_1.op({ atan2_: atan2_ });
exports.div = operation_1.op({ div_: div_ });
exports.divStrict = operation_1.op({ divStrict_: divStrict_ });
exports.floorDiv = operation_1.op({ floorDiv_: floorDiv_ });
exports.maximum = operation_1.op({ maximum_: maximum_ });
exports.maximumStrict = operation_1.op({ maximumStrict_: maximumStrict_ });
exports.minimum = operation_1.op({ minimum_: minimum_ });
exports.minimumStrict = operation_1.op({ minimumStrict_: minimumStrict_ });
exports.mod = operation_1.op({ mod_: mod_ });
exports.modStrict = operation_1.op({ modStrict_: modStrict_ });
exports.mul = operation_1.op({ mul_: mul_ });
exports.mulStrict = operation_1.op({ mulStrict_: mulStrict_ });
exports.pow = operation_1.op({ pow_: pow_ });
exports.powStrict = operation_1.op({ powStrict_: powStrict_ });
exports.squaredDifference = operation_1.op({ squaredDifference_: squaredDifference_ });
exports.squaredDifferenceStrict = operation_1.op({ squaredDifferenceStrict_: squaredDifferenceStrict_ });
exports.sub = operation_1.op({ sub_: sub_ });
exports.subStrict = operation_1.op({ subStrict_: subStrict_ });

},{"../environment":60,"../tensor_util":198,"../tensor_util_env":199,"../types":202,"../util":203,"./broadcast_util":143,"./operation":162,"./tensor_ops":180,"./unary_ops":183}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getBroadcastDims(inShape, outShape) {
    var inRank = inShape.length;
    var dims = [];
    for (var i = 0; i < inRank; i++) {
        var dim = inRank - 1 - i;
        var a = inShape[dim] || 1;
        var b = outShape[outShape.length - 1 - i] || 1;
        if (b > 1 && a === 1) {
            dims.unshift(dim);
        }
    }
    return dims;
}
exports.getBroadcastDims = getBroadcastDims;
function getReductionAxes(inShape, outShape) {
    var result = [];
    for (var i = 0; i < outShape.length; i++) {
        var inDim = inShape[inShape.length - i - 1];
        var outAxis = outShape.length - i - 1;
        var outDim = outShape[outAxis];
        if (inDim == null || (inDim === 1 && outDim > 1)) {
            result.unshift(outAxis);
        }
    }
    return result;
}
exports.getReductionAxes = getReductionAxes;
function broadcastDimsAreOuter(dims) {
    for (var i = 0; i < dims.length; i++) {
        if (dims[i] !== i) {
            return false;
        }
    }
    return true;
}
exports.broadcastDimsAreOuter = broadcastDimsAreOuter;
function assertAndGetBroadcastShape(shapeA, shapeB) {
    var result = [];
    var l = Math.max(shapeA.length, shapeB.length);
    for (var i = 0; i < l; i++) {
        var a = shapeA[shapeA.length - i - 1];
        if (a == null) {
            a = 1;
        }
        var b = shapeB[shapeB.length - i - 1];
        if (b == null) {
            b = 1;
        }
        if (a === 1) {
            result.unshift(b);
        }
        else if (b === 1) {
            result.unshift(a);
        }
        else if (a !== b) {
            var errMsg = "Operands could not be broadcast together with shapes " +
                (shapeA + " and " + shapeB + ".");
            throw Error(errMsg);
        }
        else {
            result.unshift(a);
        }
    }
    return result;
}
exports.assertAndGetBroadcastShape = assertAndGetBroadcastShape;

},{}],144:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_1 = require("../tensor_util");
var tensor_util_env_1 = require("../tensor_util_env");
var util_1 = require("../util");
var broadcast_util_1 = require("./broadcast_util");
var operation_1 = require("./operation");
var tensor_ops_1 = require("./tensor_ops");
function notEqual_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'notEqual');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'notEqual');
    tensor_util_1.assertTypesMatch($a, $b);
    broadcast_util_1.assertAndGetBroadcastShape($a.shape, $b.shape);
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.notEqual($a, $b); }, { $a: $a, $b: $b });
}
function notEqualStrict_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'notEqualStrict');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'notEqualStrict');
    util_1.assertShapesMatch($a.shape, $b.shape, 'Error in notEqualStrict: ');
    return $a.notEqual($b);
}
function less_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'less');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'less');
    tensor_util_1.assertTypesMatch($a, $b);
    broadcast_util_1.assertAndGetBroadcastShape($a.shape, $b.shape);
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.less($a, $b); }, { $a: $a, $b: $b });
}
function lessStrict_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'lessStrict');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'lessStrict');
    util_1.assertShapesMatch($a.shape, $b.shape, 'Error in lessStrict: ');
    return $a.less($b);
}
function equal_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'equal');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'equal');
    tensor_util_1.assertTypesMatch($a, $b);
    broadcast_util_1.assertAndGetBroadcastShape($a.shape, $b.shape);
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.equal($a, $b); }, { $a: $a, $b: $b });
}
function equalStrict_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'equalStrict');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'equalStrict');
    util_1.assertShapesMatch($a.shape, $b.shape, 'Error in equalStrict: ');
    return $a.equal($b);
}
function lessEqual_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'lessEqual');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'lessEqual');
    tensor_util_1.assertTypesMatch($a, $b);
    broadcast_util_1.assertAndGetBroadcastShape($a.shape, $b.shape);
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.lessEqual($a, $b); }, { $a: $a, $b: $b });
}
function lessEqualStrict_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'lessEqualStrict');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'lessEqualStrict');
    util_1.assertShapesMatch($a.shape, $b.shape, 'Error in lessEqualStrict: ');
    return $a.lessEqual($b);
}
function greater_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'greater');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'greater');
    tensor_util_1.assertTypesMatch($a, $b);
    broadcast_util_1.assertAndGetBroadcastShape($a.shape, $b.shape);
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.greater($a, $b); }, { $a: $a, $b: $b });
}
function greaterStrict_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'greaterStrict');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'greaterStrict');
    util_1.assertShapesMatch($a.shape, $b.shape, 'Error in greaterStrict: ');
    return $a.greater($b);
}
function greaterEqual_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'greaterEqual');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'greaterEqual');
    tensor_util_1.assertTypesMatch($a, $b);
    broadcast_util_1.assertAndGetBroadcastShape($a.shape, $b.shape);
    var grad = function (dy) {
        return { $a: function () { return tensor_ops_1.zerosLike($a); }, $b: function () { return tensor_ops_1.zerosLike($b); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.greaterEqual($a, $b); }, { $a: $a, $b: $b }, grad);
}
function greaterEqualStrict_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'greaterEqualStrict');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'greaterEqualStrict');
    util_1.assertShapesMatch($a.shape, $b.shape, 'Error in greaterEqualStrict: ');
    return $a.greaterEqual($b);
}
exports.equal = operation_1.op({ equal_: equal_ });
exports.equalStrict = operation_1.op({ equalStrict_: equalStrict_ });
exports.greater = operation_1.op({ greater_: greater_ });
exports.greaterEqual = operation_1.op({ greaterEqual_: greaterEqual_ });
exports.greaterEqualStrict = operation_1.op({ greaterEqualStrict_: greaterEqualStrict_ });
exports.greaterStrict = operation_1.op({ greaterStrict_: greaterStrict_ });
exports.less = operation_1.op({ less_: less_ });
exports.lessEqual = operation_1.op({ lessEqual_: lessEqual_ });
exports.lessEqualStrict = operation_1.op({ lessEqualStrict_: lessEqualStrict_ });
exports.lessStrict = operation_1.op({ lessStrict_: lessStrict_ });
exports.notEqual = operation_1.op({ notEqual_: notEqual_ });
exports.notEqualStrict = operation_1.op({ notEqualStrict_: notEqualStrict_ });

},{"../environment":60,"../tensor_util":198,"../tensor_util_env":199,"../util":203,"./broadcast_util":143,"./operation":162,"./tensor_ops":180}],145:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var operation_1 = require("./operation");
function complex_(real, imag) {
    var $real = tensor_util_env_1.convertToTensor(real, 'real', 'complex');
    var $imag = tensor_util_env_1.convertToTensor(imag, 'imag', 'complex');
    util.assertShapesMatch($real.shape, $imag.shape, "real and imag shapes, " + $real.shape + " and " + $imag.shape + ", " +
        "must match in call to tf.complex().");
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.complex($real, $imag); }, { $real: $real, $imag: $imag });
}
function real_(input) {
    var $input = tensor_util_env_1.convertToTensor(input, 'input', 'real');
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.real($input); }, { $input: $input });
}
function imag_(input) {
    var $input = tensor_util_env_1.convertToTensor(input, 'input', 'imag');
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.imag($input); }, { $input: $input });
}
exports.complex = operation_1.op({ complex_: complex_ });
exports.real = operation_1.op({ real_: real_ });
exports.imag = operation_1.op({ imag_: imag_ });

},{"../environment":60,"../tensor_util_env":199,"../util":203,"./operation":162}],146:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var util_1 = require("../util");
var axis_util_1 = require("./axis_util");
var concat_util_1 = require("./concat_util");
var operation_1 = require("./operation");
var tensor_ops_1 = require("./tensor_ops");
function concat1d_(tensors) {
    return exports.concat(tensors, 0);
}
function concat2d_(tensors, axis) {
    return exports.concat(tensors, axis);
}
function concat3d_(tensors, axis) {
    return exports.concat(tensors, axis);
}
function concat4d_(tensors, axis) {
    return exports.concat(tensors, axis);
}
function concat_(tensors, axis) {
    if (axis === void 0) { axis = 0; }
    util_1.assert(tensors.length >= 1, 'Pass at least one tensor to concat');
    var $tensors = tensor_util_env_1.convertToTensorArray(tensors, 'tensors', 'concat');
    axis = axis_util_1.parseAxisParam(axis, $tensors[0].shape)[0];
    var outShape = concat_util_1.computeOutShape($tensors.map(function (t) { return t.shape; }), axis);
    if (util_1.sizeFromShape(outShape) === 0) {
        return tensor_ops_1.tensor([], outShape);
    }
    $tensors = $tensors.filter(function (t) { return t.size > 0; });
    if ($tensors.length === 1) {
        return $tensors[0];
    }
    var shapes = $tensors.map(function (t) { return t.shape; });
    concat_util_1.assertParamsConsistent(shapes, axis);
    var der = function (dy) {
        var sizeSplits = shapes.map(function (s) { return s[axis]; });
        var derTensors = exports.split(dy, sizeSplits, axis);
        return derTensors.map(function (t) { return function () { return t; }; });
    };
    var inputs = $tensors;
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.concat($tensors, axis); }, inputs, der);
}
function split_(x, numOrSizeSplits, axis) {
    if (axis === void 0) { axis = 0; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'split');
    axis = axis_util_1.parseAxisParam(axis, $x.shape)[0];
    var splitSizes;
    if (typeof (numOrSizeSplits) === 'number') {
        util_1.assert($x.shape[axis] % numOrSizeSplits === 0, 'Number of splits must evenly divide the axis.');
        splitSizes = Array(numOrSizeSplits).fill($x.shape[axis] / numOrSizeSplits);
    }
    else {
        util_1.assert($x.shape[axis] === numOrSizeSplits.reduce(function (a, b) { return a + b; }), 'The sum of sizes must match the size of the axis dimension.');
        splitSizes = numOrSizeSplits;
    }
    var der = function (dy) { return ({ $x: function () { return exports.concat(dy, axis); } }); };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.split($x, splitSizes, axis); }, { $x: $x }, der);
}
exports.concat = operation_1.op({ concat_: concat_ });
exports.concat1d = operation_1.op({ concat1d_: concat1d_ });
exports.concat2d = operation_1.op({ concat2d_: concat2d_ });
exports.concat3d = operation_1.op({ concat3d_: concat3d_ });
exports.concat4d = operation_1.op({ concat4d_: concat4d_ });
exports.split = operation_1.op({ split_: split_ });

},{"../environment":60,"../tensor_util_env":199,"../util":203,"./axis_util":140,"./concat_util":147,"./operation":162,"./tensor_ops":180}],147:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParamsConsistent(shapes, axis) {
    var rank = shapes[0].length;
    shapes.forEach(function (shape, i) {
        util.assert(shape.length === rank, "Error in concat" + rank + "D: rank of tensors[" + i + "] must be the same " +
            ("as the rank of the rest (" + rank + ")"));
    });
    util.assert(axis >= 0 && axis < rank, "Error in concat" + rank + "D: axis must be between 0 and " + (rank - 1) + ".");
    var firstShape = shapes[0];
    shapes.forEach(function (shape, i) {
        for (var r = 0; r < rank; r++) {
            util.assert((r === axis) || (shape[r] === firstShape[r]), "Error in concat" + rank + "D: Shape of tensors[" + i + "] (" + shape + ") " +
                ("does not match the shape of the rest (" + firstShape + ") ") +
                ("along the non-concatenated axis " + i + "."));
        }
    });
}
exports.assertParamsConsistent = assertParamsConsistent;
function computeOutShape(shapes, axis) {
    var outputShape = shapes[0].slice();
    for (var i = 1; i < shapes.length; i++) {
        outputShape[axis] += shapes[i][axis];
    }
    return outputShape;
}
exports.computeOutShape = computeOutShape;

},{"../util":203}],148:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var conv_util = require("./conv_util");
var matmul_1 = require("./matmul");
var operation_1 = require("./operation");
function conv1d_(x, filter, stride, pad, dataFormat, dilation, dimRoundingMode) {
    if (dataFormat === void 0) { dataFormat = 'NWC'; }
    if (dilation === void 0) { dilation = 1; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'conv1d');
    var $filter = tensor_util_env_1.convertToTensor(filter, 'filter', 'conv1d');
    var x3D = $x;
    var reshapedTo3D = false;
    if ($x.rank === 2) {
        reshapedTo3D = true;
        x3D = $x.as3D(1, $x.shape[0], $x.shape[1]);
    }
    util.assert(x3D.rank === 3, "Error in conv1d: input must be rank 3, but got rank " + x3D.rank + ".");
    util.assert($filter.rank === 3, "Error in conv1d: filter must be rank 3, but got rank " +
        ($filter.rank + "."));
    if (dimRoundingMode != null) {
        util.assert(util.isInt(pad), "Error in conv1d: pad must be an integer when using, " +
            ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
    }
    util.assert(x3D.shape[2] === $filter.shape[1], "Error in conv1d: depth of input (" + x3D.shape[2] + ") must match " +
        ("input depth for filter " + $filter.shape[1] + "."));
    util.assert(eitherStridesOrDilationsAreOne(stride, dilation), 'Error in conv1D: Either stride or dilation must be 1. ' +
        ("Got stride " + stride + " and dilation '" + dilation + "'"));
    util.assert(dataFormat === 'NWC', "Error in conv1d: got dataFormat of " + dataFormat + " but only NWC is currently supported.");
    var filter4D = $filter.as4D(1, $filter.shape[0], $filter.shape[1], $filter.shape[2]);
    var input4D = x3D.as4D(x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]);
    var strides = [1, stride];
    var dilations = [1, dilation];
    var conv2dDataFormat = 'NHWC';
    var res = exports.conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);
    if (reshapedTo3D) {
        return res.as2D(res.shape[2], res.shape[3]);
    }
    return res.as3D(res.shape[0], res.shape[2], res.shape[3]);
}
function conv2d_(x, filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
    if (dataFormat === void 0) { dataFormat = 'NHWC'; }
    if (dilations === void 0) { dilations = [1, 1]; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'conv2d');
    var $filter = tensor_util_env_1.convertToTensor(filter, 'filter', 'conv2d');
    var x4D = $x;
    var reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);
    }
    util.assert(x4D.rank === 4, "Error in conv2d: input must be rank 4, but got rank " + x4D.rank + ".");
    util.assert($filter.rank === 4, "Error in conv2d: filter must be rank 4, but got rank " +
        ($filter.rank + "."));
    if (dimRoundingMode != null) {
        util.assert(util.isInt(pad), "Error in conv2d: pad must be an integer when using, " +
            ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
    }
    util.assert(x4D.shape[3] === $filter.shape[2], "Error in conv2d: depth of input (" + x4D.shape[3] + ") must match " +
        ("input depth for filter " + $filter.shape[2] + "."));
    util.assert(eitherStridesOrDilationsAreOne(strides, dilations), 'Error in conv2D: Either strides or dilations must be 1. ' +
        ("Got strides " + strides + " and dilations '" + dilations + "'"));
    util.assert(dataFormat === 'NHWC', "Error in conv2d: got dataFormat of " + dataFormat + " but only NHWC is currently supported.");
    var convInfo = conv_util.computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad, dimRoundingMode);
    var res;
    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&
        convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&
        convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&
        (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) {
        var x2d = x4D.reshape([-1, convInfo.inChannels]);
        var w2d = $filter.reshape([convInfo.inChannels, convInfo.outChannels]);
        res = matmul_1.matMul(x2d, w2d).reshape(convInfo.outShape);
    }
    else {
        var grad = function (dy) {
            util.assert(tupleValuesAreOne(dilations), 'Error in gradient of conv2D: dilation rates greater than 1 are not' +
                ("yet supported in gradients. Got dilations '" + dilations + "'"));
            return {
                x: function () { return conv2dDerInput_(x4D.shape, dy, $filter, strides, pad); },
                $filter: function () { return conv2dDerFilter_(x4D, dy, $filter.shape, strides, pad); }
            };
        };
        res = environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2d(x4D, $filter, convInfo); }, { x: x4D, $filter: $filter }, grad);
    }
    if (reshapedTo4D) {
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    }
    return res;
}
function conv2dDerInput_(xShape, dy, filter, strides, pad, dimRoundingMode) {
    util.assert(xShape.length === dy.rank, "Length of inShape " +
        ("(" + xShape.length + ") and rank of dy (" + dy.rank + ") must match"));
    var xShape4D = xShape;
    var dy4D = dy;
    var reshapedTo4D = false;
    if (dy.rank === 3) {
        reshapedTo4D = true;
        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
        xShape4D = [1, xShape[0], xShape[1], xShape[2]];
    }
    var inDepth = xShape4D[3];
    var outDepth = dy4D.shape[3];
    util.assert(xShape4D.length === 4, "Error in conv2dDerInput: inShape must be length 4, but got length " +
        (xShape4D.length + "."));
    util.assert(dy4D.rank === 4, "Error in conv2dDerInput: dy must be rank 4, but got " +
        ("rank " + dy4D.rank));
    util.assert(filter.rank === 4, "Error in conv2dDerInput: filter must be rank 4, but got " +
        ("rank " + filter.rank));
    util.assert(inDepth === filter.shape[2], "Error in conv2dDerInput: depth of input (" + inDepth + ") must " +
        ("match input depth for filter " + filter.shape[2] + "."));
    util.assert(outDepth === filter.shape[3], "Error in conv2dDerInput: depth of output (" + outDepth + ") must " +
        ("match output depth for filter " + filter.shape[3] + "."));
    if (dimRoundingMode != null) {
        util.assert(util.isInt(pad), "Error in conv2dDerInput: pad must be an integer when using, " +
            ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
    }
    var dilations = 1;
    var convInfo = conv_util.computeConv2DInfo(xShape4D, filter.shape, strides, dilations, pad, dimRoundingMode);
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2dDerInput(dy4D, filter, convInfo); }, { dy4D: dy4D });
    if (reshapedTo4D) {
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    }
    return res;
}
function conv2dDerFilter_(x, dy, filterShape, strides, pad, dimRoundingMode) {
    var x4D = x;
    if (x.rank === 3) {
        x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
    }
    var dy4D = dy;
    if (dy4D.rank === 3) {
        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
    }
    util.assert(x4D.rank === 4, "Error in conv2dDerFilter: input must be rank 4, but got shape " +
        (x4D.shape + "."));
    util.assert(dy4D.rank === 4, "Error in conv2dDerFilter: dy must be rank 4, but got shape " +
        (dy4D.shape + "."));
    util.assert(filterShape.length === 4, "Error in conv2dDerFilter: filterShape must be length 4, but got " +
        (filterShape + "."));
    util.assert(x4D.shape[3] === filterShape[2], "Error in conv2dDerFilter: depth of input " + x4D.shape[3] + ") must " +
        ("match input depth in filter (" + filterShape[2] + "."));
    util.assert(dy4D.shape[3] === filterShape[3], "Error in conv2dDerFilter: depth of dy (" + dy4D.shape[3] + ") must " +
        ("match output depth for filter (" + filterShape[3] + ")."));
    if (dimRoundingMode != null) {
        util.assert(util.isInt(pad), "Error in conv2dDerFilter: pad must be an integer when using, " +
            ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
    }
    var dilations = 1;
    var convInfo = conv_util.computeConv2DInfo(x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode);
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2dDerFilter(x4D, dy4D, convInfo); }, { x4D: x4D, dy4D: dy4D });
}
function conv2dTranspose_(x, filter, outputShape, strides, pad, dimRoundingMode) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'conv2dTranspose');
    var $filter = tensor_util_env_1.convertToTensor(filter, 'filter', 'conv2dTranspose');
    return conv2dDerInput_(outputShape, $x, $filter, strides, pad, dimRoundingMode);
}
function depthwiseConv2d_(x, filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
    if (dataFormat === void 0) { dataFormat = 'NHWC'; }
    if (dilations === void 0) { dilations = [1, 1]; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'depthwiseConv2d');
    var $filter = tensor_util_env_1.convertToTensor(filter, 'filter', 'depthwiseConv2d');
    var x4D = $x;
    var reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);
    }
    util.assert(x4D.rank === 4, "Error in depthwiseConv2d: input must be rank 4, but got " +
        ("rank " + x4D.rank + "."));
    util.assert($filter.rank === 4, "Error in depthwiseConv2d: filter must be rank 4, but got rank " +
        ($filter.rank + "."));
    util.assert(x4D.shape[3] === $filter.shape[2], "Error in depthwiseConv2d: number of input channels " +
        ("(" + x4D.shape[3] + ") must match the inChannels dimension in ") +
        ("filter " + $filter.shape[2] + "."));
    if (dilations == null) {
        dilations = [1, 1];
    }
    util.assert(eitherStridesOrDilationsAreOne(strides, dilations), 'Error in depthwiseConv2d: Either strides or dilations must be 1. ' +
        ("Got strides " + strides + " and dilations '" + dilations + "'"));
    if (dimRoundingMode != null) {
        util.assert(util.isInt(pad), "Error in depthwiseConv2d: pad must be an integer when using, " +
            ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
    }
    var convInfo = conv_util.computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad, dimRoundingMode, true);
    var grad = function (dy) {
        util.assert(tupleValuesAreOne(dilations), 'Error in gradient of depthwiseConv2d: dilation rates greater than ' +
            ("1 are not yet supported. Got dilations '" + dilations + "'"));
        return {
            x: function () { return depthwiseConv2dDerInput(x4D.shape, dy, $filter, convInfo); },
            $filter: function () { return depthwiseConv2dDerFilter(x4D, dy, $filter.shape, convInfo); },
        };
    };
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.depthwiseConv2D(x4D, $filter, convInfo); }, { x: x4D, $filter: $filter }, grad);
    if (reshapedTo4D) {
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    }
    return res;
}
function separableConv2d_(x, depthwiseFilter, pointwiseFilter, strides, pad, dilation, dataFormat) {
    if (dilation === void 0) { dilation = [1, 1]; }
    if (dataFormat === void 0) { dataFormat = 'NHWC'; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'separableConv2d');
    var $depthwiseFilter = tensor_util_env_1.convertToTensor(depthwiseFilter, 'depthwiseFilter', 'separableConv2d');
    var $pointwiseFilter = tensor_util_env_1.convertToTensor(pointwiseFilter, 'pointwiseFilter', 'separableConv2d');
    var x4D = $x;
    var reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);
    }
    if (dataFormat === 'NCHW') {
        throw new Error('separableConv2d currently does not support dataFormat NCHW; only ' +
            'NHWC is supported');
    }
    util.assert(x4D.rank === 4, "Error in separableConv2d: input must be rank 4, but got " +
        ("rank " + x4D.rank + "."));
    util.assert($depthwiseFilter.rank === 4, "Error in separableConv2d: depthwise filter must be rank 4, but got " +
        ("rank " + $depthwiseFilter.rank + "."));
    util.assert($pointwiseFilter.rank === 4, "Error in separableConv2d: pointwise filter must be rank 4, but got " +
        ("rank " + $depthwiseFilter.rank + "."));
    util.assert($pointwiseFilter.shape[0] === 1, "Error in separableConv2d: the first dimension of pointwise filter " +
        (" must be 1, but got " + $pointwiseFilter.shape[0] + "."));
    util.assert($pointwiseFilter.shape[1] === 1, "Error in separableConv2d: the second dimension of pointwise filter " +
        (" must be 1, but got " + $pointwiseFilter.shape[1] + "."));
    var inChannels = $depthwiseFilter.shape[2];
    var channelMultiplier = $depthwiseFilter.shape[3];
    util.assert($pointwiseFilter.shape[2] === inChannels * channelMultiplier, "Error in separableConv2d: the third dimension of pointwise filter " +
        ("must be " + inChannels * channelMultiplier + ", ") +
        ("but got " + $pointwiseFilter.shape[2] + "."));
    var depthwise = exports.depthwiseConv2d(x4D, $depthwiseFilter, strides, pad, dataFormat, dilation);
    var pointwiseStride = 1;
    var res = exports.conv2d(depthwise, $pointwiseFilter, pointwiseStride, 'valid', dataFormat);
    if (reshapedTo4D) {
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    }
    return res;
}
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}
function tupleValuesAreOne(param) {
    var _a = parseTupleParam(param), dimA = _a[0], dimB = _a[1];
    return dimA === 1 && dimB === 1;
}
function eitherStridesOrDilationsAreOne(strides, dilations) {
    return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);
}
function depthwiseConv2dDerInput(xShape, dy, filter, convInfo) {
    var dy4D = dy;
    var reshapedTo4D = false;
    if (dy.rank === 3) {
        reshapedTo4D = true;
        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
    }
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.depthwiseConv2DDerInput(dy4D, filter, convInfo); }, { dy4D: dy4D });
    if (reshapedTo4D) {
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    }
    return res;
}
function depthwiseConv2dDerFilter(x, dy, filterShape, convInfo) {
    var x4D = x;
    if (x.rank === 3) {
        x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
    }
    var dy4D = dy;
    if (dy4D.rank === 3) {
        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
    }
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.depthwiseConv2DDerFilter(x4D, dy4D, convInfo); }, { x4D: x4D, dy4D: dy4D });
}
exports.conv1d = operation_1.op({ conv1d_: conv1d_ });
exports.conv2d = operation_1.op({ conv2d_: conv2d_ });
exports.depthwiseConv2d = operation_1.op({ depthwiseConv2d_: depthwiseConv2d_ });
exports.separableConv2d = operation_1.op({ separableConv2d_: separableConv2d_ });
exports.conv2dTranspose = operation_1.op({ conv2dTranspose_: conv2dTranspose_ });

},{"../environment":60,"../tensor_util_env":199,"../util":203,"./conv_util":149,"./matmul":159,"./operation":162}],149:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function computePool2DInfo(inShape, filterSize, strides, pad, roundingMode, dataFormat) {
    if (dataFormat === void 0) { dataFormat = 'channelsLast'; }
    var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
    var filterShape;
    if (dataFormat === 'channelsLast') {
        filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
    }
    else if (dataFormat === 'channelsFirst') {
        filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
    }
    else {
        throw new Error("Unknown dataFormat " + dataFormat);
    }
    var dilations = 1;
    return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);
}
exports.computePool2DInfo = computePool2DInfo;
function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise, dataFormat) {
    if (depthwise === void 0) { depthwise = false; }
    if (dataFormat === void 0) { dataFormat = 'channelsLast'; }
    var _a = [-1, -1, -1, -1], batchSize = _a[0], inHeight = _a[1], inWidth = _a[2], inChannels = _a[3];
    if (dataFormat === 'channelsLast') {
        batchSize = inShape[0], inHeight = inShape[1], inWidth = inShape[2], inChannels = inShape[3];
    }
    else if (dataFormat === 'channelsFirst') {
        batchSize = inShape[0], inChannels = inShape[1], inHeight = inShape[2], inWidth = inShape[3];
    }
    else {
        throw new Error("Unknown dataFormat " + dataFormat);
    }
    var filterHeight = filterShape[0], filterWidth = filterShape[1], filterChannels = filterShape[3];
    var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
    var _c = parseTupleParam(dilations), dilationHeight = _c[0], dilationWidth = _c[1];
    var effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
    var effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
    var _d = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode), padInfo = _d.padInfo, outHeight = _d.outHeight, outWidth = _d.outWidth;
    var outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    var outShape;
    if (dataFormat === 'channelsFirst') {
        outShape = [batchSize, outChannels, outHeight, outWidth];
    }
    else if (dataFormat === 'channelsLast') {
        outShape = [batchSize, outHeight, outWidth, outChannels];
    }
    return {
        batchSize: batchSize,
        dataFormat: dataFormat,
        inHeight: inHeight,
        inWidth: inWidth,
        inChannels: inChannels,
        outHeight: outHeight,
        outWidth: outWidth,
        outChannels: outChannels,
        padInfo: padInfo,
        strideHeight: strideHeight,
        strideWidth: strideWidth,
        filterHeight: filterHeight,
        filterWidth: filterWidth,
        dilationHeight: dilationHeight,
        dilationWidth: dilationWidth,
        inShape: inShape,
        outShape: outShape,
        filterShape: filterShape
    };
}
exports.computeConv2DInfo = computeConv2DInfo;
function computeOutputShape3D(inShape, fieldSize, outDepth, stride, zeroPad, roundingMode) {
    if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, fieldSize, stride);
    }
    var inputRows = inShape[0];
    var inputCols = inShape[1];
    var outputRows = conditionalRound((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    util.assert(util.isInt(outputRows), "The output # of rows (" + outputRows + ") must be an integer. Change the " +
        "stride and/or zero pad parameters");
    var outputCols = conditionalRound((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    util.assert(util.isInt(outputCols), "The output # of columns (" + outputCols + ") must be an integer. Change " +
        "the stride and/or zero pad parameters");
    return [outputRows, outputCols, outDepth];
}
function computeDefaultPad(inputShape, fieldSize, stride, dilation) {
    if (dilation === void 0) { dilation = 1; }
    var effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
    return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
}
exports.computeDefaultPad = computeDefaultPad;
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}
function getEffectiveFilterSize(filterSize, dilation) {
    if (dilation <= 1) {
        return filterSize;
    }
    return filterSize + (filterSize - 1) * (dilation - 1);
}
function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode) {
    var padInfo;
    var outHeight;
    var outWidth;
    if (typeof pad === 'number') {
        var padType = (pad === 0) ? 'VALID' : 'NUMBER';
        padInfo = { top: pad, bottom: pad, left: pad, right: pad, type: padType };
        var outShape = computeOutputShape3D([inHeight, inWidth, 1], filterHeight, 1, strideHeight, pad, roundingMode);
        outHeight = outShape[0];
        outWidth = outShape[1];
    }
    else if (pad === 'same') {
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        var top_1 = Math.floor(padAlongHeight / 2);
        var bottom = padAlongHeight - top_1;
        var left = Math.floor(padAlongWidth / 2);
        var right = padAlongWidth - left;
        padInfo = { top: top_1, bottom: bottom, left: left, right: right, type: 'SAME' };
    }
    else if (pad === 'valid') {
        padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: 'VALID' };
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    }
    else {
        throw Error("Unknown padding parameter: " + pad);
    }
    return { padInfo: padInfo, outHeight: outHeight, outWidth: outWidth };
}
function conditionalRound(value, roundingMode) {
    if (!roundingMode) {
        return value;
    }
    switch (roundingMode) {
        case 'round':
            return Math.round(value);
        case 'ceil':
            return Math.ceil(value);
        case 'floor':
            return Math.floor(value);
        default:
            throw new Error("Unknown roundingMode " + roundingMode);
    }
}

},{"../util":203}],150:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERF_P = 0.3275911;
exports.ERF_A1 = 0.254829592;
exports.ERF_A2 = -0.284496736;
exports.ERF_A3 = 1.421413741;
exports.ERF_A4 = -1.453152027;
exports.ERF_A5 = 1.061405429;

},{}],151:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var operation_1 = require("./operation");
function gatherND_(x, indices) {
    var $indices = tensor_util_env_1.convertToTensor(indices, 'indices', 'gatherND', 'int32');
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'gatherND');
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.gatherND($x, $indices); }, { $x: $x, $indices: $indices });
}
exports.gatherND = operation_1.op({ gatherND_: gatherND_ });

},{"../environment":60,"../tensor_util_env":199,"./operation":162}],152:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
function prepareAndValidate(tensor, indices) {
    if (tensor.rank < 1) {
        throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' +
            (" but the rank was " + tensor.rank + "."));
    }
    if (indices.rank < 1) {
        throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' +
            (" but the rank was " + indices.rank + "."));
    }
    if (indices.dtype !== 'int32') {
        throw new Error('tf.gatherND() expects the indices to be int32 type,' +
            (" but the dtype was " + indices.dtype + "."));
    }
    if (indices.shape[indices.rank - 1] > tensor.rank) {
        throw new Error('index innermost dimension length must be <= tensor rank; saw: ' +
            (indices.shape[indices.rank - 1] + " vs. " + tensor.rank));
    }
    if (tensor.size === 0) {
        throw new Error('Requested more than 0 entries, but input is empty.' +
            (" Input shape: " + tensor.shape + "."));
    }
    var indicesShape = indices.shape;
    var sliceRank = indicesShape[indicesShape.length - 1];
    var nResult = 1;
    for (var i = 0; i < indicesShape.length - 1; ++i) {
        nResult *= indicesShape[i];
    }
    var inputShape = tensor.shape;
    var resultShape = indicesShape.slice();
    resultShape.pop();
    var sliceSize = 1;
    for (var i = sliceRank; i < tensor.rank; ++i) {
        sliceSize *= inputShape[i];
        resultShape.push(inputShape[i]);
    }
    var strides = util_1.computeStrides(tensor.shape).map(function (stride) { return stride / sliceSize; }).concat([1]).slice(0, sliceRank);
    return [resultShape, nResult, sliceSize, strides];
}
exports.prepareAndValidate = prepareAndValidate;

},{"../util":203}],153:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var non_max_suppression_impl_1 = require("../kernels/non_max_suppression_impl");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var operation_1 = require("./operation");
function resizeBilinear_(images, size, alignCorners) {
    if (alignCorners === void 0) { alignCorners = false; }
    var $images = tensor_util_env_1.convertToTensor(images, 'images', 'resizeBilinear');
    util.assert($images.rank === 3 || $images.rank === 4, "Error in resizeBilinear: x must be rank 3 or 4, but got " +
        ("rank " + $images.rank + "."));
    util.assert(size.length === 2, "Error in resizeBilinear: new shape must 2D, but got shape " +
        (size + "."));
    var batchImages = $images;
    var reshapedTo4D = false;
    if ($images.rank === 3) {
        reshapedTo4D = true;
        batchImages =
            $images.as4D(1, $images.shape[0], $images.shape[1], $images.shape[2]);
    }
    var newHeight = size[0], newWidth = size[1];
    var forward = function (backend, save) {
        return backend.resizeBilinear(batchImages, newHeight, newWidth, alignCorners);
    };
    var backward = function (dy, saved) {
        return {
            batchImages: function () { return environment_1.ENV.engine.runKernel(function (backend) {
                return backend.resizeBilinearBackprop(dy, batchImages, alignCorners);
            }, {}); }
        };
    };
    var res = environment_1.ENV.engine.runKernel(forward, { batchImages: batchImages }, backward);
    if (reshapedTo4D) {
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    }
    return res;
}
function resizeNearestNeighbor_(images, size, alignCorners) {
    if (alignCorners === void 0) { alignCorners = false; }
    var $images = tensor_util_env_1.convertToTensor(images, 'images', 'resizeNearestNeighbor');
    util.assert($images.rank === 3 || $images.rank === 4, "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got " +
        ("rank " + $images.rank + "."));
    util.assert(size.length === 2, "Error in resizeNearestNeighbor: new shape must 2D, but got shape " +
        (size + "."));
    util.assert($images.dtype === 'float32' || $images.dtype === 'int32', '`images` must have `int32` or `float32` as dtype');
    var batchImages = $images;
    var reshapedTo4D = false;
    if ($images.rank === 3) {
        reshapedTo4D = true;
        batchImages =
            $images.as4D(1, $images.shape[0], $images.shape[1], $images.shape[2]);
    }
    var newHeight = size[0], newWidth = size[1];
    var forward = function (backend, save) {
        return backend.resizeNearestNeighbor(batchImages, newHeight, newWidth, alignCorners);
    };
    var backward = function (dy, saved) {
        return {
            batchImages: function () { return environment_1.ENV.engine.runKernel(function (backend) { return backend.resizeNearestNeighborBackprop(dy, batchImages, alignCorners); }, {}); }
        };
    };
    var res = environment_1.ENV.engine.runKernel(forward, { batchImages: batchImages }, backward);
    if (reshapedTo4D) {
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    }
    return res;
}
function nonMaxSuppression_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
    if (iouThreshold === void 0) { iouThreshold = 0.5; }
    if (scoreThreshold === void 0) { scoreThreshold = Number.NEGATIVE_INFINITY; }
    var $boxes = tensor_util_env_1.convertToTensor(boxes, 'boxes', 'nonMaxSuppression');
    var $scores = tensor_util_env_1.convertToTensor(scores, 'scores', 'nonMaxSuppression');
    var inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
    maxOutputSize = inputs.maxOutputSize;
    iouThreshold = inputs.iouThreshold;
    scoreThreshold = inputs.scoreThreshold;
    return environment_1.ENV.engine.runKernel(function (b) { return b.nonMaxSuppression($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold); }, { $boxes: $boxes });
}
function nonMaxSuppressionAsync_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
    if (iouThreshold === void 0) { iouThreshold = 0.5; }
    if (scoreThreshold === void 0) { scoreThreshold = Number.NEGATIVE_INFINITY; }
    return __awaiter(this, void 0, void 0, function () {
        var $boxes, $scores, inputs, boxesVals, scoresVals, res;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    $boxes = tensor_util_env_1.convertToTensor(boxes, 'boxes', 'nonMaxSuppressionAsync');
                    $scores = tensor_util_env_1.convertToTensor(scores, 'scores', 'nonMaxSuppressionAsync');
                    inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
                    maxOutputSize = inputs.maxOutputSize;
                    iouThreshold = inputs.iouThreshold;
                    scoreThreshold = inputs.scoreThreshold;
                    return [4, $boxes.data()];
                case 1:
                    boxesVals = _a.sent();
                    return [4, $scores.data()];
                case 2:
                    scoresVals = _a.sent();
                    res = non_max_suppression_impl_1.nonMaxSuppressionImpl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
                    if ($boxes !== boxes) {
                        $boxes.dispose();
                    }
                    if ($scores !== scores) {
                        $scores.dispose();
                    }
                    return [2, res];
            }
        });
    });
}
function nonMaxSuppSanityCheck(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
    if (iouThreshold == null) {
        iouThreshold = 0.5;
    }
    if (scoreThreshold == null) {
        scoreThreshold = Number.NEGATIVE_INFINITY;
    }
    var numBoxes = boxes.shape[0];
    maxOutputSize = Math.min(maxOutputSize, numBoxes);
    util.assert(0 <= iouThreshold && iouThreshold <= 1, "iouThreshold must be in [0, 1], but was '" + iouThreshold + "'");
    util.assert(boxes.rank === 2, "boxes must be a 2D tensor, but was of rank '" + boxes.rank + "'");
    util.assert(boxes.shape[1] === 4, "boxes must have 4 columns, but 2nd dimension was " + boxes.shape[1]);
    util.assert(scores.rank === 1, 'scores must be a 1D tensor');
    util.assert(scores.shape[0] === numBoxes, "scores has incompatible shape with boxes. Expected " + numBoxes + ", " +
        ("but was " + scores.shape[0]));
    return { maxOutputSize: maxOutputSize, iouThreshold: iouThreshold, scoreThreshold: scoreThreshold };
}
function cropAndResize_(image, boxes, boxInd, cropSize, method, extrapolationValue) {
    var $image = tensor_util_env_1.convertToTensor(image, 'image', 'cropAndResize', 'float32');
    var $boxes = tensor_util_env_1.convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');
    var $boxInd = tensor_util_env_1.convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');
    method = method || 'bilinear';
    extrapolationValue = extrapolationValue || 0;
    var numBoxes = $boxes.shape[0];
    util.assert($image.rank === 4, 'Error in cropAndResize: image must be rank 4,' +
        ("but got rank " + $image.rank + "."));
    util.assert($boxes.rank === 2 && $boxes.shape[1] === 4, "Error in cropAndResize: boxes must be have size [" + numBoxes + ",4] " +
        ("but had shape " + $boxes.shape + "."));
    util.assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, "Error in cropAndResize: boxInd must be have size [" + numBoxes + "] " +
        ("but had shape " + $boxes.shape + "."));
    util.assert($boxInd.dtype === 'int32', "Error in cropAndResize: boxInd must be of dtype int32, but got dtype " +
        ($boxInd.dtype + "."));
    util.assert(cropSize.length === 2, "Error in cropAndResize: cropSize must be of length 2, but got length " +
        (cropSize.length + "."));
    util.assert(cropSize[0] >= 1 && cropSize[1] >= 1, "cropSize must be atleast [1,1], but was " + cropSize);
    util.assert(method === 'bilinear' || method === 'nearest', "method must be bilinear or nearest, but was " + method);
    var forward = function (backend, save) {
        return backend.cropAndResize($image, $boxes, $boxInd, cropSize, method, extrapolationValue);
    };
    var res = environment_1.ENV.engine.runKernel(forward, { $image: $image, $boxes: $boxes });
    return res;
}
exports.resizeBilinear = operation_1.op({ resizeBilinear_: resizeBilinear_ });
exports.resizeNearestNeighbor = operation_1.op({ resizeNearestNeighbor_: resizeNearestNeighbor_ });
exports.nonMaxSuppression = operation_1.op({ nonMaxSuppression_: nonMaxSuppression_ });
exports.nonMaxSuppressionAsync = nonMaxSuppressionAsync_;
exports.cropAndResize = cropAndResize_;

},{"../environment":60,"../kernels/non_max_suppression_impl":81,"../tensor_util_env":199,"../util":203,"./operation":162}],154:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var util_1 = require("../util");
var array_ops_1 = require("./array_ops");
var concat_split_1 = require("./concat_split");
var norm_1 = require("./norm");
var operation_1 = require("./operation");
var reduction_ops_1 = require("./reduction_ops");
var tensor_ops_1 = require("./tensor_ops");
function gramSchmidt_(xs) {
    var inputIsTensor2D;
    if (Array.isArray(xs)) {
        inputIsTensor2D = false;
        util_1.assert(xs != null && xs.length > 0, 'Gram-Schmidt process: input must not be null, undefined, or empty');
        var dim = xs[0].shape[0];
        for (var i = 1; i < xs.length; ++i) {
            util_1.assert(xs[i].shape[0] === dim, 'Gram-Schmidt: Non-unique lengths found in the input vectors: ' +
                ("(" + xs[i].shape[0] + " vs. " + dim + ")"));
        }
    }
    else {
        inputIsTensor2D = true;
        xs = concat_split_1.split(xs, xs.shape[0], 0).map(function (x) { return array_ops_1.squeeze(x, [0]); });
    }
    util_1.assert(xs.length <= xs[0].shape[0], "Gram-Schmidt: Number of vectors (" + xs.length + ") exceeds " +
        ("number of dimensions (" + xs[0].shape[0] + ")."));
    var ys = [];
    var xs1d = xs;
    var _loop_1 = function (i) {
        ys.push(environment_1.ENV.engine.tidy(function () {
            var x = xs1d[i];
            if (i > 0) {
                for (var j = 0; j < i; ++j) {
                    var proj = reduction_ops_1.sum(ys[j].mulStrict(x)).mul(ys[j]);
                    x = x.sub(proj);
                }
            }
            return x.div(norm_1.norm(x, 'euclidean'));
        }));
    };
    for (var i = 0; i < xs.length; ++i) {
        _loop_1(i);
    }
    if (inputIsTensor2D) {
        return array_ops_1.stack(ys, 0);
    }
    else {
        return ys;
    }
}
function qr_(x, fullMatrices) {
    if (fullMatrices === void 0) { fullMatrices = false; }
    if (x.rank < 2) {
        throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + x.rank);
    }
    else if (x.rank === 2) {
        return qr2d(x, fullMatrices);
    }
    else {
        var outerDimsProd = x.shape.slice(0, x.shape.length - 2)
            .reduce(function (value, prev) { return value * prev; });
        var x2ds = array_ops_1.unstack(x.reshape([
            outerDimsProd, x.shape[x.shape.length - 2],
            x.shape[x.shape.length - 1]
        ]), 0);
        var q2ds_1 = [];
        var r2ds_1 = [];
        x2ds.forEach(function (x2d) {
            var _a = qr2d(x2d, fullMatrices), q2d = _a[0], r2d = _a[1];
            q2ds_1.push(q2d);
            r2ds_1.push(r2d);
        });
        var q = array_ops_1.stack(q2ds_1, 0).reshape(x.shape);
        var r = array_ops_1.stack(r2ds_1, 0).reshape(x.shape);
        return [q, r];
    }
}
function qr2d(x, fullMatrices) {
    if (fullMatrices === void 0) { fullMatrices = false; }
    return environment_1.ENV.engine.tidy(function () {
        if (x.shape.length !== 2) {
            throw new Error("qr2d() requires a 2D Tensor, but got a " + x.shape.length + "D Tensor.");
        }
        var m = x.shape[0];
        var n = x.shape[1];
        var q = array_ops_1.eye(m);
        var r = x.clone();
        var one2D = tensor_ops_1.tensor2d([[1]], [1, 1]);
        var w = one2D.clone();
        var iters = m >= n ? n : m;
        var _loop_2 = function (j) {
            var _a;
            var rTemp = r;
            var wTemp = w;
            var qTemp = q;
            _a = environment_1.ENV.engine.tidy(function () {
                var rjEnd1 = r.slice([j, j], [m - j, 1]);
                var normX = rjEnd1.norm();
                var rjj = r.slice([j, j], [1, 1]);
                var s = rjj.sign().neg();
                var u1 = rjj.sub(s.mul(normX));
                var wPre = rjEnd1.div(u1);
                if (wPre.shape[0] === 1) {
                    w = one2D.clone();
                }
                else {
                    w = one2D.concat(wPre.slice([1, 0], [wPre.shape[0] - 1, wPre.shape[1]]), 0);
                }
                var tau = s.matMul(u1).div(normX).neg();
                var rjEndAll = r.slice([j, 0], [m - j, n]);
                var tauTimesW = tau.mul(w);
                if (j === 0) {
                    r = rjEndAll.sub(tauTimesW.matMul(w.transpose().matMul(rjEndAll)));
                }
                else {
                    r = r.slice([0, 0], [j, n])
                        .concat(rjEndAll.sub(tauTimesW.matMul(w.transpose().matMul(rjEndAll))), 0);
                }
                var qAllJEnd = q.slice([0, j], [m, q.shape[1] - j]);
                if (j === 0) {
                    q = qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tauTimesW.transpose()));
                }
                else {
                    q = q.slice([0, 0], [m, j])
                        .concat(qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tauTimesW.transpose())), 1);
                }
                return [w, r, q];
            }), w = _a[0], r = _a[1], q = _a[2];
            globals_1.dispose([rTemp, wTemp, qTemp]);
        };
        for (var j = 0; j < iters; ++j) {
            _loop_2(j);
        }
        if (!fullMatrices && m > n) {
            q = q.slice([0, 0], [m, n]);
            r = r.slice([0, 0], [n, n]);
        }
        return [q, r];
    });
}
exports.gramSchmidt = operation_1.op({ gramSchmidt_: gramSchmidt_ });
exports.qr = operation_1.op({ qr_: qr_ });

},{"../environment":60,"../globals":62,"../util":203,"./array_ops":138,"./concat_split":146,"./norm":161,"./operation":162,"./reduction_ops":167,"./tensor_ops":180}],155:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var where_impl_1 = require("../kernels/where_impl");
var tensor_util_env_1 = require("../tensor_util_env");
var util_1 = require("../util");
var broadcast_util_1 = require("./broadcast_util");
var operation_1 = require("./operation");
var tensor_ops_1 = require("./tensor_ops");
function logicalNot_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'logicalNot', 'bool');
    util_1.assert($x.dtype === 'bool', 'Error Array must be of type bool.');
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalNot($x); }, { $x: $x });
}
function logicalAnd_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'logicalAnd', 'bool');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'logicalAnd', 'bool');
    util_1.assert($a.dtype === 'bool' && $b.dtype === 'bool', 'Error Array must be of type bool.');
    broadcast_util_1.assertAndGetBroadcastShape($a.shape, $b.shape);
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalAnd($a, $b); }, { $a: $a, $b: $b });
}
function logicalOr_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'logicalOr', 'bool');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'logicalOr', 'bool');
    util_1.assert($a.dtype === 'bool' && $b.dtype === 'bool', 'Error Array must be of type bool.');
    broadcast_util_1.assertAndGetBroadcastShape($a.shape, $b.shape);
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalOr($a, $b); }, { $a: $a, $b: $b });
}
function logicalXor_(a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'logicalXor', 'bool');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'logicalXor', 'bool');
    util_1.assert($a.dtype === 'bool' && $b.dtype === 'bool', 'Error Array must be of type bool.');
    broadcast_util_1.assertAndGetBroadcastShape($a.shape, $b.shape);
    return exports.logicalOr(a, b).logicalAnd(exports.logicalAnd(a, b).logicalNot());
}
function where_(condition, a, b) {
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'where');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'where');
    var $condition = tensor_util_env_1.convertToTensor(condition, 'condition', 'where', 'bool');
    util_1.assert($condition.dtype === 'bool', 'Error Condition must be of type bool.');
    util_1.assertShapesMatch($a.shape, $b.shape, 'Error in where: ');
    if ($condition.rank === 1) {
        util_1.assert($condition.shape[0] === $a.shape[0], 'The first dimension of `a` must match the size of `condition`.');
    }
    else {
        util_1.assertShapesMatch($condition.shape, $b.shape, 'Error in where: ');
    }
    var grad = function (dy) { return ({
        $condition: function () { return tensor_ops_1.zerosLike($condition); },
        $a: function () { return dy.mul($condition.cast($a.dtype)); },
        $b: function () { return dy.mul($condition.logicalNot().cast($b.dtype)); }
    }); };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.select($condition, $a, $b); }, { $condition: $condition, $a: $a, $b: $b }, grad);
}
function whereAsync_(condition) {
    return __awaiter(this, void 0, void 0, function () {
        var $condition, vals, res;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    $condition = tensor_util_env_1.convertToTensor(condition, 'condition', 'where', 'bool');
                    util_1.assert($condition.dtype === 'bool', 'Condition must be of type bool.');
                    return [4, $condition.data()];
                case 1:
                    vals = _a.sent();
                    res = where_impl_1.whereImpl($condition.shape, vals);
                    if (condition !== $condition) {
                        $condition.dispose();
                    }
                    return [2, res];
            }
        });
    });
}
exports.logicalAnd = operation_1.op({ logicalAnd_: logicalAnd_ });
exports.logicalNot = operation_1.op({ logicalNot_: logicalNot_ });
exports.logicalOr = operation_1.op({ logicalOr_: logicalOr_ });
exports.logicalXor = operation_1.op({ logicalXor_: logicalXor_ });
exports.where = operation_1.op({ where_: where_ });
exports.whereAsync = whereAsync_;

},{"../environment":60,"../kernels/where_impl":136,"../tensor_util_env":199,"../util":203,"./broadcast_util":143,"./operation":162,"./tensor_ops":180}],156:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../globals");
var tensor_util_env_1 = require("../tensor_util_env");
var util_1 = require("../util");
var axis_util_1 = require("./axis_util");
var binary_ops_1 = require("./binary_ops");
var operation_1 = require("./operation");
var tensor_ops_1 = require("./tensor_ops");
var Reduction;
(function (Reduction) {
    Reduction[Reduction["NONE"] = 0] = "NONE";
    Reduction[Reduction["MEAN"] = 1] = "MEAN";
    Reduction[Reduction["SUM"] = 2] = "SUM";
    Reduction[Reduction["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(Reduction = exports.Reduction || (exports.Reduction = {}));
function computeWeightedLoss_(losses, weights, reduction) {
    if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
    var $losses = tensor_util_env_1.convertToTensor(losses, 'losses', 'computeWeightedLoss');
    var $weights = null;
    if (weights != null) {
        $weights = tensor_util_env_1.convertToTensor(weights, 'weights', 'computeWeightedLoss');
    }
    var weightedLoss = ($weights == null) ? $losses : $losses.mul($weights);
    if (reduction === Reduction.NONE) {
        return weightedLoss;
    }
    if (reduction === Reduction.SUM) {
        return weightedLoss.sum();
    }
    if (reduction === Reduction.MEAN) {
        if ($weights == null) {
            return weightedLoss.mean();
        }
        else {
            var broadcastFactor = util_1.sizeFromShape($losses.shape) / util_1.sizeFromShape($weights.shape);
            var result = weightedLoss.sum().div($weights.sum());
            return broadcastFactor > 1 ? result.div(tensor_ops_1.scalar(broadcastFactor)) :
                result;
        }
    }
    if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {
        if ($weights == null) {
            return weightedLoss.sum().div(tensor_ops_1.scalar($losses.size));
        }
        else {
            var broadcastedWeights = $weights.mul(tensor_ops_1.ones($losses.shape));
            var numNonZeros = broadcastedWeights.notEqual(tensor_ops_1.scalar(0)).sum().toFloat();
            return weightedLoss.sum().div(numNonZeros);
        }
    }
    throw Error("Unknown reduction: " + reduction);
}
function absoluteDifference_(labels, predictions, weights, reduction) {
    if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
    var $labels = tensor_util_env_1.convertToTensor(labels, 'labels', 'absoluteDifference');
    var $predictions = tensor_util_env_1.convertToTensor(predictions, 'predictions', 'absoluteDifference');
    var $weights = null;
    if (weights != null) {
        $weights = tensor_util_env_1.convertToTensor(weights, 'weights', 'absoluteDifference');
    }
    util_1.assertShapesMatch($labels.shape, $predictions.shape, 'Error in absoluteDifference: ');
    var losses = $labels.sub($predictions).abs();
    return exports.computeWeightedLoss(losses, $weights, reduction);
}
function meanSquaredError_(labels, predictions, weights, reduction) {
    if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
    var $labels = tensor_util_env_1.convertToTensor(labels, 'labels', 'meanSquaredError');
    var $predictions = tensor_util_env_1.convertToTensor(predictions, 'predictions', 'meanSquaredError');
    var $weights = null;
    if (weights != null) {
        $weights = tensor_util_env_1.convertToTensor(weights, 'weights', 'meanSquaredError');
    }
    util_1.assertShapesMatch($labels.shape, $predictions.shape, 'Error in meanSquaredError: ');
    var losses = $labels.squaredDifference($predictions);
    return exports.computeWeightedLoss(losses, $weights, reduction);
}
function cosineDistance_(labels, predictions, axis, weights, reduction) {
    if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
    var $labels = tensor_util_env_1.convertToTensor(labels, 'labels', 'cosineDistance');
    var $predictions = tensor_util_env_1.convertToTensor(predictions, 'predictions', 'cosineDistance');
    var $weights = null;
    if (weights != null) {
        $weights = tensor_util_env_1.convertToTensor(weights, 'weights', 'cosineDistance');
    }
    util_1.assertShapesMatch($labels.shape, $predictions.shape, 'Error in cosineDistance: ');
    var one = tensor_ops_1.scalar(1);
    var losses = one.sub($labels.mul($predictions).sum(axis, true));
    return exports.computeWeightedLoss(losses, $weights, reduction);
}
function hingeLoss_(labels, predictions, weights, reduction) {
    if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
    var $labels = tensor_util_env_1.convertToTensor(labels, 'labels', 'hingeLoss');
    var $predictions = tensor_util_env_1.convertToTensor(predictions, 'predictions', 'hingeLoss');
    var $weights = null;
    if (weights != null) {
        $weights = tensor_util_env_1.convertToTensor(weights, 'weights', 'hingeLoss');
    }
    util_1.assertShapesMatch($labels.shape, $predictions.shape, 'Error in hingeLoss: ');
    var one = tensor_ops_1.scalar(1);
    $labels = tensor_ops_1.scalar(2).mul($labels).sub(one);
    var losses = one.sub($labels.mul($predictions)).relu();
    return exports.computeWeightedLoss(losses, $weights, reduction);
}
function logLoss_(labels, predictions, weights, epsilon, reduction) {
    if (epsilon === void 0) { epsilon = 1e-7; }
    if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
    var $labels = tensor_util_env_1.convertToTensor(labels, 'labels', 'logLoss');
    var $predictions = tensor_util_env_1.convertToTensor(predictions, 'predictions', 'logLoss');
    var $weights = null;
    if (weights != null) {
        $weights = tensor_util_env_1.convertToTensor(weights, 'weights', 'logLoss');
    }
    util_1.assertShapesMatch($labels.shape, $predictions.shape, 'Error in logLoss: ');
    var one = tensor_ops_1.scalar(1);
    var epsilonScalar = tensor_ops_1.scalar(epsilon);
    var losses = $labels.mul($predictions.add(epsilonScalar).log())
        .neg()
        .sub(one.sub($labels).mul(one.sub($predictions).add(epsilonScalar).log()));
    return exports.computeWeightedLoss(losses, $weights, reduction);
}
function sigmoidCrossEntropyWithLogits_(labels, logits) {
    var $labels = tensor_util_env_1.convertToTensor(labels, 'labels', 'sigmoidCrossEntropyWithLogits');
    var $logits = tensor_util_env_1.convertToTensor(logits, 'logits', 'sigmoidCrossEntropyWithLogits');
    util_1.assertShapesMatch($labels.shape, $logits.shape, 'Error in sigmoidCrossEntropyWithLogits: ');
    var maxOutput = $logits.relu();
    var outputXTarget = $logits.mul($labels);
    var sigmoidOutput = $logits.abs().neg().exp().log1p();
    return maxOutput.sub(outputXTarget).add(sigmoidOutput);
}
function sigmoidCrossEntropy_(multiClassLabels, logits, weights, labelSmoothing, reduction) {
    if (labelSmoothing === void 0) { labelSmoothing = 0; }
    if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
    var $multiClassLabels = tensor_util_env_1.convertToTensor(multiClassLabels, 'multiClassLabels', 'sigmoidCrossEntropy');
    var $logits = tensor_util_env_1.convertToTensor(logits, 'logits', 'sigmoidCrossEntropy');
    var $weights = null;
    if (weights != null) {
        $weights = tensor_util_env_1.convertToTensor(weights, 'weights', 'sigmoidCrossEntropy');
    }
    util_1.assertShapesMatch($multiClassLabels.shape, $logits.shape, 'Error in sigmoidCrossEntropy: ');
    if (labelSmoothing > 0) {
        var labelSmoothingScalar = tensor_ops_1.scalar(labelSmoothing);
        var one = tensor_ops_1.scalar(1);
        var half = tensor_ops_1.scalar(0.5);
        $multiClassLabels = $multiClassLabels.mul(one.sub(labelSmoothingScalar))
            .add(half.mul(labelSmoothingScalar));
    }
    var losses = sigmoidCrossEntropyWithLogits_($multiClassLabels, $logits);
    return exports.computeWeightedLoss(losses, $weights, reduction);
}
function huberLoss_(labels, predictions, weights, delta, reduction) {
    if (delta === void 0) { delta = 1.0; }
    if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
    var $labels = tensor_util_env_1.convertToTensor(labels, 'labels', 'huberLoss');
    var $predictions = tensor_util_env_1.convertToTensor(predictions, 'predictions', 'huberLoss');
    var $weights = null;
    if (weights != null) {
        $weights = tensor_util_env_1.convertToTensor(weights, 'weights', 'huberLoss');
    }
    util_1.assertShapesMatch($labels.shape, $predictions.shape, 'Error in huberLoss: ');
    var deltaScalar = tensor_ops_1.scalar(delta);
    var error = $predictions.sub($labels).abs();
    var quadratic = binary_ops_1.minimum(error, deltaScalar);
    var linear = error.sub(quadratic);
    var losses = tensor_ops_1.scalar(0.5).mul(quadratic.square()).add(deltaScalar.mul(linear));
    return exports.computeWeightedLoss(losses, $weights, reduction);
}
function softmaxCrossEntropyWithLogits_(labels, logits, dim) {
    if (dim === void 0) { dim = -1; }
    if (dim === -1) {
        dim = logits.rank - 1;
    }
    if (dim !== logits.rank - 1) {
        throw Error("Softmax cross entropy along a non-last dimension is not yet " +
            ("supported. Labels / logits was rank " + logits.rank + " ") +
            ("and dim was " + dim));
    }
    var customOp = globals_1.customGrad(function (labels, logits) {
        var keepDims = true;
        var lse = logits.logSumExp([dim], keepDims);
        var logResult = logits.toFloat().sub(lse);
        var costVector = logResult.mul(labels).neg();
        var value = costVector.sum([dim]);
        var gradFunc = function (dy) {
            var dyShape = axis_util_1.expandShapeToKeepDim(dy.shape, [dim]);
            return [
                dy.reshape(dyShape).mul(labels.toFloat().sub(logResult.exp())),
                dy.reshape(dyShape).mul(logResult.exp().sub(labels.toFloat())),
            ];
        };
        return { value: value, gradFunc: gradFunc };
    });
    return customOp(labels, logits);
}
function softmaxCrossEntropy_(onehotLabels, logits, weights, labelSmoothing, reduction) {
    if (labelSmoothing === void 0) { labelSmoothing = 0; }
    if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
    var $onehotLabels = tensor_util_env_1.convertToTensor(onehotLabels, 'onehotLabels', 'softmaxCrossEntropy');
    var $logits = tensor_util_env_1.convertToTensor(logits, 'logits', 'softmaxCrossEntropy');
    var $weights = null;
    if (weights != null) {
        $weights = tensor_util_env_1.convertToTensor(weights, 'weights', 'softmaxCrossEntropy');
    }
    util_1.assertShapesMatch($onehotLabels.shape, $logits.shape, 'Error in softmaxCrossEntropy: ');
    if (labelSmoothing > 0) {
        var labelSmoothingScalar = tensor_ops_1.scalar(labelSmoothing);
        var one = tensor_ops_1.scalar(1);
        var numClasses = tensor_ops_1.scalar($onehotLabels.shape[1]);
        $onehotLabels = $onehotLabels.mul(one.sub(labelSmoothingScalar))
            .add(labelSmoothingScalar.div(numClasses));
    }
    var losses = softmaxCrossEntropyWithLogits_($onehotLabels, $logits);
    return exports.computeWeightedLoss(losses, $weights, reduction);
}
exports.absoluteDifference = operation_1.op({ absoluteDifference_: absoluteDifference_ });
exports.computeWeightedLoss = operation_1.op({ computeWeightedLoss_: computeWeightedLoss_ });
exports.cosineDistance = operation_1.op({ cosineDistance_: cosineDistance_ });
exports.hingeLoss = operation_1.op({ hingeLoss_: hingeLoss_ });
exports.huberLoss = operation_1.op({ huberLoss_: huberLoss_ });
exports.logLoss = operation_1.op({ logLoss_: logLoss_ });
exports.meanSquaredError = operation_1.op({ meanSquaredError_: meanSquaredError_ });
exports.sigmoidCrossEntropy = operation_1.op({ sigmoidCrossEntropy_: sigmoidCrossEntropy_ });
exports.softmaxCrossEntropy = operation_1.op({ softmaxCrossEntropy_: softmaxCrossEntropy_ });

},{"../globals":62,"../tensor_util_env":199,"../util":203,"./axis_util":140,"./binary_ops":142,"./operation":162,"./tensor_ops":180}],157:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var operation_1 = require("./operation");
function localResponseNormalization_(x, depthRadius, bias, alpha, beta) {
    if (depthRadius === void 0) { depthRadius = 5; }
    if (bias === void 0) { bias = 1; }
    if (alpha === void 0) { alpha = 1; }
    if (beta === void 0) { beta = 0.5; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'localResponseNormalization');
    util.assert($x.rank === 4 || $x.rank === 3, "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + $x.rank + ".");
    util.assert(util.isInt(depthRadius), "Error in localResponseNormalization: depthRadius must be an integer\n                     but got depthRadius " + depthRadius + ".");
    var x4D = $x;
    var reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);
    }
    var backward = function (dy, saved) {
        var outputImage = saved[0];
        return {
            x4D: function () { return environment_1.ENV.engine.runKernel(function (backend) { return backend.LRNGrad(dy, x4D, outputImage, depthRadius, bias, alpha, beta); }, {}); }
        };
    };
    var res = environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.localResponseNormalization4D(x4D, depthRadius, bias, alpha, beta)); }, { x4D: x4D }, backward);
    if (reshapedTo4D) {
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    }
    else {
        return res;
    }
}
exports.localResponseNormalization = operation_1.op({ localResponseNormalization_: localResponseNormalization_ });

},{"../environment":60,"../tensor_util_env":199,"../util":203,"./operation":162}],158:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_util_env_1 = require("../tensor_util_env");
var operation_1 = require("./operation");
function multiRNNCell_(lstmCells, data, c, h) {
    var $data = tensor_util_env_1.convertToTensor(data, 'data', 'multiRNNCell');
    var $c = tensor_util_env_1.convertToTensorArray(c, 'c', 'multiRNNCell');
    var $h = tensor_util_env_1.convertToTensorArray(h, 'h', 'multiRNNCell');
    var input = $data;
    var newStates = [];
    for (var i = 0; i < lstmCells.length; i++) {
        var output = lstmCells[i](input, $c[i], $h[i]);
        newStates.push(output[0]);
        newStates.push(output[1]);
        input = output[1];
    }
    var newC = [];
    var newH = [];
    for (var i = 0; i < newStates.length; i += 2) {
        newC.push(newStates[i]);
        newH.push(newStates[i + 1]);
    }
    return [newC, newH];
}
function basicLSTMCell_(forgetBias, lstmKernel, lstmBias, data, c, h) {
    var $forgetBias = tensor_util_env_1.convertToTensor(forgetBias, 'forgetBias', 'basicLSTMCell');
    var $lstmKernel = tensor_util_env_1.convertToTensor(lstmKernel, 'lstmKernel', 'basicLSTMCell');
    var $lstmBias = tensor_util_env_1.convertToTensor(lstmBias, 'lstmBias', 'basicLSTMCell');
    var $data = tensor_util_env_1.convertToTensor(data, 'data', 'basicLSTMCell');
    var $c = tensor_util_env_1.convertToTensor(c, 'c', 'basicLSTMCell');
    var $h = tensor_util_env_1.convertToTensor(h, 'h', 'basicLSTMCell');
    var combined = $data.concat($h, 1);
    var weighted = combined.matMul($lstmKernel);
    var res = weighted.add($lstmBias);
    var batchSize = res.shape[0];
    var sliceCols = res.shape[1] / 4;
    var sliceSize = [batchSize, sliceCols];
    var i = res.slice([0, 0], sliceSize);
    var j = res.slice([0, sliceCols], sliceSize);
    var f = res.slice([0, sliceCols * 2], sliceSize);
    var o = res.slice([0, sliceCols * 3], sliceSize);
    var newC = i.sigmoid().mulStrict(j.tanh()).addStrict($c.mulStrict($forgetBias.add(f).sigmoid()));
    var newH = newC.tanh().mulStrict(o.sigmoid());
    return [newC, newH];
}
exports.basicLSTMCell = operation_1.op({ basicLSTMCell_: basicLSTMCell_ });
exports.multiRNNCell = operation_1.op({ multiRNNCell_: multiRNNCell_ });

},{"../tensor_util_env":199,"./operation":162}],159:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var operation_1 = require("./operation");
function matMul_(a, b, transposeA, transposeB) {
    if (transposeA === void 0) { transposeA = false; }
    if (transposeB === void 0) { transposeB = false; }
    var $a = tensor_util_env_1.convertToTensor(a, 'a', 'matMul');
    var $b = tensor_util_env_1.convertToTensor(b, 'b', 'matMul');
    var innerShapeA = transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];
    var innerShapeB = transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];
    var outerShapeA = transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];
    var outerShapeB = transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];
    var outerDimsA = $a.shape.slice(0, -2);
    var outerDimsB = $b.shape.slice(0, -2);
    var batchDimA = util.sizeFromShape(outerDimsA);
    var batchDimB = util.sizeFromShape(outerDimsB);
    util.assert($a.rank >= 2 && $b.rank >= 2 && $a.rank === $b.rank, "Error in matMul: inputs must have the same rank of at least 2, " +
        ("got ranks " + $a.rank + " and " + $b.rank + "."));
    util.assert(util.arraysEqual(outerDimsA, outerDimsB), "Error in matMul: outer dimensions (" + outerDimsA + ") and (" +
        (outerDimsB + ") of Tensors with shapes " + $a.shape + " and ") +
        ($b.shape + " must match."));
    util.assert(innerShapeA === innerShapeB, "Error in matMul: inner shapes (" + innerShapeA + ") and (" +
        (innerShapeB + ") of Tensors with shapes " + $a.shape + " and ") +
        ($b.shape + " and transposeA=" + transposeA) +
        (" and transposeB=" + transposeB + " must match."));
    var outShape = $a.shape.slice(0, -2).concat([outerShapeA, outerShapeB]);
    var a3D = transposeA ? $a.as3D(batchDimA, innerShapeA, outerShapeA) :
        $a.as3D(batchDimA, outerShapeA, innerShapeA);
    var b3D = transposeB ? $b.as3D(batchDimB, outerShapeB, innerShapeB) :
        $b.as3D(batchDimB, innerShapeB, outerShapeB);
    var grad = function (dy) {
        if (!transposeA && !transposeB) {
            return {
                $a: function () { return dy.matMul(b3D.toFloat(), false, true); },
                $b: function () { return a3D.toFloat().matMul(dy, true, false); }
            };
        }
        else if (!transposeA && transposeB) {
            return {
                $a: function () { return dy.matMul(b3D.toFloat(), false, false); },
                $b: function () { return dy.matMul(a3D.toFloat(), true, false); }
            };
        }
        else if (transposeA && !transposeB) {
            return {
                $a: function () { return b3D.toFloat().matMul(dy, false, true); },
                $b: function () { return a3D.toFloat().matMul(dy, false, false); }
            };
        }
        else {
            return {
                $a: function () { return b3D.toFloat().matMul(dy, true, true); },
                $b: function () { return dy.matMul(a3D.toFloat(), true, true); }
            };
        }
    };
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.batchMatMul(a3D, b3D, transposeA, transposeB); }, { $a: a3D, $b: b3D }, grad);
    return res.reshape(outShape);
}
function outerProduct_(v1, v2) {
    var $v1 = tensor_util_env_1.convertToTensor(v1, 'v1', 'outerProduct');
    var $v2 = tensor_util_env_1.convertToTensor(v2, 'v2', 'outerProduct');
    util.assert($v1.rank === 1 && $v2.rank === 1, "Error in outerProduct: inputs must be rank 1, but got ranks " +
        ($v1.rank + " and " + $v2.rank + "."));
    return $v1.as2D(-1, 1).matMul($v2.as2D(1, -1));
}
function dot_(t1, t2) {
    var $t1 = tensor_util_env_1.convertToTensor(t1, 't1', 'dot');
    var $t2 = tensor_util_env_1.convertToTensor(t2, 't2', 'dot');
    util.assert(($t1.rank === 1 || $t1.rank === 2) && ($t2.rank === 1 || $t2.rank === 2), "Error in dot: inputs must all be rank 1 or 2, but got ranks " +
        ($t1.rank + " and " + $t2.rank + "."));
    var t1Inner = ($t1.rank === 1 ? $t1.size : $t1.shape[1]);
    var t2Inner = ($t2.rank === 1 ? $t2.size : $t2.shape[0]);
    util.assert(t1Inner === t2Inner, "Error in dot: inner dimensions of inputs must match, but got " +
        (t1Inner + " and " + t2Inner + "."));
    if ($t1.rank === 1 && $t2.rank === 1) {
        return $t1.as2D(1, -1).matMul($t2.as2D(-1, 1)).asScalar();
    }
    else if ($t1.rank === 1 && $t2.rank === 2) {
        return $t1.as2D(1, -1).matMul($t2.as2D($t2.shape[0], $t2.shape[1])).as1D();
    }
    else if ($t1.rank === 2 && $t2.rank === 1) {
        return $t1.matMul($t2.as2D(-1, 1)).as1D();
    }
    else {
        return $t1.matMul($t2.as2D($t2.shape[0], $t2.shape[1]));
    }
}
exports.matMul = operation_1.op({ matMul_: matMul_ });
exports.dot = operation_1.op({ dot_: dot_ });
exports.outerProduct = operation_1.op({ outerProduct_: outerProduct_ });

},{"../environment":60,"../tensor_util_env":199,"../util":203,"./operation":162}],160:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_util_1 = require("../tensor_util");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var binary_ops_1 = require("./binary_ops");
var operation_1 = require("./operation");
var tensor_ops_1 = require("./tensor_ops");
function movingAverage_(v, x, decay, step, zeroDebias) {
    if (zeroDebias === void 0) { zeroDebias = true; }
    var $v = tensor_util_env_1.convertToTensor(v, 'v', 'movingAverage');
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'movingAverage');
    var $decay = tensor_util_env_1.convertToTensor(decay, 'decay', 'movingAverage');
    tensor_util_1.assertTypesMatch($v, $x);
    util.assert(util.arraysEqual($v.shape, $x.shape), 'Shape mismatch in v and x');
    var one = tensor_ops_1.scalar(1);
    var oneMinusDecay = one.sub($decay);
    var update = $x.sub($v).mul(oneMinusDecay);
    if (zeroDebias) {
        util.assert(step != null, 'When using zeroDebias: true, step is required.');
        var $step = tensor_util_env_1.convertToTensor(step, 'step', 'movingAverage');
        update = update.div(one.sub(binary_ops_1.pow($decay, $step)));
    }
    return $v.add(update);
}
exports.movingAverage = operation_1.op({ movingAverage_: movingAverage_ });

},{"../tensor_util":198,"../tensor_util_env":199,"../util":203,"./binary_ops":142,"./operation":162,"./tensor_ops":180}],161:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_util_env_1 = require("../tensor_util_env");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var tensor_ops_1 = require("./tensor_ops");
function norm_(x, ord, axis, keepDims) {
    if (ord === void 0) { ord = 'euclidean'; }
    if (axis === void 0) { axis = null; }
    if (keepDims === void 0) { keepDims = false; }
    x = tensor_util_env_1.convertToTensor(x, 'x', 'norm');
    var norm = normImpl(x, ord, axis);
    var keepDimsShape = norm.shape;
    if (keepDims) {
        var axes = axis_util.parseAxisParam(axis, x.shape);
        keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);
    }
    return norm.reshape(keepDimsShape);
}
function normImpl(x, p, axis) {
    if (axis === void 0) { axis = null; }
    if (x.rank === 0) {
        return x.abs();
    }
    if (x.rank !== 1 && axis === null) {
        return normImpl(x.reshape([-1]), p, axis);
    }
    if (x.rank === 1 || typeof axis === 'number' ||
        axis instanceof Array && axis.length === 1) {
        if (p === 1) {
            return x.abs().sum(axis);
        }
        if (p === Infinity) {
            return x.abs().max(axis);
        }
        if (p === -Infinity) {
            return x.abs().min(axis);
        }
        if (p === 'euclidean' || p === 2) {
            return x.abs().pow(tensor_ops_1.scalar(2, 'int32')).sum(axis).sqrt();
        }
        throw new Error("Error in norm: invalid ord value: " + p);
    }
    if (axis instanceof Array && axis.length === 2) {
        if (p === 1) {
            return x.abs().sum(axis[0]).max(axis[1] - 1);
        }
        if (p === Infinity) {
            return x.abs().sum(axis[1]).max(axis[0]);
        }
        if (p === -Infinity) {
            return x.abs().sum(axis[1]).min(axis[0]);
        }
        if (p === 'fro' || p === 'euclidean') {
            return x.square().sum(axis).sqrt();
        }
        throw new Error("Error in norm: invalid ord value: " + p);
    }
    throw new Error("Error in norm: invalid axis: " + axis);
}
exports.norm = operation_1.op({ norm_: norm_ });

},{"../tensor_util_env":199,"./axis_util":140,"./operation":162,"./tensor_ops":180}],162:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
function op(f) {
    var keys = Object.keys(f);
    if (keys.length !== 1) {
        throw new Error("Please provide an object with a single key " +
            "(operation name) mapping to a function. Got an object with " +
            (keys.length + " keys."));
    }
    var opName = keys[0];
    var fn = f[opName];
    if (opName.endsWith('_')) {
        opName = opName.substring(0, opName.length - 1);
    }
    var f2 = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        environment_1.ENV.engine.startScope(opName);
        try {
            var result = fn.apply(void 0, args);
            if (result instanceof Promise) {
                console.error('Cannot return a Promise inside of tidy.');
            }
            environment_1.ENV.engine.endScope(result);
            return result;
        }
        catch (ex) {
            environment_1.ENV.engine.endScope(null);
            throw ex;
        }
    };
    Object.defineProperty(f2, 'name', { value: opName, configurable: true });
    return f2;
}
exports.op = op;

},{"../environment":60}],163:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./batchnorm"));
__export(require("./complex_ops"));
__export(require("./concat_split"));
__export(require("./conv"));
__export(require("./matmul"));
__export(require("./reverse"));
__export(require("./pool"));
__export(require("./slice"));
__export(require("./unary_ops"));
__export(require("./reduction_ops"));
__export(require("./compare"));
__export(require("./binary_ops"));
__export(require("./relu_ops"));
__export(require("./logical_ops"));
__export(require("./array_ops"));
__export(require("./tensor_ops"));
__export(require("./transpose"));
__export(require("./softmax"));
__export(require("./lrn"));
__export(require("./norm"));
__export(require("./segment_ops"));
__export(require("./lstm"));
__export(require("./moving_average"));
__export(require("./strided_slice"));
__export(require("./topk"));
__export(require("./scatter_nd"));
__export(require("./spectral_ops"));
__export(require("./gather_nd"));
var operation_1 = require("./operation");
exports.op = operation_1.op;
var losses = require("./loss_ops");
exports.losses = losses;
var linalg = require("./linalg_ops");
exports.linalg = linalg;
var image = require("./image_ops");
exports.image = image;
var spectral = require("./spectral_ops");
exports.spectral = spectral;

},{"./array_ops":138,"./batchnorm":141,"./binary_ops":142,"./compare":144,"./complex_ops":145,"./concat_split":146,"./conv":148,"./gather_nd":151,"./image_ops":153,"./linalg_ops":154,"./logical_ops":155,"./loss_ops":156,"./lrn":157,"./lstm":158,"./matmul":159,"./moving_average":160,"./norm":161,"./operation":162,"./pool":164,"./reduction_ops":167,"./relu_ops":168,"./reverse":169,"./scatter_nd":170,"./segment_ops":172,"./slice":175,"./softmax":177,"./spectral_ops":178,"./strided_slice":179,"./tensor_ops":180,"./topk":181,"./transpose":182,"./unary_ops":183}],164:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var conv_util = require("./conv_util");
var operation_1 = require("./operation");
function maxPool_(x, filterSize, strides, pad, dimRoundingMode) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'maxPool');
    var x4D = $x;
    var reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);
    }
    util.assert(x4D.rank === 4, "Error in maxPool: input must be rank 4 but got rank " + x4D.rank + ".");
    if (dimRoundingMode != null) {
        util.assert(util.isInt(pad), "Error in maxPool: pad must be an integer when using, " +
            ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
    }
    var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad, dimRoundingMode);
    var grad = function (dy, saved) {
        var y4D = saved[0];
        return {
            x: function () {
                return maxPoolBackprop(dy, x4D, y4D, filterSize, strides, pad);
            }
        };
    };
    var res = environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.maxPool(x4D, convInfo)); }, { x: x4D }, grad);
    if (reshapedTo4D) {
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    }
    return res;
}
function avgPool_(x, filterSize, strides, pad, dimRoundingMode) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'avgPool');
    util.assert($x.dtype === 'float32', 'The input dtype to avgPool must be float32');
    var x4D = $x;
    var reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = $x.as4D(1, $x.shape[0], $x.shape[1], $x.shape[2]);
    }
    util.assert(x4D.rank === 4, "Error in avgPool: x must be rank 4 but got rank " + x4D.rank + ".");
    if (dimRoundingMode != null) {
        util.assert(util.isInt(pad), "Error in avgPool: pad must be an integer when using, " +
            ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
    }
    var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad);
    var grad = function (dy) {
        return { x: function () { return avgPoolBackprop(dy, x4D, filterSize, strides, pad); } };
    };
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.avgPool(x4D, convInfo); }, { x: x4D }, grad);
    res = res.cast($x.dtype);
    if (reshapedTo4D) {
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    }
    return res;
}
function maxPoolBackprop(dy, input, output, filterSize, strides, pad, dimRoundingMode) {
    var $dy = tensor_util_env_1.convertToTensor(dy, 'dy', 'maxPoolBackprop');
    var $input = tensor_util_env_1.convertToTensor(input, 'input', 'maxPoolBackprop');
    var $output = tensor_util_env_1.convertToTensor(output, 'output', 'maxPoolBackprop');
    util.assert($input.rank === $dy.rank, "Rank of input (" + $input.rank + ") does not match rank of dy (" + $dy.rank + ")");
    util.assert($dy.rank === 4, "Error in maxPoolBackprop: dy must be rank 4 but got rank " +
        ($dy.rank + "."));
    util.assert($input.rank === 4, "Error in maxPoolBackprop: input must be rank 4 but got rank " +
        ($input.rank + "."));
    if (dimRoundingMode != null) {
        util.assert(util.isInt(pad), "Error in maxPoolBackprop: pad must be an integer when using, " +
            ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
    }
    var convInfo = conv_util.computePool2DInfo($input.shape, filterSize, strides, pad, dimRoundingMode);
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.maxPoolBackprop($dy, $input, $output, convInfo); }, { $dy: $dy, $input: $input });
    return res;
}
function avgPoolBackprop(dy, input, filterSize, strides, pad) {
    var $dy = tensor_util_env_1.convertToTensor(dy, 'dy', 'avgPoolBackprop');
    var $input = tensor_util_env_1.convertToTensor(input, 'input', 'avgPoolBackprop');
    util.assert($input.rank === $dy.rank, "Rank of input (" + $input.rank + ") does not match rank of dy (" + $dy.rank + ")");
    var input4D = $input;
    var dy4D = $dy;
    var reshapedTo4D = false;
    if ($input.rank === 3) {
        reshapedTo4D = true;
        input4D = $input.as4D(1, $input.shape[0], $input.shape[1], $input.shape[2]);
        dy4D = $dy.as4D(1, $dy.shape[0], $dy.shape[1], $dy.shape[2]);
    }
    util.assert(dy4D.rank === 4, "Error in avgPoolBackprop: dy must be rank 4 but got rank " +
        (dy4D.rank + "."));
    util.assert(input4D.rank === 4, "Error in avgPoolBackprop: input must be rank 4 but got rank " +
        (input4D.rank + "."));
    var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad);
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.avgPoolBackprop(dy4D, input4D, convInfo); }, { dy4D: dy4D, input4D: input4D });
    if (reshapedTo4D) {
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    }
    return res;
}
exports.maxPool = operation_1.op({ maxPool_: maxPool_ });
exports.avgPool = operation_1.op({ avgPool_: avgPool_ });

},{"../environment":60,"../tensor_util_env":199,"../util":203,"./conv_util":149,"./operation":162}],165:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var MPRandGauss = (function () {
    function MPRandGauss(mean, stdDeviation, dtype, truncated, seed) {
        this.mean = mean;
        this.stdDev = stdDeviation;
        this.dtype = dtype;
        this.nextVal = NaN;
        this.truncated = truncated;
        if (this.truncated) {
            this.upper = this.mean + this.stdDev * 2;
            this.lower = this.mean - this.stdDev * 2;
        }
        var seedValue = seed ? seed : Math.random();
        this.random = seedrandom.alea(seedValue.toString());
    }
    MPRandGauss.prototype.nextValue = function () {
        if (!isNaN(this.nextVal)) {
            var value = this.nextVal;
            this.nextVal = NaN;
            return value;
        }
        var resultX, resultY;
        var isValid = false;
        while (!isValid) {
            var v1 = void 0, v2 = void 0, s = void 0;
            do {
                v1 = 2 * this.random() - 1;
                v2 = 2 * this.random() - 1;
                s = v1 * v1 + v2 * v2;
            } while (s >= 1 || s === 0);
            var mul = Math.sqrt(-2.0 * Math.log(s) / s);
            resultX = this.mean + this.stdDev * v1 * mul;
            resultY = this.mean + this.stdDev * v2 * mul;
            if (!this.truncated || this.isValidTruncated(resultX)) {
                isValid = true;
            }
        }
        if (!this.truncated || this.isValidTruncated(resultY)) {
            this.nextVal = this.convertValue(resultY);
        }
        return this.convertValue(resultX);
    };
    MPRandGauss.prototype.convertValue = function (value) {
        if (this.dtype == null || this.dtype === 'float32') {
            return value;
        }
        return Math.round(value);
    };
    MPRandGauss.prototype.isValidTruncated = function (value) {
        return value <= this.upper && value >= this.lower;
    };
    return MPRandGauss;
}());
exports.MPRandGauss = MPRandGauss;

},{"seedrandom":1320}],166:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
exports.PARALLELIZE_THRESHOLD = 30;
function computeOptimalWindowSize(inSize) {
    if (inSize <= exports.PARALLELIZE_THRESHOLD) {
        return inSize;
    }
    return util_1.nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
}
exports.computeOptimalWindowSize = computeOptimalWindowSize;

},{"../util":203}],167:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var tensor_ops_1 = require("./tensor_ops");
function logSumExp_(x, axis, keepDims) {
    if (axis === void 0) { axis = null; }
    if (keepDims === void 0) { keepDims = false; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'logSumExp');
    var axes = axis_util.parseAxisParam(axis, $x.shape);
    var xMax = $x.max(axes, true);
    var a = $x.sub(xMax);
    var b = a.exp();
    var c = b.sum(axes);
    var d = c.log();
    var res = xMax.reshape(d.shape).add(d);
    if (keepDims) {
        var newShape = axis_util.expandShapeToKeepDim(res.shape, axes);
        return res.reshape(newShape);
    }
    return res;
}
function sum_(x, axis, keepDims) {
    if (axis === void 0) { axis = null; }
    if (keepDims === void 0) { keepDims = false; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'sum');
    if ($x.dtype === 'bool') {
        $x = $x.toInt();
    }
    var axes = axis_util.parseAxisParam(axis, $x.shape);
    var customOp = globals_1.customGrad(function (x) {
        var permutation = axis_util.getAxesPermutation(axes, x.rank);
        var reductionAxes = axes;
        var permutedX = x;
        if (permutation != null) {
            permutedX = x.transpose(permutation);
            reductionAxes = axis_util.getInnerMostAxes(reductionAxes.length, x.rank);
        }
        var value = environment_1.ENV.engine.runKernel(function (backend) { return backend.sum(permutedX, reductionAxes); }, { permutedX: permutedX });
        if (keepDims) {
            var newShape = axis_util.expandShapeToKeepDim(value.shape, axes);
            value = value.reshape(newShape);
        }
        var gradFunc = function (dy) {
            var expandedDyShape = x.shape.slice();
            axes.forEach(function (axis) {
                expandedDyShape[axis] = 1;
            });
            var expandedDy = dy.reshape(expandedDyShape);
            var derX = expandedDy.mul(tensor_ops_1.ones(x.shape, 'float32'));
            return derX;
        };
        return { value: value, gradFunc: gradFunc };
    });
    return customOp($x);
}
function prod_(x, axis, keepDims) {
    if (axis === void 0) { axis = null; }
    if (keepDims === void 0) { keepDims = false; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'prod');
    if ($x.dtype === 'bool') {
        $x = $x.toInt();
    }
    var axes = axis_util.parseAxisParam(axis, $x.shape);
    var permutation = axis_util.getAxesPermutation(axes, $x.rank);
    var reductionAxes = axes;
    var permutedX = $x;
    if (permutation != null) {
        permutedX = $x.transpose(permutation);
        reductionAxes = axis_util.getInnerMostAxes(reductionAxes.length, $x.rank);
    }
    var value = environment_1.ENV.engine.runKernel(function (backend) { return backend.prod(permutedX, reductionAxes); }, { permutedX: permutedX });
    if (keepDims) {
        var newShape = axis_util.expandShapeToKeepDim(value.shape, axes);
        value = value.reshape(newShape);
    }
    return value;
}
function mean_(x, axis, keepDims) {
    if (axis === void 0) { axis = null; }
    if (keepDims === void 0) { keepDims = false; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'mean');
    var axes = axis_util.parseAxisParam(axis, $x.shape);
    var shapes = axis_util.computeOutAndReduceShapes($x.shape, axes);
    var reduceShape = shapes[1];
    var reduceSize = util.sizeFromShape(reduceShape);
    var customOp = globals_1.customGrad(function (x) {
        var reduceSizeScalar = tensor_ops_1.scalar(reduceSize);
        var xReduce = reduceSizeScalar.dtype === x.dtype ? x : x.cast(reduceSizeScalar.dtype);
        var res = xReduce.div(reduceSizeScalar);
        var value = res.sum(axis, keepDims);
        var gradFunc = function (dy) {
            var expandedDyShape = x.shape.slice();
            axes.forEach(function (axis) {
                expandedDyShape[axis] = 1;
            });
            var expandedDy = dy.reshape(expandedDyShape);
            var derX = expandedDy.mul(tensor_ops_1.ones(x.shape, 'float32')).div(reduceSizeScalar);
            return derX;
        };
        return { value: value, gradFunc: gradFunc };
    });
    return customOp($x);
}
function gradForMinAndMax(dy, saved, xOrig, origAxes, permutedAxes) {
    var y = saved[0];
    if (y.rank < xOrig.rank) {
        y = y.reshape(axis_util.expandShapeToKeepDim(y.shape, origAxes));
    }
    if (dy.rank < xOrig.rank) {
        dy = dy.reshape(axis_util.expandShapeToKeepDim(dy.shape, origAxes));
    }
    return {
        $x: function () {
            var dx = dy.mul(xOrig.equal(y).cast(dy.dtype));
            return permutedAxes == null ? dx : dx.transpose(permutedAxes);
        }
    };
}
function min_(x, axis, keepDims) {
    if (axis === void 0) { axis = null; }
    if (keepDims === void 0) { keepDims = false; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'min');
    var xOrig = $x;
    var origAxes = axis_util.parseAxisParam(axis, $x.shape);
    var axes = origAxes;
    var permutedAxes = axis_util.getAxesPermutation(axes, $x.rank);
    if (permutedAxes != null) {
        $x = $x.transpose(permutedAxes);
        axes = axis_util.getInnerMostAxes(axes.length, $x.rank);
    }
    var grad = function (dy, saved) {
        return gradForMinAndMax(dy, saved, xOrig, origAxes, permutedAxes);
    };
    var res = environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.min($x, axes)); }, { $x: $x }, grad);
    if (keepDims) {
        var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
        res = res.reshape(newShape);
    }
    return res;
}
function max_(x, axis, keepDims) {
    if (axis === void 0) { axis = null; }
    if (keepDims === void 0) { keepDims = false; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'max');
    var xOrig = $x;
    var origAxes = axis_util.parseAxisParam(axis, $x.shape);
    var axes = origAxes;
    var permutedAxes = axis_util.getAxesPermutation(axes, $x.rank);
    if (permutedAxes != null) {
        $x = $x.transpose(permutedAxes);
        axes = axis_util.getInnerMostAxes(axes.length, $x.rank);
    }
    var grad = function (dy, saved) {
        return gradForMinAndMax(dy, saved, xOrig, origAxes, permutedAxes);
    };
    var res = environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.max($x, axes)); }, { $x: $x }, grad);
    if (keepDims) {
        var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
        res = res.reshape(newShape);
    }
    return res;
}
function argMin_(x, axis) {
    if (axis === void 0) { axis = 0; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'argMin');
    if (axis == null) {
        axis = 0;
    }
    var axes = axis_util.parseAxisParam(axis, $x.shape);
    var permutedAxes = axis_util.getAxesPermutation(axes, $x.rank);
    if (permutedAxes != null) {
        $x = $x.transpose(permutedAxes);
        axes = axis_util.getInnerMostAxes(axes.length, $x.rank);
    }
    var grad = function (dy) {
        return { $x: function () { return tensor_ops_1.zerosLike($x); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.argMin($x, axes[0]); }, { $x: $x }, grad);
}
function argMax_(x, axis) {
    if (axis === void 0) { axis = 0; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'argMax');
    if (axis == null) {
        axis = 0;
    }
    var axes = axis_util.parseAxisParam(axis, $x.shape);
    var permutedAxes = axis_util.getAxesPermutation(axes, $x.rank);
    if (permutedAxes != null) {
        $x = $x.transpose(permutedAxes);
        axes = axis_util.getInnerMostAxes(axes.length, $x.rank);
    }
    var grad = function (dy) {
        return { $x: function () { return tensor_ops_1.zerosLike($x); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.argMax($x, axes[0]); }, { $x: $x }, grad);
}
function all_(x, axis, keepDims) {
    if (axis === void 0) { axis = null; }
    if (keepDims === void 0) { keepDims = false; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'all', 'bool');
    util.assert($x.dtype === 'bool', "Error Tensor must be of type bool. Got: " + $x.dtype);
    var origAxes = axis_util.parseAxisParam(axis, $x.shape);
    var axes = origAxes;
    var permutedAxes = axis_util.getAxesPermutation(axes, $x.rank);
    if (permutedAxes != null) {
        $x = $x.transpose(permutedAxes);
        axes = axis_util.getInnerMostAxes(axes.length, $x.rank);
    }
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.all($x, axes); }, { $x: $x });
    if (keepDims) {
        var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
        return res.reshape(newShape);
    }
    return res;
}
function any_(x, axis, keepDims) {
    if (axis === void 0) { axis = null; }
    if (keepDims === void 0) { keepDims = false; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'any', 'bool');
    util.assert($x.dtype === 'bool', "Error Tensor must be of type bool. Got: " + $x.dtype);
    var origAxes = axis_util.parseAxisParam(axis, $x.shape);
    var axes = origAxes;
    var permutedAxes = axis_util.getAxesPermutation(axes, $x.rank);
    if (permutedAxes != null) {
        $x = $x.transpose(permutedAxes);
        axes = axis_util.getInnerMostAxes(axes.length, $x.rank);
    }
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.any($x, axes); }, { $x: $x });
    if (keepDims) {
        var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
        return res.reshape(newShape);
    }
    return res;
}
function moments_(x, axis, keepDims) {
    if (axis === void 0) { axis = null; }
    if (keepDims === void 0) { keepDims = false; }
    x = tensor_util_env_1.convertToTensor(x, 'x', 'moments');
    var axes = axis_util.parseAxisParam(axis, x.shape);
    var mean = x.mean(axes, keepDims);
    var keepDimsShape = mean.shape;
    if (!keepDims) {
        keepDimsShape = axis_util.expandShapeToKeepDim(mean.shape, axes);
    }
    var devSquared = x.toFloat().sub(mean.reshape(keepDimsShape)).square();
    var variance = devSquared.mean(axes, keepDims);
    return { mean: mean, variance: variance };
}
exports.all = operation_1.op({ all_: all_ });
exports.any = operation_1.op({ any_: any_ });
exports.argMax = operation_1.op({ argMax_: argMax_ });
exports.argMin = operation_1.op({ argMin_: argMin_ });
exports.logSumExp = operation_1.op({ logSumExp_: logSumExp_ });
exports.max = operation_1.op({ max_: max_ });
exports.mean = operation_1.op({ mean_: mean_ });
exports.min = operation_1.op({ min_: min_ });
exports.moments = operation_1.op({ moments_: moments_ });
exports.sum = operation_1.op({ sum_: sum_ });
exports.prod = operation_1.op({ prod_: prod_ });

},{"../environment":60,"../globals":62,"../tensor_util_env":199,"../util":203,"./axis_util":140,"./operation":162,"./tensor_ops":180}],168:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var binary_ops_1 = require("./binary_ops");
var logical_ops_1 = require("./logical_ops");
var operation_1 = require("./operation");
var selu_util_1 = require("./selu_util");
var tensor_ops_1 = require("./tensor_ops");
function relu_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'relu');
    if ($x.dtype === 'bool') {
        return $x.toInt();
    }
    var grad = function (dy) {
        var stepRes = $x.step();
        return { $x: function () { return dy.mulStrict(stepRes.toFloat()); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.relu($x); }, { $x: $x }, grad);
}
function elu_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'elu');
    var grad = function (dy, saved) {
        var y = saved[0];
        return {
            $x: function () {
                return environment_1.ENV.engine.runKernel(function (backend) { return backend.eluDer(dy, y); }, { dy: dy, y: y });
            }
        };
    };
    return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.elu($x)); }, { $x: $x }, grad);
}
function selu_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'selu');
    var grad = function (dy) {
        return {
            $x: function () {
                var mask = $x.greater(tensor_ops_1.scalar(0));
                var scaleAlpha = tensor_ops_1.scalar(selu_util_1.SELU_SCALEALPHA);
                var scale = tensor_ops_1.scalar(selu_util_1.SELU_SCALE);
                var greaterThanZeroDer = dy.mul(scale);
                var lessEqualZeroDer = dy.mul(scaleAlpha).mul($x.toFloat().exp());
                return logical_ops_1.where(mask, greaterThanZeroDer, lessEqualZeroDer);
            }
        };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.selu($x); }, { $x: $x }, grad);
}
function leakyRelu_(x, alpha) {
    if (alpha === void 0) { alpha = 0.2; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'leakyRelu');
    return binary_ops_1.maximum(tensor_ops_1.scalar(alpha).mul($x), $x);
}
function prelu_(x, alpha) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'prelu');
    var $alpha = tensor_util_env_1.convertToTensor(alpha, 'alpha', 'prelu');
    var zero = tensor_ops_1.scalar(0);
    return binary_ops_1.maximum(zero, $x).add($alpha.mul(binary_ops_1.minimum(zero, $x)));
}
exports.elu = operation_1.op({ elu_: elu_ });
exports.leakyRelu = operation_1.op({ leakyRelu_: leakyRelu_ });
exports.prelu = operation_1.op({ prelu_: prelu_ });
exports.relu = operation_1.op({ relu_: relu_ });
exports.selu = operation_1.op({ selu_: selu_ });

},{"../environment":60,"../tensor_util_env":199,"./binary_ops":142,"./logical_ops":155,"./operation":162,"./selu_util":174,"./tensor_ops":180}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var axis_util_1 = require("./axis_util");
var operation_1 = require("./operation");
function reverse1d_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'reverse');
    util.assert($x.rank === 1, "Error in reverse1D: x must be rank 1 but got\n             rank " + $x.rank + ".");
    return exports.reverse($x, 0);
}
function reverse2d_(x, axis) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'reverse');
    util.assert($x.rank === 2, "Error in reverse2D: x must be rank 2 but got\n             rank " + $x.rank + ".");
    return exports.reverse($x, axis);
}
function reverse3d_(x, axis) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'reverse');
    util.assert($x.rank === 3, "Error in reverse3D: x must be rank 3 but got\n             rank " + $x.rank + ".");
    return exports.reverse($x, axis);
}
function reverse4d_(x, axis) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'reverse');
    util.assert($x.rank === 4, "Error in reverse4D: x must be rank 4 but got\n             rank " + $x.rank + ".");
    return exports.reverse($x, axis);
}
function reverse_(x, axis) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'reverse');
    if ($x.rank === 0) {
        return $x.clone();
    }
    var axes = axis_util_1.parseAxisParam(axis, $x.shape);
    var grad = function (dy) {
        return { $x: function () { return dy.reverse(axes); } };
    };
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.reverse($x, axes); }, { $x: $x }, grad);
    return res.reshapeAs($x);
}
exports.reverse = operation_1.op({ reverse_: reverse_ });
exports.reverse1d = operation_1.op({ reverse1d_: reverse1d_ });
exports.reverse2d = operation_1.op({ reverse2d_: reverse2d_ });
exports.reverse3d = operation_1.op({ reverse3d_: reverse3d_ });
exports.reverse4d = operation_1.op({ reverse4d_: reverse4d_ });

},{"../environment":60,"../tensor_util_env":199,"../util":203,"./axis_util":140,"./operation":162}],170:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var operation_1 = require("./operation");
function scatterND_(indices, updates, shape) {
    var $indices = tensor_util_env_1.convertToTensor(indices, 'indices', 'scatterND', 'int32');
    var $updates = tensor_util_env_1.convertToTensor(updates, 'updates', 'scatterND');
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.scatterND($indices, $updates, shape); }, { $indices: $indices, $updates: $updates });
}
exports.scatterND = operation_1.op({ scatterND_: scatterND_ });

},{"../environment":60,"../tensor_util_env":199,"./operation":162}],171:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
function validateUpdateShape(shape, indices, updates) {
    var sliceDim = (indices.rank > 1) ? indices.shape[indices.rank - 1] : 1;
    var batchDim = (indices.rank > 1) ? indices.rank - 1 : 1;
    var shapeError = 'Must have updates.shape = indices.shape[:batchDim] + ' +
        ("shape[sliceDim:], got updates.shape: " + updates.shape) +
        (", indices.shape: " + indices.shape + ", shape: " + shape) +
        (", sliceDim: " + sliceDim + ", and batchDim: " + batchDim + ".");
    if (updates.rank < batchDim) {
        throw new Error(shapeError + (" update.rank < " + batchDim + ". "));
    }
    if (shape.length < sliceDim + (updates.rank - batchDim)) {
        throw new Error(shapeError +
            (" Output shape length < " + (sliceDim + (updates.rank - batchDim))));
    }
    if (updates.rank !== batchDim + shape.length - sliceDim) {
        throw new Error(shapeError + (" update.rank != " + (batchDim + shape.length - sliceDim)));
    }
    for (var d = 0; d < batchDim; ++d) {
        if (updates.shape[d] !== indices.shape[d]) {
            throw new Error(shapeError +
                (" updates.shape[" + d + "] (" + updates.shape[d] + ") != indices.shape[" + d + "] (" + indices.shape[d] + ")."));
        }
    }
    for (var d = 0; d < updates.rank - batchDim; ++d) {
        if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {
            throw new Error(shapeError +
                (" updates.shape[" + (d + batchDim) + "] (" + updates.shape[d + batchDim] + ") != shape[" + (d + batchDim) + "] (" + shape[d + batchDim] + ")"));
        }
    }
}
exports.validateUpdateShape = validateUpdateShape;
function prepareAndValidate(updates, indices, shape) {
    if (indices.rank < 1) {
        throw new Error('tf.scatterND() expects the indices to be rank 1 or higher,' +
            (" but the rank was " + indices.rank + "."));
    }
    if (updates.rank < 1) {
        throw new Error('tf.scatterND() expects the updates to be rank 1 or higher,' +
            (" but the rank was " + updates.rank + "."));
    }
    if (indices.dtype !== 'int32') {
        throw new Error("The dtype of 'indices' should be int32, but got dtype: " + indices.dtype);
    }
    if (shape.length < 1) {
        throw new Error("Output rank must be greater or equal to 1, but got shape: " + shape);
    }
    if (shape.length === 0) {
        if (indices.size === 0) {
            throw new Error("Indices specified for empty output. indices shape: " + indices.shape);
        }
        if (updates.size === 0) {
            throw new Error("Updates specified for empty output. updates shape: " + updates.shape);
        }
    }
    validateUpdateShape(shape, indices, updates);
    var sliceDim = (indices.rank > 1) ? indices.shape[indices.rank - 1] : 1;
    var totalNd = shape.length;
    var sliceSize = 1;
    for (var i = sliceDim; i < totalNd; ++i) {
        sliceSize *= shape[i];
    }
    var safeSliceDim = (sliceDim < 1) ? 1 : sliceDim;
    var numUpdates = indices.size / safeSliceDim;
    var outputStrides = util_1.computeStrides(shape).concat([1]);
    var sliceStrides = outputStrides.slice(outputStrides.length - sliceDim, outputStrides.length);
    return [sliceDim, numUpdates, sliceSize, sliceStrides, util_1.sizeFromShape(shape)];
}
exports.prepareAndValidate = prepareAndValidate;

},{"../util":203}],172:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var util_1 = require("../util");
var array_ops_1 = require("./array_ops");
var axis_util_1 = require("./axis_util");
var binary_ops_1 = require("./binary_ops");
var compare_1 = require("./compare");
var logical_ops_1 = require("./logical_ops");
var operation_1 = require("./operation");
var tensor_ops_1 = require("./tensor_ops");
function unsortedSegmentSum_(x, segmentIds, numSegments) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'unsortedSegmentSum');
    var $segmentIds = tensor_util_env_1.convertToTensor(segmentIds, 'segmentIds', 'unsortedSegmentSum', 'int32');
    util_1.assert($segmentIds.dtype === 'int32', 'segmentIds must be of dtype `int32`');
    util_1.assert(util_1.isInt(numSegments), 'numSegments must be of dtype int');
    var gradFunc = function (dy) {
        var derX = function () {
            return gatherDropNegatives(dy, $segmentIds);
        };
        return { $x: derX };
    };
    return environment_1.ENV.engine.runKernel(function (backend) {
        return backend.unsortedSegmentSum($x, $segmentIds, numSegments);
    }, { $x: $x }, gradFunc);
}
function gather_(x, indices, axis) {
    if (axis === void 0) { axis = 0; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'gather');
    var $indices = tensor_util_env_1.convertToTensor(indices, 'indices', 'gather', 'int32');
    util_1.assert($indices.dtype === 'int32', 'Indices must be of dtype `int32`');
    axis = axis_util_1.parseAxisParam(axis, $x.shape)[0];
    var grad = function (dy) {
        var derX = function () {
            if (axis === 0) {
                return exports.unsortedSegmentSum(dy, $indices, $x.shape[axis]);
            }
            var paramsShape = $x.shape;
            var indicesSize = $indices.size;
            var outerShape = paramsShape.slice(0, axis);
            var outerDims = outerShape.length;
            var innerShape = paramsShape.slice(axis, paramsShape.length).slice(1);
            var innerDims = innerShape.length;
            var outerAxesIndices = arrayRange(0, outerDims);
            var innerAxesIndices = arrayRange(outerDims + 1, outerDims + 1 + innerDims);
            var valuesShape = arrayConcat([outerShape, [indicesSize], innerShape]);
            var values = dy.reshape(valuesShape);
            var reshapedIndices = $indices.reshape([indicesSize]);
            var transposeDims = arrayConcat([[outerDims], outerAxesIndices, innerAxesIndices]);
            var valuesTranspose = values.transpose(transposeDims);
            var paramsGrad = exports.unsortedSegmentSum(valuesTranspose, reshapedIndices, $x.shape[axis]);
            var invertTransposeDims = axis_util_1.getUndoAxesPermutation(transposeDims);
            paramsGrad = paramsGrad.transpose(invertTransposeDims);
            return paramsGrad;
        };
        return { $x: derX };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.gather($x, $indices, axis); }, { $x: $x }, grad);
}
function arrayRange(start, stop) {
    var result = [];
    for (var i = start; i < stop; ++i) {
        result.push(i);
    }
    return result;
}
function arrayConcat(arrays) {
    var result = [];
    for (var i = 0; i < arrays.length; ++i) {
        for (var j = 0; j < arrays[i].length; ++j) {
            result.push(arrays[i][j]);
        }
    }
    return result;
}
function gatherDropNegatives(x, indices) {
    var zeroClippedIndices = binary_ops_1.maximum(indices, tensor_ops_1.zerosLike(indices));
    var gathered = exports.gather(x, zeroClippedIndices);
    var isPositive = compare_1.greaterEqual(indices, tensor_ops_1.scalar(0, 'int32'));
    var numIters = gathered.rank - isPositive.rank;
    for (var i = 0; i < numIters; ++i) {
        isPositive = array_ops_1.expandDims(isPositive, i + 1);
    }
    isPositive = logical_ops_1.logicalAnd(isPositive, tensor_ops_1.ones(gathered.shape, 'bool'));
    var zeroSlice = tensor_ops_1.zerosLike(gathered);
    return logical_ops_1.where(isPositive, gathered, zeroSlice);
}
exports.gather = operation_1.op({ gather_: gather_ });
exports.unsortedSegmentSum = operation_1.op({ unsortedSegmentSum_: unsortedSegmentSum_ });

},{"../environment":60,"../tensor_util_env":199,"../util":203,"./array_ops":138,"./axis_util":140,"./binary_ops":142,"./compare":144,"./logical_ops":155,"./operation":162,"./tensor_ops":180}],173:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var reduce_util_1 = require("./reduce_util");
function segOpComputeOptimalWindowSize(inSize, numSegments) {
    var done = false;
    var res;
    if (inSize <= reduce_util_1.PARALLELIZE_THRESHOLD) {
        res = inSize;
        done = true;
    }
    else {
        res = util_1.nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
    }
    while (!done) {
        if (res > numSegments || res === inSize) {
            done = true;
            break;
        }
        else {
            res = util_1.nearestDivisor(inSize, res + 1);
        }
    }
    return res;
}
exports.segOpComputeOptimalWindowSize = segOpComputeOptimalWindowSize;
function computeOutShape(aShape, axis, numSegments) {
    var outShape = [];
    var rank = aShape.length;
    for (var dim = 0; dim < rank; dim++) {
        if (dim !== axis) {
            outShape.push(aShape[dim]);
        }
        else {
            outShape.push(numSegments);
        }
    }
    return outShape;
}
exports.computeOutShape = computeOutShape;

},{"../util":203,"./reduce_util":166}],174:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SELU_SCALEALPHA = 1.7580993408473768599402175208123;
exports.SELU_SCALE = 1.0507009873554804934193349852946;

},{}],175:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var operation_1 = require("./operation");
var slice_util = require("./slice_util");
function slice1d_(x, begin, size) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'slice1d');
    util.assert($x.rank === 1, "slice1d expects a rank-1 tensor, but got a rank-" + $x.rank + " tensor");
    return exports.slice($x, [begin], [size]);
}
function slice2d_(x, begin, size) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'slice2d');
    util.assert($x.rank === 2, "slice2d expects a rank-2 tensor, but got a rank-" + $x.rank + " tensor");
    return exports.slice($x, begin, size);
}
function slice3d_(x, begin, size) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'slice3d');
    util.assert($x.rank === 3, "slice3d expects a rank-3 tensor, but got a rank-" + $x.rank + " tensor");
    return exports.slice($x, begin, size);
}
function slice4d_(x, begin, size) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'slice4d');
    util.assert($x.rank === 4, "slice4d expects a rank-4 tensor, but got a rank-" + $x.rank + " tensor");
    return exports.slice($x, begin, size);
}
function slice_(x, begin, size) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'slice');
    if ($x.rank === 0) {
        throw new Error('Slicing scalar is not possible');
    }
    var begin_;
    if (typeof begin === 'number') {
        begin_ = [begin].concat(new Array($x.rank - 1).fill(0));
    }
    else if (begin.length < $x.rank) {
        begin_ = begin.concat(new Array($x.rank - begin.length).fill(0));
    }
    else {
        begin_ = begin.slice();
    }
    var size_;
    if (size == null) {
        size_ = new Array($x.rank).fill(-1);
    }
    else if (typeof size === 'number') {
        size_ = [size].concat(new Array($x.rank - 1).fill(-1));
    }
    else if (size.length < $x.rank) {
        size_ = size.concat(new Array($x.rank - size.length).fill(-1));
    }
    else {
        size_ = size;
    }
    size_ = size_.map(function (d, i) {
        if (d >= 0) {
            return d;
        }
        else {
            util.assert(d === -1, 'Bad value in size');
            return $x.shape[i] - begin_[i];
        }
    });
    slice_util.assertParamsValid($x, begin_, size_);
    var inputShape = $x.shape;
    var grad = function (dy) {
        var paddings = [];
        for (var i = 0; i < dy.rank; i++) {
            paddings.push([begin_[i], inputShape[i] - begin_[i] - size_[i]]);
        }
        return { $x: function () { return dy.pad(paddings); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.slice($x, begin_, size_); }, { $x: $x }, grad);
}
exports.slice = operation_1.op({ slice_: slice_ });
exports.slice1d = operation_1.op({ slice1d_: slice1d_ });
exports.slice2d = operation_1.op({ slice2d_: slice2d_ });
exports.slice3d = operation_1.op({ slice3d_: slice3d_ });
exports.slice4d = operation_1.op({ slice4d_: slice4d_ });

},{"../environment":60,"../tensor_util_env":199,"../util":203,"./operation":162,"./slice_util":176}],176:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParamsValid(input, begin, size) {
    util.assert(input.rank === begin.length, "Error in slice" + input.rank + "D: Length of begin " + begin + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    util.assert(input.rank === size.length, "Error in slice" + input.rank + "D: Length of size " + size + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    for (var i = 0; i < input.rank; ++i) {
        util.assert(begin[i] + size[i] <= input.shape[i], "Error in slice" + input.rank + "D: begin[" + i + "] + size[" + i + "] " +
            ("(" + (begin[i] + size[i]) + ") would overflow input.shape[" + i + "] (" + input.shape[i] + ")"));
    }
}
exports.assertParamsValid = assertParamsValid;
function getStridedSlicedInfo(shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
    if (beginMask === void 0) { beginMask = 0; }
    if (endMask === void 0) { endMask = 0; }
    if (ellipsisMask === void 0) { ellipsisMask = 0; }
    if (newAxisMask === void 0) { newAxisMask = 0; }
    if (shrinkAxisMask === void 0) { shrinkAxisMask = 0; }
    if (ellipsisMask !== 0) {
        throw new Error('ellipsis mask is not yet supported');
    }
    if (newAxisMask !== 0) {
        throw new Error('new axis mask is not yet supported');
    }
    var startIndex = [];
    var endIndex = [];
    var shrinkAxis = [];
    for (var i = 0; i < shape.length; i++) {
        startIndex[i] = startForAxis(beginMask, begin, strides, shape, i);
        endIndex[i] = stopForAxis(endMask, end, strides, shape, i);
        if (shrinkAxisMask & 1 << i) {
            endIndex[i] = startIndex[i] + 1;
            shrinkAxis.push(i);
        }
    }
    var size = new Array(shape.length).fill(0);
    size = size.map(function (d, i) {
        var count = 0;
        for (var start = startIndex[i]; !(strides[i] > 0 ? start >= endIndex[i] : start <= endIndex[i]); start += strides[i]) {
            count += 1;
        }
        return count;
    });
    return [startIndex, size, shrinkAxis];
}
exports.getStridedSlicedInfo = getStridedSlicedInfo;
function startForAxis(beginMask, startIndices, strides, inputShape, axis) {
    var start = startIndices[axis];
    if (beginMask & 1 << axis) {
        if (strides[axis] > 0) {
            start = Number.MIN_SAFE_INTEGER;
        }
        else {
            start = Number.MAX_SAFE_INTEGER;
        }
    }
    var axisSize = inputShape[axis];
    if (start < 0) {
        start += axisSize;
    }
    start = util.clamp(0, start, axisSize - 1);
    return start;
}
exports.startForAxis = startForAxis;
function stopForAxis(endMask, stopIndices, strides, inputShape, axis) {
    var stop = stopIndices[axis];
    if (endMask & (1 << axis)) {
        if (strides[axis] > 0) {
            stop = Number.MAX_SAFE_INTEGER;
        }
        else {
            stop = Number.MIN_SAFE_INTEGER;
        }
    }
    var axisSize = inputShape[axis];
    if (stop < 0) {
        stop += axisSize;
    }
    if (strides[axis] > 0) {
        stop = util.clamp(0, stop, axisSize);
    }
    else {
        stop = util.clamp(-1, stop, axisSize - 1);
    }
    return stop;
}
exports.stopForAxis = stopForAxis;

},{"../util":203}],177:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gradients_1 = require("../gradients");
var tensor_util_env_1 = require("../tensor_util_env");
var operation_1 = require("./operation");
function softmax_(logits, dim) {
    if (dim === void 0) { dim = -1; }
    var $logits = tensor_util_env_1.convertToTensor(logits, 'logits', 'softmax');
    if (dim === -1) {
        dim = $logits.rank - 1;
    }
    if (dim !== $logits.rank - 1) {
        throw Error('Softmax along a non-last dimension is not yet supported. ' +
            ("Logits was rank " + $logits.rank + " and dim was " + dim));
    }
    var customOp = gradients_1.customGrad(function (logits) {
        var keepDims = true;
        var lse = logits.logSumExp([dim], keepDims);
        var logResult = logits.toFloat().sub(lse);
        var y = logResult.exp();
        var gradFunc = function (dy) {
            var dyTimesY = dy.mul(y);
            var keepDims = true;
            return dyTimesY.sub(dyTimesY.sum([dim], keepDims).mul(y));
        };
        return { value: y, gradFunc: gradFunc };
    });
    return customOp($logits);
}
exports.softmax = operation_1.op({ softmax_: softmax_ });

},{"../gradients":63,"../tensor_util_env":199,"./operation":162}],178:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var operation_1 = require("../ops/operation");
var util_1 = require("../util");
function fft_(input) {
    util_1.assert(input.dtype === 'complex64', 'dtype must be complex64');
    util_1.assert(input.rank === 1, 'input rank must be 1');
    var ret = environment_1.ENV.engine.runKernel(function (backend) { return backend.fft(input); }, { input: input });
    return ret;
}
exports.fft = operation_1.op({ fft_: fft_ });

},{"../environment":60,"../ops/operation":162,"../util":203}],179:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var operation_1 = require("./operation");
function stridedSlice_(x, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
    if (beginMask === void 0) { beginMask = 0; }
    if (endMask === void 0) { endMask = 0; }
    if (ellipsisMask === void 0) { ellipsisMask = 0; }
    if (newAxisMask === void 0) { newAxisMask = 0; }
    if (shrinkAxisMask === void 0) { shrinkAxisMask = 0; }
    if (ellipsisMask !== 0) {
        throw new Error('ellipsis mask is not yet supported');
    }
    if (newAxisMask !== 0) {
        throw new Error('new axis mask is not yet supported');
    }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'stridedSlice');
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.stridedSlice($x, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask); }, { $x: $x });
}
exports.stridedSlice = operation_1.op({ stridedSlice_: stridedSlice_ });

},{"../environment":60,"../tensor_util_env":199,"./operation":162}],180:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_1 = require("../tensor");
var tensor_util_env_1 = require("../tensor_util_env");
var tensor_util_env_2 = require("../tensor_util_env");
var util_1 = require("../util");
var complex_ops_1 = require("./complex_ops");
var operation_1 = require("./operation");
function tensor(values, shape, dtype) {
    if (dtype === void 0) { dtype = 'float32'; }
    if (dtype === 'complex64') {
        throw new Error("Cannot construct a complex64 tensor directly. " +
            "Please use tf.complex(real, imag).");
    }
    if (!util_1.isTypedArray(values) && !Array.isArray(values) &&
        typeof values !== 'number' && typeof values !== 'boolean') {
        throw new Error('values passed to tensor(values) must be an ' +
            'array of numbers or booleans, or a TypedArray');
    }
    var inferredShape = tensor_util_env_2.inferShape(values);
    if (shape != null && inferredShape.length !== 1) {
        util_1.assertShapesMatch(shape, inferredShape, "Error creating a new Tensor. " +
            ("Inferred shape (" + inferredShape + ") does not match the ") +
            ("provided shape (" + shape + "). "));
    }
    if (!util_1.isTypedArray(values) && !Array.isArray(values)) {
        values = [values];
    }
    shape = shape || inferredShape;
    return tensor_1.Tensor.make(shape, {
        values: util_1.toTypedArray(values, dtype, environment_1.ENV.get('DEBUG'))
    }, dtype);
}
exports.tensor = tensor;
function scalar(value, dtype) {
    if (dtype === void 0) { dtype = 'float32'; }
    if ((util_1.isTypedArray(value) || Array.isArray(value)) && dtype !== 'complex64') {
        throw new Error('Error creating a new Scalar: value must be a primitive ' +
            '(number|boolean)');
    }
    return tensor(value, [], dtype);
}
exports.scalar = scalar;
function tensor1d(values, dtype) {
    if (dtype === void 0) { dtype = 'float32'; }
    util_1.assertNonNull(values);
    var inferredShape = tensor_util_env_2.inferShape(values);
    if (inferredShape.length !== 1) {
        throw new Error('tensor1d() requires values to be a flat/TypedArray');
    }
    return tensor(values, inferredShape, dtype);
}
exports.tensor1d = tensor1d;
function tensor2d(values, shape, dtype) {
    if (dtype === void 0) { dtype = 'float32'; }
    util_1.assertNonNull(values);
    if (shape != null && shape.length !== 2) {
        throw new Error('tensor2d() requires shape to have two numbers');
    }
    var inferredShape = tensor_util_env_2.inferShape(values);
    if (inferredShape.length !== 2 && inferredShape.length !== 1) {
        throw new Error('tensor2d() requires values to be number[][] or flat/TypedArray');
    }
    if (inferredShape.length === 1 && shape == null) {
        throw new Error('tensor2d() requires shape to be provided when `values` ' +
            'are a flat/TypedArray');
    }
    shape = shape || inferredShape;
    return tensor(values, shape, dtype);
}
exports.tensor2d = tensor2d;
function tensor3d(values, shape, dtype) {
    if (dtype === void 0) { dtype = 'float32'; }
    util_1.assertNonNull(values);
    if (shape != null && shape.length !== 3) {
        throw new Error('tensor3d() requires shape to have three numbers');
    }
    var inferredShape = tensor_util_env_2.inferShape(values);
    if (inferredShape.length !== 3 && inferredShape.length !== 1) {
        throw new Error('tensor3d() requires values to be number[][][] or flat/TypedArray');
    }
    if (inferredShape.length === 1 && shape == null) {
        throw new Error('tensor3d() requires shape to be provided when `values` ' +
            'are a flat array');
    }
    shape = shape || inferredShape;
    return tensor(values, shape, dtype);
}
exports.tensor3d = tensor3d;
function tensor4d(values, shape, dtype) {
    if (dtype === void 0) { dtype = 'float32'; }
    util_1.assertNonNull(values);
    if (shape != null && shape.length !== 4) {
        throw new Error('tensor4d() requires shape to have four numbers');
    }
    var inferredShape = tensor_util_env_2.inferShape(values);
    if (inferredShape.length !== 4 && inferredShape.length !== 1) {
        throw new Error('tensor4d() requires values to be number[][][][] or flat/TypedArray');
    }
    if (inferredShape.length === 1 && shape == null) {
        throw new Error('tensor4d() requires shape to be provided when `values` ' +
            'are a flat array');
    }
    shape = shape || inferredShape;
    return tensor(values, shape, dtype);
}
exports.tensor4d = tensor4d;
function tensor5d(values, shape, dtype) {
    if (dtype === void 0) { dtype = 'float32'; }
    util_1.assertNonNull(values);
    if (shape != null && shape.length !== 5) {
        throw new Error('tensor5d() requires shape to have five numbers');
    }
    var inferredShape = tensor_util_env_2.inferShape(values);
    if (inferredShape.length !== 5 && inferredShape.length !== 1) {
        throw new Error('tensor5d() requires values to be ' +
            'number[][][][][] or flat/TypedArray');
    }
    if (inferredShape.length === 1 && shape == null) {
        throw new Error('tensor5d() requires shape to be provided when `values` ' +
            'are a flat array');
    }
    shape = shape || inferredShape;
    return tensor(values, shape, dtype);
}
exports.tensor5d = tensor5d;
function tensor6d(values, shape, dtype) {
    if (dtype === void 0) { dtype = 'float32'; }
    util_1.assertNonNull(values);
    if (shape != null && shape.length !== 6) {
        throw new Error('tensor6d() requires shape to have six numbers');
    }
    var inferredShape = tensor_util_env_2.inferShape(values);
    if (inferredShape.length !== 6 && inferredShape.length !== 1) {
        throw new Error('tensor6d() requires values to be number[][][][] or flat/TypedArray');
    }
    if (inferredShape.length === 1 && shape == null) {
        throw new Error('tensor6d() requires shape to be provided when `values` ' +
            'are a flat array');
    }
    shape = shape ||
        inferredShape;
    return tensor(values, shape, dtype);
}
exports.tensor6d = tensor6d;
function ones(shape, dtype) {
    if (dtype === void 0) { dtype = 'float32'; }
    if (dtype === 'complex64') {
        var real = ones(shape, 'float32');
        var imag = ones(shape, 'float32');
        return complex_ops_1.complex(real, imag);
    }
    var values = util_1.makeOnesTypedArray(util_1.sizeFromShape(shape), dtype);
    return tensor_1.Tensor.make(shape, { values: values }, dtype);
}
exports.ones = ones;
function zeros(shape, dtype) {
    if (dtype === void 0) { dtype = 'float32'; }
    if (dtype === 'complex64') {
        var real = zeros(shape, 'float32');
        var imag = zeros(shape, 'float32');
        return complex_ops_1.complex(real, imag);
    }
    var values = util_1.makeZerosTypedArray(util_1.sizeFromShape(shape), dtype);
    return tensor_1.Tensor.make(shape, { values: values }, dtype);
}
exports.zeros = zeros;
function fill(shape, value, dtype) {
    if (dtype === void 0) { dtype = 'float32'; }
    var values = util_1.getTypedArrayFromDType(dtype, util_1.sizeFromShape(shape));
    values.fill(value);
    return tensor_1.Tensor.make(shape, { values: values }, dtype);
}
exports.fill = fill;
function onesLike_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'onesLike');
    return ones($x.shape, $x.dtype);
}
function zerosLike_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'zerosLike');
    return zeros($x.shape, $x.dtype);
}
function linspace(start, stop, num) {
    if (num === 0) {
        throw new Error('Cannot request zero samples');
    }
    var step = (stop - start) / (num - 1);
    var values = util_1.makeZerosTypedArray(num, 'float32');
    values[0] = start;
    for (var i = 1; i < values.length; i++) {
        values[i] = values[i - 1] + step;
    }
    return tensor1d(values, 'float32');
}
exports.linspace = linspace;
function range(start, stop, step, dtype) {
    if (step === void 0) { step = 1; }
    if (dtype === void 0) { dtype = 'float32'; }
    if (step === 0) {
        throw new Error('Cannot have a step of zero');
    }
    var sameStartStop = start === stop;
    var increasingRangeNegativeStep = start < stop && step < 0;
    var decreasingRangePositiveStep = stop < start && step > 1;
    if (sameStartStop || increasingRangeNegativeStep ||
        decreasingRangePositiveStep) {
        return zeros([0], dtype);
    }
    var numElements = Math.abs(Math.ceil((stop - start) / step));
    var values = util_1.makeZerosTypedArray(numElements, dtype);
    if (stop < start && step === 1) {
        step = -1;
    }
    values[0] = start;
    for (var i = 1; i < values.length; i++) {
        values[i] = values[i - 1] + step;
    }
    return tensor1d(values, dtype);
}
exports.range = range;
exports.onesLike = operation_1.op({ onesLike_: onesLike_ });
exports.zerosLike = operation_1.op({ zerosLike_: zerosLike_ });

},{"../environment":60,"../tensor":196,"../tensor_util_env":199,"../util":203,"./complex_ops":145,"./operation":162}],181:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var operation_1 = require("./operation");
function topk_(x, k, sorted) {
    if (k === void 0) { k = 1; }
    if (sorted === void 0) { sorted = true; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'topk');
    if ($x.rank === 0) {
        throw new Error('topk() expects the input to be of rank 1 or higher');
    }
    var lastDim = $x.shape[$x.shape.length - 1];
    if (k > lastDim) {
        throw new Error("'k' passed to topk() must be <= the last dimension (" + lastDim + ") " +
            ("but got " + k));
    }
    var _a = environment_1.ENV.engine.runKernel(function (b) { return b.topk($x, k, sorted); }, { $x: $x }), values = _a[0], indices = _a[1];
    return { values: values, indices: indices };
}
exports.topk = operation_1.op({ topk_: topk_ });

},{"../environment":60,"../tensor_util_env":199,"./operation":162}],182:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
function transpose_(x, perm) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'transpose');
    if (perm == null) {
        perm = $x.shape.map(function (s, i) { return i; }).reverse();
    }
    util.assert($x.rank === perm.length, "Error in transpose: rank of input " + $x.rank + " " +
        ("must match length of perm " + perm + "."));
    perm.forEach(function (axis) {
        util.assert(axis >= 0 && axis < $x.rank, "All entries in 'perm' must be between 0 and " + ($x.rank - 1) +
            (" but got " + perm));
    });
    if ($x.rank <= 1) {
        return $x.clone();
    }
    var der = function (dy) {
        var undoPerm = axis_util.getUndoAxesPermutation(perm);
        return { $x: function () { return dy.transpose(undoPerm); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.transpose($x, perm); }, { $x: $x }, der);
}
exports.transpose = operation_1.op({ transpose_: transpose_ });

},{"../environment":60,"../tensor_util_env":199,"../util":203,"./axis_util":140,"./operation":162}],183:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var tensor_util_env_1 = require("../tensor_util_env");
var util = require("../util");
var operation_1 = require("./operation");
var tensor_ops_1 = require("./tensor_ops");
function neg_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'neg');
    var grad = function (dy) {
        return { $x: function () { return dy.neg(); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.neg($x); }, { $x: $x }, grad);
}
function ceil_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'ceil');
    var grad = function (dy) {
        return { $x: function () { return tensor_ops_1.zerosLike(dy); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.ceil($x); }, { $x: $x }, grad);
}
function floor_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'floor');
    var grad = function (dy) {
        return { $x: function () { return tensor_ops_1.zerosLike(dy); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.floor($x); }, { $x: $x }, grad);
}
function sign_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'sign');
    var grad = function (dy) {
        return { $x: function () { return tensor_ops_1.zerosLike(dy); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.sign($x); }, { $x: $x }, grad);
}
function round_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'round');
    var grad = function (dy) {
        return { $x: function () { return tensor_ops_1.zerosLike(dy); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.round($x); }, { $x: $x }, grad);
}
function exp_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'exp');
    var bck = function (dy, saved) {
        var y = saved[0];
        return { $x: function () { return dy.mulStrict(y); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.exp($x)); }, { $x: $x }, bck);
}
function expm1_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'expm1');
    var grad = function (dy) {
        return { $x: function () { return dy.mulStrict($x.exp()); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.expm1($x); }, { $x: $x }, grad);
}
function log_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'log');
    var grad = function (dy) {
        return { $x: function () { return dy.divStrict($x.toFloat()); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.log($x); }, { $x: $x }, grad);
}
function log1p_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'log1p');
    var grad = function (dy) {
        return { $x: function () { return dy.divStrict($x.add(tensor_ops_1.scalar(1))); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.log1p($x); }, { $x: $x }, grad);
}
function sqrt_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'sqrt');
    var grad = function (dy) {
        return { $x: function () { return dy.divStrict($x.toFloat().sqrt().mul(tensor_ops_1.scalar(2))); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.sqrt($x); }, { $x: $x }, grad);
}
function rsqrt_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'rsqrt');
    var grad = function (dy) {
        return { $x: function () { return dy.divStrict($x.pow(tensor_ops_1.scalar(1.5)).mul(tensor_ops_1.scalar(2))).neg(); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.rsqrt($x); }, { $x: $x }, grad);
}
function square_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'square');
    var grad = function (dy) {
        return { $x: function () { return dy.mulStrict($x.toFloat().mul(tensor_ops_1.scalar(2))); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.square($x); }, { $x: $x }, grad);
}
function reciprocal_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'reciprocal');
    var grad = function (dy) {
        return { $x: function () { return dy.divStrict($x.square().neg()); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.reciprocal($x); }, { $x: $x }, grad);
}
function abs_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'abs');
    var grad = function (dy) {
        return { $x: function () { return dy.mulStrict($x.toFloat().step(-1)); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.abs($x); }, { $x: $x }, grad);
}
function clipByValue_(x, clipValueMin, clipValueMax) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'clipByValue');
    util.assert((clipValueMin <= clipValueMax), "Error in clip: min (" + clipValueMin + ") must be " +
        ("less than or equal to max (" + clipValueMax + ")."));
    var grad = function (dy) {
        return {
            $x: function () { return dy.where($x.greaterEqual(tensor_ops_1.scalar(clipValueMin))
                .logicalAnd($x.lessEqual(tensor_ops_1.scalar(clipValueMax))), tensor_ops_1.zerosLike(dy)); },
        };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.clip($x, clipValueMin, clipValueMax); }, { $x: $x }, grad);
}
function sigmoid_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'sigmoid');
    var grad = function (dy, saved) {
        var y = saved[0];
        return { $x: function () { return dy.mulStrict(y.mul(tensor_ops_1.scalar(1).sub(y))); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.sigmoid($x)); }, { $x: $x }, grad);
}
function logSigmoid_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'logSigmoid');
    var grad = function (dy) {
        return { $x: function () { return dy.mulStrict($x.neg().sigmoid()); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.softplus($x.neg()).neg(); }, { $x: $x }, grad);
}
function softplus_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'softplus');
    var grad = function (dy) {
        return { $x: function () { return dy.mulStrict($x.sigmoid()); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.softplus($x); }, { $x: $x }, grad);
}
function sin_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'sin');
    var grad = function (dy) {
        return { $x: function () { return $x.toFloat().cos().mulStrict(dy); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.sin($x); }, { $x: $x }, grad);
}
function cos_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'cos');
    var grad = function (dy) {
        return { $x: function () { return $x.toFloat().sin().neg().mulStrict(dy); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.cos($x); }, { $x: $x }, grad);
}
function tan_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'tan');
    var grad = function (dy) {
        return { $x: function () { return dy.divStrict($x.cos().square()); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.tan($x); }, { $x: $x }, grad);
}
function asin_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'asin');
    var grad = function (dy) {
        return {
            $x: function () { return dy.divStrict(tensor_ops_1.scalar(1).sub($x.toFloat().square()).sqrt()); }
        };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.asin($x); }, { $x: $x }, grad);
}
function acos_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'acos');
    var grad = function (dy) {
        return {
            $x: function () {
                return dy.divStrict(tensor_ops_1.scalar(1).sub($x.toFloat().square()).sqrt()).neg();
            }
        };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.acos($x); }, { $x: $x }, grad);
}
function atan_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'atan');
    var grad = function (dy) {
        return { $x: function () { return dy.divStrict(tensor_ops_1.scalar(1).add($x.toFloat().square())); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.atan($x); }, { $x: $x }, grad);
}
function sinh_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'sinh');
    var grad = function (dy) {
        return { $x: function () { return $x.toFloat().cosh().mulStrict(dy); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.sinh($x); }, { $x: $x }, grad);
}
function cosh_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'cosh');
    var grad = function (dy) {
        return { $x: function () { return $x.toFloat().sinh().mulStrict(dy); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.cosh($x); }, { $x: $x }, grad);
}
function tanh_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'tanh');
    var grad = function (dy, saved) {
        var y = saved[0];
        return { $x: function () { return tensor_ops_1.scalar(1).sub(y.square()).mulStrict(dy); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.tanh($x)); }, { $x: $x }, grad);
}
function asinh_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'asinh');
    var grad = function (dy) {
        return {
            $x: function () { return dy.divStrict(tensor_ops_1.scalar(1).add($x.toFloat().square()).sqrt()); }
        };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.asinh($x); }, { $x: $x }, grad);
}
function acosh_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'acosh');
    var grad = function (dy) {
        return {
            $x: function () { return dy.divStrict($x.toFloat().square().sub(tensor_ops_1.scalar(1)).sqrt()); }
        };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.acosh($x); }, { $x: $x }, grad);
}
function atanh_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'atanh');
    var grad = function (dy) {
        return { $x: function () { return dy.divStrict(tensor_ops_1.scalar(1).sub($x.toFloat().square())); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.atanh($x); }, { $x: $x }, grad);
}
function erf_(x) {
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'erf');
    util.assert($x.dtype === 'int32' || $x.dtype === 'float32', 'Input dtype must be `int32` or `float32`.');
    if ($x.dtype === 'int32') {
        $x = $x.toFloat();
    }
    var grad = function (dy) {
        return {
            $x: function () { return dy.mulStrict(tensor_ops_1.scalar(2 / Math.sqrt(Math.PI)).mul($x.square().neg().exp())); }
        };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.erf($x); }, { $x: $x }, grad);
}
function step_(x, alpha) {
    if (alpha === void 0) { alpha = 0.0; }
    var $x = tensor_util_env_1.convertToTensor(x, 'x', 'step');
    var grad = function (dy) {
        return { $x: function () { return tensor_ops_1.zerosLike(dy); } };
    };
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.step($x, alpha); }, { $x: $x }, grad);
}
exports.abs = operation_1.op({ abs_: abs_ });
exports.acos = operation_1.op({ acos_: acos_ });
exports.acosh = operation_1.op({ acosh_: acosh_ });
exports.asin = operation_1.op({ asin_: asin_ });
exports.asinh = operation_1.op({ asinh_: asinh_ });
exports.atan = operation_1.op({ atan_: atan_ });
exports.atanh = operation_1.op({ atanh_: atanh_ });
exports.ceil = operation_1.op({ ceil_: ceil_ });
exports.clipByValue = operation_1.op({ clipByValue_: clipByValue_ });
exports.cos = operation_1.op({ cos_: cos_ });
exports.cosh = operation_1.op({ cosh_: cosh_ });
exports.erf = operation_1.op({ erf_: erf_ });
exports.exp = operation_1.op({ exp_: exp_ });
exports.expm1 = operation_1.op({ expm1_: expm1_ });
exports.floor = operation_1.op({ floor_: floor_ });
exports.log = operation_1.op({ log_: log_ });
exports.log1p = operation_1.op({ log1p_: log1p_ });
exports.logSigmoid = operation_1.op({ logSigmoid_: logSigmoid_ });
exports.neg = operation_1.op({ neg_: neg_ });
exports.reciprocal = operation_1.op({ reciprocal_: reciprocal_ });
exports.round = operation_1.op({ round_: round_ });
exports.rsqrt = operation_1.op({ rsqrt_: rsqrt_ });
exports.sigmoid = operation_1.op({ sigmoid_: sigmoid_ });
exports.sign = operation_1.op({ sign_: sign_ });
exports.sin = operation_1.op({ sin_: sin_ });
exports.sinh = operation_1.op({ sinh_: sinh_ });
exports.softplus = operation_1.op({ softplus_: softplus_ });
exports.sqrt = operation_1.op({ sqrt_: sqrt_ });
exports.square = operation_1.op({ square_: square_ });
exports.step = operation_1.op({ step_: step_ });
exports.tan = operation_1.op({ tan_: tan_ });
exports.tanh = operation_1.op({ tanh_: tanh_ });

},{"../environment":60,"../tensor_util_env":199,"../util":203,"./operation":162,"./tensor_ops":180}],184:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var AdadeltaOptimizer = (function (_super) {
    __extends(AdadeltaOptimizer, _super);
    function AdadeltaOptimizer(learningRate, rho, epsilon) {
        if (epsilon === void 0) { epsilon = null; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.rho = rho;
        _this.epsilon = epsilon;
        _this.accumulatedGrads = {};
        _this.accumulatedUpdates = {};
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.rhoScalar = globals_1.keep(ops_1.scalar(rho));
        _this.oneMinusRho = globals_1.keep(ops_1.scalar(1 - rho));
        if (epsilon === null) {
            epsilon = environment_1.ENV.get('EPSILON');
        }
        _this.epsilonScalar = globals_1.keep(ops_1.scalar(epsilon));
        return _this;
    }
    AdadeltaOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulatedGrads[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulatedGrads[variableName] =
                        ops_1.zerosLike(value).variable(trainable_1);
                });
            }
            if (this_1.accumulatedUpdates[variableName] == null) {
                var trainable_2 = false;
                globals_1.tidy(function () {
                    _this.accumulatedUpdates[variableName] =
                        ops_1.zerosLike(value).variable(trainable_2);
                });
            }
            var gradient = variableGradients[variableName];
            var accumulatedGrad = this_1.accumulatedGrads[variableName];
            var accumulatedUpdate = this_1.accumulatedUpdates[variableName];
            globals_1.tidy(function () {
                var newAccumulatedGrad = _this.rhoScalar.mul(accumulatedGrad)
                    .add(_this.oneMinusRho.mul(gradient.square()));
                var updates = accumulatedUpdate.add(_this.epsilonScalar)
                    .sqrt()
                    .div(accumulatedGrad.add(_this.epsilonScalar).sqrt())
                    .mul(gradient);
                var newAccumulatedUpdate = _this.rhoScalar.mul(accumulatedUpdate)
                    .add(_this.oneMinusRho.mul(updates.square()));
                _this.accumulatedGrads[variableName].assign(newAccumulatedGrad);
                _this.accumulatedUpdates[variableName].assign(newAccumulatedUpdate);
                var newValue = _this.c.mul(updates).add(value);
                value.assign(newValue);
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    AdadeltaOptimizer.prototype.dispose = function () {
        var _this = this;
        this.c.dispose();
        this.epsilonScalar.dispose();
        this.rhoScalar.dispose();
        this.oneMinusRho.dispose();
        if (this.accumulatedUpdates != null) {
            Object.keys(this.accumulatedUpdates)
                .forEach(function (name) { return _this.accumulatedUpdates[name].dispose(); });
            Object.keys(this.accumulatedGrads)
                .forEach(function (name) { return _this.accumulatedGrads[name].dispose(); });
        }
    };
    AdadeltaOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            rho: this.rho,
            epsilon: this.epsilon
        };
    };
    AdadeltaOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.rho, config.epsilon);
    };
    AdadeltaOptimizer.className = 'AdadeltaOptimizer';
    return AdadeltaOptimizer;
}(optimizer_1.Optimizer));
exports.AdadeltaOptimizer = AdadeltaOptimizer;
serialization_1.registerClass(AdadeltaOptimizer);

},{"../environment":60,"../globals":62,"../ops/ops":163,"../serialization":194,"./optimizer":189}],185:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var AdagradOptimizer = (function (_super) {
    __extends(AdagradOptimizer, _super);
    function AdagradOptimizer(learningRate, initialAccumulatorValue) {
        if (initialAccumulatorValue === void 0) { initialAccumulatorValue = 0.1; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.initialAccumulatorValue = initialAccumulatorValue;
        _this.accumulatedGrads = {};
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.epsilon = globals_1.keep(ops_1.scalar(environment_1.ENV.get('EPSILON')));
        return _this;
    }
    AdagradOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulatedGrads[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulatedGrads[variableName] =
                        ops_1.fill(value.shape, _this.initialAccumulatorValue)
                            .variable(trainable_1);
                });
            }
            var gradient = variableGradients[variableName];
            var accumulatedGrad = this_1.accumulatedGrads[variableName];
            globals_1.tidy(function () {
                var newAccumulatedGrad = accumulatedGrad.add(gradient.square());
                _this.accumulatedGrads[variableName].assign(newAccumulatedGrad);
                var newValue = _this.c
                    .mul(gradient.div(newAccumulatedGrad.add(_this.epsilon).sqrt()))
                    .add(value);
                value.assign(newValue);
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    AdagradOptimizer.prototype.dispose = function () {
        var _this = this;
        this.epsilon.dispose();
        this.c.dispose();
        if (this.accumulatedGrads != null) {
            Object.keys(this.accumulatedGrads)
                .forEach(function (name) { return _this.accumulatedGrads[name].dispose(); });
        }
    };
    AdagradOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            initialAccumulatorValue: this.initialAccumulatorValue,
        };
    };
    AdagradOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.initialAccumulatorValue);
    };
    AdagradOptimizer.className = 'AdagradOptimizer';
    return AdagradOptimizer;
}(optimizer_1.Optimizer));
exports.AdagradOptimizer = AdagradOptimizer;
serialization_1.registerClass(AdagradOptimizer);

},{"../environment":60,"../globals":62,"../ops/ops":163,"../serialization":194,"./optimizer":189}],186:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var AdamOptimizer = (function (_super) {
    __extends(AdamOptimizer, _super);
    function AdamOptimizer(learningRate, beta1, beta2, epsilon) {
        if (epsilon === void 0) { epsilon = null; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.epsilon = epsilon;
        _this.accumulatedFirstMoment = {};
        _this.accumulatedSecondMoment = {};
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.beta1Scalar = globals_1.keep(ops_1.scalar(beta1));
        _this.beta2Scalar = globals_1.keep(ops_1.scalar(beta2));
        globals_1.tidy(function () {
            _this.accBeta1 = ops_1.scalar(beta1).variable();
            _this.accBeta2 = ops_1.scalar(beta2).variable();
        });
        _this.oneMinusBeta1 = globals_1.keep(ops_1.scalar(1 - beta1));
        _this.oneMinusBeta2 = globals_1.keep(ops_1.scalar(1 - beta2));
        _this.one = globals_1.keep(ops_1.scalar(1));
        if (epsilon === null) {
            epsilon = environment_1.ENV.get('EPSILON');
        }
        _this.epsScalar = globals_1.keep(ops_1.scalar(epsilon));
        return _this;
    }
    AdamOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        globals_1.tidy(function () {
            var oneMinusAccBeta1 = _this.one.sub(_this.accBeta1);
            var oneMinusAccBeta2 = _this.one.sub(_this.accBeta2);
            for (var variableName in variableGradients) {
                var value = environment_1.ENV.engine.registeredVariables[variableName];
                if (_this.accumulatedFirstMoment[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedFirstMoment[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                if (_this.accumulatedSecondMoment[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedSecondMoment[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                var gradient = variableGradients[variableName];
                var firstMoment = _this.accumulatedFirstMoment[variableName];
                var secondMoment = _this.accumulatedSecondMoment[variableName];
                var newFirstMoment = _this.beta1Scalar.mul(firstMoment)
                    .add(_this.oneMinusBeta1.mul(gradient));
                var newSecondMoment = _this.beta2Scalar.mul(secondMoment)
                    .add(_this.oneMinusBeta2.mul(gradient.square()));
                var biasCorrectedFirstMoment = newFirstMoment.div(oneMinusAccBeta1);
                var biasCorrectedSecondMoment = newSecondMoment.div(oneMinusAccBeta2);
                _this.accumulatedFirstMoment[variableName].assign(newFirstMoment);
                _this.accumulatedSecondMoment[variableName].assign(newSecondMoment);
                var newValue = _this.c
                    .mul(biasCorrectedFirstMoment.div(_this.epsScalar.add(biasCorrectedSecondMoment.sqrt())))
                    .add(value);
                value.assign(newValue);
            }
            _this.accBeta1.assign(_this.accBeta1.mul(_this.beta1Scalar));
            _this.accBeta2.assign(_this.accBeta2.mul(_this.beta2Scalar));
        });
    };
    AdamOptimizer.prototype.dispose = function () {
        var _this = this;
        this.c.dispose();
        this.epsScalar.dispose();
        this.beta1Scalar.dispose();
        this.beta2Scalar.dispose();
        this.accBeta1.dispose();
        this.accBeta2.dispose();
        this.oneMinusBeta1.dispose();
        this.oneMinusBeta2.dispose();
        this.one.dispose();
        if (this.accumulatedFirstMoment != null) {
            Object.keys(this.accumulatedFirstMoment)
                .forEach(function (name) { return _this.accumulatedFirstMoment[name].dispose(); });
        }
        if (this.accumulatedSecondMoment != null) {
            Object.keys(this.accumulatedSecondMoment)
                .forEach(function (name) { return _this.accumulatedSecondMoment[name].dispose(); });
        }
    };
    AdamOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            beta1: this.beta1,
            beta2: this.beta2,
            epsilon: this.epsilon,
        };
    };
    AdamOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.beta1, config.beta2, config.epsilon);
    };
    AdamOptimizer.className = 'AdamOptimizer';
    return AdamOptimizer;
}(optimizer_1.Optimizer));
exports.AdamOptimizer = AdamOptimizer;
serialization_1.registerClass(AdamOptimizer);

},{"../environment":60,"../globals":62,"../ops/ops":163,"../serialization":194,"./optimizer":189}],187:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var AdamaxOptimizer = (function (_super) {
    __extends(AdamaxOptimizer, _super);
    function AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay) {
        if (epsilon === void 0) { epsilon = null; }
        if (decay === void 0) { decay = 0.0; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.epsilon = epsilon;
        _this.decay = decay;
        _this.accumulatedFirstMoment = {};
        _this.accumulatedWeightedInfNorm = {};
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.beta1Scalar = globals_1.keep(ops_1.scalar(beta1));
        _this.beta2Scalar = globals_1.keep(ops_1.scalar(beta2));
        _this.decayScalar = globals_1.keep(ops_1.scalar(decay));
        globals_1.tidy(function () {
            _this.iteration = ops_1.scalar(0).variable();
            _this.accBeta1 = ops_1.scalar(beta1).variable();
        });
        _this.oneMinusBeta1 = globals_1.keep(ops_1.scalar(1 - beta1));
        _this.one = globals_1.keep(ops_1.scalar(1));
        if (epsilon === null) {
            epsilon = environment_1.ENV.get('EPSILON');
        }
        _this.epsScalar = globals_1.keep(ops_1.scalar(epsilon));
        return _this;
    }
    AdamaxOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        globals_1.tidy(function () {
            var oneMinusAccBeta1 = _this.one.sub(_this.accBeta1);
            var lr = _this.c.div(_this.one.add(_this.decayScalar.mul(_this.iteration)));
            for (var variableName in variableGradients) {
                var value = environment_1.ENV.engine.registeredVariables[variableName];
                if (_this.accumulatedFirstMoment[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedFirstMoment[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                if (_this.accumulatedWeightedInfNorm[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedWeightedInfNorm[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                var gradient = variableGradients[variableName];
                var firstMoment = _this.accumulatedFirstMoment[variableName];
                var weightedInfNorm = _this.accumulatedWeightedInfNorm[variableName];
                var newFirstMoment = _this.beta1Scalar.mul(firstMoment)
                    .add(_this.oneMinusBeta1.mul(gradient));
                var ut0 = _this.beta2Scalar.mul(weightedInfNorm);
                var ut1 = gradient.abs();
                var newWeightedInfNorm = ut0.maximum(ut1);
                _this.accumulatedFirstMoment[variableName].assign(newFirstMoment);
                _this.accumulatedWeightedInfNorm[variableName].assign(newWeightedInfNorm);
                var newValue = lr.div(oneMinusAccBeta1)
                    .mul(newFirstMoment.div(_this.epsScalar.add(newWeightedInfNorm)))
                    .add(value);
                value.assign(newValue);
            }
            _this.iteration.assign(_this.iteration.add(_this.one));
            _this.accBeta1.assign(_this.accBeta1.mul(_this.beta1Scalar));
        });
    };
    AdamaxOptimizer.prototype.dispose = function () {
        var _this = this;
        this.c.dispose();
        this.epsScalar.dispose();
        this.accBeta1.dispose();
        this.beta1Scalar.dispose();
        this.beta2Scalar.dispose();
        this.oneMinusBeta1.dispose();
        this.decayScalar.dispose();
        this.iteration.dispose();
        this.one.dispose();
        if (this.accumulatedFirstMoment != null) {
            Object.keys(this.accumulatedFirstMoment)
                .forEach(function (name) { return _this.accumulatedFirstMoment[name].dispose(); });
        }
        if (this.accumulatedWeightedInfNorm != null) {
            Object.keys(this.accumulatedWeightedInfNorm)
                .forEach(function (name) { return _this.accumulatedWeightedInfNorm[name].dispose(); });
        }
    };
    AdamaxOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            beta1: this.beta1,
            beta2: this.beta2,
            epsilon: this.epsilon,
            decay: this.decay
        };
    };
    AdamaxOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.beta1, config.beta2, config.epsilon, config.decay);
    };
    AdamaxOptimizer.className = 'AdamaxOptimizer';
    return AdamaxOptimizer;
}(optimizer_1.Optimizer));
exports.AdamaxOptimizer = AdamaxOptimizer;
serialization_1.registerClass(AdamaxOptimizer);

},{"../environment":60,"../globals":62,"../ops/ops":163,"../serialization":194,"./optimizer":189}],188:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var sgd_optimizer_1 = require("./sgd_optimizer");
var MomentumOptimizer = (function (_super) {
    __extends(MomentumOptimizer, _super);
    function MomentumOptimizer(learningRate, momentum, useNesterov) {
        if (useNesterov === void 0) { useNesterov = false; }
        var _this = _super.call(this, learningRate) || this;
        _this.learningRate = learningRate;
        _this.momentum = momentum;
        _this.useNesterov = useNesterov;
        _this.m = ops_1.scalar(_this.momentum);
        _this.accumulations = {};
        return _this;
    }
    MomentumOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulations[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulations[variableName] =
                        ops_1.zerosLike(value).variable(trainable_1);
                });
            }
            var accumulation = this_1.accumulations[variableName];
            var gradient = variableGradients[variableName];
            globals_1.tidy(function () {
                var newValue;
                var newAccumulation = _this.m.mul(accumulation).add(gradient);
                if (_this.useNesterov) {
                    newValue =
                        _this.c.mul(gradient.add(newAccumulation.mul(_this.m))).add(value);
                }
                else {
                    newValue = _this.c.mul(newAccumulation).add(value);
                }
                _this.accumulations[variableName].assign(newAccumulation);
                value.assign(newValue);
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    MomentumOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.m.dispose();
        if (this.accumulations != null) {
            for (var variableName in this.accumulations) {
                this.accumulations[variableName].dispose();
            }
        }
    };
    MomentumOptimizer.prototype.setMomentum = function (momentum) {
        this.momentum = momentum;
    };
    MomentumOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            momentum: this.momentum,
            useNesterov: this.useNesterov
        };
    };
    MomentumOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.momentum, config.useNesterov);
    };
    MomentumOptimizer.className = 'MomentumOptimizer';
    return MomentumOptimizer;
}(sgd_optimizer_1.SGDOptimizer));
exports.MomentumOptimizer = MomentumOptimizer;
serialization_1.registerClass(MomentumOptimizer);

},{"../environment":60,"../globals":62,"../ops/ops":163,"../serialization":194,"./sgd_optimizer":192}],189:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../globals");
var serialization_1 = require("../serialization");
var Optimizer = (function (_super) {
    __extends(Optimizer, _super);
    function Optimizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Optimizer.prototype.minimize = function (f, returnCost, varList) {
        if (returnCost === void 0) { returnCost = false; }
        var _a = this.computeGradients(f, varList), value = _a.value, grads = _a.grads;
        this.applyGradients(grads);
        var varNames = Object.keys(grads);
        varNames.forEach(function (varName) { return grads[varName].dispose(); });
        if (returnCost) {
            return value;
        }
        else {
            value.dispose();
            return null;
        }
    };
    Optimizer.prototype.computeGradients = function (f, varList) {
        return globals_1.variableGrads(f, varList);
    };
    return Optimizer;
}(serialization_1.Serializable));
exports.Optimizer = Optimizer;

},{"../globals":62,"../serialization":194}],190:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var adadelta_optimizer_1 = require("./adadelta_optimizer");
var adagrad_optimizer_1 = require("./adagrad_optimizer");
var adam_optimizer_1 = require("./adam_optimizer");
var adamax_optimizer_1 = require("./adamax_optimizer");
var momentum_optimizer_1 = require("./momentum_optimizer");
var rmsprop_optimizer_1 = require("./rmsprop_optimizer");
var sgd_optimizer_1 = require("./sgd_optimizer");
var OptimizerConstructors = (function () {
    function OptimizerConstructors() {
    }
    OptimizerConstructors.sgd = function (learningRate) {
        return new sgd_optimizer_1.SGDOptimizer(learningRate);
    };
    OptimizerConstructors.momentum = function (learningRate, momentum, useNesterov) {
        if (useNesterov === void 0) { useNesterov = false; }
        return new momentum_optimizer_1.MomentumOptimizer(learningRate, momentum, useNesterov);
    };
    OptimizerConstructors.rmsprop = function (learningRate, decay, momentum, epsilon, centered) {
        if (decay === void 0) { decay = .9; }
        if (momentum === void 0) { momentum = 0.0; }
        if (epsilon === void 0) { epsilon = null; }
        if (centered === void 0) { centered = false; }
        return new rmsprop_optimizer_1.RMSPropOptimizer(learningRate, decay, momentum, epsilon, centered);
    };
    OptimizerConstructors.adam = function (learningRate, beta1, beta2, epsilon) {
        if (learningRate === void 0) { learningRate = 0.001; }
        if (beta1 === void 0) { beta1 = 0.9; }
        if (beta2 === void 0) { beta2 = 0.999; }
        if (epsilon === void 0) { epsilon = null; }
        return new adam_optimizer_1.AdamOptimizer(learningRate, beta1, beta2, epsilon);
    };
    OptimizerConstructors.adadelta = function (learningRate, rho, epsilon) {
        if (learningRate === void 0) { learningRate = .001; }
        if (rho === void 0) { rho = .95; }
        if (epsilon === void 0) { epsilon = null; }
        return new adadelta_optimizer_1.AdadeltaOptimizer(learningRate, rho, epsilon);
    };
    OptimizerConstructors.adamax = function (learningRate, beta1, beta2, epsilon, decay) {
        if (learningRate === void 0) { learningRate = 0.002; }
        if (beta1 === void 0) { beta1 = 0.9; }
        if (beta2 === void 0) { beta2 = 0.999; }
        if (epsilon === void 0) { epsilon = null; }
        if (decay === void 0) { decay = 0.0; }
        return new adamax_optimizer_1.AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay);
    };
    OptimizerConstructors.adagrad = function (learningRate, initialAccumulatorValue) {
        if (initialAccumulatorValue === void 0) { initialAccumulatorValue = 0.1; }
        return new adagrad_optimizer_1.AdagradOptimizer(learningRate, initialAccumulatorValue);
    };
    return OptimizerConstructors;
}());
exports.OptimizerConstructors = OptimizerConstructors;

},{"./adadelta_optimizer":184,"./adagrad_optimizer":185,"./adam_optimizer":186,"./adamax_optimizer":187,"./momentum_optimizer":188,"./rmsprop_optimizer":191,"./sgd_optimizer":192}],191:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var RMSPropOptimizer = (function (_super) {
    __extends(RMSPropOptimizer, _super);
    function RMSPropOptimizer(learningRate, decay, momentum, epsilon, centered) {
        if (decay === void 0) { decay = 0.9; }
        if (momentum === void 0) { momentum = 0.0; }
        if (epsilon === void 0) { epsilon = null; }
        if (centered === void 0) { centered = false; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.decay = decay;
        _this.momentum = momentum;
        _this.epsilon = epsilon;
        _this.accumulatedMeanSquares = {};
        _this.accumulatedMeanGrads = {};
        _this.accumulatedMoments = {};
        _this.c = globals_1.keep(ops_1.scalar(learningRate));
        _this.decayScalar = globals_1.keep(ops_1.scalar(decay));
        _this.momentumScalar = globals_1.keep(ops_1.scalar(momentum));
        _this.oneMinusDecay = globals_1.keep(ops_1.scalar(1 - decay));
        _this.centered = centered;
        if (epsilon === null) {
            epsilon = environment_1.ENV.get('EPSILON');
        }
        _this.epsilonScalar = globals_1.keep(ops_1.scalar(epsilon));
        return _this;
    }
    RMSPropOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulatedMeanSquares[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulatedMeanSquares[variableName] =
                        ops_1.zerosLike(value).variable(trainable_1);
                });
            }
            if (this_1.accumulatedMeanGrads[variableName] == null && this_1.centered) {
                var trainable_2 = false;
                globals_1.tidy(function () {
                    _this.accumulatedMeanGrads[variableName] =
                        ops_1.zerosLike(value).variable(trainable_2);
                });
            }
            if (this_1.accumulatedMoments[variableName] == null) {
                var trainable_3 = false;
                globals_1.tidy(function () {
                    _this.accumulatedMoments[variableName] =
                        ops_1.zerosLike(value).variable(trainable_3);
                });
            }
            var accumulatedMeanSquare = this_1.accumulatedMeanSquares[variableName];
            var accumulatedMeanGrad = this_1.accumulatedMeanGrads[variableName];
            var accumulatedMoments = this_1.accumulatedMoments[variableName];
            var gradient = variableGradients[variableName];
            globals_1.tidy(function () {
                var newAccumulatedMeanSquare = _this.decayScalar.mul(accumulatedMeanSquare)
                    .add(_this.oneMinusDecay.mul(gradient.square()));
                if (_this.centered) {
                    var newAccumulatedMeanGrad = _this.decayScalar.mul(accumulatedMeanGrad)
                        .add(_this.oneMinusDecay.mul(gradient));
                    var newAccumulatedMoments = _this.momentumScalar.mul(accumulatedMoments)
                        .add(_this.c.mul(gradient).div(newAccumulatedMeanSquare
                        .sub(newAccumulatedMeanGrad.square().add(_this.epsilonScalar))
                        .sqrt()));
                    _this.accumulatedMeanSquares[variableName].assign(newAccumulatedMeanSquare);
                    _this.accumulatedMeanGrads[variableName].assign(newAccumulatedMeanGrad);
                    _this.accumulatedMoments[variableName].assign(newAccumulatedMoments);
                    var newValue = value.sub(newAccumulatedMoments);
                    value.assign(newValue);
                }
                else {
                    var newAccumulatedMeanSquare_1 = _this.decayScalar.mul(accumulatedMeanSquare)
                        .add(_this.oneMinusDecay.mul(gradient.square()));
                    var newAccumulatedMoments = _this.momentumScalar.mul(accumulatedMoments)
                        .add(_this.c.mul(gradient).div(newAccumulatedMeanSquare_1.add(_this.epsilonScalar).sqrt()));
                    _this.accumulatedMeanSquares[variableName].assign(newAccumulatedMeanSquare_1);
                    _this.accumulatedMoments[variableName].assign(newAccumulatedMoments);
                    var newValue = value.sub(newAccumulatedMoments);
                    value.assign(newValue);
                }
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    RMSPropOptimizer.prototype.dispose = function () {
        var _this = this;
        this.c.dispose();
        this.epsilonScalar.dispose();
        this.decayScalar.dispose();
        this.momentumScalar.dispose();
        this.oneMinusDecay.dispose();
        if (this.accumulatedMeanSquares != null) {
            Object.keys(this.accumulatedMeanSquares)
                .forEach(function (name) { return _this.accumulatedMeanSquares[name].dispose(); });
        }
        if (this.accumulatedMeanGrads != null && this.centered) {
            Object.keys(this.accumulatedMeanGrads)
                .forEach(function (name) { return _this.accumulatedMeanGrads[name].dispose(); });
        }
        if (this.accumulatedMoments != null) {
            Object.keys(this.accumulatedMoments)
                .forEach(function (name) { return _this.accumulatedMoments[name].dispose(); });
        }
    };
    RMSPropOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            decay: this.decay,
            momentum: this.momentum,
            epsilon: this.epsilon,
            centered: this.centered
        };
    };
    RMSPropOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.decay, config.momentum, config.epsilon, config.centered);
    };
    RMSPropOptimizer.className = 'RMSPropOptimizer';
    return RMSPropOptimizer;
}(optimizer_1.Optimizer));
exports.RMSPropOptimizer = RMSPropOptimizer;
serialization_1.registerClass(RMSPropOptimizer);

},{"../environment":60,"../globals":62,"../ops/ops":163,"../serialization":194,"./optimizer":189}],192:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var SGDOptimizer = (function (_super) {
    __extends(SGDOptimizer, _super);
    function SGDOptimizer(learningRate) {
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.setLearningRate(learningRate);
        return _this;
    }
    SGDOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var varNames = Object.keys(variableGradients);
        varNames.forEach(function (varName) {
            var gradient = variableGradients[varName];
            var value = environment_1.ENV.engine.registeredVariables[varName];
            globals_1.tidy(function () {
                var newValue = _this.c.mul(gradient).add(value);
                value.assign(newValue);
            });
        });
    };
    SGDOptimizer.prototype.setLearningRate = function (learningRate) {
        this.learningRate = learningRate;
        if (this.c != null) {
            this.c.dispose();
        }
        this.c = globals_1.keep(ops_1.scalar(-learningRate));
    };
    SGDOptimizer.prototype.dispose = function () {
        this.c.dispose();
    };
    SGDOptimizer.prototype.getConfig = function () {
        return { learningRate: this.learningRate };
    };
    SGDOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate);
    };
    SGDOptimizer.className = 'SGDOptimizer';
    return SGDOptimizer;
}(optimizer_1.Optimizer));
exports.SGDOptimizer = SGDOptimizer;
serialization_1.registerClass(SGDOptimizer);

},{"../environment":60,"../globals":62,"../ops/ops":163,"../serialization":194,"./optimizer":189}],193:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
var Profiler = (function () {
    function Profiler(backendTimer, logger) {
        this.backendTimer = backendTimer;
        this.logger = logger;
        if (logger == null) {
            this.logger = new Logger();
        }
    }
    Profiler.prototype.profileKernel = function (name, f) {
        var _this = this;
        var result;
        var holdResultWrapperFn = function () {
            result = f();
        };
        var timer = this.backendTimer.time(holdResultWrapperFn);
        var results = Array.isArray(result) ? result : [result];
        results.forEach(function (r) {
            var vals = r.dataSync();
            util.checkComputationForNaN(vals, r.dtype, name);
            timer.then(function (timing) {
                _this.logger.logKernelProfile(name, r, vals, timing.kernelMs);
            });
        });
        return result;
    };
    return Profiler;
}());
exports.Profiler = Profiler;
var Logger = (function () {
    function Logger() {
    }
    Logger.prototype.logKernelProfile = function (name, result, vals, timeMs) {
        var time = util.rightPad(timeMs + "ms", 9);
        var paddedName = util.rightPad(name, 25);
        var rank = result.rank;
        var size = result.size;
        var shape = util.rightPad(result.shape.toString(), 14);
        console.log("%c" + paddedName + "\t%c" + time + "\t%c" + rank + "D " + shape + "\t%c" + size, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange');
    };
    return Logger;
}());
exports.Logger = Logger;

},{"./util":203}],194:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var Serializable = (function () {
    function Serializable() {
    }
    Serializable.prototype.getClassName = function () {
        return this.constructor
            .className;
    };
    Serializable.fromConfig = function (cls, config) {
        return new cls(config);
    };
    return Serializable;
}());
exports.Serializable = Serializable;
var SerializationMap = (function () {
    function SerializationMap() {
        this.classNameMap = {};
    }
    SerializationMap.getMap = function () {
        if (SerializationMap.instance == null) {
            SerializationMap.instance = new SerializationMap();
        }
        return SerializationMap.instance;
    };
    SerializationMap.register = function (cls) {
        SerializationMap.getMap().classNameMap[cls.className] =
            [cls, cls.fromConfig];
    };
    return SerializationMap;
}());
exports.SerializationMap = SerializationMap;
function registerClass(cls) {
    util_1.assert(cls.className != null, "Class being registered does not have the static className property " +
        "defined.");
    util_1.assert(typeof cls.className === 'string', "className is required to be a string, but got type " +
        typeof cls.className);
    util_1.assert(cls.className.length > 0, "Class being registered has an empty-string as its className, which " +
        "is disallowed.");
    SerializationMap.register(cls);
}
exports.registerClass = registerClass;

},{"./util":203}],195:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("./tensor");
var util = require("./util");
function getFilteredNodesXToY(tape, xs, y) {
    var tensorsFromX = {};
    var nodesFromX = {};
    for (var i = 0; i < xs.length; i++) {
        tensorsFromX[xs[i].id] = true;
    }
    for (var i = 0; i < tape.length; i++) {
        var node = tape[i];
        var nodeInputs = node.inputs;
        for (var inputName in nodeInputs) {
            var input = nodeInputs[inputName];
            var anyInputFromX = false;
            for (var j = 0; j < xs.length; j++) {
                if (tensorsFromX[input.id]) {
                    node.outputs.forEach(function (output) { return tensorsFromX[output.id] = true; });
                    anyInputFromX = true;
                    nodesFromX[node.id] = true;
                    break;
                }
            }
            if (anyInputFromX) {
                break;
            }
        }
    }
    var tensorsLeadToY = {};
    tensorsLeadToY[y.id] = true;
    var nodesToY = {};
    for (var i = tape.length - 1; i >= 0; i--) {
        var node = tape[i];
        var nodeInputs = node.inputs;
        for (var j = 0; j < node.outputs.length; j++) {
            if (tensorsLeadToY[node.outputs[j].id]) {
                for (var inputName in nodeInputs) {
                    tensorsLeadToY[nodeInputs[inputName].id] = true;
                    nodesToY[node.id] = true;
                }
                break;
            }
        }
    }
    var filteredTape = [];
    for (var i = 0; i < tape.length; i++) {
        var node = tape[i];
        if (nodesFromX[node.id] && nodesToY[node.id]) {
            var prunedInputs = {};
            for (var inputName in node.inputs) {
                var nodeInput = node.inputs[inputName];
                if (tensorsFromX[nodeInput.id]) {
                    prunedInputs[inputName] = nodeInput;
                }
            }
            var prunedNode = Object.assign({}, node);
            prunedNode.inputs = prunedInputs;
            prunedNode.outputs = node.outputs;
            filteredTape.push(prunedNode);
        }
    }
    return filteredTape;
}
exports.getFilteredNodesXToY = getFilteredNodesXToY;
function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape) {
    var _loop_1 = function (i) {
        var node = filteredTape[i];
        var dys = [];
        node.outputs.forEach(function (o) {
            var gradTensor = tensorAccumulatedGradientMap[o.id];
            if (gradTensor != null) {
                dys.push(gradTensor);
            }
            else {
                var dy = tensor_1.Tensor.make(o.shape, { values: util.makeZerosTypedArray(o.size, o.dtype) }, o.dtype);
                dys.push(dy);
            }
        });
        if (node.gradient == null) {
            throw new Error("Cannot compute gradient: gradient function not found " +
                ("for " + node.name + "."));
        }
        var inputGradients = node.gradient(node.outputs.length === 1 ? dys[0] : dys);
        for (var inputName in node.inputs) {
            if (!(inputName in inputGradients)) {
                throw new Error("Cannot backprop through input " + inputName + ". " +
                    ("Available gradients found: " + Object.keys(inputGradients) + "."));
            }
            var dx = inputGradients[inputName]();
            var x = node.inputs[inputName];
            if (!util.arraysEqual(dx.shape, x.shape)) {
                throw new Error("Error in gradient for op " + node.name + ". The gradient of input " +
                    ("'" + inputName + "' has shape '" + dx.shape + "', which does not match ") +
                    ("the shape of the input '" + x.shape + "'"));
            }
            if (tensorAccumulatedGradientMap[x.id] == null) {
                tensorAccumulatedGradientMap[x.id] = dx;
            }
            else {
                var curGradient = tensorAccumulatedGradientMap[x.id];
                tensorAccumulatedGradientMap[x.id] = curGradient.add(dx);
                curGradient.dispose();
            }
        }
    };
    for (var i = filteredTape.length - 1; i >= 0; i--) {
        _loop_1(i);
    }
}
exports.backpropagateGradients = backpropagateGradients;

},{"./tensor":196,"./util":203}],196:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_format_1 = require("./tensor_format");
var util = require("./util");
var util_1 = require("./util");
var TensorBuffer = (function () {
    function TensorBuffer(shape, dtype, values) {
        this.dtype = dtype;
        this.shape = shape.slice();
        this.size = util.sizeFromShape(shape);
        if (values != null) {
            var n = values.length;
            util.assert(n === this.size, "Length of values '" + n + "' does not match the size " +
                ("inferred by the shape '" + this.size + "'."));
        }
        if (dtype === 'complex64') {
            throw new Error("complex64 dtype TensorBuffers are not supported. Please create " +
                "a TensorBuffer for the real and imaginary parts separately and " +
                "call tf.complex(real, imag).");
        }
        this.values = values ||
            util.getTypedArrayFromDType(dtype, util.sizeFromShape(this.shape));
        this.strides = util_1.computeStrides(shape);
    }
    TensorBuffer.prototype.set = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        if (locs.length === 0) {
            locs = [0];
        }
        util.assert(locs.length === this.rank, "The number of provided coordinates (" + locs.length + ") must " +
            ("match the rank (" + this.rank + ")"));
        var index = this.locToIndex(locs);
        this.values[index] = value;
    };
    TensorBuffer.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        if (locs.length === 0) {
            locs = [0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.values[index];
    };
    TensorBuffer.prototype.locToIndex = function (locs) {
        if (this.rank === 0) {
            return 0;
        }
        else if (this.rank === 1) {
            return locs[0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return index;
    };
    TensorBuffer.prototype.indexToLoc = function (index) {
        if (this.rank === 0) {
            return [];
        }
        else if (this.rank === 1) {
            return [index];
        }
        var locs = new Array(this.shape.length);
        for (var i = 0; i < locs.length - 1; ++i) {
            locs[i] = Math.floor(index / this.strides[i]);
            index -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index;
        return locs;
    };
    Object.defineProperty(TensorBuffer.prototype, "rank", {
        get: function () {
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    TensorBuffer.prototype.toTensor = function () {
        return Tensor.make(this.shape, { values: this.values }, this.dtype);
    };
    return TensorBuffer;
}());
exports.TensorBuffer = TensorBuffer;
var trackerFn = null;
var opHandler = null;
function setTensorTracker(fn) {
    trackerFn = fn;
}
exports.setTensorTracker = setTensorTracker;
function setOpHandler(handler) {
    opHandler = handler;
}
exports.setOpHandler = setOpHandler;
var Tensor = (function () {
    function Tensor(shape, dtype, values, dataId) {
        this.isDisposedInternal = false;
        this.shape = shape.slice();
        this.dtype = dtype || 'float32';
        this.size = util.sizeFromShape(shape);
        if (values != null) {
            util.assert(this.size === values.length, "Based on the provided shape, [" + shape + "], and dtype " +
                (this.dtype + ", the tensor should have ") +
                (this.size + " values but has " + values.length));
        }
        this.strides = util_1.computeStrides(shape);
        this.dataId = dataId != null ? dataId : {};
        this.id = Tensor.nextId++;
        this.rankType = (this.rank < 5 ? this.rank.toString() : 'higher');
        trackerFn().registerTensor(this);
        if (values != null) {
            trackerFn().write(this.dataId, values);
        }
    }
    Tensor.make = function (shape, data, dtype) {
        return new Tensor(shape, dtype, data.values, data.dataId);
    };
    Tensor.prototype.flatten = function () {
        this.throwIfDisposed();
        return this.as1D();
    };
    Tensor.prototype.asScalar = function () {
        this.throwIfDisposed();
        util.assert(this.size === 1, 'The array must have only 1 element.');
        return this.reshape([]);
    };
    Tensor.prototype.as1D = function () {
        this.throwIfDisposed();
        return this.reshape([this.size]);
    };
    Tensor.prototype.as2D = function (rows, columns) {
        this.throwIfDisposed();
        return this.reshape([rows, columns]);
    };
    Tensor.prototype.as3D = function (rows, columns, depth) {
        this.throwIfDisposed();
        return this.reshape([rows, columns, depth]);
    };
    Tensor.prototype.as4D = function (rows, columns, depth, depth2) {
        this.throwIfDisposed();
        return this.reshape([rows, columns, depth, depth2]);
    };
    Tensor.prototype.asType = function (dtype) {
        this.throwIfDisposed();
        return opHandler.cast(this, dtype);
    };
    Object.defineProperty(Tensor.prototype, "rank", {
        get: function () {
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    Tensor.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        util.assert(locs.length === this.rank, 'Number of coordinates in get() must match the rank of the tensor');
        util.assert(this.dtype !== 'complex64', 'Tensor.get() is not supported for complex64 tensors yet.');
        this.throwIfDisposed();
        if (locs.length === 0) {
            locs = [0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.dataSync()[index];
    };
    Tensor.prototype.buffer = function () {
        return opHandler.buffer(this.shape, this.dtype, this.dataSync());
    };
    Tensor.prototype.data = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.throwIfDisposed();
                return [2, trackerFn().read(this.dataId)];
            });
        });
    };
    Tensor.prototype.dataSync = function () {
        this.throwIfDisposed();
        return trackerFn().readSync(this.dataId);
    };
    Tensor.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        trackerFn().disposeTensor(this);
        this.isDisposedInternal = true;
    };
    Object.defineProperty(Tensor.prototype, "isDisposed", {
        get: function () {
            return this.isDisposedInternal;
        },
        enumerable: true,
        configurable: true
    });
    Tensor.prototype.throwIfDisposed = function () {
        if (this.isDisposed) {
            throw new Error("Tensor is disposed.");
        }
    };
    Tensor.prototype.toFloat = function () {
        return this.asType('float32');
    };
    Tensor.prototype.toInt = function () {
        return this.asType('int32');
    };
    Tensor.prototype.toBool = function () {
        return this.asType('bool');
    };
    Tensor.prototype.print = function (verbose) {
        if (verbose === void 0) { verbose = false; }
        return opHandler.print(this, verbose);
    };
    Tensor.prototype.reshape = function (newShape) {
        this.throwIfDisposed();
        return opHandler.reshape(this, newShape);
    };
    Tensor.prototype.reshapeAs = function (x) {
        this.throwIfDisposed();
        return this.reshape(x.shape);
    };
    Tensor.prototype.expandDims = function (axis) {
        if (axis === void 0) { axis = 0; }
        return opHandler.expandDims(this, axis);
    };
    Tensor.prototype.cumsum = function (axis, exclusive, reverse) {
        if (axis === void 0) { axis = 0; }
        if (exclusive === void 0) { exclusive = false; }
        if (reverse === void 0) { reverse = false; }
        return opHandler.cumsum(this, axis, exclusive, reverse);
    };
    Tensor.prototype.squeeze = function (axis) {
        this.throwIfDisposed();
        return opHandler.squeeze(this, axis);
    };
    Tensor.prototype.clone = function () {
        this.throwIfDisposed();
        return opHandler.clone(this);
    };
    Tensor.prototype.toString = function (verbose) {
        if (verbose === void 0) { verbose = false; }
        var vals = this.dataSync();
        return tensor_format_1.tensorToString(vals, this.shape, this.dtype, verbose);
    };
    Tensor.prototype.tile = function (reps) {
        this.throwIfDisposed();
        return opHandler.tile(this, reps);
    };
    Tensor.prototype.gather = function (indices, axis) {
        if (axis === void 0) { axis = 0; }
        this.throwIfDisposed();
        return opHandler.gather(this, indices, axis);
    };
    Tensor.prototype.matMul = function (b, transposeA, transposeB) {
        if (transposeA === void 0) { transposeA = false; }
        if (transposeB === void 0) { transposeB = false; }
        this.throwIfDisposed();
        return opHandler.matMul(this, b, transposeA, transposeB);
    };
    Tensor.prototype.dot = function (b) {
        this.throwIfDisposed();
        return opHandler.dot(this, b);
    };
    Tensor.prototype.norm = function (ord, axis, keepDims) {
        if (ord === void 0) { ord = 'euclidean'; }
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return opHandler.norm(this, ord, axis, keepDims);
    };
    Tensor.prototype.slice = function (begin, size) {
        this.throwIfDisposed();
        return opHandler.slice(this, begin, size);
    };
    Tensor.prototype.reverse = function (axis) {
        this.throwIfDisposed();
        return opHandler.reverse(this, axis);
    };
    Tensor.prototype.concat = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        this.throwIfDisposed();
        return opHandler.concat([this, x], axis);
    };
    Tensor.prototype.split = function (numOrSizeSplits, axis) {
        if (axis === void 0) { axis = 0; }
        this.throwIfDisposed();
        return opHandler.split(this, numOrSizeSplits, axis);
    };
    Tensor.prototype.stack = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        return opHandler.stack([this, x], axis);
    };
    Tensor.prototype.unstack = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        return opHandler.unstack(this, axis);
    };
    Tensor.prototype.pad = function (paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        return opHandler.pad(this, paddings, constantValue);
    };
    Tensor.prototype.batchNormalization = function (mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        this.throwIfDisposed();
        return opHandler.batchNormalization(this, mean, variance, varianceEpsilon, scale, offset);
    };
    Tensor.prototype.all = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return opHandler.all(this, axis, keepDims);
    };
    Tensor.prototype.any = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return opHandler.any(this, axis, keepDims);
    };
    Tensor.prototype.logSumExp = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return opHandler.logSumExp(this, axis, keepDims);
    };
    Tensor.prototype.sum = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return opHandler.sum(this, axis, keepDims);
    };
    Tensor.prototype.prod = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return opHandler.prod(this, axis, keepDims);
    };
    Tensor.prototype.mean = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return opHandler.mean(this, axis, keepDims);
    };
    Tensor.prototype.min = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return opHandler.min(this, axis, keepDims);
    };
    Tensor.prototype.max = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return opHandler.max(this, axis, keepDims);
    };
    Tensor.prototype.argMin = function (axis) {
        if (axis === void 0) { axis = null; }
        this.throwIfDisposed();
        return opHandler.argMin(this, axis);
    };
    Tensor.prototype.argMax = function (axis) {
        if (axis === void 0) { axis = null; }
        this.throwIfDisposed();
        return opHandler.argMax(this, axis);
    };
    Tensor.prototype.cast = function (dtype) {
        this.throwIfDisposed();
        return opHandler.cast(this, dtype);
    };
    Tensor.prototype.add = function (x) {
        this.throwIfDisposed();
        return opHandler.add(this, x);
    };
    Tensor.prototype.addStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.addStrict(this, x);
    };
    Tensor.prototype.atan2 = function (x) {
        this.throwIfDisposed();
        return opHandler.atan2(this, x);
    };
    Tensor.prototype.sub = function (x) {
        this.throwIfDisposed();
        return opHandler.sub(this, x);
    };
    Tensor.prototype.subStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.subStrict(this, x);
    };
    Tensor.prototype.pow = function (exp) {
        this.throwIfDisposed();
        return opHandler.pow(this, exp);
    };
    Tensor.prototype.powStrict = function (exp) {
        this.throwIfDisposed();
        return opHandler.powStrict(this, exp);
    };
    Tensor.prototype.mul = function (x) {
        this.throwIfDisposed();
        return opHandler.mul(this, x);
    };
    Tensor.prototype.mulStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.mulStrict(this, x);
    };
    Tensor.prototype.div = function (x) {
        this.throwIfDisposed();
        return opHandler.div(this, x);
    };
    Tensor.prototype.floorDiv = function (x) {
        this.throwIfDisposed();
        return opHandler.floorDiv(this, x);
    };
    Tensor.prototype.divStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.divStrict(this, x);
    };
    Tensor.prototype.minimum = function (x) {
        this.throwIfDisposed();
        return opHandler.minimum(this, x);
    };
    Tensor.prototype.minimumStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.minimumStrict(this, x);
    };
    Tensor.prototype.maximum = function (x) {
        this.throwIfDisposed();
        return opHandler.maximum(this, x);
    };
    Tensor.prototype.maximumStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.maximumStrict(this, x);
    };
    Tensor.prototype.mod = function (x) {
        this.throwIfDisposed();
        return opHandler.mod(this, x);
    };
    Tensor.prototype.modStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.modStrict(this, x);
    };
    Tensor.prototype.squaredDifference = function (x) {
        this.throwIfDisposed();
        return opHandler.squaredDifference(this, x);
    };
    Tensor.prototype.squaredDifferenceStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.squaredDifferenceStrict(this, x);
    };
    Tensor.prototype.transpose = function (perm) {
        this.throwIfDisposed();
        return opHandler.transpose(this, perm);
    };
    Tensor.prototype.notEqual = function (x) {
        this.throwIfDisposed();
        return opHandler.notEqual(this, x);
    };
    Tensor.prototype.notEqualStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.notEqualStrict(this, x);
    };
    Tensor.prototype.less = function (x) {
        this.throwIfDisposed();
        return opHandler.less(this, x);
    };
    Tensor.prototype.lessStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.lessStrict(this, x);
    };
    Tensor.prototype.equal = function (x) {
        this.throwIfDisposed();
        return opHandler.equal(this, x);
    };
    Tensor.prototype.equalStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.equalStrict(this, x);
    };
    Tensor.prototype.lessEqual = function (x) {
        this.throwIfDisposed();
        return opHandler.lessEqual(this, x);
    };
    Tensor.prototype.lessEqualStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.lessEqualStrict(this, x);
    };
    Tensor.prototype.greater = function (x) {
        this.throwIfDisposed();
        return opHandler.greater(this, x);
    };
    Tensor.prototype.greaterStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.greaterStrict(this, x);
    };
    Tensor.prototype.greaterEqual = function (x) {
        this.throwIfDisposed();
        return opHandler.greaterEqual(this, x);
    };
    Tensor.prototype.greaterEqualStrict = function (x) {
        this.throwIfDisposed();
        return opHandler.greaterEqualStrict(this, x);
    };
    Tensor.prototype.logicalAnd = function (x) {
        this.throwIfDisposed();
        return opHandler.logicalAnd(this, x);
    };
    Tensor.prototype.logicalOr = function (x) {
        this.throwIfDisposed();
        return opHandler.logicalOr(this, x);
    };
    Tensor.prototype.logicalNot = function () {
        this.throwIfDisposed();
        return opHandler.logicalNot(this);
    };
    Tensor.prototype.logicalXor = function (x) {
        this.throwIfDisposed();
        return opHandler.logicalXor(this, x);
    };
    Tensor.prototype.where = function (condition, x) {
        this.throwIfDisposed();
        return opHandler.where(condition, this, x);
    };
    Tensor.prototype.neg = function () {
        this.throwIfDisposed();
        return opHandler.neg(this);
    };
    Tensor.prototype.ceil = function () {
        this.throwIfDisposed();
        return opHandler.ceil(this);
    };
    Tensor.prototype.floor = function () {
        this.throwIfDisposed();
        return opHandler.floor(this);
    };
    Tensor.prototype.sign = function () {
        this.throwIfDisposed();
        return opHandler.sign(this);
    };
    Tensor.prototype.exp = function () {
        this.throwIfDisposed();
        return opHandler.exp(this);
    };
    Tensor.prototype.expm1 = function () {
        this.throwIfDisposed();
        return opHandler.expm1(this);
    };
    Tensor.prototype.log = function () {
        this.throwIfDisposed();
        return opHandler.log(this);
    };
    Tensor.prototype.log1p = function () {
        this.throwIfDisposed();
        return opHandler.log1p(this);
    };
    Tensor.prototype.sqrt = function () {
        this.throwIfDisposed();
        return opHandler.sqrt(this);
    };
    Tensor.prototype.rsqrt = function () {
        this.throwIfDisposed();
        return opHandler.rsqrt(this);
    };
    Tensor.prototype.square = function () {
        this.throwIfDisposed();
        return opHandler.square(this);
    };
    Tensor.prototype.reciprocal = function () {
        this.throwIfDisposed();
        return opHandler.reciprocal(this);
    };
    Tensor.prototype.abs = function () {
        this.throwIfDisposed();
        return opHandler.abs(this);
    };
    Tensor.prototype.clipByValue = function (min, max) {
        this.throwIfDisposed();
        return opHandler.clipByValue(this, min, max);
    };
    Tensor.prototype.relu = function () {
        this.throwIfDisposed();
        return opHandler.relu(this);
    };
    Tensor.prototype.elu = function () {
        this.throwIfDisposed();
        return opHandler.elu(this);
    };
    Tensor.prototype.selu = function () {
        this.throwIfDisposed();
        return opHandler.selu(this);
    };
    Tensor.prototype.leakyRelu = function (alpha) {
        if (alpha === void 0) { alpha = 0.2; }
        this.throwIfDisposed();
        return opHandler.leakyRelu(this, alpha);
    };
    Tensor.prototype.prelu = function (alpha) {
        this.throwIfDisposed();
        return opHandler.prelu(this, alpha);
    };
    Tensor.prototype.sigmoid = function () {
        this.throwIfDisposed();
        return opHandler.sigmoid(this);
    };
    Tensor.prototype.logSigmoid = function () {
        this.throwIfDisposed();
        return opHandler.logSigmoid(this);
    };
    Tensor.prototype.softplus = function () {
        this.throwIfDisposed();
        return opHandler.softplus(this);
    };
    Tensor.prototype.zerosLike = function () {
        this.throwIfDisposed();
        return opHandler.zerosLike(this);
    };
    Tensor.prototype.onesLike = function () {
        this.throwIfDisposed();
        return opHandler.onesLike(this);
    };
    Tensor.prototype.sin = function () {
        this.throwIfDisposed();
        return opHandler.sin(this);
    };
    Tensor.prototype.cos = function () {
        this.throwIfDisposed();
        return opHandler.cos(this);
    };
    Tensor.prototype.tan = function () {
        this.throwIfDisposed();
        return opHandler.tan(this);
    };
    Tensor.prototype.asin = function () {
        this.throwIfDisposed();
        return opHandler.asin(this);
    };
    Tensor.prototype.acos = function () {
        this.throwIfDisposed();
        return opHandler.acos(this);
    };
    Tensor.prototype.atan = function () {
        this.throwIfDisposed();
        return opHandler.atan(this);
    };
    Tensor.prototype.sinh = function () {
        this.throwIfDisposed();
        return opHandler.sinh(this);
    };
    Tensor.prototype.cosh = function () {
        this.throwIfDisposed();
        return opHandler.cosh(this);
    };
    Tensor.prototype.tanh = function () {
        this.throwIfDisposed();
        return opHandler.tanh(this);
    };
    Tensor.prototype.asinh = function () {
        this.throwIfDisposed();
        return opHandler.asinh(this);
    };
    Tensor.prototype.acosh = function () {
        this.throwIfDisposed();
        return opHandler.acosh(this);
    };
    Tensor.prototype.atanh = function () {
        this.throwIfDisposed();
        return opHandler.atanh(this);
    };
    Tensor.prototype.erf = function () {
        this.throwIfDisposed();
        return opHandler.erf(this);
    };
    Tensor.prototype.round = function () {
        this.throwIfDisposed();
        return opHandler.round(this);
    };
    Tensor.prototype.step = function (alpha) {
        if (alpha === void 0) { alpha = 0.0; }
        this.throwIfDisposed();
        return opHandler.step(this, alpha);
    };
    Tensor.prototype.softmax = function (dim) {
        if (dim === void 0) { dim = -1; }
        this.throwIfDisposed();
        return opHandler.softmax(this, dim);
    };
    Tensor.prototype.resizeBilinear = function (newShape2D, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        this.throwIfDisposed();
        return opHandler.image.resizeBilinear(this, newShape2D, alignCorners);
    };
    Tensor.prototype.resizeNearestNeighbor = function (newShape2D, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        this.throwIfDisposed();
        return opHandler.image.resizeNearestNeighbor(this, newShape2D, alignCorners);
    };
    Tensor.prototype.conv1d = function (filter, stride, pad, dataFormat, dilation, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NWC'; }
        if (dilation === void 0) { dilation = 1; }
        this.throwIfDisposed();
        return opHandler.conv1d(this, filter, stride, pad, dataFormat, dilation, dimRoundingMode);
    };
    Tensor.prototype.conv2d = function (filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NHWC'; }
        if (dilations === void 0) { dilations = [1, 1]; }
        this.throwIfDisposed();
        return opHandler.conv2d(this, filter, strides, pad, dataFormat, dilations, dimRoundingMode);
    };
    Tensor.prototype.conv2dTranspose = function (filter, outputShape, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return opHandler.conv2dTranspose(this, filter, outputShape, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.depthwiseConv2D = function (filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NHWC'; }
        if (dilations === void 0) { dilations = [1, 1]; }
        this.throwIfDisposed();
        return opHandler.depthwiseConv2d(this, filter, strides, pad, dataFormat, dilations, dimRoundingMode);
    };
    Tensor.prototype.separableConv2d = function (depthwiseFilter, pointwiseFilter, strides, pad, dilation, dataFormat) {
        if (dilation === void 0) { dilation = [1, 1]; }
        if (dataFormat === void 0) { dataFormat = 'NHWC'; }
        this.throwIfDisposed();
        return opHandler.separableConv2d(this, depthwiseFilter, pointwiseFilter, strides, pad, dilation, dataFormat);
    };
    Tensor.prototype.avgPool = function (filterSize, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return opHandler.avgPool(this, filterSize, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.maxPool = function (filterSize, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return opHandler.maxPool(this, filterSize, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.localResponseNormalization = function (radius, bias, alpha, beta) {
        if (radius === void 0) { radius = 5; }
        if (bias === void 0) { bias = 1; }
        if (alpha === void 0) { alpha = 1; }
        if (beta === void 0) { beta = 0.5; }
        return opHandler.localResponseNormalization(this, radius, bias, alpha, beta);
    };
    Tensor.prototype.variable = function (trainable, name, dtype) {
        if (trainable === void 0) { trainable = true; }
        this.throwIfDisposed();
        return Variable.variable(this, trainable, name, dtype);
    };
    Tensor.prototype.unsortedSegmentSum = function (segmentIds, numSegments) {
        this.throwIfDisposed();
        return opHandler.unsortedSegmentSum(this, segmentIds, numSegments);
    };
    Tensor.prototype.batchToSpaceND = function (blockShape, crops) {
        this.throwIfDisposed();
        return opHandler.batchToSpaceND(this, blockShape, crops);
    };
    Tensor.prototype.spaceToBatchND = function (blockShape, paddings) {
        this.throwIfDisposed();
        return opHandler.spaceToBatchND(this, blockShape, paddings);
    };
    Tensor.prototype.topk = function (k, sorted) {
        if (k === void 0) { k = 1; }
        if (sorted === void 0) { sorted = true; }
        this.throwIfDisposed();
        return opHandler.topk(this, k, sorted);
    };
    Tensor.prototype.stridedSlice = function (begin, end, strides, beginMask, endMask) {
        if (beginMask === void 0) { beginMask = 0; }
        if (endMask === void 0) { endMask = 0; }
        this.throwIfDisposed();
        return opHandler.stridedSlice(this, begin, end, strides, beginMask, endMask);
    };
    Tensor.prototype.depthToSpace = function (blockSize, dataFormat) {
        this.throwIfDisposed();
        return opHandler.depthToSpace(this, blockSize, dataFormat);
    };
    Tensor.prototype.fft = function () {
        this.throwIfDisposed();
        return opHandler.spectral.fft(this);
    };
    Tensor.nextId = 0;
    return Tensor;
}());
exports.Tensor = Tensor;
Object.defineProperty(Tensor, Symbol.hasInstance, {
    value: function (instance) {
        return !!instance && instance.shape != null && instance.dtype != null;
    }
});
var Variable = (function (_super) {
    __extends(Variable, _super);
    function Variable(initialValue, trainable, name) {
        if (trainable === void 0) { trainable = true; }
        var _this = _super.call(this, initialValue.shape, initialValue.dtype, null, initialValue.dataId) || this;
        _this.trainable = trainable;
        _this.name = name;
        if (_this.name == null) {
            _this.name = Variable.nextVarId.toString();
            Variable.nextVarId++;
        }
        try {
            trackerFn().registerVariable(_this);
        }
        catch (ex) {
            trackerFn().disposeTensor(_this);
            throw ex;
        }
        return _this;
    }
    Variable.variable = function (initialValue, trainable, name, dtype) {
        if (trainable === void 0) { trainable = true; }
        if (dtype != null && dtype !== initialValue.dtype) {
            initialValue = initialValue.asType(dtype);
        }
        return new Variable(initialValue, trainable, name);
    };
    Variable.prototype.assign = function (newValue) {
        if (newValue.dtype !== this.dtype) {
            throw new Error("dtype of the new value (" + newValue.dtype + ") and " +
                ("previous value (" + this.dtype + ") must match"));
        }
        if (!util.arraysEqual(newValue.shape, this.shape)) {
            throw new Error("shape of the new value (" + newValue.shape + ") and " +
                ("previous value (" + this.shape + ") must match"));
        }
        trackerFn().disposeTensor(this);
        this.dataId = newValue.dataId;
        trackerFn().registerTensor(this);
    };
    Variable.nextVarId = 0;
    return Variable;
}(Tensor));
exports.Variable = Variable;
Object.defineProperty(Variable, Symbol.hasInstance, {
    value: function (instance) {
        return instance instanceof Tensor && instance.assign != null &&
            instance.assign instanceof Function;
    }
});
var variable = Variable.variable;
exports.variable = variable;

},{"./tensor_format":197,"./util":203}],197:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var FORMAT_LIMIT_NUM_VALS = 20;
var FORMAT_NUM_FIRST_LAST_VALS = 3;
var FORMAT_NUM_SIG_DIGITS = 7;
function tensorToString(vals, shape, dtype, verbose) {
    var strides = util_1.computeStrides(shape);
    var padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);
    var rank = shape.length;
    var valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);
    var lines = ['Tensor'];
    if (verbose) {
        lines.push("  dtype: " + dtype);
        lines.push("  rank: " + rank);
        lines.push("  shape: [" + shape + "]");
        lines.push("  values:");
    }
    lines.push(valsLines.map(function (l) { return '    ' + l; }).join('\n'));
    return lines.join('\n');
}
exports.tensorToString = tensorToString;
function computeMaxSizePerColumn(vals, shape, dtype, strides) {
    var n = util_1.sizeFromShape(shape);
    var numCols = strides[strides.length - 1];
    var padPerCol = new Array(numCols).fill(0);
    var rank = shape.length;
    var valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;
    if (rank > 1) {
        for (var row = 0; row < n / numCols; row++) {
            var offset = row * numCols;
            for (var j = 0; j < numCols; j++) {
                padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0).length);
            }
        }
    }
    return padPerCol;
}
function valToString(val, pad) {
    var valStr;
    if (Array.isArray(val)) {
        valStr = parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS)) + " + " +
            (parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS)) + "j");
    }
    else {
        valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();
    }
    return util_1.rightPad(valStr, pad);
}
function subTensorToString(vals, shape, dtype, strides, padPerCol, isLast) {
    if (isLast === void 0) { isLast = true; }
    var storagePerElement = dtype === 'complex64' ? 2 : 1;
    var size = shape[0];
    var rank = shape.length;
    if (rank === 0) {
        if (dtype === 'complex64') {
            var complexTuple = createComplexTuples(vals);
            return [valToString(complexTuple[0], 0)];
        }
        return [vals[0].toString()];
    }
    if (rank === 1) {
        if (size > FORMAT_LIMIT_NUM_VALS) {
            var firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;
            var firstVals = Array.from(vals.subarray(0, firstValsSize));
            var lastVals = Array.from(vals.subarray(size - FORMAT_NUM_FIRST_LAST_VALS * storagePerElement, size));
            if (dtype === 'complex64') {
                firstVals = createComplexTuples(firstVals);
                lastVals = createComplexTuples(lastVals);
            }
            return [
                '[' + firstVals.map(function (x, i) { return valToString(x, padPerCol[i]); }).join(', ') +
                    ', ..., ' +
                    lastVals
                        .map(function (x, i) { return valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i]); })
                        .join(', ') +
                    ']'
            ];
        }
        var displayVals = dtype === 'complex64' ? createComplexTuples(vals) : Array.from(vals);
        return [
            '[' + displayVals.map(function (x, i) { return valToString(x, padPerCol[i]); }).join(', ') +
                ']'
        ];
    }
    var subshape = shape.slice(1);
    var substrides = strides.slice(1);
    var stride = strides[0] * storagePerElement;
    var lines = [];
    if (size > FORMAT_LIMIT_NUM_VALS) {
        for (var i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {
            var start = i * stride;
            var end = start + stride;
            lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, dtype, substrides, padPerCol, false));
        }
        lines.push('...');
        for (var i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {
            var start = i * stride;
            var end = start + stride;
            lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, dtype, substrides, padPerCol, i === size - 1));
        }
    }
    else {
        for (var i = 0; i < size; i++) {
            var start = i * stride;
            var end = start + stride;
            lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, dtype, substrides, padPerCol, i === size - 1));
        }
    }
    var sep = rank === 2 ? ',' : '';
    lines[0] = '[' + lines[0] + sep;
    for (var i = 1; i < lines.length - 1; i++) {
        lines[i] = ' ' + lines[i] + sep;
    }
    var newLineSep = ',\n';
    for (var i = 2; i < rank; i++) {
        newLineSep += '\n';
    }
    lines[lines.length - 1] =
        ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);
    return lines;
}
function createComplexTuples(vals) {
    var complexTuples = [];
    for (var i = 0; i < vals.length; i += 2) {
        complexTuples.push([vals[i], vals[i + 1]]);
    }
    return complexTuples;
}

},{"./util":203}],198:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("./tensor");
var util_1 = require("./util");
function assertTypesMatch(a, b) {
    util_1.assert(a.dtype === b.dtype, "The dtypes of the first(" + a.dtype + ") and" +
        (" second(" + b.dtype + ") input must match"));
}
exports.assertTypesMatch = assertTypesMatch;
function isTensorInList(tensor, tensorList) {
    for (var i = 0; i < tensorList.length; i++) {
        if (tensorList[i].id === tensor.id) {
            return true;
        }
    }
    return false;
}
exports.isTensorInList = isTensorInList;
function flattenNameArrayMap(nameArrayMap, keys) {
    var xs = [];
    if (nameArrayMap instanceof tensor_1.Tensor) {
        xs.push(nameArrayMap);
    }
    else {
        var xMap = nameArrayMap;
        for (var i = 0; i < keys.length; i++) {
            xs.push(xMap[keys[i]]);
        }
    }
    return xs;
}
exports.flattenNameArrayMap = flattenNameArrayMap;
function unflattenToNameArrayMap(keys, flatArrays) {
    if (keys.length !== flatArrays.length) {
        throw new Error("Cannot unflatten Tensor[], keys and arrays are not of same length.");
    }
    var result = {};
    for (var i = 0; i < keys.length; i++) {
        result[keys[i]] = flatArrays[i];
    }
    return result;
}
exports.unflattenToNameArrayMap = unflattenToNameArrayMap;
function getTensorsInContainer(result) {
    var list = [];
    var seen = new Set();
    walkTensorContainer(result, list, seen);
    return list;
}
exports.getTensorsInContainer = getTensorsInContainer;
function walkTensorContainer(container, list, seen) {
    if (container == null) {
        return;
    }
    if (container instanceof tensor_1.Tensor) {
        list.push(container);
        return;
    }
    if (!isIterable(container)) {
        return;
    }
    var iterable = container;
    for (var k in iterable) {
        var val = iterable[k];
        if (!seen.has(val)) {
            seen.add(val);
            walkTensorContainer(val, list, seen);
        }
    }
}
function isIterable(obj) {
    return Array.isArray(obj) || typeof obj === 'object';
}

},{"./tensor":196,"./util":203}],199:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("./environment");
var tensor_1 = require("./tensor");
var util_1 = require("./util");
function inferShape(val) {
    var firstElem = val;
    if (util_1.isTypedArray(val)) {
        return [val.length];
    }
    if (!Array.isArray(val)) {
        return [];
    }
    var shape = [];
    while (firstElem instanceof Array) {
        shape.push(firstElem.length);
        firstElem = firstElem[0];
    }
    if (val instanceof Array && environment_1.ENV.get('TENSORLIKE_CHECK_SHAPE_CONSISTENCY')) {
        deepAssertShapeConsistency(val, shape, []);
    }
    return shape;
}
exports.inferShape = inferShape;
function deepAssertShapeConsistency(val, shape, indices) {
    indices = indices || [];
    if (!(val instanceof Array)) {
        util_1.assert(shape.length === 0, function () { return "Element arr[" + indices.join('][') + "] is a primitive, " +
            ("but should be an array of " + shape[0] + " elements"); });
        return;
    }
    util_1.assert(shape.length > 0, function () { return "Element arr[" + indices.join('][') + "] should be a primitive, " +
        ("but is an array of " + val.length + " elements"); });
    util_1.assert(val.length === shape[0], function () { return "Element arr[" + indices.join('][') + "] should have " + shape[0] + " " +
        ("elements, but has " + val.length + " elements"); });
    var subShape = shape.slice(1);
    for (var i = 0; i < val.length; ++i) {
        deepAssertShapeConsistency(val[i], subShape, indices.concat(i));
    }
}
function convertToTensor(x, argName, functionName, dtype) {
    if (dtype === void 0) { dtype = 'float32'; }
    dtype = dtype || 'float32';
    if (x instanceof tensor_1.Tensor) {
        return x;
    }
    if (!util_1.isTypedArray(x) && !Array.isArray(x) && typeof x !== 'number' &&
        typeof x !== 'boolean') {
        throw new Error("Argument '" + argName + "' passed to '" + functionName + "' must be a " +
            ("Tensor or TensorLike, but got " + x.constructor.name));
    }
    var inferredShape = inferShape(x);
    if (!util_1.isTypedArray(x) && !Array.isArray(x)) {
        x = [x];
    }
    return tensor_1.Tensor.make(inferredShape, { values: util_1.toTypedArray(x, dtype, environment_1.ENV.get('DEBUG')) }, dtype);
}
exports.convertToTensor = convertToTensor;
function convertToTensorArray(arg, argName, functionName) {
    if (!Array.isArray(arg)) {
        throw new Error("Argument " + argName + " passed to " + functionName + " must be a " +
            '`Tensor[]` or `TensorLike[]`');
    }
    var tensors = arg;
    return tensors.map(function (t, i) { return convertToTensor(t, argName + "[" + i + "]", functionName); });
}
exports.convertToTensorArray = convertToTensorArray;

},{"./environment":60,"./tensor":196,"./util":203}],200:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("./environment");
var tensor_1 = require("./tensor");
var util = require("./util");
exports.WEBGL_ENVS = {
    'HAS_WEBGL': true
};
exports.NODE_ENVS = {
    'IS_NODE': true
};
exports.CHROME_ENVS = {
    'IS_CHROME': true
};
exports.BROWSER_ENVS = {
    'IS_BROWSER': true
};
exports.CPU_ENVS = {
    'HAS_WEBGL': false
};
exports.ALL_ENVS = {};
function expectArraysClose(actual, expected, epsilon) {
    if (epsilon == null) {
        epsilon = environment_1.ENV.get('TEST_EPSILON');
    }
    if (!(actual instanceof tensor_1.Tensor) && !(expected instanceof tensor_1.Tensor)) {
        var aType = actual.constructor.name;
        var bType = expected.constructor.name;
        if (aType !== bType) {
            throw new Error("Arrays are of different type actual: " + aType + " " +
                ("vs expected: " + bType));
        }
    }
    else if (actual instanceof tensor_1.Tensor && expected instanceof tensor_1.Tensor) {
        if (actual.dtype !== expected.dtype) {
            throw new Error("Arrays are of different type actual: " + actual.dtype + " " +
                ("vs expected: " + expected.dtype + "."));
        }
        if (!util.arraysEqual(actual.shape, expected.shape)) {
            throw new Error("Arrays are of different shape actual: " + actual.shape + " " +
                ("vs expected: " + expected.shape + "."));
        }
    }
    var actualValues;
    var expectedValues;
    if (actual instanceof tensor_1.Tensor) {
        actualValues = actual.dataSync();
    }
    else {
        actualValues = actual;
    }
    if (expected instanceof tensor_1.Tensor) {
        expectedValues = expected.dataSync();
    }
    else {
        expectedValues = expected;
    }
    if (actualValues.length !== expectedValues.length) {
        throw new Error("Arrays have different lengths actual: " + actualValues.length + " vs " +
            ("expected: " + expectedValues.length + ".\n") +
            ("Actual:   " + actualValues + ".\n") +
            ("Expected: " + expectedValues + "."));
    }
    for (var i = 0; i < expectedValues.length; ++i) {
        var a = actualValues[i];
        var e = expectedValues[i];
        if (!areClose(a, Number(e), epsilon)) {
            throw new Error("Arrays differ: actual[" + i + "] = " + a + ", expected[" + i + "] = " + e + ".\n" +
                ("Actual:   " + actualValues + ".\n") +
                ("Expected: " + expectedValues + "."));
        }
    }
}
exports.expectArraysClose = expectArraysClose;
function expectPromiseToFail(fn, done) {
    fn().then(function () { return done.fail(); }, function () { return done(); });
}
exports.expectPromiseToFail = expectPromiseToFail;
function expectArraysEqual(actual, expected) {
    return expectArraysClose(actual, expected, 0);
}
exports.expectArraysEqual = expectArraysEqual;
function expectNumbersClose(a, e, epsilon) {
    if (epsilon == null) {
        epsilon = environment_1.ENV.get('TEST_EPSILON');
    }
    if (!areClose(a, e, epsilon)) {
        throw new Error("Numbers differ: actual === " + a + ", expected === " + e);
    }
}
exports.expectNumbersClose = expectNumbersClose;
function areClose(a, e, epsilon) {
    if (isNaN(a) && isNaN(e)) {
        return true;
    }
    if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
        return false;
    }
    return true;
}
function expectValuesInRange(actual, low, high) {
    var actualVals;
    if (actual instanceof tensor_1.Tensor) {
        actualVals = actual.dataSync();
    }
    else {
        actualVals = actual;
    }
    for (var i = 0; i < actualVals.length; i++) {
        if (actualVals[i] < low || actualVals[i] > high) {
            throw new Error("Value out of range:" + actualVals[i] + " low: " + low + ", high: " + high);
        }
    }
}
exports.expectValuesInRange = expectValuesInRange;
function expectArrayBuffersEqual(actual, expected) {
    expect(new Float32Array(actual)).toEqual(new Float32Array(expected));
}
exports.expectArrayBuffersEqual = expectArrayBuffersEqual;

},{"./environment":60,"./tensor":196,"./util":203}],201:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var adadelta_optimizer_1 = require("./optimizers/adadelta_optimizer");
var adagrad_optimizer_1 = require("./optimizers/adagrad_optimizer");
var adam_optimizer_1 = require("./optimizers/adam_optimizer");
var adamax_optimizer_1 = require("./optimizers/adamax_optimizer");
var momentum_optimizer_1 = require("./optimizers/momentum_optimizer");
var optimizer_constructors_1 = require("./optimizers/optimizer_constructors");
var rmsprop_optimizer_1 = require("./optimizers/rmsprop_optimizer");
var sgd_optimizer_1 = require("./optimizers/sgd_optimizer");
[momentum_optimizer_1.MomentumOptimizer, sgd_optimizer_1.SGDOptimizer, adadelta_optimizer_1.AdadeltaOptimizer, adagrad_optimizer_1.AdagradOptimizer,
    rmsprop_optimizer_1.RMSPropOptimizer, adamax_optimizer_1.AdamaxOptimizer, adam_optimizer_1.AdamOptimizer];
exports.train = {
    sgd: optimizer_constructors_1.OptimizerConstructors.sgd,
    momentum: optimizer_constructors_1.OptimizerConstructors.momentum,
    adadelta: optimizer_constructors_1.OptimizerConstructors.adadelta,
    adagrad: optimizer_constructors_1.OptimizerConstructors.adagrad,
    rmsprop: optimizer_constructors_1.OptimizerConstructors.rmsprop,
    adamax: optimizer_constructors_1.OptimizerConstructors.adamax,
    adam: optimizer_constructors_1.OptimizerConstructors.adam
};

},{"./optimizers/adadelta_optimizer":184,"./optimizers/adagrad_optimizer":185,"./optimizers/adam_optimizer":186,"./optimizers/adamax_optimizer":187,"./optimizers/momentum_optimizer":188,"./optimizers/optimizer_constructors":190,"./optimizers/rmsprop_optimizer":191,"./optimizers/sgd_optimizer":192}],202:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DType;
(function (DType) {
    DType["float32"] = "float32";
    DType["int32"] = "int32";
    DType["bool"] = "bool";
})(DType = exports.DType || (exports.DType = {}));
var Rank;
(function (Rank) {
    Rank["R0"] = "R0";
    Rank["R1"] = "R1";
    Rank["R2"] = "R2";
    Rank["R3"] = "R3";
    Rank["R4"] = "R4";
    Rank["R5"] = "R5";
    Rank["R6"] = "R6";
})(Rank = exports.Rank || (exports.Rank = {}));
var UpcastInt32AndMap;
(function (UpcastInt32AndMap) {
    UpcastInt32AndMap["float32"] = "float32";
    UpcastInt32AndMap["int32"] = "int32";
    UpcastInt32AndMap["bool"] = "int32";
    UpcastInt32AndMap["complex64"] = "complex64";
})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
var UpcastBoolAndMap;
(function (UpcastBoolAndMap) {
    UpcastBoolAndMap["float32"] = "float32";
    UpcastBoolAndMap["int32"] = "int32";
    UpcastBoolAndMap["bool"] = "bool";
    UpcastBoolAndMap["complex64"] = "complex64";
})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
var UpcastFloat32AndMap;
(function (UpcastFloat32AndMap) {
    UpcastFloat32AndMap["float32"] = "float32";
    UpcastFloat32AndMap["int32"] = "float32";
    UpcastFloat32AndMap["bool"] = "float32";
    UpcastFloat32AndMap["complex64"] = "complex64";
})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
var UpcastComplex64AndMap;
(function (UpcastComplex64AndMap) {
    UpcastComplex64AndMap["float32"] = "complex64";
    UpcastComplex64AndMap["int32"] = "complex64";
    UpcastComplex64AndMap["bool"] = "complex64";
    UpcastComplex64AndMap["complex64"] = "complex64";
})(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));
var upcastTypeMap = {
    'float32': UpcastFloat32AndMap,
    'int32': UpcastInt32AndMap,
    'bool': UpcastBoolAndMap,
    'complex64': UpcastComplex64AndMap
};
function upcastType(typeA, typeB) {
    return upcastTypeMap[typeA][typeB];
}
exports.upcastType = upcastType;
function sumOutType(type) {
    return upcastType(type, 'int32');
}
exports.sumOutType = sumOutType;

},{}],203:[function(require,module,exports){
(function (process){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function shuffle(array) {
    var counter = array.length;
    var temp = 0;
    var index = 0;
    while (counter > 0) {
        index = (Math.random() * counter) | 0;
        counter--;
        temp = array[counter];
        array[counter] = array[index];
        array[index] = temp;
    }
}
exports.shuffle = shuffle;
function clamp(min, x, max) {
    return Math.max(min, Math.min(x, max));
}
exports.clamp = clamp;
function nearestLargerEven(val) {
    return val % 2 === 0 ? val : val + 1;
}
exports.nearestLargerEven = nearestLargerEven;
function randUniform(a, b) {
    var r = Math.random();
    return (b * r) + (1 - r) * a;
}
exports.randUniform = randUniform;
function distSquared(a, b) {
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        var diff = Number(a[i]) - Number(b[i]);
        result += diff * diff;
    }
    return result;
}
exports.distSquared = distSquared;
function assert(expr, msg) {
    if (!expr) {
        throw new Error(typeof msg === 'string' ? msg : msg());
    }
}
exports.assert = assert;
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
    assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + (" Shapes " + shapeA + " and " + shapeB + " must match"));
}
exports.assertShapesMatch = assertShapesMatch;
function assertNonNull(a) {
    assert(a != null, "The input to the tensor constructor must be a non-null value.");
}
exports.assertNonNull = assertNonNull;
function flatten(arr, ret) {
    if (ret === void 0) { ret = []; }
    if (Array.isArray(arr)) {
        for (var i = 0; i < arr.length; ++i) {
            flatten(arr[i], ret);
        }
    }
    else {
        ret.push(arr);
    }
    return ret;
}
exports.flatten = flatten;
function sizeFromShape(shape) {
    if (shape.length === 0) {
        return 1;
    }
    var size = shape[0];
    for (var i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}
exports.sizeFromShape = sizeFromShape;
function isScalarShape(shape) {
    return shape.length === 0;
}
exports.isScalarShape = isScalarShape;
function arraysEqual(n1, n2) {
    if (n1 === n2) {
        return true;
    }
    if (n1 == null || n2 == null) {
        return false;
    }
    if (n1.length !== n2.length) {
        return false;
    }
    for (var i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
            return false;
        }
    }
    return true;
}
exports.arraysEqual = arraysEqual;
function isInt(a) {
    return a % 1 === 0;
}
exports.isInt = isInt;
function tanh(x) {
    if (Math.tanh != null) {
        return Math.tanh(x);
    }
    if (x === Infinity) {
        return 1;
    }
    else if (x === -Infinity) {
        return -1;
    }
    else {
        var e2x = Math.exp(2 * x);
        return (e2x - 1) / (e2x + 1);
    }
}
exports.tanh = tanh;
function sizeToSquarishShape(size) {
    for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {
        if (size % a === 0) {
            return [a, size / a];
        }
    }
    return [1, size];
}
exports.sizeToSquarishShape = sizeToSquarishShape;
function createShuffledIndices(n) {
    var shuffledIndices = new Uint32Array(n);
    for (var i = 0; i < n; ++i) {
        shuffledIndices[i] = i;
    }
    shuffle(shuffledIndices);
    return shuffledIndices;
}
exports.createShuffledIndices = createShuffledIndices;
function rightPad(a, size) {
    if (size <= a.length) {
        return a;
    }
    return a + ' '.repeat(size - a.length);
}
exports.rightPad = rightPad;
function repeatedTry(checkFn, delayFn, maxCounter) {
    if (delayFn === void 0) { delayFn = function (counter) { return 0; }; }
    return new Promise(function (resolve, reject) {
        var tryCount = 0;
        var tryFn = function () {
            if (checkFn()) {
                resolve();
                return;
            }
            tryCount++;
            var nextBackoff = delayFn(tryCount);
            if (maxCounter != null && tryCount >= maxCounter) {
                reject();
                return;
            }
            setTimeout(tryFn, nextBackoff);
        };
        tryFn();
    });
}
exports.repeatedTry = repeatedTry;
function inferFromImplicitShape(shape, size) {
    var shapeProd = 1;
    var implicitIdx = -1;
    for (var i = 0; i < shape.length; ++i) {
        if (shape[i] >= 0) {
            shapeProd *= shape[i];
        }
        else if (shape[i] === -1) {
            if (implicitIdx !== -1) {
                throw Error("Shapes can only have 1 implicit size. " +
                    ("Found -1 at dim " + implicitIdx + " and dim " + i));
            }
            implicitIdx = i;
        }
        else if (shape[i] < 0) {
            throw Error("Shapes can not be < 0. Found " + shape[i] + " at dim " + i);
        }
    }
    if (implicitIdx === -1) {
        if (size > 0 && size !== shapeProd) {
            throw Error("Size(" + size + ") must match the product of shape " + shape);
        }
        return shape;
    }
    if (shapeProd === 0) {
        throw Error("Cannot infer the missing size in [" + shape + "] when " +
            "there are 0 elements");
    }
    if (size % shapeProd !== 0) {
        throw Error("The implicit shape can't be a fractional number. " +
            ("Got " + size + " / " + shapeProd));
    }
    var newShape = shape.slice();
    newShape[implicitIdx] = size / shapeProd;
    return newShape;
}
exports.inferFromImplicitShape = inferFromImplicitShape;
function squeezeShape(shape, axis) {
    var newShape = [];
    var keptDims = [];
    var j = 0;
    for (var i = 0; i < shape.length; ++i) {
        if (axis != null) {
            if (axis[j] === i && shape[i] !== 1) {
                throw new Error("Can't squeeze axis " + i + " since its dim '" + shape[i] + "' is not 1");
            }
            if ((axis[j] == null || axis[j] > i) && shape[i] === 1) {
                newShape.push(shape[i]);
                keptDims.push(i);
            }
            if (axis[j] <= i) {
                j++;
            }
        }
        if (shape[i] !== 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
        }
    }
    return { newShape: newShape, keptDims: keptDims };
}
exports.squeezeShape = squeezeShape;
function getTypedArrayFromDType(dtype, size) {
    var values = null;
    if (dtype == null || dtype === 'float32') {
        values = new Float32Array(size);
    }
    else if (dtype === 'int32') {
        values = new Int32Array(size);
    }
    else if (dtype === 'bool') {
        values = new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
    return values;
}
exports.getTypedArrayFromDType = getTypedArrayFromDType;
function checkComputationForNaN(vals, dtype, name) {
    if (dtype !== 'float32') {
        return;
    }
    for (var i = 0; i < vals.length; i++) {
        if (isNaN(vals[i])) {
            throw Error("The result of the '" + name + "' has NaNs.");
        }
    }
}
exports.checkComputationForNaN = checkComputationForNaN;
function checkConversionForNaN(vals, dtype) {
    if (dtype === 'float32') {
        return;
    }
    for (var i = 0; i < vals.length; i++) {
        if (isNaN(vals[i])) {
            throw Error("NaN is not a valid value for dtype: '" + dtype + "'.");
        }
    }
}
exports.checkConversionForNaN = checkConversionForNaN;
function hasEncodingLoss(oldType, newType) {
    if (newType === 'complex64') {
        return false;
    }
    if (newType === 'float32' && oldType !== 'complex64') {
        return false;
    }
    if (newType === 'int32' && oldType !== 'float32' && oldType !== 'complex64') {
        return false;
    }
    if (newType === 'bool' && oldType === 'bool') {
        return false;
    }
    return true;
}
exports.hasEncodingLoss = hasEncodingLoss;
function copyTypedArray(array, dtype, debugMode) {
    if (dtype == null || dtype === 'float32' || dtype === 'complex64') {
        return new Float32Array(array);
    }
    else if (dtype === 'int32') {
        if (debugMode) {
            checkConversionForNaN(array, dtype);
        }
        return new Int32Array(array);
    }
    else if (dtype === 'bool') {
        var bool = new Uint8Array(array.length);
        for (var i = 0; i < bool.length; ++i) {
            if (Math.round(array[i]) !== 0) {
                bool[i] = 1;
            }
        }
        return bool;
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
}
function isTypedArray(a) {
    return a instanceof Float32Array || a instanceof Int32Array ||
        a instanceof Uint8Array;
}
exports.isTypedArray = isTypedArray;
function bytesPerElement(dtype) {
    if (dtype === 'float32' || dtype === 'int32') {
        return 4;
    }
    else if (dtype === 'complex64') {
        return 8;
    }
    else if (dtype === 'bool') {
        return 1;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.bytesPerElement = bytesPerElement;
function isFunction(f) {
    return !!(f && f.constructor && f.call && f.apply);
}
exports.isFunction = isFunction;
function nearestDivisor(size, start) {
    for (var i = start; i < size; ++i) {
        if (size % i === 0) {
            return i;
        }
    }
    return size;
}
exports.nearestDivisor = nearestDivisor;
function computeStrides(shape) {
    var rank = shape.length;
    if (rank < 2) {
        return [];
    }
    var strides = new Array(rank - 1);
    strides[rank - 2] = shape[rank - 1];
    for (var i = rank - 3; i >= 0; --i) {
        strides[i] = strides[i + 1] * shape[i + 1];
    }
    return strides;
}
exports.computeStrides = computeStrides;
function toTypedArray(a, dtype, debugMode) {
    if (noConversionNeeded(a, dtype)) {
        return a;
    }
    if (Array.isArray(a)) {
        a = flatten(a);
    }
    return copyTypedArray(a, dtype, debugMode);
}
exports.toTypedArray = toTypedArray;
function noConversionNeeded(a, dtype) {
    return (a instanceof Float32Array && dtype === 'float32') ||
        (a instanceof Int32Array && dtype === 'int32') ||
        (a instanceof Uint8Array && dtype === 'bool');
}
function makeOnesTypedArray(size, dtype) {
    var array = makeZerosTypedArray(size, dtype);
    for (var i = 0; i < array.length; i++) {
        array[i] = 1;
    }
    return array;
}
exports.makeOnesTypedArray = makeOnesTypedArray;
function makeZerosTypedArray(size, dtype) {
    if (dtype == null || dtype === 'float32' || dtype === 'complex64') {
        return new Float32Array(size);
    }
    else if (dtype === 'int32') {
        return new Int32Array(size);
    }
    else if (dtype === 'bool') {
        return new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
}
exports.makeZerosTypedArray = makeZerosTypedArray;
function now() {
    if (typeof performance !== 'undefined') {
        return performance.now();
    }
    else if (typeof process !== 'undefined') {
        var time = process.hrtime();
        return time[0] * 1000 + time[1] / 1000000;
    }
    else {
        throw new Error('Cannot measure time in this environment. You should run tf.js ' +
            'in the browser or in Node.js');
    }
}
exports.now = now;

}).call(this,require('_process'))
},{"_process":5}],204:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.13.6';
exports.version = version;

},{}],205:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gpgpu_util = require("./kernels/webgl/gpgpu_util");
exports.gpgpu_util = gpgpu_util;
var webgl_util = require("./kernels/webgl/webgl_util");
exports.webgl_util = webgl_util;
var backend_webgl_1 = require("./kernels/backend_webgl");
exports.MathBackendWebGL = backend_webgl_1.MathBackendWebGL;
var gpgpu_context_1 = require("./kernels/webgl/gpgpu_context");
exports.GPGPUContext = gpgpu_context_1.GPGPUContext;

},{"./kernels/backend_webgl":79,"./kernels/webgl/gpgpu_context":103,"./kernels/webgl/gpgpu_util":105,"./kernels/webgl/webgl_util":135}],206:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var state_1 = require("./backend/state");
var generic_utils_1 = require("./utils/generic_utils");
var Activation = (function (_super) {
    __extends(Activation, _super);
    function Activation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Activation.prototype.getConfig = function () {
        return {};
    };
    return Activation;
}(tfjs_core_1.serialization.Serializable));
exports.Activation = Activation;
var Elu = (function (_super) {
    __extends(Elu, _super);
    function Elu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Elu.prototype.apply = function (x, alpha) {
        if (alpha === void 0) { alpha = 1; }
        return K.elu(x, alpha);
    };
    Elu.className = 'elu';
    return Elu;
}(Activation));
exports.Elu = Elu;
tfjs_core_1.serialization.registerClass(Elu);
var Selu = (function (_super) {
    __extends(Selu, _super);
    function Selu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Selu.prototype.apply = function (x) {
        return tfc.selu(x);
    };
    Selu.className = 'selu';
    return Selu;
}(Activation));
exports.Selu = Selu;
tfjs_core_1.serialization.registerClass(Selu);
var Relu = (function (_super) {
    __extends(Relu, _super);
    function Relu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Relu.prototype.apply = function (x) {
        return tfc.relu(x);
    };
    Relu.className = 'relu';
    return Relu;
}(Activation));
exports.Relu = Relu;
tfjs_core_1.serialization.registerClass(Relu);
var Relu6 = (function (_super) {
    __extends(Relu6, _super);
    function Relu6() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Relu6.prototype.apply = function (x) {
        return tfjs_core_1.tidy(function () { return tfc.minimum(state_1.getScalar(6.0), tfc.relu(x)); });
    };
    Relu6.className = 'relu6';
    return Relu6;
}(Activation));
exports.Relu6 = Relu6;
tfjs_core_1.serialization.registerClass(Relu6);
var Linear = (function (_super) {
    __extends(Linear, _super);
    function Linear() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Linear.prototype.apply = function (x) {
        return x;
    };
    Linear.className = 'linear';
    return Linear;
}(Activation));
exports.Linear = Linear;
tfjs_core_1.serialization.registerClass(Linear);
var Sigmoid = (function (_super) {
    __extends(Sigmoid, _super);
    function Sigmoid() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Sigmoid.prototype.apply = function (x) {
        return tfc.sigmoid(x);
    };
    Sigmoid.className = 'sigmoid';
    return Sigmoid;
}(Activation));
exports.Sigmoid = Sigmoid;
tfjs_core_1.serialization.registerClass(Sigmoid);
var HardSigmoid = (function (_super) {
    __extends(HardSigmoid, _super);
    function HardSigmoid() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HardSigmoid.prototype.apply = function (x) {
        return K.hardSigmoid(x);
    };
    HardSigmoid.className = 'hardSigmoid';
    return HardSigmoid;
}(Activation));
exports.HardSigmoid = HardSigmoid;
tfjs_core_1.serialization.registerClass(HardSigmoid);
var Softplus = (function (_super) {
    __extends(Softplus, _super);
    function Softplus() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Softplus.prototype.apply = function (x) {
        return tfc.softplus(x);
    };
    Softplus.className = 'softplus';
    return Softplus;
}(Activation));
exports.Softplus = Softplus;
tfjs_core_1.serialization.registerClass(Softplus);
var Softsign = (function (_super) {
    __extends(Softsign, _super);
    function Softsign() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Softsign.prototype.apply = function (x) {
        return K.softsign(x);
    };
    Softsign.className = 'softsign';
    return Softsign;
}(Activation));
exports.Softsign = Softsign;
tfjs_core_1.serialization.registerClass(Softsign);
var Tanh = (function (_super) {
    __extends(Tanh, _super);
    function Tanh() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Tanh.prototype.apply = function (x) {
        return tfc.tanh(x);
    };
    Tanh.className = 'tanh';
    return Tanh;
}(Activation));
exports.Tanh = Tanh;
tfjs_core_1.serialization.registerClass(Tanh);
var Softmax = (function (_super) {
    __extends(Softmax, _super);
    function Softmax() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Softmax.prototype.apply = function (x, axis) {
        if (axis === void 0) { axis = (-1); }
        return tfc.softmax(x, axis);
    };
    Softmax.className = 'softmax';
    return Softmax;
}(Activation));
exports.Softmax = Softmax;
tfjs_core_1.serialization.registerClass(Softmax);
function serializeActivation(activation) {
    return activation.getClassName();
}
exports.serializeActivation = serializeActivation;
function deserializeActivation(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'activation');
}
exports.deserializeActivation = deserializeActivation;
function getActivation(identifier) {
    if (identifier == null) {
        var config = { className: 'linear', config: {} };
        return deserializeActivation(config);
    }
    if (typeof identifier === 'string') {
        var config = { className: identifier, config: {} };
        return deserializeActivation(config);
    }
    else if (identifier instanceof Activation) {
        return identifier;
    }
    else {
        return deserializeActivation(identifier);
    }
}
exports.getActivation = getActivation;

},{"./backend/state":208,"./backend/tfjs_backend":209,"./utils/generic_utils":250,"@tensorflow/tfjs-core":64}],207:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var _epsilon = tfjs_core_1.ENV.get('EPSILON');
function epsilon() {
    return _epsilon;
}
exports.epsilon = epsilon;
function setEpsilon(e) {
    _epsilon = e;
}
exports.setEpsilon = setEpsilon;
function imageDataFormat() {
    return 'channelsLast';
}
exports.imageDataFormat = imageDataFormat;

},{"@tensorflow/tfjs-core":64}],208:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var _nextUniqueTensorId = 0;
function getNextUniqueTensorId() {
    return _nextUniqueTensorId++;
}
exports.getNextUniqueTensorId = getNextUniqueTensorId;
var _uidPrefixes = {};
function getUid(prefix) {
    if (prefix === void 0) { prefix = ''; }
    if (!(prefix in _uidPrefixes)) {
        _uidPrefixes[prefix] = 0;
    }
    _uidPrefixes[prefix] += 1;
    return prefix + _uidPrefixes[prefix].toString();
}
exports.getUid = getUid;
var scalarCache = {
    float32: {},
    int32: {}
};
var DEFAULT_DTYPE = 'float32';
function getScalar(value, dtype) {
    if (dtype === undefined) {
        dtype = DEFAULT_DTYPE;
    }
    if (scalarCache[dtype][value] == null) {
        scalarCache[dtype][value] = tfjs_core_1.scalar(value, dtype);
        tfjs_core_1.keep(scalarCache[dtype][value]);
    }
    return scalarCache[dtype][value];
}
exports.getScalar = getScalar;
function disposeScalarCache() {
    for (var typeKey in scalarCache) {
        for (var key in scalarCache[typeKey]) {
            scalarCache[typeKey][key].dispose();
            delete scalarCache[typeKey][key];
        }
    }
}
exports.disposeScalarCache = disposeScalarCache;

},{"@tensorflow/tfjs-core":64}],209:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var state_1 = require("../backend/state");
var common_1 = require("../common");
var errors_1 = require("../errors");
var math_utils = require("../utils/math_utils");
var common_2 = require("./common");
var backend = 'webgl';
function setBackend(requestedBackend) {
    tfc.setBackend(requestedBackend);
    backend = requestedBackend;
    state_1.disposeScalarCache();
}
exports.setBackend = setBackend;
function getBackend() {
    return backend;
}
exports.getBackend = getBackend;
function isBackendSymbolic() {
    return false;
}
exports.isBackendSymbolic = isBackendSymbolic;
function countParams(x) {
    var shape = x.shape;
    if (shape.length > 0) {
        return shape.reduce(function (a, b) { return a * b; });
    }
    else {
        return 1;
    }
}
exports.countParams = countParams;
function cast(x, dtype) {
    return x.asType(dtype);
}
exports.cast = cast;
function expandDims(x, axis) {
    if (axis === void 0) { axis = -1; }
    var outShape = x.shape.slice();
    if (axis < 0) {
        axis = outShape.length + axis + 1;
    }
    outShape.splice(axis, 0, 1);
    return x.reshape(outShape);
}
exports.expandDims = expandDims;
function repeat(x, n) {
    return tfjs_core_1.tidy(function () {
        if (x.shape.length !== 2) {
            throw new errors_1.ValueError("repeat() expects a rank-2 tensor, but received a " +
                ("rank-" + x.shape.length + " tensor."));
        }
        var y = expandDims(x, 1);
        return tile(y, [1, n, 1]);
    });
}
exports.repeat = repeat;
function flatten(x) {
    var newShape = [math_utils.arrayProd(x.shape)];
    return x.reshape(newShape);
}
exports.flatten = flatten;
function batchFlatten(x) {
    if (x.rank <= 1) {
        throw new errors_1.ValueError("batchFlatten requires a minimum rank of 2. Got rank: " + x.rank + ".");
    }
    var newShape = [x.shape[0], math_utils.arrayProd(x.shape, 1)];
    return x.reshape(newShape);
}
exports.batchFlatten = batchFlatten;
function sliceAlongFirstAxis(array, start, size) {
    return tfjs_core_1.tidy(function () {
        switch (array.rank) {
            case 1:
                return tfc.slice1d(array, start, size);
            case 2:
                return tfc.slice2d(array, [start, 0], [size, array.shape[1]]);
            case 3:
                return tfc.slice3d(array, [start, 0, 0], [size, array.shape[1], array.shape[2]]);
            case 4:
                return tfc.slice4d(array, [start, 0, 0, 0], [size, array.shape[1], array.shape[2], array.shape[3]]);
            default:
                throw new errors_1.ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: " +
                    ("" + array.rank));
        }
    });
}
exports.sliceAlongFirstAxis = sliceAlongFirstAxis;
function sliceAlongLastAxis(array, start, size) {
    return tfjs_core_1.tidy(function () {
        switch (array.rank) {
            case 1:
                return tfc.slice1d(array, start, size);
            case 2:
                return tfc.slice2d(array, [0, start], [array.shape[0], size]);
            case 3:
                return tfc.slice3d(array, [0, 0, start], [array.shape[0], array.shape[1], size]);
            case 4:
                return tfc.slice4d(array, [0, 0, 0, start], [array.shape[0], array.shape[1], array.shape[2], size]);
            default:
                throw new errors_1.ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " +
                    ("" + array.rank));
        }
    });
}
exports.sliceAlongLastAxis = sliceAlongLastAxis;
function sliceAlongAxis(array, start, size, axis) {
    return tfjs_core_1.tidy(function () {
        switch (array.rank) {
            case 1:
                return tfc.slice1d(array, start, size);
            case 2:
                switch (axis) {
                    case 1:
                        return sliceAlongFirstAxis(array, start, size);
                    case 2:
                        return sliceAlongLastAxis(array, start, size);
                    default:
                        throw new errors_1.ValueError("The axis is not within the rank of the tensor " +
                            ("" + axis));
                }
            case 3:
                switch (axis) {
                    case 1:
                        return sliceAlongFirstAxis(array, start, size);
                    case 2:
                        return tfc.slice3d(array, [0, start, 0], [array.shape[0], size, array.shape[2]]);
                    case 3:
                        return sliceAlongLastAxis(array, start, size);
                    default:
                        throw new errors_1.ValueError("The axis is not within the rank of the tensor " +
                            ("" + axis));
                }
            case 4:
                switch (axis) {
                    case 1:
                        return sliceAlongFirstAxis(array, start, size);
                    case 2:
                        return tfc.slice4d(array, [0, start, 0, 0], [array.shape[0], size, array.shape[2], array.shape[3]]);
                    case 3:
                        return tfc.slice4d(array, [0, 0, start, 0], [array.shape[0], array.shape[1], size, array.shape[3]]);
                    case 4:
                        return sliceAlongLastAxis(array, start, size);
                    default:
                        throw new errors_1.ValueError("The axis is not within the rank of the tensor " +
                            ("" + axis));
                }
            default:
                throw new errors_1.ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " +
                    ("" + array.rank));
        }
    });
}
exports.sliceAlongAxis = sliceAlongAxis;
function concatenate(tensors, axis) {
    if (axis === void 0) { axis = -1; }
    var rank;
    if (axis < 0) {
        rank = tensors[0].rank;
        if (rank !== 0) {
            axis = rank;
        }
        else {
            axis = 0;
        }
    }
    if (axis === tensors[0].rank) {
        axis = -1;
    }
    return tfc.concat(tensors, axis);
}
exports.concatenate = concatenate;
function concatAlongFirstAxis(a, b) {
    switch (a.rank) {
        case 1:
            return tfc.concat1d([a, b]);
        case 2:
            return tfc.concat2d([a, b], 0);
        case 3:
            return tfc.concat3d([a, b], 0);
        case 4:
            return tfc.concat4d([a, b], 0);
        default:
            throw new errors_1.ValueError('concatAlongFirstAxis() received an unsupported tensor rank: ' +
                a.rank);
    }
}
exports.concatAlongFirstAxis = concatAlongFirstAxis;
function tile(x, n) {
    if (!Array.isArray(n)) {
        n = [n];
    }
    if (x.rank !== n.length) {
        throw new errors_1.ValueError("The length of input n (" + n.length + ") does not match " +
            ("the number of dimensions in input x (" + x.rank + ")"));
    }
    return tfc.tile(x, n);
}
exports.tile = tile;
function randomNormal(shape, mean, stddev, dtype, seed) {
    if (mean === void 0) { mean = 0.0; }
    if (stddev === void 0) { stddev = 1.0; }
    return tfc.randomNormal(shape, mean, stddev, dtype, seed);
}
exports.randomNormal = randomNormal;
function dot(x, y) {
    if ((x.rank < 2) || (y.rank < 2)) {
        throw new errors_1.NotImplementedError("dot requires both inputs to be rank >= 2" +
            (" but got x shape = " + x.shape + " and y shape = " + y.shape));
    }
    if (y.rank >= 3) {
        var xLastDim = x.shape.slice(-1)[0];
        var ySecondLastDim = y.shape.slice(-2)[0];
        if (xLastDim !== ySecondLastDim) {
            throw new errors_1.NotImplementedError("If rank y >= 3, then the second last dim" +
                (" of y must equal the last dim of x but got x shape = " + x.shape + " and ") +
                (" y shape = " + y.shape));
        }
    }
    if ((x.rank === 2) && (y.rank === 2)) {
        return tfc.matMul(x, y);
    }
    else {
        var xFirstDims = x.shape.slice();
        var xLastDim = xFirstDims.pop();
        x = x.reshape([-1, xLastDim]);
        var yShape = y.shape.slice();
        var yLastDim = yShape.pop();
        var ySecondLastDim = yShape.pop();
        var yOtherDims = yShape.concat([yLastDim]);
        var perm = Array.from({ length: y.rank }, function (_, i) {
            if (i === 0) {
                return y.rank - 2;
            }
            else if (i <= y.rank - 2) {
                return i - 1;
            }
            return i;
        });
        y = y.transpose(perm).reshape([ySecondLastDim, -1]);
        var outputShape = xFirstDims.concat(yOtherDims);
        return tfc.matMul(x, y).reshape(outputShape);
    }
}
exports.dot = dot;
function sign(x) {
    return tfjs_core_1.tidy(function () {
        var zerosLikeX = tfjs_core_1.zerosLike(x);
        var onesLikeX = tfjs_core_1.onesLike(x);
        return tfjs_core_1.where(tfc.equal(x, zerosLikeX), zerosLikeX, tfjs_core_1.where(tfc.greater(x, tfjs_core_1.zerosLike(x)), onesLikeX, tfc.mul(state_1.getScalar(-1), onesLikeX)));
    });
}
exports.sign = sign;
function oneHot(indices, numClasses) {
    return tfjs_core_1.tidy(function () {
        if (indices.rank !== 1) {
            throw new Error('Only 1D one-hot tensors are supported in the ' +
                'deeplearn backend, at present.');
        }
        indices = indices.toInt();
        return tfc.oneHot(indices, numClasses).toFloat();
    });
}
exports.oneHot = oneHot;
function gather(reference, indices, axis) {
    return tfjs_core_1.tidy(function () {
        if (Array.isArray(indices)) {
            indices = tfjs_core_1.tensor1d(indices, 'int32');
        }
        else {
            indices = indices.toInt();
        }
        return tfc.gather(reference, indices, axis);
    });
}
exports.gather = gather;
function square(x) {
    return tfc.mulStrict(x, x);
}
exports.square = square;
function pow(x, a) {
    return tfjs_core_1.tidy(function () {
        if (typeof (a) === 'number') {
            a = tfjs_core_1.scalar(Math.round(a), 'int32');
        }
        if (a.dtype !== 'int32') {
            throw new errors_1.NotImplementedError("Non-int32 dtype (" + a.dtype + ") is not supported by pow() yet");
        }
        return tfc.pow(x, a);
    });
}
exports.pow = pow;
function biasAdd(x, bias, dataFormat) {
    return tfjs_core_1.tidy(function () {
        if (dataFormat == null) {
            dataFormat = common_2.imageDataFormat();
        }
        common_1.checkDataFormat(dataFormat);
        if (bias.rank !== 1 && bias.rank !== x.rank) {
            throw new errors_1.ValueError('Unexpected bias dimensions: ' + bias.rank +
                '; expected it to be 1 or ' + x.rank);
        }
        var biasShape = bias.shape;
        var y;
        if (x.rank === 5) {
            if (dataFormat === 'channelsFirst') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, biasShape[0], 1, 1, 1]));
                }
                else {
                    y = x.add(bias.reshape([1, biasShape[3], biasShape[0], biasShape[1], biasShape[2]]));
                }
            }
            else if (dataFormat === 'channelsLast') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, 1, 1, 1, biasShape[0]]));
                }
                else {
                    y = x.add(bias.reshape([1].concat(biasShape)));
                }
            }
        }
        else if (x.rank === 4) {
            if (dataFormat === 'channelsFirst') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, biasShape[0], 1, 1]));
                }
                else {
                    y = x.add(bias.reshape([1, biasShape[2], biasShape[0], biasShape[1]]));
                }
            }
            else if (dataFormat === 'channelsLast') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, 1, 1, biasShape[0]]));
                }
                else {
                    y = x.add(bias.reshape([1].concat(biasShape)));
                }
            }
        }
        else if (x.rank === 3) {
            if (dataFormat === 'channelsFirst') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, biasShape[0], 1]));
                }
                else {
                    y = x.add(bias.reshape([1, biasShape[1], biasShape[0]]));
                }
            }
            else if (dataFormat === 'channelsLast') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, 1, biasShape[0]]));
                }
                else {
                    y = x.add(bias.reshape([1].concat(biasShape)));
                }
            }
        }
        else if (x.rank < 3) {
            y = x.add(bias);
        }
        else {
            throw new errors_1.ValueError("Unsupported input rank by biasAdd: " + x.rank);
        }
        return y;
    });
}
exports.biasAdd = biasAdd;
function elu(x, alpha) {
    if (alpha === void 0) { alpha = 1; }
    if (alpha !== 1) {
        throw new errors_1.NotImplementedError("Support for alpha values other than 1 (" + alpha + ") is not implemented " +
            "yet.");
    }
    return tfc.elu(x);
}
exports.elu = elu;
function softsign(x) {
    return tfjs_core_1.tidy(function () { return tfc.div(x, tfc.add(state_1.getScalar(1), tfc.abs(x))); });
}
exports.softsign = softsign;
function dropout(x, level, noiseShape, seed) {
    return tfjs_core_1.tidy(function () {
        if (noiseShape != null && !tfjs_core_1.util.arraysEqual(x.shape, noiseShape)) {
            throw new errors_1.NotImplementedError('Non-default noise shape is not implemented yet: ' +
                JSON.stringify(noiseShape));
        }
        if (seed != null) {
            throw new errors_1.NotImplementedError('seed is not implemented for dropout yet.');
        }
        var multiplier = tfc.step(tfc.add(tfc.neg(level), tfc.randomUniform(x.shape, 0, 1, 'float32')));
        multiplier = tfc.mul(tfc.div(state_1.getScalar(1), tfc.sub(state_1.getScalar(1), level)), multiplier);
        return tfc.mul(x, multiplier);
    });
}
exports.dropout = dropout;
function hardSigmoid(x) {
    return tfjs_core_1.tidy(function () {
        var y = tfc.add(state_1.getScalar(0.5), tfc.mul(state_1.getScalar(0.2), x));
        return tfc.clipByValue(y, 0, 1);
    });
}
exports.hardSigmoid = hardSigmoid;
function inTrainPhase(x, alt, training) {
    if (training === void 0) { training = false; }
    return training ? x() : alt();
}
exports.inTrainPhase = inTrainPhase;

},{"../backend/state":208,"../common":212,"../errors":222,"../utils/math_utils":252,"./common":207,"@tensorflow/tfjs-core":64}],210:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var state_1 = require("./backend/state");
var errors_1 = require("./errors");
var logs_1 = require("./logs");
var generic_utils = require("./utils/generic_utils");
var ModelLoggingVerbosity;
(function (ModelLoggingVerbosity) {
    ModelLoggingVerbosity[ModelLoggingVerbosity["SILENT"] = 0] = "SILENT";
    ModelLoggingVerbosity[ModelLoggingVerbosity["VERBOSE"] = 1] = "VERBOSE";
})(ModelLoggingVerbosity = exports.ModelLoggingVerbosity || (exports.ModelLoggingVerbosity = {}));
var BaseCallback = (function () {
    function BaseCallback() {
        this.validationData = null;
    }
    BaseCallback.prototype.setParams = function (params) {
        this.params = params;
    };
    BaseCallback.prototype.onEpochBegin = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    BaseCallback.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    BaseCallback.prototype.onBatchBegin = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    BaseCallback.prototype.onBatchEnd = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    BaseCallback.prototype.onTrainBegin = function (logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    BaseCallback.prototype.onTrainEnd = function (logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    BaseCallback.prototype.setModel = function (model) {
    };
    return BaseCallback;
}());
exports.BaseCallback = BaseCallback;
var CallbackList = (function () {
    function CallbackList(callbacks, queueLength) {
        if (queueLength === void 0) { queueLength = 10; }
        if (callbacks == null) {
            callbacks = [];
        }
        this.callbacks = callbacks;
        this.queueLength = queueLength;
    }
    CallbackList.prototype.append = function (callback) {
        this.callbacks.push(callback);
    };
    CallbackList.prototype.setParams = function (params) {
        for (var _i = 0, _a = this.callbacks; _i < _a.length; _i++) {
            var callback = _a[_i];
            callback.setParams(params);
        }
    };
    CallbackList.prototype.setModel = function (model) {
        for (var _i = 0, _a = this.callbacks; _i < _a.length; _i++) {
            var callback = _a[_i];
            callback.setModel(model);
        }
    };
    CallbackList.prototype.onEpochBegin = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onEpochBegin(epoch, logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onEpochEnd(epoch, logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onBatchBegin = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onBatchBegin(batch, logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onBatchEnd = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        return [4, logs_1.resolveScalarsInLogs(logs)];
                    case 1:
                        _b.sent();
                        _i = 0, _a = this.callbacks;
                        _b.label = 2;
                    case 2:
                        if (!(_i < _a.length)) return [3, 5];
                        callback = _a[_i];
                        return [4, callback.onBatchEnd(batch, logs)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        _i++;
                        return [3, 2];
                    case 5: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onTrainBegin = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onTrainBegin(logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onTrainEnd = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onTrainEnd(logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    return CallbackList;
}());
exports.CallbackList = CallbackList;
var ModelTrainingYielder = (function () {
    function ModelTrainingYielder(yieldEvery) {
        this.yieldEvery = yieldEvery;
        this.batchCount = 0;
        this.batchDurationsMillis = [];
        this.autoYieldEveryBatches = null;
        this.batchStartMillis = tfjs_core_1.util.now();
    }
    ModelTrainingYielder.prototype.resolveOneTensorInLogs = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, _i, key, value;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = [];
                        for (_b in logs)
                            _a.push(_b);
                        _i = 0;
                        _c.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        key = _a[_i];
                        value = logs[key];
                        if (!(typeof value !== 'number')) return [3, 3];
                        return [4, value.data()];
                    case 2:
                        _c.sent();
                        return [3, 4];
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    ModelTrainingYielder.prototype.maybeYieldOnBatch = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            var t, meanBatchDuration;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.yieldEvery === 'auto')) return [3, 7];
                        this.batchCount++;
                        if (!(this.autoYieldEveryBatches == null)) return [3, 3];
                        return [4, this.resolveOneTensorInLogs(logs)];
                    case 1:
                        _a.sent();
                        t = tfjs_core_1.util.now();
                        return [4, tfjs_core_1.nextFrame()];
                    case 2:
                        _a.sent();
                        if (this.batchCount > ModelTrainingYielder.SKIP_FIRST_BATCHES) {
                            this.batchDurationsMillis.push(t - this.batchStartMillis);
                            if (this.batchDurationsMillis.length >=
                                ModelTrainingYielder.DECISION_BATCH_COUNT) {
                                meanBatchDuration = this.batchDurationsMillis.reduce(function (dur, prev) { return dur + prev; }) /
                                    this.batchDurationsMillis.length;
                                this.autoYieldEveryBatches = Math.round(ModelTrainingYielder.THRESHOLD_MILLIS / meanBatchDuration);
                                if (this.autoYieldEveryBatches < 1) {
                                    this.autoYieldEveryBatches = 1;
                                }
                            }
                        }
                        this.batchStartMillis = tfjs_core_1.util.now();
                        this.lastYieldBatchCount = this.batchCount;
                        return [3, 6];
                    case 3:
                        if (!(this.batchCount - this.lastYieldBatchCount >=
                            this.autoYieldEveryBatches)) return [3, 6];
                        return [4, tfjs_core_1.nextFrame()];
                    case 4:
                        _a.sent();
                        return [4, this.resolveOneTensorInLogs(logs)];
                    case 5:
                        _a.sent();
                        this.lastYieldBatchCount = this.batchCount;
                        _a.label = 6;
                    case 6: return [3, 9];
                    case 7:
                        if (!(this.yieldEvery === 'batch')) return [3, 9];
                        return [4, tfjs_core_1.nextFrame()];
                    case 8:
                        _a.sent();
                        _a.label = 9;
                    case 9: return [2];
                }
            });
        });
    };
    ModelTrainingYielder.prototype.maybeYieldOnEpoch = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.yieldEvery === 'epoch')) return [3, 2];
                        return [4, tfjs_core_1.nextFrame()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2];
                }
            });
        });
    };
    ModelTrainingYielder.SKIP_FIRST_BATCHES = 1;
    ModelTrainingYielder.DECISION_BATCH_COUNT = 2;
    ModelTrainingYielder.THRESHOLD_MILLIS = 16;
    return ModelTrainingYielder;
}());
exports.ModelTrainingYielder = ModelTrainingYielder;
var BaseLogger = (function (_super) {
    __extends(BaseLogger, _super);
    function BaseLogger(yieldEvery) {
        var _this = _super.call(this) || this;
        _this.yieldEvery = yieldEvery || 'auto';
        return _this;
    }
    BaseLogger.prototype.onTrainBegin = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.autoYielder = new ModelTrainingYielder(this.yieldEvery);
                return [2];
            });
        });
    };
    BaseLogger.prototype.onEpochBegin = function (epoch) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.seen = 0;
                this.totals = {};
                return [2];
            });
        });
    };
    BaseLogger.prototype.onBatchEnd = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var batchSize, _loop_1, this_1, key;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.autoYielder.maybeYieldOnBatch(logs)];
                    case 1:
                        _a.sent();
                        if (logs == null) {
                            logs = {};
                        }
                        batchSize = logs['size'] == null ? 0 : logs['size'];
                        this.seen += batchSize;
                        _loop_1 = function (key) {
                            var value = logs[key];
                            if (typeof value === 'number') {
                                if (!this_1.totals.hasOwnProperty(key)) {
                                    this_1.totals[key] = 0;
                                }
                                this_1.totals[key] = this_1.totals[key] + value * batchSize;
                            }
                            else {
                                var oldTotalsToDispose = void 0;
                                if (key in this_1.totals) {
                                    oldTotalsToDispose = this_1.totals[key];
                                }
                                else {
                                    this_1.totals[key] = state_1.getScalar(0);
                                }
                                this_1.totals[key] = tfjs_core_1.tidy(function () { return tfjs_core_1.add(_this.totals[key], tfjs_core_1.mul(value, state_1.getScalar(batchSize))); });
                                if (oldTotalsToDispose != null) {
                                    oldTotalsToDispose.dispose();
                                }
                            }
                        };
                        this_1 = this;
                        for (key in logs) {
                            _loop_1(key);
                        }
                        return [2];
                }
            });
        });
    };
    BaseLogger.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var _loop_2, this_2, _i, _a, key;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4, this.autoYielder.maybeYieldOnEpoch()];
                    case 1:
                        _b.sent();
                        if (logs != null) {
                            _loop_2 = function (key) {
                                if (this_2.totals[key] == null) {
                                    return "continue";
                                }
                                if (typeof this_2.totals[key] === 'number') {
                                    logs[key] = this_2.totals[key] / this_2.seen;
                                }
                                else {
                                    tfjs_core_1.tidy(function () {
                                        logs[key] = tfjs_core_1.mul(tfjs_core_1.div(state_1.getScalar(1), state_1.getScalar(_this.seen)), _this.totals[key]);
                                        _this.totals[key].dispose();
                                        tfjs_core_1.keep(logs[key]);
                                    });
                                }
                            };
                            this_2 = this;
                            for (_i = 0, _a = this.params['metrics']; _i < _a.length; _i++) {
                                key = _a[_i];
                                _loop_2(key);
                            }
                        }
                        return [2];
                }
            });
        });
    };
    return BaseLogger;
}(BaseCallback));
exports.BaseLogger = BaseLogger;
var History = (function (_super) {
    __extends(History, _super);
    function History() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    History.prototype.onTrainBegin = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.epoch = [];
                this.history = {};
                return [2];
            });
        });
    };
    History.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var key;
            return __generator(this, function (_a) {
                if (logs == null) {
                    logs = {};
                }
                this.epoch.push(epoch);
                for (key in logs) {
                    if (this.history[key] == null) {
                        this.history[key] = [];
                    }
                    this.history[key].push(logs[key]);
                }
                return [2];
            });
        });
    };
    History.prototype.syncData = function () {
        return __awaiter(this, void 0, void 0, function () {
            var promises, keys, indices, key, valueArray, i, valueScalar, values, n, tensorToDispose;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = [];
                        keys = [];
                        indices = [];
                        for (key in this.history) {
                            valueArray = this.history[key];
                            for (i = 0; i < valueArray.length; ++i) {
                                if (typeof valueArray[i] !== 'number') {
                                    valueScalar = valueArray[i];
                                    promises.push(valueScalar.data());
                                    keys.push(key);
                                    indices.push(i);
                                }
                            }
                        }
                        return [4, Promise.all(promises)];
                    case 1:
                        values = _a.sent();
                        for (n = 0; n < values.length; ++n) {
                            tensorToDispose = this.history[keys[n]][indices[n]];
                            tensorToDispose.dispose();
                            this.history[keys[n]][indices[n]] = values[n][0];
                        }
                        return [2];
                }
            });
        });
    };
    return History;
}(BaseCallback));
exports.History = History;
var CustomCallback = (function (_super) {
    __extends(CustomCallback, _super);
    function CustomCallback(config) {
        var _this = _super.call(this) || this;
        _this.trainBegin = config.onTrainBegin;
        _this.trainEnd = config.onTrainEnd;
        _this.epochBegin = config.onEpochBegin;
        _this.epochEnd = config.onEpochEnd;
        _this.batchBegin = config.onBatchBegin;
        _this.batchEnd = config.onBatchEnd;
        return _this;
    }
    CustomCallback.prototype.onEpochBegin = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.epochBegin != null)) return [3, 3];
                        return [4, logs_1.resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.epochBegin(epoch, logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.epochEnd != null)) return [3, 3];
                        return [4, logs_1.resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.epochEnd(epoch, logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onBatchBegin = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.batchBegin != null)) return [3, 3];
                        return [4, logs_1.resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.batchBegin(batch, logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onBatchEnd = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.batchEnd != null)) return [3, 3];
                        return [4, logs_1.resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.batchEnd(batch, logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onTrainBegin = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.trainBegin != null)) return [3, 3];
                        return [4, logs_1.resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.trainBegin(logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onTrainEnd = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.trainEnd != null)) return [3, 3];
                        return [4, logs_1.resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.trainEnd(logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    return CustomCallback;
}(BaseCallback));
exports.CustomCallback = CustomCallback;
function standardizeCallbacks(callbacks) {
    if (callbacks == null) {
        return null;
    }
    if (callbacks instanceof BaseCallback) {
        return [callbacks];
    }
    if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {
        return callbacks;
    }
    var callbackConfigs = generic_utils.toList(callbacks);
    return callbackConfigs.map(function (callbackConfig) { return new CustomCallback(callbackConfig); });
}
exports.standardizeCallbacks = standardizeCallbacks;
var CallbackConstructorRegistry = (function () {
    function CallbackConstructorRegistry() {
    }
    CallbackConstructorRegistry.registerCallbackConstructor = function (verbosityLevel, callbackConstructor) {
        tfjs_core_1.util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), "Verbosity level is expected to be an integer >= 0, " +
            ("but got " + verbosityLevel));
        CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);
        if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {
            CallbackConstructorRegistry.constructors[verbosityLevel] = [];
        }
        CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);
    };
    CallbackConstructorRegistry.checkForDuplicate = function (callbackConstructor) {
        for (var levelName in CallbackConstructorRegistry.constructors) {
            var constructors = CallbackConstructorRegistry.constructors[+levelName];
            constructors.forEach(function (ctor) {
                if (ctor === callbackConstructor) {
                    throw new errors_1.ValueError('Duplicate callback constructor.');
                }
            });
        }
    };
    CallbackConstructorRegistry.clear = function () {
        CallbackConstructorRegistry.constructors = {};
    };
    CallbackConstructorRegistry.createCallbacks = function (verbosityLevel) {
        var constructors = [];
        for (var levelName in CallbackConstructorRegistry.constructors) {
            var level = +levelName;
            if (verbosityLevel >= level) {
                constructors.push.apply(constructors, CallbackConstructorRegistry.constructors[level]);
            }
        }
        return constructors.map(function (ctor) { return new ctor(); });
    };
    CallbackConstructorRegistry.constructors = {};
    return CallbackConstructorRegistry;
}());
exports.CallbackConstructorRegistry = CallbackConstructorRegistry;
function configureCallbacks(callbacks, yieldEvery, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {
    var history = new History();
    var actualCallbacks = [
        new BaseLogger(yieldEvery)
    ].concat(CallbackConstructorRegistry.createCallbacks(verbose));
    if (callbacks != null) {
        actualCallbacks.push.apply(actualCallbacks, callbacks);
    }
    actualCallbacks.push(history);
    var callbackList = new CallbackList(actualCallbacks);
    callbackList.setParams({
        epochs: epochs,
        initialEpoch: initialEpoch,
        samples: numTrainSamples,
        steps: stepsPerEpoch,
        batchSize: batchSize,
        verbose: verbose,
        doValidation: doValidation,
        metrics: callbackMetrics,
    });
    return { callbackList: callbackList, history: history };
}
exports.configureCallbacks = configureCallbacks;

},{"./backend/state":208,"./errors":222,"./logs":243,"./utils/generic_utils":250,"@tensorflow/tfjs-core":64}],211:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var base_callbacks_1 = require("./base_callbacks");
var training_1 = require("./engine/training");
var Callback = (function (_super) {
    __extends(Callback, _super);
    function Callback() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.model = null;
        return _this;
    }
    Callback.prototype.setModel = function (model) {
        if (!(model instanceof training_1.Model)) {
            throw new Error('model must be a Model, not some other Container');
        }
        this.model = model;
    };
    return Callback;
}(base_callbacks_1.BaseCallback));
exports.Callback = Callback;

},{"./base_callbacks":210,"./engine/training":219}],212:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var generic_utils_1 = require("./utils/generic_utils");
var nameMap = new Map();
exports.VALID_DATA_FORMAT_VALUES = ['channelsFirst', 'channelsLast'];
function checkDataFormat(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_DATA_FORMAT_VALUES, 'DataFormat', value);
}
exports.checkDataFormat = checkDataFormat;
exports.VALID_PADDING_MODE_VALUES = ['valid', 'same', 'causal'];
function checkPaddingMode(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_PADDING_MODE_VALUES, 'PaddingMode', value);
}
exports.checkPaddingMode = checkPaddingMode;
exports.VALID_POOL_MODE_VALUES = ['max', 'avg'];
function checkPoolMode(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_POOL_MODE_VALUES, 'PoolMode', value);
}
exports.checkPoolMode = checkPoolMode;
var _nameScopeStack = [];
var _nameScopeDivider = '/';
function nameScope(name, fn) {
    _nameScopeStack.push(name);
    try {
        var val = fn();
        _nameScopeStack.pop();
        return val;
    }
    catch (e) {
        _nameScopeStack.pop();
        throw e;
    }
}
exports.nameScope = nameScope;
function currentNameScopePrefix() {
    if (_nameScopeStack.length === 0) {
        return '';
    }
    else {
        return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;
    }
}
function getScopedTensorName(tensorName) {
    if (!isValidTensorName(tensorName)) {
        throw new Error('Not a valid tensor name: \'' + tensorName + '\'');
    }
    return currentNameScopePrefix() + tensorName;
}
exports.getScopedTensorName = getScopedTensorName;
function getUniqueTensorName(scopedName) {
    if (!isValidTensorName(scopedName)) {
        throw new Error('Not a valid tensor name: \'' + scopedName + '\'');
    }
    if (!nameMap.has(scopedName)) {
        nameMap.set(scopedName, 0);
    }
    var index = nameMap.get(scopedName);
    nameMap.set(scopedName, nameMap.get(scopedName) + 1);
    if (index > 0) {
        var result = scopedName + '_' + index;
        nameMap.set(result, 1);
        return result;
    }
    else {
        return scopedName;
    }
}
exports.getUniqueTensorName = getUniqueTensorName;
var tensorNameRegex = new RegExp(/^[A-Za-z][A-Za-z0-9\._\/]*$/);
function isValidTensorName(name) {
    return name.match(tensorNameRegex) ? true : false;
}
exports.isValidTensorName = isValidTensorName;

},{"./utils/generic_utils":250}],213:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("./backend/common");
var state_1 = require("./backend/state");
var generic_utils_1 = require("./utils/generic_utils");
function calcL2Norms(w, axis) {
    return tfjs_core_1.tidy(function () { return tfc.sqrt(tfc.sum(tfc.mulStrict(w, w), axis, true)); });
}
var Constraint = (function (_super) {
    __extends(Constraint, _super);
    function Constraint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Constraint.prototype.getConfig = function () {
        return {};
    };
    return Constraint;
}(tfjs_core_1.serialization.Serializable));
exports.Constraint = Constraint;
var MaxNorm = (function (_super) {
    __extends(MaxNorm, _super);
    function MaxNorm(config) {
        var _this = _super.call(this) || this;
        _this.defaultMaxValue = 2;
        _this.defaultAxis = 0;
        _this.maxValue =
            config.maxValue != null ? config.maxValue : _this.defaultMaxValue;
        _this.axis = config.axis != null ? config.axis : _this.defaultAxis;
        return _this;
    }
    MaxNorm.prototype.apply = function (w) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var norms = calcL2Norms(w, _this.axis);
            var desired = tfc.clipByValue(norms, 0, _this.maxValue);
            return tfc.mul(w, tfc.div(desired, tfc.add(state_1.getScalar(common_1.epsilon()), norms)));
        });
    };
    MaxNorm.prototype.getConfig = function () {
        return { maxValue: this.maxValue, axis: this.axis };
    };
    MaxNorm.className = 'MaxNorm';
    return MaxNorm;
}(Constraint));
exports.MaxNorm = MaxNorm;
tfjs_core_1.serialization.registerClass(MaxNorm);
var UnitNorm = (function (_super) {
    __extends(UnitNorm, _super);
    function UnitNorm(config) {
        var _this = _super.call(this) || this;
        _this.defaultAxis = 0;
        _this.axis = config.axis != null ? config.axis : _this.defaultAxis;
        return _this;
    }
    UnitNorm.prototype.apply = function (w) {
        var _this = this;
        return tfjs_core_1.tidy(function () { return tfc.div(w, tfc.add(state_1.getScalar(common_1.epsilon()), calcL2Norms(w, _this.axis))); });
    };
    UnitNorm.prototype.getConfig = function () {
        return { axis: this.axis };
    };
    UnitNorm.className = 'UnitNorm';
    return UnitNorm;
}(Constraint));
exports.UnitNorm = UnitNorm;
tfjs_core_1.serialization.registerClass(UnitNorm);
var NonNeg = (function (_super) {
    __extends(NonNeg, _super);
    function NonNeg() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NonNeg.prototype.apply = function (w) {
        return tfc.relu(w);
    };
    NonNeg.className = 'NonNeg';
    return NonNeg;
}(Constraint));
exports.NonNeg = NonNeg;
tfjs_core_1.serialization.registerClass(NonNeg);
var MinMaxNorm = (function (_super) {
    __extends(MinMaxNorm, _super);
    function MinMaxNorm(config) {
        var _this = _super.call(this) || this;
        _this.defaultMinValue = 0.0;
        _this.defaultMaxValue = 1.0;
        _this.defaultRate = 1.0;
        _this.defaultAxis = 0;
        _this.minValue =
            config.minValue != null ? config.minValue : _this.defaultMinValue;
        _this.maxValue =
            config.maxValue != null ? config.maxValue : _this.defaultMaxValue;
        _this.rate = config.rate != null ? config.rate : _this.defaultRate;
        _this.axis = config.axis != null ? config.axis : _this.defaultAxis;
        return _this;
    }
    MinMaxNorm.prototype.apply = function (w) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var norms = calcL2Norms(w, _this.axis);
            var desired = tfc.add(tfc.mul(state_1.getScalar(_this.rate), tfc.clipByValue(norms, _this.minValue, _this.maxValue)), tfc.mul(state_1.getScalar(1.0 - _this.rate), norms));
            return tfc.mul(w, tfc.div(desired, tfc.add(state_1.getScalar(common_1.epsilon()), norms)));
        });
    };
    MinMaxNorm.prototype.getConfig = function () {
        return {
            minValue: this.minValue,
            maxValue: this.maxValue,
            rate: this.rate,
            axis: this.axis
        };
    };
    MinMaxNorm.className = 'MinMaxNorm';
    return MinMaxNorm;
}(Constraint));
exports.MinMaxNorm = MinMaxNorm;
tfjs_core_1.serialization.registerClass(MinMaxNorm);
exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    'maxNorm': 'MaxNorm',
    'minMaxNorm': 'MinMaxNorm',
    'nonNeg': 'NonNeg',
    'unitNorm': 'UnitNorm'
};
function serializeConstraint(constraint) {
    return generic_utils_1.serializeKerasObject(constraint);
}
exports.serializeConstraint = serializeConstraint;
function deserializeConstraint(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'constraint');
}
exports.deserializeConstraint = deserializeConstraint;
function getConstraint(identifier) {
    if (identifier == null) {
        return null;
    }
    if (typeof identifier === 'string') {
        var className = identifier in exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ?
            exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :
            identifier;
        var config = { className: className, config: {} };
        return deserializeConstraint(config);
    }
    else if (identifier instanceof Constraint) {
        return identifier;
    }
    else {
        return deserializeConstraint(identifier);
    }
}
exports.getConstraint = getConstraint;

},{"./backend/common":207,"./backend/state":208,"./utils/generic_utils":250,"@tensorflow/tfjs-core":64}],214:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var state_1 = require("../backend/state");
var errors_1 = require("../errors");
var serialization_1 = require("../layers/serialization");
var generic_utils = require("../utils/generic_utils");
var serialization_utils_1 = require("../utils/serialization_utils");
var types_utils = require("../utils/types_utils");
var variables_1 = require("../variables");
var version_1 = require("../version");
var input_layer_1 = require("./input_layer");
var topology_1 = require("./topology");
function preprocessWeightsForLoading(layer, weights, originalKerasVersion, originalBackend) {
    if (!originalKerasVersion.startsWith('2.')) {
        throw new errors_1.ValueError('Unsupported Keras version in weights being loaded: ' +
            originalKerasVersion);
    }
    return weights;
}
function loadTensor(dtype, shape, value) {
    var dataType = generic_utils.stringToDType(dtype);
    return tfjs_core_1.Tensor.make(shape, { values: shape.length === 0 ? value : tfjs_core_1.util.flatten(value) }, dataType);
}
function loadWeightsFromJson(weightsJSON, layers, skipMismatch) {
    if (skipMismatch === void 0) { skipMismatch = false; }
    var originalKerasVersion = weightsJSON['keras_version'];
    var originalBackend = weightsJSON['backend'];
    var layerNames = layers.map(function (layer) { return layer.name; });
    var index = {};
    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
        var layer = layers_1[_i];
        if (layer.name != null) {
            if (index[layer.name] == null) {
                index[layer.name] = [];
            }
            index[layer.name].push(layer);
        }
    }
    var nameToWeights = weightsJSON['weights'];
    var weightValueTuples = [];
    for (var k = 0; k < layerNames.length; ++k) {
        var name_1 = layerNames[k];
        var layerWeights = nameToWeights[name_1];
        if (layerWeights == null) {
            layerWeights = [];
        }
        var weightValues = [];
        for (var n = 0; n < layerWeights.length; ++n) {
            var weightEntry = layerWeights[n];
            weightValues.push(new variables_1.LayerVariable(loadTensor(weightEntry['dtype'], weightEntry['shape'], weightEntry['value'])));
        }
        for (var _a = 0, _b = index[name_1]; _a < _b.length; _a++) {
            var layer = _b[_a];
            var symbolicWeights = layer.weights;
            weightValues = preprocessWeightsForLoading(layer, weightValues, originalKerasVersion, originalBackend);
            if (weightValues.length !== symbolicWeights.length) {
                if (skipMismatch) {
                    console.warn("Skipping loading of weights of layer " + layer.name + " " +
                        ("due to mismatch in number of weights: (" + weightValues.length + " ") +
                        ("vs " + symbolicWeights.length + ")."));
                }
                else {
                    throw new errors_1.ValueError("Layer #" + k + " (named \"" + layer.name + "\") expects " +
                        (symbolicWeights.length + " weight(s), but the saved weights ") +
                        ("have " + weightValues.length + " element(s)."));
                }
            }
            for (var i = 0; i < weightValues.length; ++i) {
                if (skipMismatch) {
                    if (!tfjs_core_1.util.arraysEqual(symbolicWeights[i].shape, weightValues[i].shape)) {
                        console.warn("Skipping loading of weights for layer " + layer.name + " due " +
                            ("to mismatch in shape (" + symbolicWeights[i].shape + " vs ") +
                            (weightValues[i].shape + ")"));
                        continue;
                    }
                }
                weightValueTuples.push([symbolicWeights[i], weightValues[i].read()]);
            }
        }
    }
    variables_1.batchSetValue(weightValueTuples);
}
exports.loadWeightsFromJson = loadWeightsFromJson;
function loadWeightsFromNamedTensorMap(weights, layers, strict) {
    if (strict === void 0) { strict = true; }
    var nameToWeight = {};
    var totalWeightsCount = 0;
    for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {
        var layer = layers_2[_i];
        for (var _a = 0, _b = layer.weights; _a < _b.length; _a++) {
            var weight = _b[_a];
            if (nameToWeight[weight.originalName] != null) {
                throw new errors_1.ValueError("Duplicate weight name: " + weight.originalName);
            }
            nameToWeight[weight.originalName] = weight;
            totalWeightsCount++;
        }
    }
    var weightValueTuples = [];
    for (var name_2 in weights) {
        if (nameToWeight[name_2] != null) {
            weightValueTuples.push([nameToWeight[name_2], weights[name_2]]);
        }
        else if (strict) {
            throw new errors_1.ValueError("Provided weight data has no target variable: " + name_2);
        }
        delete nameToWeight[name_2];
    }
    if (strict) {
        var unsetNames = [];
        for (var name_3 in nameToWeight) {
            unsetNames.push(name_3);
        }
        if (unsetNames.length > 0) {
            throw new errors_1.ValueError(unsetNames.length + " of " + totalWeightsCount + " weights are not set: " +
                ("" + unsetNames));
        }
    }
    variables_1.batchSetValue(weightValueTuples);
}
exports.loadWeightsFromNamedTensorMap = loadWeightsFromNamedTensorMap;
var Container = (function (_super) {
    __extends(Container, _super);
    function Container(config) {
        var _this = _super.call(this, {}) || this;
        _this.containerNodes = new Set();
        _this.name = config.name;
        if (_this.name == null) {
            var prefix = _this.getClassName().toLowerCase();
            _this.name = state_1.getUid(prefix);
        }
        _this.supportsMasking = false;
        _this.trainable = true;
        _this.updatable = true;
        if (Array.isArray(config.inputs)) {
            _this.inputs = config.inputs.slice();
        }
        else {
            _this.inputs = [config.inputs];
        }
        if (Array.isArray(config.outputs)) {
            _this.outputs = config.outputs.slice();
        }
        else {
            _this.outputs = [config.outputs];
        }
        if (generic_utils.unique(_this.inputs).length !== _this.inputs.length) {
            throw new errors_1.ValueError('The list of inputs passed to the model is ' +
                'redundant. All inputs should only appear once. Found: ' +
                _this.inputs.map(function (x) { return x.name; }));
        }
        if (generic_utils.unique(_this.outputs).length !== _this.outputs.length) {
            console.warn('The list of outputs passed to the model is redundant. ' +
                'All outputs should only appear once. Found: ' +
                _this.outputs.map(function (x) { return x.name; }));
        }
        _this.inputLayers = [];
        _this.inputLayersNodeIndices = [];
        _this.inputLayersTensorIndices = [];
        _this.outputLayers = [];
        _this.outputLayersNodeIndices = [];
        _this.outputLayersTensorIndices = [];
        _this.layers = [];
        for (var _i = 0, _a = _this.outputs; _i < _a.length; _i++) {
            var x = _a[_i];
            var layer = x.sourceLayer;
            var nodeIndex = x.nodeIndex;
            var tensorIndex = x.tensorIndex;
            _this.outputLayers.push(layer);
            _this.outputLayersNodeIndices.push(nodeIndex);
            _this.outputLayersTensorIndices.push(tensorIndex);
        }
        for (var _b = 0, _c = _this.inputs; _b < _c.length; _b++) {
            var x = _c[_b];
            var layer = x.sourceLayer;
            var nodeIndex = x.nodeIndex;
            var tensorIndex = x.tensorIndex;
            generic_utils.assert(nodeIndex === 0, 'input layer has >1 nodes');
            generic_utils.assert(tensorIndex === 0, 'input layer has >1 tensors');
            _this.inputLayers.push(layer);
            _this.inputLayersNodeIndices.push(nodeIndex);
            _this.inputLayersTensorIndices.push(tensorIndex);
        }
        _this.inputNames = [];
        _this.outputNames = [];
        _this.feedInputShapes = [];
        _this.feedInputNames = [];
        _this.feedOutputNames = [];
        for (var i = 0; i < _this.inputLayers.length; i++) {
            var layer = _this.inputLayers[i];
            if (!(layer instanceof input_layer_1.InputLayer)) {
                throw new TypeError('Input layers to a Model must be InputLayer objects. ' +
                    ("Received inputs: " + config.inputs + ". ") +
                    ("Input " + i + " (0-based) originates ") +
                    ("from layer type " + layer.getClassName() + "."));
            }
            _this.inputNames.push(layer.name);
            _this.feedInputShapes.push(layer.batchInputShape);
            _this.feedInputNames.push(layer.name);
        }
        for (var _d = 0, _e = _this.outputLayers; _d < _e.length; _d++) {
            var layer = _e[_d];
            _this.outputNames.push(layer.name);
        }
        _this.internalInputShapes = _this.inputs.map(function (x) { return x.shape; });
        _this.internalOutputShapes = _this.outputs.map(function (x) { return x.shape; });
        var nodesDepths = {};
        var nodeIDToNode = {};
        var layersDepths = {};
        var layerIDToLayer = {};
        var layerIndices = {};
        var nodesInDecreasingDepth = [];
        var buildMapOfGraph = function (tensor, finishedNodes, nodesInProgress, layer, nodeIndex, tensorIndex) {
            if (layer == null || nodeIndex == null || tensorIndex == null) {
                layer = tensor.sourceLayer;
                nodeIndex = tensor.nodeIndex;
                tensorIndex = tensor.tensorIndex;
            }
            var node = layer.inboundNodes[nodeIndex];
            if (nodesInProgress.indexOf(node) !== -1) {
                throw new errors_1.RuntimeError("The tensor " + tensor.name + " at layer \"" + layer.name + "\" " +
                    'is part of a cycle.');
            }
            if (finishedNodes.indexOf(node) !== -1) {
                return;
            }
            _this.containerNodes.add(Container.nodeKey(layer, nodeIndex));
            if (!(layer.id in layerIndices)) {
                layerIndices[layer.id] = Object.keys(layerIndices).length;
            }
            if (nodesInProgress.indexOf(node) === -1) {
                nodesInProgress.push(node);
            }
            var numInboundLayers = node.inboundLayers.length;
            for (var i = 0; i < numInboundLayers; i++) {
                var x = node.inputTensors[i];
                var layer_1 = node.inboundLayers[i];
                var nodeIndex_1 = node.nodeIndices[i];
                var tensorIndex_1 = node.tensorIndices[i];
                buildMapOfGraph(x, finishedNodes, nodesInProgress, layer_1, nodeIndex_1, tensorIndex_1);
            }
            finishedNodes.push(node);
            while (nodesInProgress.indexOf(node) >= 0) {
                nodesInProgress.splice(nodesInProgress.indexOf(node), 1);
            }
            nodesInDecreasingDepth.push(node);
        };
        var finishedNodes = [];
        var nodesInProgress = [];
        for (var _f = 0, _g = _this.outputs; _f < _g.length; _f++) {
            var x = _g[_f];
            buildMapOfGraph(x, finishedNodes, nodesInProgress);
        }
        var reversedNodesInDecreasingDepth = nodesInDecreasingDepth.slice().reverse();
        for (var _h = 0, reversedNodesInDecreasingDepth_1 = reversedNodesInDecreasingDepth; _h < reversedNodesInDecreasingDepth_1.length; _h++) {
            var node = reversedNodesInDecreasingDepth_1[_h];
            nodeIDToNode[node.id] = node;
            if (!(node.id in nodesDepths)) {
                nodesDepths[node.id] = 0;
            }
            var depth = nodesDepths[node.id];
            var previousDepth = (layersDepths[node.outboundLayer.id] == null ?
                0 :
                layersDepths[node.outboundLayer.id]);
            depth = Math.max(depth, previousDepth);
            layersDepths[node.outboundLayer.id] = depth;
            layerIDToLayer[node.outboundLayer.id] = node.outboundLayer;
            nodesDepths[node.id] = depth;
            for (var i = 0; i < node.inboundLayers.length; i++) {
                var inboundLayer = node.inboundLayers[i];
                var nodeIndex = node.nodeIndices[i];
                var inboundNode = inboundLayer.inboundNodes[nodeIndex];
                var previousDepth_1 = (nodesDepths[inboundNode.id] == null ? 0 :
                    nodesDepths[inboundNode.id]);
                nodesDepths[inboundNode.id] = Math.max(depth + 1, previousDepth_1);
                nodeIDToNode[inboundNode.id] = inboundNode;
            }
        }
        var nodesByDepth = {};
        for (var nodeID in nodesDepths) {
            var depth = nodesDepths[nodeID];
            if (!(depth in nodesByDepth)) {
                nodesByDepth[depth] = [];
            }
            nodesByDepth[depth].push(nodeIDToNode[nodeID]);
        }
        var layersByDepth = {};
        for (var layerID in layersDepths) {
            var depth = layersDepths[layerID];
            if (!(depth in layersByDepth)) {
                layersByDepth[depth] = [];
            }
            layersByDepth[depth].push(layerIDToLayer[layerID]);
        }
        var depthKeys = Object.keys(layersByDepth)
            .map(function (x) { return parseInt(x, 10); })
            .sort(generic_utils.reverseNumberCompare);
        _this.layers = [];
        for (var _j = 0, depthKeys_1 = depthKeys; _j < depthKeys_1.length; _j++) {
            var depth = depthKeys_1[_j];
            var layersForDepth = layersByDepth[depth];
            layersForDepth.sort(function (a, b) {
                var aIndex = layerIndices[a.id];
                var bIndex = layerIndices[b.id];
                if (aIndex < bIndex) {
                    return -1;
                }
                if (aIndex > bIndex) {
                    return 1;
                }
                return 0;
            });
            for (var _k = 0, layersForDepth_1 = layersForDepth; _k < layersForDepth_1.length; _k++) {
                var layer = layersForDepth_1[_k];
                _this.layers.push(layer);
            }
        }
        _this.layersByDepth = layersByDepth;
        depthKeys = Object.keys(nodesByDepth)
            .map(function (x) { return parseInt(x, 10); })
            .sort(generic_utils.reverseNumberCompare);
        var computableTensors = _this.inputs.slice();
        var layersWithCompleteInput = [];
        for (var _l = 0, depthKeys_2 = depthKeys; _l < depthKeys_2.length; _l++) {
            var depth = depthKeys_2[_l];
            for (var _m = 0, _o = nodesByDepth[depth]; _m < _o.length; _m++) {
                var node = _o[_m];
                var layer = node.outboundLayer;
                if (layer != null) {
                    for (var _p = 0, _q = node.inputTensors; _p < _q.length; _p++) {
                        var x = _q[_p];
                        if (computableTensors.indexOf(x) === -1) {
                            throw new errors_1.RuntimeError("Graph disconnected: cannot obtain value for tensor " + x +
                                (" at layer \"" + layer.name + "\". ") +
                                'The following previous layers were accessed without ' +
                                ("issue: " + layersWithCompleteInput));
                        }
                    }
                    for (var _r = 0, _s = node.outputTensors; _r < _s.length; _r++) {
                        var x = _s[_r];
                        computableTensors.push(x);
                    }
                    layersWithCompleteInput.push(layer.name);
                }
            }
        }
        _this.nodesByDepth = nodesByDepth;
        var allNames = _this.layers.map(function (x) { return x.name; });
        var _loop_1 = function (name_4) {
            var numOccurrences = allNames.filter(function (x) { return x === name_4; }).length;
            if (numOccurrences !== 1) {
                throw new errors_1.RuntimeError("The name \"" + name_4 + "\" is used " + numOccurrences + " times " +
                    'in the model. All layer names should be unique. Layer names: ' +
                    JSON.stringify(allNames));
            }
        };
        for (var _t = 0, allNames_1 = allNames; _t < allNames_1.length; _t++) {
            var name_4 = allNames_1[_t];
            _loop_1(name_4);
        }
        _this.outboundNodes = [];
        _this.inboundNodes = [];
        new topology_1.Node({
            outboundLayer: _this,
            inboundLayers: [],
            nodeIndices: [],
            tensorIndices: [],
            inputTensors: _this.inputs,
            outputTensors: _this.outputs,
            inputMasks: _this.inputs.map(function (x) { return null; }),
            outputMasks: _this.outputs.map(function (x) { return null; }),
            inputShapes: _this.inputs.map(function (x) { return x.shape; }),
            outputShapes: _this.outputs.map(function (x) { return x.shape; })
        });
        _this.built = true;
        _this._refCount = 1;
        return _this;
    }
    Container.prototype.assertNotDisposed = function () {
        if (this._refCount === 0) {
            throw new Error("Container '" + this.name + "' is already disposed.");
        }
    };
    Container.prototype.dispose = function () {
        this.assertNotDisposed();
        var result = { refCountAfterDispose: null, numDisposedVariables: 0 };
        if (--this._refCount === 0) {
            for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                result.numDisposedVariables += layer.dispose().numDisposedVariables;
            }
        }
        result.refCountAfterDispose = this._refCount;
        return result;
    };
    Object.defineProperty(Container.prototype, "trainableWeights", {
        get: function () {
            if (this._trainableWeights.length > 0) {
                throw new errors_1.ValueError('Container instance unexpectedly contains _trainableWeights.' +
                    'The trainable weights of a Container are a union of the ' +
                    'trainable weights of its consituent Layers. Its own ' +
                    '_trainableWeights must remain an empty Array.');
            }
            if (!this.trainable) {
                return [];
            }
            var weights = [];
            for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                weights = weights.concat(layer.trainableWeights);
            }
            return weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "nonTrainableWeights", {
        get: function () {
            var weights = [];
            for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                weights.push.apply(weights, layer.nonTrainableWeights);
            }
            if (!this.trainable) {
                var trainableWeights = [];
                for (var _b = 0, _c = this.layers; _b < _c.length; _b++) {
                    var layer = _c[_b];
                    trainableWeights.push.apply(trainableWeights, layer.trainableWeights);
                }
                return trainableWeights.concat(weights);
            }
            return weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "weights", {
        get: function () {
            return this.trainableWeights.concat(this.nonTrainableWeights);
        },
        enumerable: true,
        configurable: true
    });
    Container.prototype.loadWeights = function (weightsJSON, skipMismatch, isNamedTensorMap, strict) {
        if (skipMismatch === void 0) { skipMismatch = false; }
        if (isNamedTensorMap === void 0) { isNamedTensorMap = false; }
        if (strict === void 0) { strict = true; }
        if (isNamedTensorMap) {
            loadWeightsFromNamedTensorMap(weightsJSON, this.layers, strict);
        }
        else {
            loadWeightsFromJson(weightsJSON, this.layers, skipMismatch);
        }
    };
    Container.prototype.updatedConfig = function () {
        var theConfig = this.getConfig();
        var modelConfig = {
            className: this.getClassName(),
            config: theConfig,
            kerasVersion: "tfjs-layers " + version_1.version,
            backend: 'TensorFlow.js'
        };
        return modelConfig;
    };
    Container.prototype.toJSON = function (unused, returnString) {
        if (returnString === void 0) { returnString = true; }
        var modelConfig = serialization_utils_1.convertTsToPythonic(this.updatedConfig());
        return returnString ? JSON.stringify(modelConfig) : modelConfig;
    };
    Container.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.toList(inputs);
            var masks;
            if ('mask' in kwargs) {
                masks = generic_utils.toList(kwargs['mask']);
            }
            else {
                masks = generic_utils.pyListRepeat(null, inputs.length);
            }
            return _this.runInternalGraph(inputs, masks)[0];
        });
    };
    Container.prototype.computeMask = function (inputs, mask) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.toList(inputs);
            var masks;
            if (mask == null) {
                masks = generic_utils.pyListRepeat(null, inputs.length);
            }
            else {
                masks = generic_utils.toList(mask);
            }
            return _this.runInternalGraph(inputs, masks)[1];
        });
    };
    Container.prototype.computeOutputShape = function (inputShape) {
        var inputShapes = types_utils.normalizeShapeList(inputShape);
        if (inputShapes.length !== this.inputLayers.length) {
            throw new errors_1.ValueError("Invalid inputShape argument " + inputShape + ": " +
                ("model has " + this.inputLayers.length + " tensor inputs."));
        }
        var layersToOutputShapes = {};
        for (var i = 0; i < inputShapes.length; i++) {
            var layer = this.inputLayers[i];
            var inputShape_1 = inputShapes[i];
            var shapeKey = layer.name + '_0_0';
            layersToOutputShapes[shapeKey] = inputShape_1;
        }
        var depthKeys = Object.keys(this.nodesByDepth)
            .map(function (x) { return parseInt(x, 10); })
            .sort(generic_utils.reverseNumberCompare);
        if (depthKeys.length > 1) {
            for (var _i = 0, depthKeys_3 = depthKeys; _i < depthKeys_3.length; _i++) {
                var depth = depthKeys_3[_i];
                var nodes = this.nodesByDepth[depth];
                for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {
                    var node = nodes_1[_a];
                    var layer = node.outboundLayer;
                    if (this.inputLayers.map(function (x) { return x.id; }).indexOf(layer.id) !== -1) {
                        continue;
                    }
                    var inputShapes_1 = [];
                    for (var j = 0; j < node.inboundLayers.length; j++) {
                        var inboundLayer = node.inboundLayers[j];
                        var nodeIndex_2 = node.nodeIndices[j];
                        var tensorIndex = node.tensorIndices[j];
                        var shapeKey = inboundLayer.name + "_" + nodeIndex_2 + "_" + tensorIndex;
                        var inputShape_2 = layersToOutputShapes[shapeKey];
                        inputShapes_1.push(inputShape_2);
                    }
                    var outputShape = layer.computeOutputShape(generic_utils.singletonOrArray(inputShapes_1));
                    var outputShapes_1 = types_utils.normalizeShapeList(outputShape);
                    var nodeIndex = layer.inboundNodes.indexOf(node);
                    for (var j = 0; j < outputShapes_1.length; j++) {
                        var shapeKey = layer.name + "_" + nodeIndex + "_" + j;
                        layersToOutputShapes[shapeKey] = outputShapes_1[j];
                    }
                }
            }
        }
        var outputShapes = [];
        var outputShapeKeys = [];
        for (var i = 0; i < this.outputLayers.length; i++) {
            var layer = this.outputLayers[i];
            var nodeIndex = this.outputLayersNodeIndices[i];
            var tensorIndex = this.outputLayersTensorIndices[i];
            var shapeKey = layer.name + "_" + nodeIndex + "_" + tensorIndex;
            outputShapeKeys.push(shapeKey);
        }
        for (var i = 0; i < outputShapeKeys.length; i++) {
            var key = outputShapeKeys[i];
            generic_utils.assert(key in layersToOutputShapes);
            outputShapes.push(layersToOutputShapes[key]);
        }
        return generic_utils.singletonOrArray(outputShapes);
    };
    Container.prototype.runInternalGraph = function (inputs, masks) {
        if (masks == null) {
            masks = generic_utils.pyListRepeat(null, inputs.length);
        }
        var tensorMap = {};
        for (var i = 0; i < this.inputs.length; ++i) {
            var x = this.inputs[i];
            var y = inputs[i];
            var mask = masks[i];
            tensorMap[x.id] = [y, mask];
        }
        var depthKeys = Object.keys(this.nodesByDepth)
            .map(function (x) { return parseInt(x, 10); })
            .sort(generic_utils.reverseNumberCompare);
        for (var _i = 0, depthKeys_4 = depthKeys; _i < depthKeys_4.length; _i++) {
            var depth = depthKeys_4[_i];
            var nodes = this.nodesByDepth[depth];
            for (var _a = 0, nodes_2 = nodes; _a < nodes_2.length; _a++) {
                var node = nodes_2[_a];
                var layer = node.outboundLayer;
                var referenceInputTensors = node.inputTensors;
                var referenceOutputTensors = node.outputTensors;
                var computedData = new Array();
                for (var _b = 0, referenceInputTensors_1 = referenceInputTensors; _b < referenceInputTensors_1.length; _b++) {
                    var x = referenceInputTensors_1[_b];
                    if (x.id in tensorMap) {
                        computedData.push(tensorMap[x.id]);
                    }
                }
                if (computedData.length === referenceInputTensors.length) {
                    var kwargs = {};
                    var computedTensors = void 0;
                    var computedMasks = void 0;
                    var outputTensors_1 = void 0;
                    var outputMasks_1 = void 0;
                    if (node.callArgs != null) {
                        kwargs = node.callArgs;
                    }
                    if (computedData.length === 1) {
                        var _c = computedData[0], computedTensor = _c[0], computedMask = _c[1];
                        if (kwargs.mask == null) {
                            kwargs['mask'] = computedMask;
                        }
                        outputTensors_1 =
                            generic_utils.toList(layer.call(computedTensor, kwargs));
                        outputMasks_1 = generic_utils.toList(layer.computeMask(computedTensor, computedMask));
                        computedTensors = [computedTensor];
                        computedMasks = [computedMask];
                    }
                    else {
                        computedTensors = computedData.map(function (x) { return x[0]; });
                        computedMasks = computedData.map(function (x) { return x[1]; });
                        if (kwargs.mask == null) {
                            kwargs['mask'] = computedMasks;
                        }
                        outputTensors_1 =
                            generic_utils.toList(layer.call(computedTensors, kwargs));
                        outputMasks_1 = generic_utils.toList(layer.computeMask(computedTensors, computedMasks));
                    }
                    if (layer.activityRegularizer) {
                        throw new errors_1.NotImplementedError('Model invocation with concrete Tensor value(s) in the ' +
                            'presence of activity regularizer(s) is not supported yet.');
                    }
                    for (var i = 0; i < referenceOutputTensors.length; ++i) {
                        var x = referenceOutputTensors[i];
                        var y = outputTensors_1[i];
                        var mask = outputMasks_1[i];
                        tensorMap[x.id] = [y, mask];
                    }
                }
            }
        }
        var outputTensors = [];
        var outputMasks = [];
        var outputShapes = [];
        for (var _d = 0, _e = this.outputs; _d < _e.length; _d++) {
            var x = _e[_d];
            generic_utils.assert(x.id in tensorMap, "Could not compute output " + x.name + " : " + x.id);
            var _f = tensorMap[x.id], tensor = _f[0], mask = _f[1];
            outputShapes.push(tensor.shape);
            outputTensors.push(tensor);
            outputMasks.push(mask);
        }
        return [outputTensors, outputMasks, outputShapes];
    };
    Container.prototype.buildNodeConversionMap = function (layers) {
        var nodeConversionMap = {};
        var keptNodes;
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            keptNodes = layer instanceof Container ? 1 : 0;
            for (var originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
                var nodeKey = Container.nodeKey(layer, originalNodeIndex);
                if (nodeKey in this.containerNodes) {
                    nodeConversionMap[nodeKey] = keptNodes;
                    keptNodes += 1;
                }
            }
        }
        return nodeConversionMap;
    };
    Container.prototype.getLayer = function (name, index) {
        if (index != null) {
            if (this.layers.length <= index) {
                throw new errors_1.ValueError("Was asked to retrieve layer at index " + index + ", but model only " +
                    ("has " + this.layers.length + " layer(s)."));
            }
            else {
                return this.layers[index];
            }
        }
        else {
            if (name == null) {
                throw new errors_1.ValueError('Provide either a layer name or layer index');
            }
        }
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            if (layer.name === name) {
                return layer;
            }
        }
        throw new errors_1.ValueError("No such layer: " + name);
    };
    Container.prototype.calculateLosses = function () {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var losses = [];
            for (var _i = 0, _a = _this.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                for (var nodeIndex = 0; nodeIndex < layer.inboundNodes.length; ++nodeIndex) {
                    var nodeKey = Container.nodeKey(layer, nodeIndex);
                    if (_this.containerNodes.has(nodeKey)) {
                        losses.push.apply(losses, layer.calculateLosses());
                    }
                }
            }
            return losses;
        });
    };
    Container.prototype.getConfig = function () {
        var config = { name: this.name };
        var nodeConversionMap = this.buildNodeConversionMap(this.layers);
        var layerConfigs = [];
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            var layerClassName = layer.getClassName();
            var layerConfig = layer.getConfig();
            var filteredInboundNodes = [];
            for (var originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
                var node = layer.inboundNodes[originalNodeIndex];
                var nodeKey = Container.nodeKey(layer, originalNodeIndex);
                var kwargs = {};
                if (this.containerNodes.has(nodeKey)) {
                    if (node.callArgs) {
                        try {
                            JSON.stringify(node.callArgs);
                            kwargs = node.callArgs;
                        }
                        catch (err) {
                            console.warn("Layer " + layer.name + " was passed " +
                                "non-serializable keyword arguments: " +
                                (node.callArgs + ". They will not be included ") +
                                "in the serialized model (and thus will be " +
                                "missing at deserialization time).");
                            kwargs = {};
                        }
                    }
                    if (node.inboundLayers.length > 0) {
                        var nodeData = [];
                        for (var i = 0; i < node.inboundLayers.length; i++) {
                            var inboundLayer = node.inboundLayers[i];
                            var nodeIndex = node.nodeIndices[i];
                            var tensorIndex = node.tensorIndices[i];
                            var nodeKey_1 = Container.nodeKey(inboundLayer, nodeIndex);
                            var newNodeIndex = nodeConversionMap[nodeKey_1];
                            if (newNodeIndex === null || newNodeIndex === undefined) {
                                newNodeIndex = 0;
                            }
                            nodeData.push([inboundLayer.name, newNodeIndex, tensorIndex, kwargs]);
                        }
                        filteredInboundNodes.push(nodeData);
                    }
                }
            }
            layerConfigs.push({
                name: layer.name,
                className: layerClassName,
                config: layerConfig,
                inboundNodes: filteredInboundNodes
            });
        }
        config['layers'] = layerConfigs;
        var modelInputs = [];
        for (var i = 0; i < this.inputLayers.length; i++) {
            var layer = this.inputLayers[i];
            var nodeIndex = this.inputLayersNodeIndices[i];
            var nodeKey = Container.nodeKey(layer, nodeIndex);
            if (!this.containerNodes.has(nodeKey)) {
                continue;
            }
            var newNodeIndex = nodeConversionMap[nodeKey];
            if (newNodeIndex === null || newNodeIndex === undefined) {
                newNodeIndex = 0;
            }
            var tensorIndex = this.inputLayersTensorIndices[i];
            modelInputs.push([layer.name, newNodeIndex, tensorIndex]);
        }
        config['inputLayers'] = modelInputs;
        var modelOutputs = [];
        for (var i = 0; i < this.outputLayers.length; i++) {
            var layer = this.outputLayers[i];
            var nodeIndex = this.outputLayersNodeIndices[i];
            var nodeKey = Container.nodeKey(layer, nodeIndex);
            if (!this.containerNodes.has(nodeKey)) {
                continue;
            }
            var newNodeIndex = nodeConversionMap[nodeKey];
            if (newNodeIndex === null || newNodeIndex === undefined) {
                newNodeIndex = 0;
            }
            var tensorIndex = this.outputLayersTensorIndices[i];
            modelOutputs.push([layer.name, newNodeIndex, tensorIndex]);
        }
        config['outputLayers'] = modelOutputs;
        return config;
    };
    Container.fromConfig = function (cls, config) {
        var createdLayers = {};
        var unprocessedNodes = {};
        function addUnprocessedNode(layer, nodeData) {
            if (!(layer.name in unprocessedNodes)) {
                unprocessedNodes[layer.name] = [nodeData];
            }
            else {
                unprocessedNodes[layer.name].push(nodeData);
            }
        }
        function processNode(layer, nodeData) {
            var inputTensors = [];
            var kwargs;
            for (var _i = 0, nodeData_1 = nodeData; _i < nodeData_1.length; _i++) {
                var inputData = nodeData_1[_i];
                var inboundLayerName = inputData[0];
                var inboundNodeIndex = inputData[1];
                var inboundTensorIndex = inputData[2];
                if (inputData.length === 3) {
                    kwargs = {};
                }
                else if (inputData.length === 4) {
                    kwargs = inputData[3];
                }
                else {
                    throw new errors_1.ValueError("Improperly formatted model config for layer " + JSON.stringify(layer) + ": " + JSON.stringify(inputData));
                }
                if (!(inboundLayerName in createdLayers)) {
                    addUnprocessedNode(layer, nodeData);
                    return;
                }
                var inboundLayer = createdLayers[inboundLayerName];
                if (inboundLayer.inboundNodes.length <= inboundNodeIndex) {
                    addUnprocessedNode(layer, nodeData);
                    return;
                }
                var inboundNode = inboundLayer.inboundNodes[inboundNodeIndex];
                inputTensors.push(inboundNode.outputTensors[inboundTensorIndex]);
            }
            if (inputTensors.length > 0) {
                layer.apply(generic_utils.singletonOrArray(inputTensors), kwargs);
            }
        }
        function processLayer(layerData) {
            var layerName = layerData.name;
            var layer = serialization_1.deserialize(layerData, config.customObjects != null ?
                config.customObjects :
                {});
            createdLayers[layerName] = layer;
            var inboundNodesData = layerData.inboundNodes;
            for (var _i = 0, inboundNodesData_1 = inboundNodesData; _i < inboundNodesData_1.length; _i++) {
                var nodeData = inboundNodesData_1[_i];
                if (!(nodeData instanceof Array)) {
                    throw new errors_1.ValueError("Corrupted configuration, expected array for nodeData: " + nodeData);
                }
                addUnprocessedNode(layer, nodeData);
            }
        }
        var name = config.name;
        var layersFromConfig = config.layers;
        for (var _i = 0, layersFromConfig_1 = layersFromConfig; _i < layersFromConfig_1.length; _i++) {
            var layerData = layersFromConfig_1[_i];
            processLayer(layerData);
        }
        while (!generic_utils.isObjectEmpty(unprocessedNodes)) {
            for (var _a = 0, layersFromConfig_2 = layersFromConfig; _a < layersFromConfig_2.length; _a++) {
                var layerData = layersFromConfig_2[_a];
                var layer = createdLayers[layerData.name];
                if (layer.name in unprocessedNodes) {
                    for (var _b = 0, _c = unprocessedNodes[layer.name]; _b < _c.length; _b++) {
                        var nodeData = _c[_b];
                        processNode(layer, nodeData);
                    }
                    delete unprocessedNodes[layer.name];
                }
            }
        }
        var inputTensors = [];
        var outputTensors = [];
        var inputLayersFromConfig = config.inputLayers;
        for (var _d = 0, inputLayersFromConfig_1 = inputLayersFromConfig; _d < inputLayersFromConfig_1.length; _d++) {
            var layerData = inputLayersFromConfig_1[_d];
            var layerName = layerData[0];
            var nodeIndex = layerData[1];
            var tensorIndex = layerData[2];
            generic_utils.assert(layerName in createdLayers);
            var layer = createdLayers[layerName];
            var layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
            inputTensors.push(layerOutputTensors[tensorIndex]);
        }
        var outputLayersFromConfig = config.outputLayers;
        for (var _e = 0, outputLayersFromConfig_1 = outputLayersFromConfig; _e < outputLayersFromConfig_1.length; _e++) {
            var layerData = outputLayersFromConfig_1[_e];
            var layerName = layerData[0];
            var nodeIndex = layerData[1];
            var tensorIndex = layerData[2];
            generic_utils.assert(layerName in createdLayers);
            var layer = createdLayers[layerName];
            var layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
            outputTensors.push(layerOutputTensors[tensorIndex]);
        }
        return new cls({ inputs: inputTensors, outputs: outputTensors, name: name });
    };
    Object.defineProperty(Container.prototype, "stateful", {
        get: function () {
            if (this._stateful) {
                throw new errors_1.ValueError('Container instance unexpectedly has _stateful = true. The ' +
                    'statefulness of a Container is determined by the Layers it ' +
                    'contains. Its _stateful property must remain the default false.');
            }
            for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                if (layer.stateful) {
                    return true;
                }
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Container.prototype.resetStates = function () {
        var _this = this;
        tfjs_core_1.tidy(function () {
            _this.layers.forEach(function (layer) {
                if (layer.stateful) {
                    layer.resetStates();
                }
            });
        });
    };
    return Container;
}(topology_1.Layer));
exports.Container = Container;

},{"../backend/state":208,"../errors":222,"../layers/serialization":241,"../utils/generic_utils":250,"../utils/serialization_utils":253,"../utils/types_utils":254,"../variables":256,"../version":257,"./input_layer":217,"./topology":218,"@tensorflow/tfjs-core":64}],215:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LazyIterator = (function () {
    function LazyIterator() {
    }
    return LazyIterator;
}());
exports.LazyIterator = LazyIterator;
var Dataset = (function () {
    function Dataset() {
    }
    return Dataset;
}());
exports.Dataset = Dataset;

},{}],216:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var errors_1 = require("../errors");
var input_layer_1 = require("./input_layer");
function assertFeedCompatibility(key, val) {
    if (key.shape != null) {
        if (key.shape.length !== val.shape.length) {
            throw new errors_1.ValueError("The rank of feed (" + val.shape.length + ") does not match the rank of " +
                ("the key (" + key.shape.length + ")."));
        }
        for (var i = 0; i < key.shape.length; ++i) {
            if (key.shape[i] != null && key.shape[i] !== val.shape[i]) {
                throw new errors_1.ValueError("The " + i + "-th dimension of the feed (" + val.shape[i] + ") is " +
                    ("incompatible with that of the key (" + key.shape[i] + ")."));
            }
        }
    }
    if (key.dtype == null || key.dtype === val.dtype) {
        return val;
    }
    try {
        return tfjs_core_1.cast(val, key.dtype);
    }
    catch (err) {
        throw new errors_1.ValueError("The dtype of the feed (" + val.dtype + ") can not be cast to the dtype " +
            ("of the key '" + key.name + "' (" + key.dtype + ")."));
    }
}
var FeedDict = (function () {
    function FeedDict(feeds) {
        this.id2Value = {};
        if (feeds instanceof FeedDict) {
            for (var id in feeds.id2Value) {
                this.id2Value[id] = feeds.id2Value[id];
            }
        }
        else {
            if (feeds == null) {
                return;
            }
            for (var _i = 0, feeds_1 = feeds; _i < feeds_1.length; _i++) {
                var feed = feeds_1[_i];
                this.add(feed.key, feed.value);
            }
        }
    }
    FeedDict.prototype.add = function (key, value) {
        if (this.id2Value[key.id] == null) {
            this.id2Value[key.id] = assertFeedCompatibility(key, value);
        }
        else {
            throw new errors_1.ValueError("Duplicate key: name=" + key.name + ", id=" + key.id);
        }
        return this;
    };
    FeedDict.prototype.addFeed = function (feed) {
        this.add(feed.key, feed.value);
    };
    FeedDict.prototype.hasKey = function (key) {
        return this.id2Value[key.id] != null;
    };
    FeedDict.prototype.getValue = function (key) {
        if (this.id2Value[key.id] == null) {
            throw new errors_1.ValueError("Nonexistent key: " + JSON.stringify(key));
        }
        else {
            return this.id2Value[key.id];
        }
    };
    return FeedDict;
}());
exports.FeedDict = FeedDict;
function execute(fetches, feedDict, kwargs) {
    var arrayFetches = Array.isArray(fetches);
    var fetchArray = arrayFetches ? fetches : [fetches];
    var outputs = [];
    var internalFeedDict = new FeedDict(feedDict);
    for (var _i = 0, fetchArray_1 = fetchArray; _i < fetchArray_1.length; _i++) {
        var fetch_1 = fetchArray_1[_i];
        outputs.push(executeInternal(fetch_1, internalFeedDict, kwargs));
    }
    return arrayFetches ? outputs : outputs[0];
}
exports.execute = execute;
function executeInternal(fetch, internalFeedDict, kwargs) {
    if (internalFeedDict.hasKey(fetch)) {
        return internalFeedDict.getValue(fetch);
    }
    if (fetch.sourceLayer instanceof input_layer_1.InputLayer) {
        throw new errors_1.ValueError("Missing a feed value for SymbolicTensor from InputLayer " +
            ("'" + input_layer_1.InputLayer.name + "'"));
    }
    var inputs = fetch.inputs;
    var inputValues = [];
    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
        var input = inputs_1[_i];
        var inputVal = executeInternal(input, internalFeedDict, kwargs);
        inputValues.push(inputVal);
    }
    var output = fetch.sourceLayer.apply(inputValues, kwargs);
    if (!Array.isArray(output)) {
        output = [output];
    }
    var layerOutputs = getNodeOutputs(fetch);
    var outputSymbolicTensors = Array.isArray(layerOutputs) ? layerOutputs : [layerOutputs];
    for (var i = 0; i < outputSymbolicTensors.length; ++i) {
        internalFeedDict.add(outputSymbolicTensors[i], output[i]);
    }
    return output.length === 1 ? output[0] : output[fetch.outputTensorIndex];
}
function getNodeOutputs(fetch) {
    var layerOutputs;
    if (fetch.sourceLayer.inboundNodes.length === 1) {
        layerOutputs = fetch.sourceLayer.output;
    }
    else {
        var nodeIndex = null;
        for (var i = 0; i < fetch.sourceLayer.inboundNodes.length; ++i) {
            for (var _i = 0, _a = fetch.sourceLayer.inboundNodes[i]
                .outputTensors; _i < _a.length; _i++) {
                var outputTensor = _a[_i];
                if (outputTensor.id === fetch.id) {
                    nodeIndex = i;
                    break;
                }
            }
        }
        layerOutputs = fetch.sourceLayer.getOutputAt(nodeIndex);
    }
    return layerOutputs;
}

},{"../errors":222,"./input_layer":217,"@tensorflow/tfjs-core":64}],217:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var state_1 = require("../backend/state");
var errors_1 = require("../errors");
var topology_1 = require("./topology");
var InputLayer = (function (_super) {
    __extends(InputLayer, _super);
    function InputLayer(config) {
        var _this = _super.call(this, {
            dtype: config.dtype,
            name: config.name != null ? config.name : state_1.getUid('input').toString()
        }) || this;
        if (config.batchSize == null) {
            config.batchSize = null;
        }
        if (config.sparse == null) {
            config.sparse = false;
        }
        _this.trainable = false;
        _this.built = true;
        _this.sparse = config.sparse;
        if (config.inputShape != null && config.batchInputShape != null) {
            throw new errors_1.ValueError('Only provide the inputShape OR ' +
                'batchInputShape argument to inputLayer, not both at the same time.');
        }
        var batchInputShape = config.batchInputShape;
        if (batchInputShape == null) {
            if (config.inputShape == null) {
                throw new errors_1.ValueError('An InputLayer should be passed either a ' +
                    '`batchInputShape` or an `inputShape`.');
            }
            else {
                batchInputShape = [config.batchSize].concat(config.inputShape);
            }
        }
        else {
            if (config.batchSize != null) {
                throw new errors_1.ValueError('Cannot specify batchSize if batchInputShape is' +
                    'specified when creating an InputLayer.');
            }
        }
        var dtype = config.dtype || 'float32';
        _this.batchInputShape = batchInputShape;
        _this.dtype = dtype;
        _this.inputSpec = [{ shape: batchInputShape }];
        var inputTensor = new topology_1.SymbolicTensor(_this.dtype, _this.batchInputShape, _this, [], {}, _this.name);
        inputTensor.nodeIndex = 0;
        inputTensor.tensorIndex = 0;
        new topology_1.Node({
            outboundLayer: _this,
            inboundLayers: [],
            nodeIndices: [],
            tensorIndices: [],
            inputTensors: [inputTensor],
            outputTensors: [inputTensor],
            inputMasks: [null],
            outputMasks: [null],
            inputShapes: [batchInputShape],
            outputShapes: [batchInputShape]
        });
        return _this;
    }
    InputLayer.prototype.apply = function (inputs, kwargs) {
        throw new errors_1.ValueError('Cannot pass any input to an ' +
            ("InputLayer's apply() method. InputLayer name: " + this.name));
    };
    InputLayer.prototype.dispose = function () {
        return {
            refCountAfterDispose: this._refCount,
            numDisposedVariables: 0
        };
    };
    InputLayer.prototype.getConfig = function () {
        return {
            batchInputShape: this.batchInputShape,
            dtype: this.dtype,
            sparse: this.sparse,
            name: this.name
        };
    };
    InputLayer.className = 'InputLayer';
    return InputLayer;
}(topology_1.Layer));
exports.InputLayer = InputLayer;
tfjs_core_1.serialization.registerClass(InputLayer);
function Input(config) {
    if (config.batchShape == null && config.shape == null) {
        throw new Error('Please provide to Input either a `shape`' +
            ' or a `batchShape` argument. Note that ' +
            '`shape` does not include the batch ' +
            'dimension.');
    }
    if (config.batchShape != null && config.shape != null) {
        throw new errors_1.ValueError('Please provide either a `shape` or `batchShape` ' +
            'argument to Input, but not both.');
    }
    var batchShape = config.batchShape;
    if (config.shape != null && batchShape == null) {
        batchShape = [null].concat(config.shape);
    }
    var dtype = config.dtype;
    if (dtype == null) {
        dtype = 'float32';
    }
    var inputLayer = new InputLayer({
        batchInputShape: batchShape,
        name: config.name,
        dtype: dtype,
        sparse: config.sparse
    });
    var outputs = inputLayer.inboundNodes[0].outputTensors;
    return outputs[0];
}
exports.Input = Input;

},{"../backend/state":208,"../errors":222,"./topology":218,"@tensorflow/tfjs-core":64}],218:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var state_1 = require("../backend/state");
var common_1 = require("../common");
var errors_1 = require("../errors");
var generic_utils = require("../utils/generic_utils");
var types_utils = require("../utils/types_utils");
var variable_utils = require("../utils/variable_utils");
var variables_1 = require("../variables");
var InputSpec = (function () {
    function InputSpec(config) {
        this.dtype = config.dtype;
        this.shape = config.shape;
        if (config.shape != null) {
            this.ndim = config.shape.length;
        }
        else {
            this.ndim = config.ndim;
        }
        this.maxNDim = config.maxNDim;
        this.minNDim = config.minNDim;
        this.axes = config.axes || {};
    }
    return InputSpec;
}());
exports.InputSpec = InputSpec;
var SymbolicTensor = (function () {
    function SymbolicTensor(dtype, shape, sourceLayer, inputs, callArgs, name, outputTensorIndex) {
        this.dtype = dtype;
        this.shape = shape;
        this.sourceLayer = sourceLayer;
        this.inputs = inputs;
        this.callArgs = callArgs;
        this.outputTensorIndex = outputTensorIndex;
        this.id = state_1.getNextUniqueTensorId();
        if (name != null) {
            this.originalName = common_1.getScopedTensorName(name);
            this.name = common_1.getUniqueTensorName(this.originalName);
        }
        this.rank = shape.length;
    }
    return SymbolicTensor;
}());
exports.SymbolicTensor = SymbolicTensor;
var _nextNodeID = 0;
var Node = (function () {
    function Node(config, callArgs) {
        this.callArgs = callArgs;
        this.id = _nextNodeID++;
        this.outboundLayer = config.outboundLayer;
        this.inboundLayers = config.inboundLayers;
        this.nodeIndices = config.nodeIndices;
        this.tensorIndices = config.tensorIndices;
        this.inputTensors = config.inputTensors;
        this.outputTensors = config.outputTensors;
        this.inputMasks = config.inputMasks;
        this.outputMasks = config.outputMasks;
        this.inputShapes = config.inputShapes;
        this.outputShapes = config.outputShapes;
        for (var _i = 0, _a = config.inboundLayers; _i < _a.length; _i++) {
            var layer = _a[_i];
            if (layer != null) {
                layer.outboundNodes.push(this);
            }
        }
        config.outboundLayer.inboundNodes.push(this);
    }
    Node.prototype.getConfig = function () {
        var inboundNames = [];
        for (var _i = 0, _a = this.inboundLayers; _i < _a.length; _i++) {
            var layer = _a[_i];
            if (layer != null) {
                inboundNames.push(layer.name);
            }
            else {
                inboundNames.push(null);
            }
        }
        return {
            outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
            inboundLayers: inboundNames,
            nodeIndices: this.nodeIndices,
            tensorIndices: this.tensorIndices
        };
    };
    return Node;
}());
exports.Node = Node;
var _nextLayerID = 0;
var Layer = (function (_super) {
    __extends(Layer, _super);
    function Layer(config) {
        var _this = _super.call(this) || this;
        _this._callHook = null;
        _this._addedWeightNames = [];
        _this._stateful = false;
        _this.id = _nextLayerID++;
        _this.activityRegularizer = null;
        _this.inputSpec = null;
        _this.supportsMasking = false;
        _this._trainableWeights = [];
        _this._nonTrainableWeights = [];
        _this._losses = [];
        _this._updates = [];
        _this._built = false;
        _this.inboundNodes = [];
        _this.outboundNodes = [];
        var name = config.name;
        if (!name) {
            var prefix = _this.getClassName();
            name = generic_utils.toSnakeCase(prefix) + '_' + state_1.getUid(prefix);
        }
        _this.name = name;
        _this.trainable = config.trainable == null ? true : config.trainable;
        _this.updatable = config.updatable == null ? true : config.updatable;
        if (config.inputShape != null || config.batchInputShape != null) {
            var batchInputShape = void 0;
            if (config.batchInputShape != null) {
                batchInputShape = config.batchInputShape;
            }
            else if (config.inputShape != null) {
                var batchSize = null;
                if (config.batchSize != null) {
                    batchSize = config.batchSize;
                }
                batchInputShape = [batchSize].concat(config.inputShape);
            }
            _this.batchInputShape = batchInputShape;
            var dtype = config.dtype;
            if (dtype == null) {
                dtype = config.inputDType;
            }
            if (dtype == null) {
                dtype = 'float32';
            }
            _this.dtype = dtype;
        }
        if (config.weights != null) {
            _this.initialWeights = config.weights;
        }
        else {
            _this.initialWeights = null;
        }
        _this._refCount = null;
        return _this;
    }
    Layer.nodeKey = function (layer, nodeIndex) {
        return layer.name + '_ib-' + nodeIndex.toString();
    };
    Layer.prototype.getNodeAtIndex = function (nodeIndex, attrName) {
        if (this.inboundNodes.length === 0) {
            throw new errors_1.RuntimeError('The layer has never been called ' +
                ("and thus has no defined " + attrName + "."));
        }
        if (this.inboundNodes.length <= nodeIndex) {
            throw new errors_1.ValueError("Asked to get " + attrName + " at node " + nodeIndex + ", " +
                ("but the layer has only " + this.inboundNodes.length + " inbound nodes."));
        }
        return this.inboundNodes[nodeIndex];
    };
    Layer.prototype.getInputAt = function (nodeIndex) {
        return generic_utils.singletonOrArray(this.getNodeAtIndex(nodeIndex, 'input').inputTensors);
    };
    Layer.prototype.getOutputAt = function (nodeIndex) {
        return generic_utils.singletonOrArray(this.getNodeAtIndex(nodeIndex, 'output').outputTensors);
    };
    Object.defineProperty(Layer.prototype, "input", {
        get: function () {
            if (this.inboundNodes.length > 1) {
                throw new errors_1.AttributeError("Layer " + this.name +
                    ' has multiple inbound nodes, ' +
                    'hence the notion of "layer input" ' +
                    'is ill-defined. ' +
                    'Use `getInputAt(nodeIndex)` instead.');
            }
            else if (this.inboundNodes.length === 0) {
                throw new errors_1.AttributeError("Layer " + this.name +
                    ' is not connected, no input to return.');
            }
            return generic_utils.singletonOrArray(this.getNodeAtIndex(0, 'input').inputTensors);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "output", {
        get: function () {
            if (this.inboundNodes.length === 0) {
                throw new errors_1.AttributeError("Layer " + this.name +
                    ' has no inbound nodes.');
            }
            if (this.inboundNodes.length > 1) {
                throw new errors_1.AttributeError("Layer " + this.name +
                    ' has multiple inbound nodes, ' +
                    'hence the notion of "layer output" ' +
                    'is ill-defined. ' +
                    'Use `getOutputAt(nodeIndex)` instead.');
            }
            return generic_utils.singletonOrArray(this.getNodeAtIndex(0, 'output').outputTensors);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "losses", {
        get: function () {
            return this._losses;
        },
        enumerable: true,
        configurable: true
    });
    Layer.prototype.calculateLosses = function () {
        return this.losses.map(function (lossFn) { return lossFn(); });
    };
    Object.defineProperty(Layer.prototype, "updates", {
        get: function () {
            return this._updates;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "built", {
        get: function () {
            return this._built;
        },
        set: function (built) {
            this._built = built;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "trainableWeights", {
        get: function () {
            if (this.trainable) {
                return this._trainableWeights;
            }
            else {
                return [];
            }
        },
        set: function (weights) {
            this._trainableWeights = weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "nonTrainableWeights", {
        get: function () {
            if (!this.trainable) {
                return this._trainableWeights.concat(this._nonTrainableWeights);
            }
            else {
                return this._nonTrainableWeights;
            }
        },
        set: function (weights) {
            this._nonTrainableWeights = weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "weights", {
        get: function () {
            return this.trainableWeights.concat(this.nonTrainableWeights);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "stateful", {
        get: function () {
            return this._stateful;
        },
        enumerable: true,
        configurable: true
    });
    Layer.prototype.resetStates = function () {
        if (!this.stateful) {
            throw new Error('Cannot call the resetStates() method of a non-stateful Layer ' +
                'object.');
        }
    };
    Layer.prototype.assertInputCompatibility = function (inputs) {
        inputs = generic_utils.toList(inputs);
        if (this.inputSpec == null || this.inputSpec.length === 0) {
            return;
        }
        var inputSpec = generic_utils.toList(this.inputSpec);
        if (inputs.length !== inputSpec.length) {
            throw new errors_1.ValueError("Layer " + this.name + " expects " + inputSpec.length + " inputs, " +
                ("but it received " + inputs.length + " input tensors. ") +
                ("Input received: " + inputs));
        }
        for (var inputIndex = 0; inputIndex < inputs.length; inputIndex++) {
            var x = inputs[inputIndex];
            var spec = inputSpec[inputIndex];
            if (spec == null) {
                continue;
            }
            var ndim = x.rank;
            if (spec.ndim != null) {
                if (ndim !== spec.ndim) {
                    throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name + ": " +
                        ("expected ndim=" + spec.ndim + ", found ndim=" + ndim));
                }
            }
            if (spec.maxNDim != null) {
                if (ndim > spec.maxNDim) {
                    throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name +
                        (": expected max_ndim=" + spec.maxNDim + ", found ndim=" + ndim));
                }
            }
            if (spec.minNDim != null) {
                if (ndim < spec.minNDim) {
                    throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name +
                        (": expected min_ndim=" + spec.minNDim + ", found ndim=" + ndim + "."));
                }
            }
            if (spec.dtype != null) {
                if (x.dtype !== spec.dtype) {
                    throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name + " " +
                        (": expected dtype=" + spec.dtype + ", found dtype=" + x.dtype + "."));
                }
            }
            if (spec.axes) {
                var xShape = x.shape;
                for (var key in spec.axes) {
                    var axis = Number(key);
                    var value = spec.axes[key];
                    var xShapeAtAxis = axis >= 0 ? xShape[axis] : xShape[xShape.length + axis];
                    if (value != null && [value, null].indexOf(xShapeAtAxis) === -1) {
                        throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " +
                            (this.name + ": expected axis " + axis + " of input shape to ") +
                            ("have value " + value + " but got shape " + xShape + "."));
                    }
                }
            }
            if (spec.shape != null) {
                for (var i = 0; i < spec.shape.length; ++i) {
                    var specDim = spec.shape[i];
                    var dim = x.shape[i];
                    if (specDim != null && dim != null) {
                        if (specDim !== dim) {
                            throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " +
                                (this.name + ": expected shape=" + spec.shape + ", ") +
                                'found shape=${xShape}.');
                        }
                    }
                }
            }
        }
    };
    Layer.prototype.call = function (inputs, kwargs) {
        return inputs;
    };
    Layer.prototype.invokeCallHook = function (inputs, kwargs) {
        if (this._callHook != null) {
            this._callHook(inputs, kwargs);
        }
    };
    Layer.prototype.setCallHook = function (callHook) {
        this._callHook = callHook;
    };
    Layer.prototype.clearCallHook = function () {
        this._callHook = null;
    };
    Layer.prototype.apply = function (inputs, kwargs) {
        var _this = this;
        kwargs = kwargs || {};
        this.assertNotDisposed();
        var inputsList = generic_utils.toList(inputs);
        var allAreSymbolic = true;
        for (var _i = 0, inputsList_1 = inputsList; _i < inputsList_1.length; _i++) {
            var input = inputsList_1[_i];
            if (!(input instanceof SymbolicTensor)) {
                allAreSymbolic = false;
                break;
            }
        }
        var noneAreSymbolic = true;
        for (var _a = 0, inputsList_2 = inputsList; _a < inputsList_2.length; _a++) {
            var input = inputsList_2[_a];
            if (input instanceof SymbolicTensor) {
                noneAreSymbolic = false;
                break;
            }
        }
        if (allAreSymbolic === noneAreSymbolic) {
            throw new errors_1.ValueError('Arguments to apply() must be all ' +
                'SymbolicTensors or all Tensors');
        }
        return common_1.nameScope(this.name, function () {
            if (!_this.built) {
                _this.assertInputCompatibility(inputs);
                var inputShapes = [];
                for (var _i = 0, _a = generic_utils.toList(inputs); _i < _a.length; _i++) {
                    var xElem = _a[_i];
                    inputShapes.push(xElem.shape);
                }
                _this.build(generic_utils.singletonOrArray(inputShapes));
                _this.built = true;
                if (_this.initialWeights) {
                    _this.setWeights(_this.initialWeights);
                }
                if (_this._refCount === null && noneAreSymbolic) {
                    _this._refCount = 1;
                }
            }
            _this.assertInputCompatibility(inputs);
            if (noneAreSymbolic) {
                var output = _this.call(inputs, kwargs);
                var outputList = generic_utils.toList(output);
                var outputListCopy = [];
                for (var _b = 0, outputList_1 = outputList; _b < outputList_1.length; _b++) {
                    var x = outputList_1[_b];
                    if (inputsList.indexOf(x) !== -1) {
                        x = x.clone();
                    }
                    outputListCopy.push(x);
                }
                output = generic_utils.singletonOrArray(outputListCopy);
                if (_this.activityRegularizer != null) {
                    throw new errors_1.NotImplementedError('Layer invocation in the presence of activity ' +
                        'regularizer(s) is not supported yet.');
                }
                return output;
            }
            else {
                var inputShape = collectInputShape(inputs);
                var outputShape = _this.computeOutputShape(inputShape);
                var output = void 0;
                var outputDType_1 = guessOutputDType(inputs);
                _this.warnOnIncompatibleInputShape(Array.isArray(inputs) ? inputShape[0] :
                    inputShape);
                if (outputShape != null && outputShape.length > 0 &&
                    Array.isArray(outputShape[0])) {
                    output = outputShape
                        .map(function (shape, index) { return new SymbolicTensor(outputDType_1, shape, _this, generic_utils.toList(inputs), kwargs, _this.name, index); });
                }
                else {
                    output = new SymbolicTensor(outputDType_1, outputShape, _this, generic_utils.toList(inputs), kwargs, _this.name);
                }
                _this.addInboundNode(inputs, output, null, null, inputShape, outputShape, kwargs);
                _this._refCount++;
                if (_this.activityRegularizer != null) {
                    throw new errors_1.NotImplementedError('Layer invocation in the presence of activity ' +
                        'regularizer(s) is not supported yet.');
                }
                return output;
            }
        });
    };
    Layer.prototype.warnOnIncompatibleInputShape = function (inputShape) {
        if (this.batchInputShape == null) {
            return;
        }
        else if (inputShape.length !== this.batchInputShape.length) {
            console.warn("The rank of the input tensor provided (shape: " +
                (JSON.stringify(inputShape) + ") does not match that of the ") +
                ("batchInputShape (" + JSON.stringify(this.batchInputShape) + ") ") +
                ("of the layer " + this.name));
        }
        else {
            var dimMismatch_1 = false;
            this.batchInputShape.forEach(function (dimension, i) {
                if (dimension != null && inputShape[i] != null &&
                    inputShape[i] !== dimension) {
                    dimMismatch_1 = true;
                }
            });
            if (dimMismatch_1) {
                console.warn("The shape of the input tensor " +
                    ("(" + JSON.stringify(inputShape) + ") does not ") +
                    ("match the expectation of layer " + this.name + ": ") +
                    ("" + JSON.stringify(this.batchInputShape)));
            }
        }
    };
    Object.defineProperty(Layer.prototype, "outputShape", {
        get: function () {
            if (this.inboundNodes == null || this.inboundNodes.length === 0) {
                throw new errors_1.AttributeError("The layer " + this.name + " has never been called and thus has no " +
                    "defined output shape.");
            }
            var allOutputShapes = [];
            for (var _i = 0, _a = this.inboundNodes; _i < _a.length; _i++) {
                var node = _a[_i];
                var shapeString = JSON.stringify(node.outputShapes);
                if (allOutputShapes.indexOf(shapeString) === -1) {
                    allOutputShapes.push(shapeString);
                }
            }
            if (allOutputShapes.length === 1) {
                var outputShapes = this.inboundNodes[0].outputShapes;
                if (Array.isArray(outputShapes) && Array.isArray(outputShapes[0]) &&
                    outputShapes.length === 1) {
                    return outputShapes[0];
                }
                else {
                    return outputShapes;
                }
            }
            else {
                throw new errors_1.AttributeError("The layer " + this.name + " has multiple inbound nodes with different " +
                    "output shapes. Hence the notion of \"outut shape\" is ill-defined " +
                    "for the layer.");
            }
        },
        enumerable: true,
        configurable: true
    });
    Layer.prototype.countParams = function () {
        if (!this.built) {
            throw new errors_1.RuntimeError("You tried to call countParams() on " + this.name + ", " +
                "but the layer is not built yet. Build it first by calling " +
                "build(batchInputShape).");
        }
        return variable_utils.countParamsInWeights(this.weights);
    };
    Layer.prototype.build = function (inputShape) {
        this.built = true;
    };
    Layer.prototype.getWeights = function (trainableOnly) {
        if (trainableOnly === void 0) { trainableOnly = false; }
        return variables_1.batchGetValue(trainableOnly ? this.trainableWeights : this.weights);
    };
    Layer.prototype.setWeights = function (weights) {
        var _this = this;
        tfjs_core_1.tidy(function () {
            var params = _this.weights;
            if (params.length !== weights.length) {
                throw new errors_1.ValueError("You called setWeights(weights) on layer \"" + _this.name + "\" " +
                    ("with a weight list of length " + weights.length + ", ") +
                    ("but the layer was expecting " + params.length + " weights. ") +
                    ("Provided weights: " + weights + "..."));
            }
            if (params.length === 0) {
                return;
            }
            var weightValueTuples = [];
            var paramValues = variables_1.batchGetValue(params);
            for (var i = 0; i < paramValues.length; ++i) {
                var pv = paramValues[i];
                var p = params[i];
                var w = weights[i];
                if (!tfjs_core_1.util.arraysEqual(pv.shape, w.shape)) {
                    throw new errors_1.ValueError("Layer weight shape " + pv.shape + " " +
                        ("not compatible with provided weight shape " + w.shape));
                }
                weightValueTuples.push([p, w]);
            }
            variables_1.batchSetValue(weightValueTuples);
        });
    };
    Layer.prototype.addWeight = function (name, shape, dtype, initializer, regularizer, trainable, constraint) {
        if (this._addedWeightNames.indexOf(name) !== -1) {
            throw new errors_1.ValueError("Duplicate weight name " + name + " for layer " + this.name);
        }
        this._addedWeightNames.push(name);
        if (dtype == null) {
            dtype = 'float32';
        }
        var weight = new variables_1.LayerVariable(initializer.apply(shape, dtype), dtype, name, trainable, constraint);
        if (regularizer != null) {
            this.addLoss(function () { return regularizer.apply(weight.read()); });
        }
        if (trainable == null) {
            trainable = true;
        }
        if (trainable) {
            this._trainableWeights.push(weight);
        }
        else {
            this._nonTrainableWeights.push(weight);
        }
        return weight;
    };
    Layer.prototype.addLoss = function (losses) {
        if (losses == null || Array.isArray(losses) && losses.length === 0) {
            return;
        }
        losses = generic_utils.toList(losses);
        if (this._losses !== undefined && this._losses !== null) {
            (_a = this.losses).push.apply(_a, losses);
        }
        var _a;
    };
    Layer.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    Layer.prototype.computeMask = function (inputs, mask) {
        var _this = this;
        if (!this.supportsMasking) {
            if (mask != null) {
                if (Array.isArray(mask)) {
                    mask.forEach(function (maskElement) {
                        if (maskElement != null) {
                            throw new TypeError("Layer " + _this.name + " does not support masking," +
                                'but was passed an inputMask.');
                        }
                    });
                }
                else {
                    throw new TypeError("Layer " + this.name + " does not support masking," +
                        'but was passed an inputMask.');
                }
            }
            return null;
        }
        return mask;
    };
    Layer.prototype.addInboundNode = function (inputTensors, outputTensors, inputMasks, outputMasks, inputShapes, outputShapes, kwargs) {
        if (kwargs === void 0) { kwargs = null; }
        var inputTensorList = generic_utils.toList(inputTensors);
        outputTensors = generic_utils.toList(outputTensors);
        inputMasks = generic_utils.toList(inputMasks);
        outputMasks = generic_utils.toList(outputMasks);
        inputShapes = types_utils.normalizeShapeList(inputShapes);
        outputShapes = types_utils.normalizeShapeList(outputShapes);
        var inboundLayers = [];
        var nodeIndices = [];
        var tensorIndices = [];
        for (var _i = 0, inputTensorList_1 = inputTensorList; _i < inputTensorList_1.length; _i++) {
            var x = inputTensorList_1[_i];
            inboundLayers.push(x.sourceLayer);
            nodeIndices.push(x.nodeIndex);
            tensorIndices.push(x.tensorIndex);
        }
        new Node({
            outboundLayer: this,
            inboundLayers: inboundLayers,
            nodeIndices: nodeIndices,
            tensorIndices: tensorIndices,
            inputTensors: inputTensorList,
            outputTensors: outputTensors,
            inputMasks: inputMasks,
            outputMasks: outputMasks,
            inputShapes: inputShapes,
            outputShapes: outputShapes
        }, kwargs);
        for (var i = 0; i < outputTensors.length; i++) {
            outputTensors[i].sourceLayer = this;
            outputTensors[i].nodeIndex = this.inboundNodes.length - 1;
            outputTensors[i].tensorIndex = i;
        }
    };
    Layer.prototype.getConfig = function () {
        var config = { name: this.name, trainable: this.trainable };
        if (this.batchInputShape != null) {
            config['batchInputShape'] = this.batchInputShape;
        }
        if (this.dtype != null) {
            config['dtype'] = this.dtype;
        }
        return config;
    };
    Layer.prototype.disposeWeights = function () {
        this.weights.forEach(function (weight) { return weight.dispose(); });
        return this.weights.length;
    };
    Layer.prototype.assertNotDisposed = function () {
        if (this._refCount === 0) {
            throw new Error("Layer '" + this.name + "' is already disposed.");
        }
    };
    Layer.prototype.dispose = function () {
        if (!this.built) {
            throw new Error("Cannot dispose Layer " + this.name + " because it has not been " +
                "built yet.");
        }
        if (this._refCount === null) {
            throw new Error("Cannot dispose Layer " + this.name + " because it has not been used " +
                "yet.");
        }
        this.assertNotDisposed();
        var numDisposedVariables = 0;
        if (--this._refCount === 0) {
            numDisposedVariables = this.disposeWeights();
        }
        return { refCountAfterDispose: this._refCount, numDisposedVariables: numDisposedVariables };
    };
    return Layer;
}(tfjs_core_1.serialization.Serializable));
exports.Layer = Layer;
function collectInputShape(inputTensors) {
    inputTensors =
        generic_utils.toList(inputTensors);
    var shapes = [];
    for (var _i = 0, inputTensors_1 = inputTensors; _i < inputTensors_1.length; _i++) {
        var x = inputTensors_1[_i];
        shapes.push(x.shape);
    }
    return generic_utils.singletonOrArray(shapes);
}
function guessOutputDType(inputTensors) {
    return 'float32';
}
function getSourceInputs(tensor, layer, nodeIndex) {
    if (layer == null || (nodeIndex != null && nodeIndex > 0)) {
        layer = tensor.sourceLayer;
        nodeIndex = tensor.nodeIndex;
    }
    if (layer.inboundNodes.length === 0) {
        return [tensor];
    }
    else {
        var node = layer.inboundNodes[nodeIndex];
        if (node.inboundLayers.length === 0) {
            return node.inputTensors;
        }
        else {
            var sourceTensors = [];
            for (var i = 0; i < node.inboundLayers.length; i++) {
                var x = node.inputTensors[i];
                var layer_1 = node.inboundLayers[i];
                var nodeIndex_1 = node.nodeIndices[i];
                var previousSources = getSourceInputs(x, layer_1, nodeIndex_1);
                for (var _i = 0, previousSources_1 = previousSources; _i < previousSources_1.length; _i++) {
                    var x_1 = previousSources_1[_i];
                    if (sourceTensors.indexOf(x_1) === -1) {
                        sourceTensors.push(x_1);
                    }
                }
            }
            return sourceTensors;
        }
    }
}
exports.getSourceInputs = getSourceInputs;

},{"../backend/state":208,"../common":212,"../errors":222,"../utils/generic_utils":250,"../utils/types_utils":254,"../utils/variable_utils":255,"../variables":256,"@tensorflow/tfjs-core":64}],219:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var state_1 = require("../backend/state");
var K = require("../backend/tfjs_backend");
var common_1 = require("../common");
var errors_1 = require("../errors");
var losses = require("../losses");
var Metrics = require("../metrics");
var optimizers = require("../optimizers");
var generic_utils_1 = require("../utils/generic_utils");
var layer_utils_1 = require("../utils/layer_utils");
var math_utils_1 = require("../utils/math_utils");
var container_1 = require("./container");
var executor_1 = require("./executor");
var training_dataset_1 = require("./training_dataset");
var training_tensors_1 = require("./training_tensors");
function isDataTensor(x) {
    return x instanceof tfjs_core_1.Tensor;
}
exports.isDataTensor = isDataTensor;
function isDataArray(x) {
    return Array.isArray(x);
}
exports.isDataArray = isDataArray;
function isDataDict(x) {
    return !isDataTensor(x) && !isDataArray(x);
}
exports.isDataDict = isDataDict;
function standardizeInputData(data, names, shapes, checkBatchAxis, exceptionPrefix) {
    if (checkBatchAxis === void 0) { checkBatchAxis = true; }
    if (exceptionPrefix === void 0) { exceptionPrefix = ''; }
    if (names == null || names.length === 0) {
        if (data != null) {
            var gotUnexpectedData = false;
            if (isDataArray(data) && data.length > 0) {
                gotUnexpectedData = true;
            }
            else if (isDataDict(data)) {
                for (var key in data) {
                    if (data.hasOwnProperty(key)) {
                        gotUnexpectedData = true;
                        break;
                    }
                }
            }
            else {
                gotUnexpectedData = true;
            }
            if (gotUnexpectedData) {
                throw new errors_1.ValueError("Error when checking model " + exceptionPrefix + " expected no data, " +
                    ("but got " + data));
            }
        }
        return [];
    }
    if (data == null) {
        return names.map(function (name) { return null; });
    }
    var arrays;
    if (isDataDict(data)) {
        data = data;
        arrays = [];
        for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
            var name_1 = names_1[_i];
            if (data[name_1] == null) {
                throw new errors_1.ValueError("No data provided for \"" + name_1 + "\". Need data for each key in: " +
                    ("" + names));
            }
            arrays.push(data[name_1]);
        }
    }
    else if (isDataArray(data)) {
        data = data;
        if (data.length !== names.length) {
            throw new errors_1.ValueError("Error when checking model " + exceptionPrefix + ": the Array of " +
                "Tensors that you are passing to your model is not the size the " +
                ("model expected. Expected to see " + names.length + " Tensor(s), but ") +
                ("instead got the following list of Tensor(s): " + data));
        }
        arrays = data;
    }
    else {
        data = data;
        if (names.length > 1) {
            throw new errors_1.ValueError("The model " + exceptionPrefix + " expects " + names.length + " Tensor(s), " +
                ("but only received one Tensor. Found: Tensor with shape " + data.shape));
        }
        arrays = [data];
    }
    for (var i = 0; i < names.length; ++i) {
        var array = arrays[i];
        if (array.shape.length === 1) {
            arrays[i] = K.expandDims(array, 1);
        }
    }
    if (shapes != null) {
        for (var i = 0; i < names.length; ++i) {
            if (shapes[i] == null) {
                continue;
            }
            var array = arrays[i];
            if (array.shape.length !== shapes[i].length) {
                throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " + names[i] + " " +
                    ("to have " + shapes[i].length + " dimension(s). but got array with ") +
                    ("shape " + array.shape));
            }
            for (var j = 0; j < shapes[i].length; ++j) {
                if (j === 0 && !checkBatchAxis) {
                    continue;
                }
                var dim = array.shape[j];
                var refDim = shapes[i][j];
                if (refDim != null && refDim >= 0 && dim !== refDim) {
                    throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " + names[i] + " " +
                        ("to have shape [" + shapes[i] + "], but got array with shape ") +
                        ("[" + array.shape + "]."));
                }
            }
        }
    }
    return arrays;
}
exports.standardizeInputData = standardizeInputData;
function checkArrayLengths(inputs, targets, weights) {
    var setX = generic_utils_1.unique(inputs.map(function (input) { return input.shape[0]; }));
    setX.sort();
    var setY = generic_utils_1.unique(targets.map(function (target) { return target.shape[0]; }));
    setY.sort();
    if (setX.length > 1) {
        throw new errors_1.ValueError("All input Tensors (x) should have the same number of samples. " +
            "Got array shapes: " +
            ("" + JSON.stringify(inputs.map(function (input) { return input.shape; }))));
    }
    if (setY.length > 1) {
        throw new errors_1.ValueError("All target Tensors (y) should have the same number of samples. " +
            "Got array shapes: " +
            ("" + JSON.stringify(targets.map(function (target) { return target.shape; }))));
    }
    if (setX.length > 0 && setY.length > 0 && !tfjs_core_1.util.arraysEqual(setX, setY)) {
        throw new errors_1.ValueError("Input Tensors should have the same number of samples as target " +
            ("Tensors. Found " + setX[0] + " input sample(s) and " + setY[0] + " target ") +
            "sample(s).");
    }
}
exports.checkArrayLengths = checkArrayLengths;
function checkLossAndTargetCompatibility(targets, lossFns, outputShapes) {
    var keyLosses = [
        losses.meanSquaredError, losses.binaryCrossentropy,
        losses.categoricalCrossentropy
    ];
    for (var i = 0; i < targets.length; ++i) {
        var y = targets[i];
        var loss = lossFns[i];
        var shape = outputShapes[i];
        if (loss == null) {
            continue;
        }
        if (loss === losses.categoricalCrossentropy) {
            if (y.shape[y.shape.length - 1] === 1) {
                throw new errors_1.ValueError("You are passing a target array of shape " + y.shape + " while using " +
                    "a loss 'categorical_crossentropy'. 'categorical_crossentropy'" +
                    "expects targets to be binary matrices (1s and 0s) of shape " +
                    "[samples, classes].");
            }
        }
        if (keyLosses.indexOf(loss) !== -1) {
            var slicedYShape = y.shape.slice(1);
            var slicedShape = shape.slice(1);
            for (var j = 0; j < slicedYShape.length; ++j) {
                var targetDim = slicedYShape[j];
                var outDim = slicedShape[j];
                if (outDim != null && targetDim !== outDim) {
                    throw new errors_1.ValueError("A target Tensor with shape " + y.shape + " was passed for an " +
                        ("output of shape " + shape + ", while using a loss function that ") +
                        "expects targets to have the same shape as the output.");
                }
            }
        }
    }
}
function checkInputData(data, names, shapes, checkBatchAxis, exceptionPrefix) {
    if (checkBatchAxis === void 0) { checkBatchAxis = true; }
    if (exceptionPrefix === void 0) { exceptionPrefix = ''; }
    var arrays;
    if (Array.isArray(data)) {
        if (data.length !== names.length) {
            throw new errors_1.ValueError("Error when checking model " + exceptionPrefix + ": the Array of " +
                "Tensors that you are passing to your model is not the size the " +
                ("the model expected. Expected to see " + names.length + " Tensor(s),") +
                (" but instead got " + data.length + " Tensors(s)."));
        }
        arrays = data;
    }
    else {
        if (names.length > 1) {
            throw new errors_1.ValueError("The model expects " + names.length + " " + exceptionPrefix + " Tensors, " +
                "but only received one Tensor. Found: array with shape " +
                (JSON.stringify(data.shape) + "."));
        }
        arrays = [data];
    }
    if (shapes != null) {
        for (var i = 0; i < names.length; ++i) {
            if (shapes[i] == null) {
                continue;
            }
            var array = arrays[i];
            if (array.shape.length !== shapes[i].length) {
                throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " + names[i] + " " +
                    ("to have " + shapes[i].length + " dimension(s), but got array with ") +
                    ("shape " + JSON.stringify(array.shape)));
            }
            for (var j = 0; j < shapes[i].length; ++j) {
                if (j === 0 && !checkBatchAxis) {
                    continue;
                }
                var dim = array.shape[j];
                var refDim = shapes[i][j];
                if (refDim != null) {
                    if (refDim !== dim) {
                        throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " +
                            (names[i] + " to have shape " + JSON.stringify(shapes[i]) + " but ") +
                            ("got array with shape " + JSON.stringify(array.shape) + "."));
                    }
                }
            }
        }
    }
}
function collectMetrics(metrics, outputNames) {
    if (metrics == null || Array.isArray(metrics) && metrics.length === 0) {
        return outputNames.map(function (name) { return []; });
    }
    if (Array.isArray(metrics)) {
        return outputNames.map(function (name) { return metrics; });
    }
    else if (metrics != null) {
        var nestedMetrics = [];
        for (var _i = 0, outputNames_1 = outputNames; _i < outputNames_1.length; _i++) {
            var name_2 = outputNames_1[_i];
            var outputMetrics = metrics.hasOwnProperty(name_2) ? metrics[name_2] : [];
            if (!Array.isArray(outputMetrics)) {
                outputMetrics = [outputMetrics];
            }
            nestedMetrics.push(outputMetrics);
        }
        return nestedMetrics;
    }
    else {
        throw new TypeError('Type of metrics argument not understood. Expected an Array or ' +
            'Object, found: ' + metrics);
    }
}
var Model = (function (_super) {
    __extends(Model, _super);
    function Model(config) {
        var _this = _super.call(this, config) || this;
        _this.isTraining = false;
        return _this;
    }
    Model.prototype.summary = function (lineLength, positions, printFn) {
        if (printFn === void 0) { printFn = console.log; }
        if (!this.built) {
            throw new errors_1.ValueError("This model has never been called, thus its weights have not been " +
                "created yet. So no summary can be displayed. Build the model " +
                "first (e.g., by calling it on some test data).");
        }
        layer_utils_1.printSummary(this, lineLength, positions, printFn);
    };
    Model.prototype.compile = function (config) {
        var _this = this;
        if (config.loss == null) {
            config.loss = [];
        }
        this.loss = config.loss;
        if (typeof config.optimizer === 'string') {
            this.optimizer = optimizers.getOptimizer(config.optimizer);
        }
        else {
            if (!(config.optimizer instanceof tfjs_core_1.Optimizer)) {
                throw new errors_1.ValueError("User-defined optimizer must be an instance of tf.Optimizer.");
            }
            this.optimizer = config.optimizer;
        }
        var lossFunctions = [];
        if (!Array.isArray(config.loss) && typeof config.loss !== 'string' &&
            typeof config.loss !== 'function') {
            config.loss = config.loss;
            for (var name_3 in config.loss) {
                if (this.outputNames.indexOf(name_3) === -1) {
                    throw new errors_1.ValueError("Unknown entry in loss dictionary: \"" + name_3 + "\". Only expect the " +
                        ("following keys: " + this.outputNames));
                }
            }
            for (var name_4 in this.outputNames) {
                if (config.loss[name_4] == null) {
                    console.warn("Output \"" + name_4 + "\" is missing from loss dictionary. We assume " +
                        "this was done on purpose, and we will not be expecting data " +
                        ("to be passed to " + name_4 + " during training"));
                }
                lossFunctions.push(losses.get(config.loss[name_4]));
            }
        }
        else if (Array.isArray(config.loss)) {
            if (config.loss.length !== this.outputs.length) {
                throw new errors_1.ValueError("When passing an Array as loss, it should have one entry per " +
                    ("model output. The model has " + this.outputs.length + " output(s), ") +
                    ("but you passed loss=" + config.loss + "."));
            }
            var theLosses = config.loss;
            lossFunctions = theLosses.map(function (l) { return losses.get(l); });
        }
        else {
            var lossFunction_1 = losses.get(config.loss);
            this.outputs.map(function (layer) {
                lossFunctions.push(lossFunction_1);
            });
        }
        this.lossFunctions = lossFunctions;
        this.feedOutputNames = [];
        this.feedOutputShapes = [];
        this.feedLossFns = [];
        for (var i = 0; i < this.outputs.length; ++i) {
            var shape = this.internalOutputShapes[i];
            var name_5 = this.outputNames[i];
            this.feedOutputNames.push(name_5);
            this.feedOutputShapes.push(shape);
            this.feedLossFns.push(this.lossFunctions[i]);
        }
        var skipTargetIndices = [];
        this.metrics = config.metrics;
        this.metricsNames = ['loss'];
        this.metricsTensors = [];
        common_1.nameScope('loss', function () {
            for (var i = 0; i < _this.outputs.length; ++i) {
                if (skipTargetIndices.indexOf(i) !== -1) {
                    continue;
                }
                var weightedLoss = _this.lossFunctions[i];
                if (_this.outputs.length > 1) {
                    _this.metricsTensors.push([weightedLoss, i]);
                    _this.metricsNames.push(_this.outputNames[i] + '_loss');
                }
            }
        });
        var nestedMetrics = collectMetrics(config.metrics, this.outputNames);
        var appendMetric = function (outputIndex, metricName, metricTensor) {
            if (_this.outputNames.length > 1) {
                metricName = _this.outputNames[outputIndex] + '_' + metricName;
            }
            _this.metricsNames.push(metricName);
            _this.metricsTensors.push([metricTensor, outputIndex]);
        };
        common_1.nameScope('metric', function () {
            var _loop_1 = function (i) {
                if (skipTargetIndices.indexOf(i) !== -1) {
                    return "continue";
                }
                var outputMetrics = nestedMetrics[i];
                var handleMetrics = function (metrics) {
                    var metricNamePrefix = '';
                    var metricName;
                    var accFn;
                    var weightedMetricFn;
                    var _loop_2 = function (metric) {
                        if (['accuracy', 'acc', 'crossentropy', 'ce'].indexOf(metric) !==
                            -1) {
                            var outputShape = _this.internalOutputShapes[i];
                            if (outputShape[outputShape.length - 1] === 1 ||
                                _this.lossFunctions[i] === losses.binaryCrossentropy) {
                                if (['accuracy', 'acc'].indexOf(metric) !== -1) {
                                    accFn = Metrics.binaryAccuracy;
                                }
                                else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {
                                    accFn = Metrics.binaryCrossentropy;
                                }
                            }
                            else if (_this.lossFunctions[i] ===
                                losses.sparseCategoricalCrossentropy) {
                                if (['accuracy', 'acc'].indexOf(metric) !== -1) {
                                    accFn = Metrics.sparseCategoricalAccuracy;
                                }
                                else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {
                                    accFn = Metrics.sparseCategoricalCrossentropy;
                                }
                            }
                            else {
                                if (['accuracy', 'acc'].indexOf(metric) !== -1) {
                                    accFn = Metrics.categoricalAccuracy;
                                }
                                else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {
                                    accFn = Metrics.categoricalCrossentropy;
                                }
                            }
                            var suffix = void 0;
                            if (['accuracy', 'acc'].indexOf(metric) !== -1) {
                                suffix = 'acc';
                            }
                            else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {
                                suffix = 'ce';
                            }
                            weightedMetricFn = accFn;
                            metricName = metricNamePrefix + suffix;
                        }
                        else {
                            var metricFn = Metrics.get(metric);
                            weightedMetricFn = metricFn;
                            metricName = metricNamePrefix + metric;
                        }
                        var metricResult;
                        common_1.nameScope(metricName, function () {
                            metricResult = weightedMetricFn;
                        });
                        appendMetric(i, metricName, metricResult);
                    };
                    for (var _i = 0, metrics_1 = metrics; _i < metrics_1.length; _i++) {
                        var metric = metrics_1[_i];
                        _loop_2(metric);
                    }
                };
                handleMetrics(outputMetrics);
            };
            for (var i = 0; i < _this.outputs.length; ++i) {
                _loop_1(i);
            }
        });
        this.collectedTrainableWeights = this.trainableWeights;
    };
    Model.prototype.checkTrainableWeightsConsistency = function () {
        if (this.collectedTrainableWeights == null) {
            return;
        }
        if (this.trainableWeights.length !==
            this.collectedTrainableWeights.length) {
            console.warn('Discrepancy between trainableweights and collected trainable ' +
                'weights. Did you set `model.trainable` without calling ' +
                '`model.compile()` afterwards?');
        }
    };
    Model.prototype.evaluate = function (x, y, config) {
        if (config === void 0) { config = {}; }
        var batchSize = config.batchSize == null ? 32 : config.batchSize;
        training_tensors_1.checkBatchSize(batchSize);
        var standardizedOuts = this.standardizeUserData(x, y, true, batchSize);
        var ins = standardizedOuts[0].concat(standardizedOuts[1]);
        this.makeTestFunction();
        var f = this.testFunction;
        var testOuts = this.testLoop(f, ins, batchSize, config.verbose, config.steps);
        return generic_utils_1.singletonOrArray(testOuts);
    };
    Model.prototype.evaluateDataset = function (dataset, config) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.makeTestFunction();
                return [2, training_dataset_1.evaluateDataset(this, dataset, config)];
            });
        });
    };
    Model.prototype.checkNumSamples = function (ins, batchSize, steps, stepsName) {
        if (stepsName === void 0) { stepsName = 'steps'; }
        var numSamples;
        if (steps != null) {
            numSamples = null;
            if (batchSize != null) {
                throw new errors_1.ValueError("If " + stepsName + " is set, batchSize must be null or undefined." +
                    ("Got batchSize = " + batchSize));
            }
        }
        else if (ins != null) {
            if (Array.isArray(ins)) {
                numSamples = ins[0].shape[0];
            }
            else {
                numSamples = ins.shape[0];
            }
        }
        else {
            throw new errors_1.ValueError("Either the input data should have a defined shape, or " +
                (stepsName + " shoud be specified."));
        }
        return numSamples;
    };
    Model.prototype.execute = function (inputs, outputs) {
        if (Array.isArray(outputs) && outputs.length === 0) {
            throw new errors_1.ValueError('`outputs` is an empty Array, which is not allowed.');
        }
        var outputsIsArray = Array.isArray(outputs);
        var outputNames = (outputsIsArray ? outputs :
            [outputs]);
        var outputSymbolicTensors = this.retrieveSymbolicTensors(outputNames);
        var feedDict = new executor_1.FeedDict();
        if (inputs instanceof tfjs_core_1.Tensor) {
            inputs = [inputs];
        }
        if (Array.isArray(inputs)) {
            if (inputs.length !== this.inputs.length) {
                throw new errors_1.ValueError("The number of inputs provided (" + inputs.length + ") " +
                    "does not match the number of inputs of this model " +
                    ("(" + this.inputs.length + ")."));
            }
            for (var i = 0; i < this.inputs.length; ++i) {
                feedDict.add(this.inputs[i], inputs[i]);
            }
        }
        else {
            for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {
                var input = _a[_i];
                var tensorValue = inputs[input.name];
                if (tensorValue == null) {
                    throw new errors_1.ValueError("No value is provided for the model's input " + input.name);
                }
                feedDict.add(input, tensorValue);
            }
        }
        var executeOutputs = executor_1.execute(outputSymbolicTensors, feedDict);
        return outputsIsArray ? executeOutputs : executeOutputs[0];
    };
    Model.prototype.retrieveSymbolicTensors = function (symbolicTensorNames) {
        var outputSymbolicTensors = generic_utils_1.pyListRepeat(null, symbolicTensorNames.length);
        var outputsRemaining = symbolicTensorNames.length;
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            var layerOutputs = Array.isArray(layer.output) ?
                layer.output :
                [layer.output];
            var layerOutputNames = layerOutputs.map(function (output) { return output.name; });
            for (var i = 0; i < symbolicTensorNames.length; ++i) {
                var index = layerOutputNames.indexOf(symbolicTensorNames[i]);
                if (index !== -1) {
                    outputSymbolicTensors[i] = layerOutputs[index];
                    outputsRemaining--;
                }
                if (outputsRemaining === 0) {
                    break;
                }
            }
            if (outputsRemaining === 0) {
                break;
            }
        }
        if (outputsRemaining > 0) {
            var remainingNames_1 = [];
            outputSymbolicTensors.forEach(function (tensor, i) {
                if (tensor == null) {
                    remainingNames_1.push(symbolicTensorNames[i]);
                }
            });
            throw new errors_1.ValueError("Cannot find SymbolicTensors for output name(s): " +
                ("" + JSON.stringify(remainingNames_1)));
        }
        return outputSymbolicTensors;
    };
    Model.prototype.predictLoop = function (ins, batchSize, verbose) {
        var _this = this;
        if (batchSize === void 0) { batchSize = 32; }
        if (verbose === void 0) { verbose = false; }
        return tfc.tidy(function () {
            var numSamples = _this.checkNumSamples(ins);
            if (verbose) {
                throw new errors_1.NotImplementedError('Verbose predictLoop() is not implemented yet.');
            }
            var batches = training_tensors_1.makeBatches(numSamples, batchSize);
            var outs = [];
            var _loop_3 = function (batchIndex) {
                var batchOuts = tfc.tidy(function () {
                    var batchStart = batches[batchIndex][0];
                    var batchEnd = batches[batchIndex][1];
                    var insBatch = training_tensors_1.sliceArrays(ins, batchStart, batchEnd);
                    var feeds = [];
                    if (Array.isArray(insBatch)) {
                        for (var i = 0; i < insBatch.length; ++i) {
                            feeds.push({ key: _this.inputs[i], value: insBatch[i] });
                        }
                    }
                    else {
                        feeds.push({ key: _this.inputs[0], value: insBatch });
                    }
                    var feedDict = new executor_1.FeedDict(feeds);
                    return executor_1.execute(_this.outputs, feedDict);
                });
                if (batchIndex === 0) {
                    for (var _i = 0, batchOuts_1 = batchOuts; _i < batchOuts_1.length; _i++) {
                        var batchOut = batchOuts_1[_i];
                        outs.push(batchOut);
                    }
                }
                else {
                    for (var i = 0; i < batchOuts.length; ++i) {
                        outs[i] = K.concatAlongFirstAxis(outs[i], batchOuts[i]);
                    }
                }
            };
            for (var batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
                _loop_3(batchIndex);
            }
            return generic_utils_1.singletonOrArray(outs);
        });
    };
    Model.prototype.predict = function (x, config) {
        if (config === void 0) { config = {}; }
        checkInputData(x, this.inputNames, this.feedInputShapes, false);
        var batchSize = config.batchSize == null ? 32 : config.batchSize;
        training_tensors_1.checkBatchSize(batchSize);
        return this.predictLoop(x, batchSize);
    };
    Model.prototype.predictOnBatch = function (x) {
        checkInputData(x, this.inputNames, this.feedInputShapes, true);
        return this.predictLoop(x, x.shape[0]);
    };
    Model.prototype.standardizeUserData = function (x, y, checkBatchAxis, batchSize) {
        if (checkBatchAxis === void 0) { checkBatchAxis = true; }
        if (this.optimizer == null) {
            throw new errors_1.RuntimeError('You must compile a model before training/testing. Use ' +
                'Model.compile(modelCompileConfig).');
        }
        var outputShapes = [];
        for (var i = 0; i < this.feedOutputShapes.length; ++i) {
            var outputShape = this.feedOutputShapes[i];
            var lossFn = this.feedLossFns[i];
            if (lossFn === losses.sparseCategoricalCrossentropy) {
                outputShapes.push(outputShape.slice(0, outputShape.length - 1).concat([1]));
            }
            else {
                outputShapes.push(outputShape);
            }
        }
        x = standardizeInputData(x, this.feedInputNames, this.feedInputShapes, false, 'input');
        y = standardizeInputData(y, this.feedOutputNames, outputShapes, false, 'target');
        checkArrayLengths(x, y, null);
        checkLossAndTargetCompatibility(y, this.feedLossFns, this.feedOutputShapes);
        if (this.stateful && batchSize != null && batchSize > 0) {
            if (x[0].shape[0] % batchSize !== 0) {
                throw new errors_1.ValueError("In a stateful network, you should only pass inputs with a " +
                    "number of samples that is divisible by the batch size " +
                    (batchSize + ". Found: " + x[0].shape[0] + " sample(s)."));
            }
        }
        return [x, y, null];
    };
    Model.prototype.testLoop = function (f, ins, batchSize, verbose, steps) {
        var _this = this;
        if (verbose === void 0) { verbose = 0; }
        return tfc.tidy(function () {
            var numSamples = _this.checkNumSamples(ins, batchSize, steps, 'steps');
            var outs = [];
            if (verbose > 0) {
                throw new errors_1.NotImplementedError('Verbose mode is not implemented yet.');
            }
            if (steps != null) {
                throw new errors_1.NotImplementedError('steps mode in testLoop() is not implemented yet');
            }
            else {
                var batches = training_tensors_1.makeBatches(numSamples, batchSize);
                var indexArray = tfjs_core_1.tensor1d(math_utils_1.range(0, numSamples));
                for (var batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
                    var batchStart = batches[batchIndex][0];
                    var batchEnd = batches[batchIndex][1];
                    var batchIds = K.sliceAlongFirstAxis(indexArray, batchStart, batchEnd - batchStart);
                    var insBatch = training_tensors_1.sliceArraysByIndices(ins, batchIds);
                    var batchOuts = f(insBatch);
                    if (batchIndex === 0) {
                        for (var i = 0; i < batchOuts.length; ++i) {
                            outs.push(state_1.getScalar(0));
                        }
                    }
                    for (var i = 0; i < batchOuts.length; ++i) {
                        var batchOut = batchOuts[i];
                        outs[i] =
                            tfc.add(outs[i], tfc.mul(state_1.getScalar(batchEnd - batchStart), batchOut));
                    }
                }
                for (var i = 0; i < outs.length; ++i) {
                    outs[i] = tfc.div(outs[i], state_1.getScalar(numSamples));
                }
            }
            return outs;
        });
    };
    Model.prototype.getDedupedMetricsNames = function () {
        var outLabels = this.metricsNames;
        var dedupedOutLabels = [];
        for (var i = 0; i < outLabels.length; ++i) {
            var label = outLabels[i];
            var newLabel = label;
            if (generic_utils_1.count(outLabels, label) > 1) {
                var dupIndex = generic_utils_1.count(outLabels.slice(0, i), label);
                newLabel += "_" + dupIndex;
            }
            dedupedOutLabels.push(newLabel);
        }
        return dedupedOutLabels;
    };
    Model.prototype.makeTrainFunction = function () {
        var _this = this;
        return function (data) {
            var losses = [];
            var lossValues = [];
            var inputs = data.slice(0, _this.inputs.length);
            var targets = data.slice(_this.inputs.length, _this.inputs.length + _this.outputs.length);
            var metricsValues = [];
            var totalLossFunction = function () {
                var feeds = [];
                for (var i = 0; i < _this.inputs.length; ++i) {
                    feeds.push({ key: _this.inputs[i], value: inputs[i] });
                }
                var feedDict = new executor_1.FeedDict(feeds);
                var outputs = executor_1.execute(_this.outputs, feedDict, { 'training': true });
                var totalLoss;
                for (var i = 0; i < _this.lossFunctions.length; ++i) {
                    var lossFunction = _this.lossFunctions[i];
                    var loss = lossFunction(targets[i], outputs[i]);
                    losses.push(loss);
                    var meanLoss = tfc.mean(loss);
                    lossValues.push(meanLoss);
                    if (i === 0) {
                        totalLoss = loss;
                    }
                    else {
                        totalLoss = tfc.add(totalLoss, loss);
                    }
                }
                for (var i = 0; i < _this.metricsTensors.length; ++i) {
                    var metric = _this.metricsTensors[i][0];
                    var outputIndex = _this.metricsTensors[i][1];
                    var meanMetric = tfc.mean(metric(targets[outputIndex], outputs[outputIndex]));
                    tfc.keep(meanMetric);
                    metricsValues.push(meanMetric);
                }
                totalLoss = tfc.mean(totalLoss);
                _this.calculateLosses().forEach(function (regularizerLoss) {
                    totalLoss = tfc.add(totalLoss, regularizerLoss);
                });
                return totalLoss;
            };
            var variables = _this.collectedTrainableWeights.map(function (param) { return param.read(); });
            var returnCost = true;
            var totalLossValue = _this.optimizer.minimize(totalLossFunction, returnCost, variables);
            return [totalLossValue].concat(metricsValues);
        };
    };
    Model.prototype.makeTestFunction = function () {
        var _this = this;
        this.testFunction = function (data) {
            return tfc.tidy(function () {
                var valOutputs = [];
                var totalLoss;
                var inputs = data.slice(0, _this.inputs.length);
                var targets = data.slice(_this.inputs.length, _this.inputs.length + _this.outputs.length);
                var feeds = [];
                for (var i = 0; i < _this.inputs.length; ++i) {
                    feeds.push({ key: _this.inputs[i], value: inputs[i] });
                }
                var feedDict = new executor_1.FeedDict(feeds);
                var outputs = executor_1.execute(_this.outputs, feedDict);
                for (var i = 0; i < _this.lossFunctions.length; ++i) {
                    var lossFunction = _this.lossFunctions[i];
                    var loss = tfc.mean(lossFunction(targets[i], outputs[i]));
                    if (i === 0) {
                        totalLoss = loss;
                    }
                    else {
                        totalLoss = tfc.add(totalLoss, loss);
                    }
                    valOutputs.push(totalLoss);
                }
                for (var i = 0; i < _this.metricsTensors.length; ++i) {
                    var metric = _this.metricsTensors[i][0];
                    var outputIndex = _this.metricsTensors[i][1];
                    var meanMetric = tfc.mean(metric(targets[outputIndex], outputs[outputIndex]));
                    valOutputs.push(meanMetric);
                }
                return valOutputs;
            });
        };
    };
    Model.prototype.fit = function (x, y, config) {
        if (config === void 0) { config = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, training_tensors_1.fitTensors(this, x, y, config)];
            });
        });
    };
    Model.prototype.fitDataset = function (dataset, config) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, training_dataset_1.fitDataset(this, dataset, config)];
            });
        });
    };
    Model.prototype.getNamedWeights = function (config) {
        var namedWeights = {};
        var trainableOnly = config != null && config.trainableOnly;
        var weights = trainableOnly ? this.trainableWeights : this.weights;
        var weightValues = this.getWeights(trainableOnly);
        for (var i = 0; i < weights.length; ++i) {
            if (trainableOnly && !weights[i].trainable) {
                continue;
            }
            namedWeights[weights[i].originalName] = weightValues[i];
        }
        return namedWeights;
    };
    Object.defineProperty(Model.prototype, "stopTraining", {
        set: function (stop) {
            this.stopTraining_ = stop;
        },
        enumerable: true,
        configurable: true
    });
    Model.prototype.save = function (handlerOrURL, config) {
        return __awaiter(this, void 0, void 0, function () {
            var handlers, weightDataAndSpecs, returnString, unusedArg, modelConfig;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (typeof handlerOrURL === 'string') {
                            handlers = tfjs_core_1.io.getSaveHandlers(handlerOrURL);
                            if (handlers.length === 0) {
                                throw new errors_1.ValueError("Cannot find any save handlers for URL '" + handlerOrURL + "'");
                            }
                            else if (handlers.length > 1) {
                                throw new errors_1.ValueError("Found more than one (" + handlers.length + ") save handlers for " +
                                    ("URL '" + handlerOrURL + "'"));
                            }
                            handlerOrURL = handlers[0];
                        }
                        if (handlerOrURL.save == null) {
                            throw new errors_1.ValueError('Model.save() cannot proceed because the IOHandler provided does ' +
                                'not have the `save` attribute defined.');
                        }
                        return [4, tfjs_core_1.io.encodeWeights(this.getNamedWeights(config))];
                    case 1:
                        weightDataAndSpecs = _a.sent();
                        returnString = false;
                        unusedArg = null;
                        modelConfig = this.toJSON(unusedArg, returnString);
                        return [2, handlerOrURL.save({
                                modelTopology: modelConfig,
                                weightData: weightDataAndSpecs.data,
                                weightSpecs: weightDataAndSpecs.specs
                            })];
                }
            });
        });
    };
    Model.className = 'Model';
    return Model;
}(container_1.Container));
exports.Model = Model;
tfjs_core_1.serialization.registerClass(Model);

},{"../backend/state":208,"../backend/tfjs_backend":209,"../common":212,"../errors":222,"../losses":244,"../metrics":245,"../optimizers":247,"../utils/generic_utils":250,"../utils/layer_utils":251,"../utils/math_utils":252,"./container":214,"./executor":216,"./training_dataset":220,"./training_tensors":221,"@tensorflow/tfjs-core":64}],220:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var state_1 = require("../backend/state");
var base_callbacks_1 = require("../base_callbacks");
var errors_1 = require("../errors");
var logs_1 = require("../logs");
var generic_utils_1 = require("../utils/generic_utils");
var dataset_stub_1 = require("./dataset_stub");
var DEFAULT_VALIDATION_BATCH_SIZE = 32;
function standardizeDataIteratorOutput(model, iteratorOut) {
    if (model.outputs.length > 1) {
        throw new errors_1.NotImplementedError("Support for training a model with multiple output tensors with " +
            "a dataset object is not implemented yet.");
    }
    tfc.util.assert(Array.isArray(iteratorOut) && iteratorOut.length === 2, 'Dataset iterator for fitDataset() is expected to generate ' +
        'an Array of length 2: `[xs, ys]`, but instead generates ' +
        iteratorOut);
    iteratorOut = iteratorOut;
    var ys = iteratorOut[1];
    var xs = iteratorOut[0];
    if (xs instanceof tfc.Tensor) {
        tfc.util.assert(model.inputs.length === 1, "Model has multiple " + model.inputs.length + " inputs, hence it " +
            "expects the input dataset to generate a dictionary of tensors " +
            (" (with keys " + JSON.stringify(model.inputNames) + ", ") +
            "but received a single tensor.");
        tfc.util.assert(xs.shape[0] === ys.shape[0], "Mismatch in batch size between x and y tensors (" + xs.shape[0] + " vs. " +
            (ys.shape[0] + ")"));
        return [xs, ys];
    }
    else {
        var batchSize = void 0;
        xs = xs;
        var flattendXs = [];
        for (var _i = 0, _a = model.inputNames; _i < _a.length; _i++) {
            var inputName = _a[_i];
            if (xs[inputName] == null) {
                throw new errors_1.ValueError("The feature data generated by the dataset lacks the required " +
                    ("input key '" + inputName + "'."));
            }
            flattendXs.push(xs[inputName]);
            if (batchSize == null) {
                batchSize = xs[inputName].shape[0];
            }
            else {
                tfc.util.assert(xs[inputName].shape[0] === batchSize, "Mismatch in batch size between x and y tensors " +
                    ("(" + xs[inputName].shape[0] + " vs. " + ys.shape[0] + ")"));
            }
        }
        return flattendXs.concat(ys);
    }
}
function standardizeTensorValidationData(data) {
    if (data.length === 3) {
        throw new errors_1.NotImplementedError('Validation with sample weights is not implemented yet.');
    }
    return { xs: data[0], ys: data[1] };
}
function fitDataset(model, dataset, config) {
    return __awaiter(this, void 0, void 0, function () {
        var doValidation, validationDataIterator, valXs, valYs, validationData, trainFunction, outLabels, callbackMetrics, callbacks, _a, callbackList, history_1, epoch, epochLogs, dataIterator, stepsDone, batchIndex, iteratorOut, xsAndYs, batchLogs, outs, i, label, out, valOuts, _b, i;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    tfc.util.assert(model.optimizer != null, 'You must compile a model before training/testing. Use ' +
                        'Model.compile(modelCompileConfig).');
                    tfc.util.assert(config != null, "For fitDataset(), the 2nd argument (config) is required, " +
                        "but it is not provided in this call.");
                    tfc.util.assert(config.epochs != null && config.epochs > 0 &&
                        Number.isInteger(config.epochs), "For fitDataset(), config.epochs is expected to be a positive " +
                        ("integer, but got " + config.epochs));
                    tfc.util.assert(config.batchesPerEpoch != null && config.batchesPerEpoch > 0 &&
                        Number.isInteger(config.batchesPerEpoch), "For fitDataset(), config.batchesPerEpoch is expected to be a " +
                        ("positive integer, but got " + config.batchesPerEpoch));
                    if (model.isTraining) {
                        throw new Error('Cannot start training because another fit() call is ongoing.');
                    }
                    model.isTraining = true;
                    _c.label = 1;
                case 1:
                    _c.trys.push([1, , 21, 22]);
                    doValidation = config.validationData != null;
                    validationDataIterator = void 0;
                    valXs = void 0;
                    valYs = void 0;
                    if (!doValidation) return [3, 4];
                    if (!(config.validationData instanceof dataset_stub_1.Dataset)) return [3, 3];
                    tfc.util.assert(config.validationBatches > 0 &&
                        Number.isInteger(config.validationBatches), "For fitDataset() with dataset-based validation, " +
                        "config.validationBatches is expected to be a " +
                        ("positive integer, but got " + config.validationBatches));
                    return [4, config.validationData.iterator()];
                case 2:
                    validationDataIterator = _c.sent();
                    return [3, 4];
                case 3:
                    validationData = standardizeTensorValidationData(config.validationData);
                    valXs = validationData.xs;
                    valYs = validationData.ys;
                    _c.label = 4;
                case 4:
                    trainFunction = model.makeTrainFunction();
                    outLabels = model.getDedupedMetricsNames();
                    callbackMetrics = void 0;
                    if (doValidation) {
                        callbackMetrics =
                            outLabels.slice().concat(outLabels.map(function (n) { return 'val_' + n; }));
                    }
                    else {
                        callbackMetrics = outLabels.slice();
                    }
                    callbacks = base_callbacks_1.standardizeCallbacks(config.callbacks);
                    _a = base_callbacks_1.configureCallbacks(callbacks, config.yieldEvery, config.verbose, config.epochs, null, null, config.batchesPerEpoch, null, doValidation, callbackMetrics), callbackList = _a.callbackList, history_1 = _a.history;
                    model.history = history_1;
                    return [4, callbackList.onTrainBegin()];
                case 5:
                    _c.sent();
                    epoch = config.initialEpoch == null ? 0 : config.initialEpoch;
                    epochLogs = {};
                    return [4, dataset.iterator()];
                case 6:
                    dataIterator = _c.sent();
                    _c.label = 7;
                case 7:
                    if (!(epoch < config.epochs)) return [3, 18];
                    return [4, callbackList.onEpochBegin(epoch)];
                case 8:
                    _c.sent();
                    stepsDone = 0;
                    batchIndex = 0;
                    _c.label = 9;
                case 9:
                    if (!(stepsDone < config.batchesPerEpoch)) return [3, 16];
                    return [4, dataIterator.next()];
                case 10:
                    iteratorOut = _c.sent();
                    if (iteratorOut.done) {
                        console.warn('Your dataset iterator ran out of data; ' +
                            'interrupting training. Make sure that your ' +
                            'dataset can generate at least `batchesPerEpoch * epochs` ' +
                            'batches (in this case, ' +
                            (config.batchesPerEpoch * config.epochs + " batches). ") +
                            'You may need to use the repeat() function when building ' +
                            'your dataset.');
                        return [3, 16];
                    }
                    xsAndYs = standardizeDataIteratorOutput(model, iteratorOut.value);
                    batchLogs = {};
                    batchLogs['batch'] = batchIndex;
                    batchLogs['size'] = xsAndYs[0].shape[0];
                    callbackList.onBatchBegin(batchIndex, batchLogs);
                    outs = trainFunction(xsAndYs);
                    tfc.dispose(xsAndYs);
                    for (i = 0; i < outLabels.length; ++i) {
                        label = outLabels[i];
                        out = outs[i];
                        batchLogs[label] = out;
                        tfc.keep(out);
                    }
                    return [4, callbackList.onBatchEnd(batchIndex, batchLogs)];
                case 11:
                    _c.sent();
                    logs_1.disposeTensorsInLogs(batchLogs);
                    batchIndex++;
                    stepsDone++;
                    if (!(stepsDone >= config.batchesPerEpoch && doValidation)) return [3, 15];
                    valOuts = void 0;
                    if (!(config.validationData instanceof dataset_stub_1.Dataset)) return [3, 13];
                    _b = generic_utils_1.toList;
                    return [4, model.evaluateDataset(validationDataIterator, { batches: config.validationBatches })];
                case 12:
                    valOuts = _b.apply(void 0, [_c.sent()]);
                    return [3, 14];
                case 13:
                    valOuts = generic_utils_1.toList(model.evaluate(valXs, valYs, {
                        batchSize: config.validationBatchSize == null ?
                            DEFAULT_VALIDATION_BATCH_SIZE :
                            config.validationBatchSize,
                        verbose: 0
                    }));
                    _c.label = 14;
                case 14:
                    for (i = 0; i < model.metricsNames.length; ++i) {
                        epochLogs["val_" + model.metricsNames[i]] = valOuts[i];
                    }
                    _c.label = 15;
                case 15:
                    if (model.stopTraining_) {
                        return [3, 16];
                    }
                    return [3, 9];
                case 16: return [4, callbackList.onEpochEnd(epoch, epochLogs)];
                case 17:
                    _c.sent();
                    epoch++;
                    if (model.stopTraining_) {
                        return [3, 18];
                    }
                    return [3, 7];
                case 18: return [4, callbackList.onTrainEnd()];
                case 19:
                    _c.sent();
                    return [4, model.history.syncData()];
                case 20:
                    _c.sent();
                    return [2, model.history];
                case 21:
                    model.isTraining = false;
                    return [7];
                case 22: return [2];
            }
        });
    });
}
exports.fitDataset = fitDataset;
function evaluateDataset(model, dataset, config) {
    return __awaiter(this, void 0, void 0, function () {
        var f, outs, dataIterator, _a, numExamples, _loop_1, batch, state_2, _loop_2, i;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    f = model.testFunction;
                    outs = [];
                    if (config.verbose > 0) {
                        throw new errors_1.NotImplementedError('Verbose mode is not implemented yet.');
                    }
                    tfc.util.assert(config.batches > 0 && Number.isInteger(config.batches), 'Test loop expects `batches` to be a positive integer, but ' +
                        ("received " + JSON.stringify(config.batches)));
                    if (!(dataset instanceof dataset_stub_1.LazyIterator)) return [3, 1];
                    _a = dataset;
                    return [3, 3];
                case 1: return [4, dataset.iterator()];
                case 2:
                    _a = _b.sent();
                    _b.label = 3;
                case 3:
                    dataIterator = _a;
                    numExamples = 0;
                    _loop_1 = function (batch) {
                        var iteratorOut, xsAndYs, batchOuts, i, batchSize, _loop_3, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, dataIterator.next()];
                                case 1:
                                    iteratorOut = _a.sent();
                                    if (iteratorOut.done) {
                                        console.warn('Your dataset iterator ran out of data during evaluateDataset(). ' +
                                            'Interrupting evalution. Make sure that your ' +
                                            'dataset can generate at least `batches` ' +
                                            ("batches (in this case, " + config.batches + " batches). ") +
                                            'You may need to use the repeat() function when building ' +
                                            'your dataset.');
                                        return [2, "break"];
                                    }
                                    xsAndYs = standardizeDataIteratorOutput(model, iteratorOut.value);
                                    batchOuts = tfc.tidy(function () { return f(xsAndYs); });
                                    tfc.dispose(xsAndYs);
                                    if (batch === 0) {
                                        for (i = 0; i < batchOuts.length; ++i) {
                                            outs.push(state_1.getScalar(0));
                                        }
                                    }
                                    batchSize = xsAndYs[0].shape[0];
                                    _loop_3 = function (i) {
                                        var batchOut = batchOuts[i];
                                        var oldScalar = outs[i];
                                        outs[i] = tfc.tidy(function () { return tfc.add(outs[i], tfc.mul(state_1.getScalar(batchSize), batchOut)); });
                                        if (batch > 0) {
                                            tfc.dispose(oldScalar);
                                        }
                                    };
                                    for (i = 0; i < batchOuts.length; ++i) {
                                        _loop_3(i);
                                    }
                                    tfc.dispose(batchOuts);
                                    numExamples += batchSize;
                                    return [2];
                            }
                        });
                    };
                    batch = 0;
                    _b.label = 4;
                case 4:
                    if (!(batch < config.batches)) return [3, 7];
                    return [5, _loop_1(batch)];
                case 5:
                    state_2 = _b.sent();
                    if (state_2 === "break")
                        return [3, 7];
                    _b.label = 6;
                case 6:
                    ++batch;
                    return [3, 4];
                case 7:
                    _loop_2 = function (i) {
                        var oldScalar = outs[i];
                        outs[i] =
                            tfc.tidy(function () { return tfc.div(outs[i], state_1.getScalar(numExamples)); });
                        tfc.dispose(oldScalar);
                    };
                    for (i = 0; i < outs.length; ++i) {
                        _loop_2(i);
                    }
                    return [2, generic_utils_1.singletonOrArray(outs)];
            }
        });
    });
}
exports.evaluateDataset = evaluateDataset;

},{"../backend/state":208,"../base_callbacks":210,"../errors":222,"../logs":243,"../utils/generic_utils":250,"./dataset_stub":215,"@tensorflow/tfjs-core":64}],221:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var tfjs_backend_1 = require("../backend/tfjs_backend");
var base_callbacks_1 = require("../base_callbacks");
var errors_1 = require("../errors");
var logs_1 = require("../logs");
var math_utils_1 = require("../utils/math_utils");
function checkBatchSize(batchSize) {
    tfc.util.assert(batchSize > 0 && Number.isInteger(batchSize), "batchSize is required to be a positive integer, but got " + batchSize);
}
exports.checkBatchSize = checkBatchSize;
function sliceArrays(arrays, start, stop) {
    if (arrays == null) {
        return [null];
    }
    else if (Array.isArray(arrays)) {
        return arrays.map(function (array) { return tfjs_backend_1.sliceAlongFirstAxis(array, start, stop - start); });
    }
    else {
        return tfjs_backend_1.sliceAlongFirstAxis(arrays, start, stop - start);
    }
}
exports.sliceArrays = sliceArrays;
function sliceArraysByIndices(arrays, indices) {
    return tfc.tidy(function () {
        if (arrays == null) {
            return null;
        }
        else if (Array.isArray(arrays)) {
            return arrays.map(function (array) { return sliceArraysByIndices(array, indices); });
        }
        else {
            return tfjs_backend_1.gather(arrays, indices.dtype === 'int32' ? indices : indices.toInt());
        }
    });
}
exports.sliceArraysByIndices = sliceArraysByIndices;
function makeBatches(size, batchSize) {
    var output = [];
    var batchStart = 0;
    var batchEnd = null;
    while (batchStart < size) {
        batchEnd = batchStart + batchSize;
        if (batchEnd >= size) {
            batchEnd = size;
        }
        output.push([batchStart, batchEnd]);
        batchStart = batchEnd;
    }
    return output;
}
exports.makeBatches = makeBatches;
function fitLoop(model, f, ins, outLabels, batchSize, epochs, verbose, callbacks, valF, valIns, shuffle, callbackMetrics, initialEpoch, stepsPerEpoch, validationSteps, yieldEvery) {
    return __awaiter(this, void 0, void 0, function () {
        var doValidation, numTrainSamples, indexArray, _a, callbackList, history, _loop_1, epoch, state_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (batchSize == null) {
                        batchSize = 32;
                    }
                    if (epochs == null) {
                        epochs = 1;
                    }
                    if (shuffle == null) {
                        shuffle = true;
                    }
                    if (initialEpoch == null) {
                        initialEpoch = 0;
                    }
                    doValidation = false;
                    if (valF != null && valIns != null) {
                        doValidation = true;
                    }
                    if (validationSteps != null) {
                        doValidation = true;
                        if (stepsPerEpoch == null) {
                            throw new errors_1.ValueError('Can only use `validationSteps` when doing step-wise training, ' +
                                'i.e., `stepsPerEpoch` must be set.');
                        }
                    }
                    numTrainSamples = model.checkNumSamples(ins, batchSize, stepsPerEpoch, 'steps_per_epoch');
                    if (numTrainSamples != null) {
                        indexArray = math_utils_1.range(0, numTrainSamples);
                    }
                    if (verbose == null) {
                        verbose = 1;
                    }
                    _a = base_callbacks_1.configureCallbacks(callbacks, yieldEvery, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics), callbackList = _a.callbackList, history = _a.history;
                    callbackList.setModel(model);
                    model.history = history;
                    return [4, callbackList.onTrainBegin()];
                case 1:
                    _b.sent();
                    model.stopTraining_ = false;
                    _loop_1 = function (epoch) {
                        var epochLogs, epochIndexArray1D_1, batches_1, _loop_2, batchIndex, state_2;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, callbackList.onEpochBegin(epoch)];
                                case 1:
                                    _a.sent();
                                    epochLogs = {};
                                    if (!(stepsPerEpoch != null)) return [3, 2];
                                    throw new errors_1.NotImplementedError('stepsPerEpoch mode is not implemented yet.');
                                case 2:
                                    if (shuffle === 'batch') {
                                        throw new errors_1.NotImplementedError('batch shuffling is not implemneted yet');
                                    }
                                    else if (shuffle) {
                                        tfjs_core_1.util.shuffle(indexArray);
                                    }
                                    epochIndexArray1D_1 = tfjs_core_1.tensor1d(indexArray);
                                    batches_1 = makeBatches(numTrainSamples, batchSize);
                                    _loop_2 = function (batchIndex) {
                                        var batchLogs;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    batchLogs = {};
                                                    return [4, callbackList.onBatchBegin(batchIndex, batchLogs)];
                                                case 1:
                                                    _a.sent();
                                                    tfc.tidy(function () {
                                                        var batchStart = batches_1[batchIndex][0];
                                                        var batchEnd = batches_1[batchIndex][1];
                                                        var batchIds = tfjs_backend_1.sliceAlongFirstAxis(epochIndexArray1D_1, batchStart, batchEnd - batchStart);
                                                        batchLogs['batch'] = batchIndex;
                                                        batchLogs['size'] = batchEnd - batchStart;
                                                        var insBatch = sliceArraysByIndices(ins, batchIds);
                                                        var outs = f(insBatch);
                                                        for (var i = 0; i < outLabels.length; ++i) {
                                                            var label = outLabels[i];
                                                            var out = outs[i];
                                                            batchLogs[label] = out;
                                                            tfc.keep(out);
                                                        }
                                                        if (batchIndex === batches_1.length - 1) {
                                                            if (doValidation) {
                                                                var valOuts = model.testLoop(valF, valIns, batchSize);
                                                                for (var i = 0; i < outLabels.length; ++i) {
                                                                    var label = outLabels[i];
                                                                    var out = valOuts[i];
                                                                    tfc.keep(out);
                                                                    epochLogs['val_' + label] = out;
                                                                }
                                                            }
                                                        }
                                                    });
                                                    return [4, callbackList.onBatchEnd(batchIndex, batchLogs)];
                                                case 2:
                                                    _a.sent();
                                                    logs_1.disposeTensorsInLogs(batchLogs);
                                                    if (model.stopTraining_) {
                                                        return [2, "break"];
                                                    }
                                                    return [2];
                                            }
                                        });
                                    };
                                    batchIndex = 0;
                                    _a.label = 3;
                                case 3:
                                    if (!(batchIndex < batches_1.length)) return [3, 6];
                                    return [5, _loop_2(batchIndex)];
                                case 4:
                                    state_2 = _a.sent();
                                    if (state_2 === "break")
                                        return [3, 6];
                                    _a.label = 5;
                                case 5:
                                    ++batchIndex;
                                    return [3, 3];
                                case 6:
                                    epochIndexArray1D_1.dispose();
                                    _a.label = 7;
                                case 7: return [4, callbackList.onEpochEnd(epoch, epochLogs)];
                                case 8:
                                    _a.sent();
                                    if (model.stopTraining_) {
                                        return [2, "break"];
                                    }
                                    return [2];
                            }
                        });
                    };
                    epoch = initialEpoch;
                    _b.label = 2;
                case 2:
                    if (!(epoch < epochs)) return [3, 5];
                    return [5, _loop_1(epoch)];
                case 3:
                    state_1 = _b.sent();
                    if (state_1 === "break")
                        return [3, 5];
                    _b.label = 4;
                case 4:
                    ++epoch;
                    return [3, 2];
                case 5: return [4, callbackList.onTrainEnd()];
                case 6:
                    _b.sent();
                    return [4, model.history.syncData()];
                case 7:
                    _b.sent();
                    return [2, model.history];
            }
        });
    });
}
function fitTensors(model, x, y, config) {
    if (config === void 0) { config = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var batchSize, standardizedOuts, inputs, targets, doValidation, valX, valY, valIns, needValidationDisposal, valStandardized, splitAt, originalBatchSize, ins, trainFunction, outLabels, valFunction, callbackMetrics, callbacks, out;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (model.isTraining) {
                        throw new Error('Cannot start training because another fit() call is ongoing.');
                    }
                    model.isTraining = true;
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 3, 4]);
                    batchSize = config.batchSize == null ? 32 : config.batchSize;
                    checkBatchSize(batchSize);
                    standardizedOuts = model.standardizeUserData(x, y, false, batchSize);
                    inputs = standardizedOuts[0];
                    targets = standardizedOuts[1];
                    doValidation = false;
                    valX = void 0;
                    valY = void 0;
                    valIns = void 0;
                    needValidationDisposal = false;
                    if (config.validationData != null && config.validationData.length > 0) {
                        doValidation = true;
                        if (config.validationData.length === 2) {
                            valX = config.validationData[0];
                            valY = config.validationData[1];
                        }
                        else if (config.validationData.length === 3) {
                            throw new errors_1.NotImplementedError('validationData including sample weights is not supported yet.');
                        }
                        else {
                            throw new errors_1.ValueError("When passing validation data, it must contain 2 (valX, valY) " +
                                "or 3 (valX, valY, valSampleWeight) items; " +
                                (config.validationData + " is invalid."));
                        }
                        valStandardized = model.standardizeUserData(valX, valY, true, batchSize);
                        valX = valStandardized[0];
                        valY = valStandardized[1];
                        valIns = valX.concat(valY);
                    }
                    else if (config.validationSplit != null && config.validationSplit > 0 &&
                        config.validationSplit < 1) {
                        doValidation = true;
                        splitAt = Math.floor(inputs[0].shape[0] * (1 - config.validationSplit));
                        originalBatchSize = inputs[0].shape[0];
                        valX = sliceArrays(inputs, splitAt, originalBatchSize);
                        inputs = sliceArrays(inputs, 0, splitAt);
                        valY = sliceArrays(targets, splitAt, originalBatchSize);
                        targets = sliceArrays(targets, 0, splitAt);
                        needValidationDisposal = true;
                        valIns = valX.concat(valY);
                    }
                    else if (config.validationSteps != null) {
                        doValidation = true;
                    }
                    ins = inputs.concat(targets);
                    model.checkTrainableWeightsConsistency();
                    trainFunction = model.makeTrainFunction();
                    outLabels = model.getDedupedMetricsNames();
                    valFunction = void 0;
                    callbackMetrics = void 0;
                    if (doValidation) {
                        model.makeTestFunction();
                        valFunction = model.testFunction;
                        callbackMetrics =
                            outLabels.slice().concat(outLabels.map(function (n) { return 'val_' + n; }));
                    }
                    else {
                        valFunction = null;
                        valIns = [];
                        callbackMetrics = outLabels.slice();
                    }
                    callbacks = base_callbacks_1.standardizeCallbacks(config.callbacks);
                    return [4, fitLoop(model, trainFunction, ins, outLabels, batchSize, config.epochs, config.verbose, callbacks, valFunction, valIns, config.shuffle, callbackMetrics, config.initialEpoch, null, null, config.yieldEvery)];
                case 2:
                    out = _a.sent();
                    if (needValidationDisposal) {
                        valIns.forEach(function (tensor) { return tensor.dispose(); });
                        inputs.forEach(function (tensor) { return tensor.dispose(); });
                        targets.forEach(function (tensor) { return tensor.dispose(); });
                    }
                    model.isTraining = false;
                    return [2, out];
                case 3:
                    model.isTraining = false;
                    return [7];
                case 4: return [2];
            }
        });
    });
}
exports.fitTensors = fitTensors;

},{"../backend/tfjs_backend":209,"../base_callbacks":210,"../errors":222,"../logs":243,"../utils/math_utils":252,"@tensorflow/tfjs-core":64}],222:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AttributeError = (function (_super) {
    __extends(AttributeError, _super);
    function AttributeError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, AttributeError.prototype);
        return _this;
    }
    return AttributeError;
}(Error));
exports.AttributeError = AttributeError;
var RuntimeError = (function (_super) {
    __extends(RuntimeError, _super);
    function RuntimeError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, RuntimeError.prototype);
        return _this;
    }
    return RuntimeError;
}(Error));
exports.RuntimeError = RuntimeError;
var ValueError = (function (_super) {
    __extends(ValueError, _super);
    function ValueError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, ValueError.prototype);
        return _this;
    }
    return ValueError;
}(Error));
exports.ValueError = ValueError;
var NotImplementedError = (function (_super) {
    __extends(NotImplementedError, _super);
    function NotImplementedError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, NotImplementedError.prototype);
        return _this;
    }
    return NotImplementedError;
}(Error));
exports.NotImplementedError = NotImplementedError;
var AssertionError = (function (_super) {
    __extends(AssertionError, _super);
    function AssertionError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, AssertionError.prototype);
        return _this;
    }
    return AssertionError;
}(Error));
exports.AssertionError = AssertionError;
var IndexError = (function (_super) {
    __extends(IndexError, _super);
    function IndexError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, IndexError.prototype);
        return _this;
    }
    return IndexError;
}(Error));
exports.IndexError = IndexError;

},{}],223:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var input_layer_1 = require("./engine/input_layer");
var training_1 = require("./engine/training");
var models_1 = require("./models");
var base_callbacks_1 = require("./base_callbacks");
function model(config) {
    return new training_1.Model(config);
}
exports.model = model;
function sequential(config) {
    return new models_1.Sequential(config);
}
exports.sequential = sequential;
function loadModel(pathOrIOHandler, strict) {
    if (strict === void 0) { strict = true; }
    return models_1.loadModelInternal(pathOrIOHandler, strict);
}
exports.loadModel = loadModel;
function input(config) {
    return input_layer_1.Input(config);
}
exports.input = input;
function registerCallbackConstructor(verbosityLevel, callbackConstructor) {
    base_callbacks_1.CallbackConstructorRegistry.registerCallbackConstructor(verbosityLevel, callbackConstructor);
}
exports.registerCallbackConstructor = registerCallbackConstructor;

},{"./base_callbacks":210,"./engine/input_layer":217,"./engine/training":219,"./models":246}],224:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var constraints_1 = require("./constraints");
function maxNorm(config) {
    return new constraints_1.MaxNorm(config);
}
exports.maxNorm = maxNorm;
function unitNorm(config) {
    return new constraints_1.UnitNorm(config);
}
exports.unitNorm = unitNorm;
function nonNeg() {
    return new constraints_1.NonNeg();
}
exports.nonNeg = nonNeg;
function minMaxNorm(config) {
    return new constraints_1.MinMaxNorm(config);
}
exports.minMaxNorm = minMaxNorm;

},{"./constraints":213}],225:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var initializers_1 = require("./initializers");
function zeros() {
    return new initializers_1.Zeros();
}
exports.zeros = zeros;
function ones() {
    return new initializers_1.Ones();
}
exports.ones = ones;
function constant(config) {
    return new initializers_1.Constant(config);
}
exports.constant = constant;
function randomUniform(config) {
    return new initializers_1.RandomUniform(config);
}
exports.randomUniform = randomUniform;
function randomNormal(config) {
    return new initializers_1.RandomNormal(config);
}
exports.randomNormal = randomNormal;
function truncatedNormal(config) {
    return new initializers_1.TruncatedNormal(config);
}
exports.truncatedNormal = truncatedNormal;
function identity(config) {
    return new initializers_1.Identity(config);
}
exports.identity = identity;
function varianceScaling(config) {
    return new initializers_1.VarianceScaling(config);
}
exports.varianceScaling = varianceScaling;
function glorotUniform(config) {
    return new initializers_1.GlorotUniform(config);
}
exports.glorotUniform = glorotUniform;
function glorotNormal(config) {
    return new initializers_1.GlorotNormal(config);
}
exports.glorotNormal = glorotNormal;
function heNormal(config) {
    return new initializers_1.HeNormal(config);
}
exports.heNormal = heNormal;
function leCunNormal(config) {
    return new initializers_1.LeCunNormal(config);
}
exports.leCunNormal = leCunNormal;
function orthogonal(config) {
    return new initializers_1.Orthogonal(config);
}
exports.orthogonal = orthogonal;

},{"./initializers":230}],226:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var input_layer_1 = require("./engine/input_layer");
var topology_1 = require("./engine/topology");
exports.Layer = topology_1.Layer;
var exports_1 = require("./exports");
exports.input = exports_1.input;
var advanced_activations_1 = require("./layers/advanced_activations");
var convolutional_1 = require("./layers/convolutional");
var convolutional_depthwise_1 = require("./layers/convolutional_depthwise");
var core_1 = require("./layers/core");
var embeddings_1 = require("./layers/embeddings");
var merge_1 = require("./layers/merge");
var normalization_1 = require("./layers/normalization");
var padding_1 = require("./layers/padding");
var pooling_1 = require("./layers/pooling");
var recurrent_1 = require("./layers/recurrent");
exports.RNN = recurrent_1.RNN;
exports.RNNCell = recurrent_1.RNNCell;
var wrappers_1 = require("./layers/wrappers");
function inputLayer(config) {
    return new input_layer_1.InputLayer(config);
}
exports.inputLayer = inputLayer;
function elu(config) {
    return new advanced_activations_1.ELU(config);
}
exports.elu = elu;
function reLU(config) {
    return new advanced_activations_1.ReLU(config);
}
exports.reLU = reLU;
function leakyReLU(config) {
    return new advanced_activations_1.LeakyReLU(config);
}
exports.leakyReLU = leakyReLU;
function softmax(config) {
    return new advanced_activations_1.Softmax(config);
}
exports.softmax = softmax;
function thresholdedReLU(config) {
    return new advanced_activations_1.ThresholdedReLU(config);
}
exports.thresholdedReLU = thresholdedReLU;
function conv1d(config) {
    return new convolutional_1.Conv1D(config);
}
exports.conv1d = conv1d;
function conv2d(config) {
    return new convolutional_1.Conv2D(config);
}
exports.conv2d = conv2d;
function conv2dTranspose(config) {
    return new convolutional_1.Conv2DTranspose(config);
}
exports.conv2dTranspose = conv2dTranspose;
function separableConv2d(config) {
    return new convolutional_1.SeparableConv2D(config);
}
exports.separableConv2d = separableConv2d;
function cropping2D(config) {
    return new convolutional_1.Cropping2D(config);
}
exports.cropping2D = cropping2D;
function upSampling2d(config) {
    return new convolutional_1.UpSampling2D(config);
}
exports.upSampling2d = upSampling2d;
function depthwiseConv2d(config) {
    return new convolutional_depthwise_1.DepthwiseConv2D(config);
}
exports.depthwiseConv2d = depthwiseConv2d;
function activation(config) {
    return new core_1.Activation(config);
}
exports.activation = activation;
function dense(config) {
    return new core_1.Dense(config);
}
exports.dense = dense;
function dropout(config) {
    return new core_1.Dropout(config);
}
exports.dropout = dropout;
function flatten(config) {
    return new core_1.Flatten(config);
}
exports.flatten = flatten;
function repeatVector(config) {
    return new core_1.RepeatVector(config);
}
exports.repeatVector = repeatVector;
function reshape(config) {
    return new core_1.Reshape(config);
}
exports.reshape = reshape;
function permute(config) {
    return new core_1.Permute(config);
}
exports.permute = permute;
function embedding(config) {
    return new embeddings_1.Embedding(config);
}
exports.embedding = embedding;
function add(config) {
    return new merge_1.Add(config);
}
exports.add = add;
function average(config) {
    return new merge_1.Average(config);
}
exports.average = average;
function concatenate(config) {
    return new merge_1.Concatenate(config);
}
exports.concatenate = concatenate;
function maximum(config) {
    return new merge_1.Maximum(config);
}
exports.maximum = maximum;
function minimum(config) {
    return new merge_1.Minimum(config);
}
exports.minimum = minimum;
function multiply(config) {
    return new merge_1.Multiply(config);
}
exports.multiply = multiply;
function dot(config) {
    return new merge_1.Dot(config);
}
exports.dot = dot;
function batchNormalization(config) {
    return new normalization_1.BatchNormalization(config);
}
exports.batchNormalization = batchNormalization;
function zeroPadding2d(config) {
    return new padding_1.ZeroPadding2D(config);
}
exports.zeroPadding2d = zeroPadding2d;
function averagePooling1d(config) {
    return new pooling_1.AveragePooling1D(config);
}
exports.averagePooling1d = averagePooling1d;
function avgPool1d(config) {
    return averagePooling1d(config);
}
exports.avgPool1d = avgPool1d;
function avgPooling1d(config) {
    return averagePooling1d(config);
}
exports.avgPooling1d = avgPooling1d;
function averagePooling2d(config) {
    return new pooling_1.AveragePooling2D(config);
}
exports.averagePooling2d = averagePooling2d;
function avgPool2d(config) {
    return averagePooling2d(config);
}
exports.avgPool2d = avgPool2d;
function avgPooling2d(config) {
    return averagePooling2d(config);
}
exports.avgPooling2d = avgPooling2d;
function globalAveragePooling1d(config) {
    return new pooling_1.GlobalAveragePooling1D(config);
}
exports.globalAveragePooling1d = globalAveragePooling1d;
function globalAveragePooling2d(config) {
    return new pooling_1.GlobalAveragePooling2D(config);
}
exports.globalAveragePooling2d = globalAveragePooling2d;
function globalMaxPooling1d(config) {
    return new pooling_1.GlobalMaxPooling1D(config);
}
exports.globalMaxPooling1d = globalMaxPooling1d;
function globalMaxPooling2d(config) {
    return new pooling_1.GlobalMaxPooling2D(config);
}
exports.globalMaxPooling2d = globalMaxPooling2d;
function maxPooling1d(config) {
    return new pooling_1.MaxPooling1D(config);
}
exports.maxPooling1d = maxPooling1d;
function maxPooling2d(config) {
    return new pooling_1.MaxPooling2D(config);
}
exports.maxPooling2d = maxPooling2d;
function gru(config) {
    return new recurrent_1.GRU(config);
}
exports.gru = gru;
function gruCell(config) {
    return new recurrent_1.GRUCell(config);
}
exports.gruCell = gruCell;
function lstm(config) {
    return new recurrent_1.LSTM(config);
}
exports.lstm = lstm;
function lstmCell(config) {
    return new recurrent_1.LSTMCell(config);
}
exports.lstmCell = lstmCell;
function simpleRNN(config) {
    return new recurrent_1.SimpleRNN(config);
}
exports.simpleRNN = simpleRNN;
function simpleRNNCell(config) {
    return new recurrent_1.SimpleRNNCell(config);
}
exports.simpleRNNCell = simpleRNNCell;
function rnn(config) {
    return new recurrent_1.RNN(config);
}
exports.rnn = rnn;
function stackedRNNCells(config) {
    return new recurrent_1.StackedRNNCells(config);
}
exports.stackedRNNCells = stackedRNNCells;
function bidirectional(config) {
    return new wrappers_1.Bidirectional(config);
}
exports.bidirectional = bidirectional;
function timeDistributed(config) {
    return new wrappers_1.TimeDistributed(config);
}
exports.timeDistributed = timeDistributed;
exports.globalMaxPool1d = globalMaxPooling1d;
exports.globalMaxPool2d = globalMaxPooling2d;
exports.maxPool1d = maxPooling1d;
exports.maxPool2d = maxPooling2d;

},{"./engine/input_layer":217,"./engine/topology":218,"./exports":223,"./layers/advanced_activations":231,"./layers/convolutional":232,"./layers/convolutional_depthwise":233,"./layers/core":234,"./layers/embeddings":235,"./layers/merge":236,"./layers/normalization":237,"./layers/padding":238,"./layers/pooling":239,"./layers/recurrent":240,"./layers/wrappers":242}],227:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var losses = require("./losses");
var metrics = require("./metrics");
function binaryAccuracy(yTrue, yPred) {
    return metrics.binaryAccuracy(yTrue, yPred);
}
exports.binaryAccuracy = binaryAccuracy;
function binaryCrossentropy(yTrue, yPred) {
    return metrics.binaryCrossentropy(yTrue, yPred);
}
exports.binaryCrossentropy = binaryCrossentropy;
function categoricalAccuracy(yTrue, yPred) {
    return metrics.categoricalAccuracy(yTrue, yPred);
}
exports.categoricalAccuracy = categoricalAccuracy;
function categoricalCrossentropy(yTrue, yPred) {
    return metrics.categoricalCrossentropy(yTrue, yPred);
}
exports.categoricalCrossentropy = categoricalCrossentropy;
function precision(yTrue, yPred) {
    return metrics.precision(yTrue, yPred);
}
exports.precision = precision;
function recall(yTrue, yPred) {
    return metrics.recall(yTrue, yPred);
}
exports.recall = recall;
function cosineProximity(yTrue, yPred) {
    return losses.cosineProximity(yTrue, yPred);
}
exports.cosineProximity = cosineProximity;
function meanAbsoluteError(yTrue, yPred) {
    return losses.meanAbsoluteError(yTrue, yPred);
}
exports.meanAbsoluteError = meanAbsoluteError;
function meanAbsolutePercentageError(yTrue, yPred) {
    return losses.meanAbsolutePercentageError(yTrue, yPred);
}
exports.meanAbsolutePercentageError = meanAbsolutePercentageError;
function MAPE(yTrue, yPred) {
    return losses.meanAbsolutePercentageError(yTrue, yPred);
}
exports.MAPE = MAPE;
function mape(yTrue, yPred) {
    return losses.meanAbsolutePercentageError(yTrue, yPred);
}
exports.mape = mape;
function meanSquaredError(yTrue, yPred) {
    return losses.meanSquaredError(yTrue, yPred);
}
exports.meanSquaredError = meanSquaredError;
function MSE(yTrue, yPred) {
    return losses.meanSquaredError(yTrue, yPred);
}
exports.MSE = MSE;
function mse(yTrue, yPred) {
    return losses.meanSquaredError(yTrue, yPred);
}
exports.mse = mse;

},{"./losses":244,"./metrics":245}],228:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var regularizers = require("./regularizers");
var regularizers_1 = require("./regularizers");
function l1l2(config) {
    return new regularizers_1.L1L2(config);
}
exports.l1l2 = l1l2;
function l1(config) {
    return regularizers.l1(config);
}
exports.l1 = l1;
function l2(config) {
    return regularizers.l2(config);
}
exports.l2 = l2;

},{"./regularizers":248}],229:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var constraints = require("./exports_constraints");
exports.constraints = constraints;
var initializers = require("./exports_initializers");
exports.initializers = initializers;
var layers = require("./exports_layers");
exports.layers = layers;
var metrics = require("./exports_metrics");
exports.metrics = metrics;
var regularizers = require("./exports_regularizers");
exports.regularizers = regularizers;
var base_callbacks_1 = require("./base_callbacks");
exports.CallbackList = base_callbacks_1.CallbackList;
exports.CustomCallback = base_callbacks_1.CustomCallback;
exports.History = base_callbacks_1.History;
var callbacks_1 = require("./callbacks");
exports.Callback = callbacks_1.Callback;
var topology_1 = require("./engine/topology");
exports.InputSpec = topology_1.InputSpec;
exports.SymbolicTensor = topology_1.SymbolicTensor;
var training_1 = require("./engine/training");
exports.Model = training_1.Model;
var exports_1 = require("./exports");
exports.input = exports_1.input;
exports.loadModel = exports_1.loadModel;
exports.model = exports_1.model;
exports.registerCallbackConstructor = exports_1.registerCallbackConstructor;
exports.sequential = exports_1.sequential;
var recurrent_1 = require("./layers/recurrent");
exports.RNN = recurrent_1.RNN;
var models_1 = require("./models");
exports.Sequential = models_1.Sequential;
var variables_1 = require("./variables");
exports.LayerVariable = variables_1.LayerVariable;
var version_1 = require("./version");
exports.version_layers = version_1.version;

},{"./base_callbacks":210,"./callbacks":211,"./engine/topology":218,"./engine/training":219,"./exports":223,"./exports_constraints":224,"./exports_initializers":225,"./exports_layers":226,"./exports_metrics":227,"./exports_regularizers":228,"./layers/recurrent":240,"./models":246,"./variables":256,"./version":257}],230:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var state_1 = require("./backend/state");
var K = require("./backend/tfjs_backend");
var common_1 = require("./common");
var errors_1 = require("./errors");
var generic_utils_1 = require("./utils/generic_utils");
var math_utils_1 = require("./utils/math_utils");
exports.VALID_FAN_MODE_VALUES = ['fanIn', 'fanOut', 'fanAvg'];
function checkFanMode(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_FAN_MODE_VALUES, 'FanMode', value);
}
exports.checkFanMode = checkFanMode;
exports.VALID_DISTRIBUTION_VALUES = ['normal', 'uniform'];
function checkDistribution(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_DISTRIBUTION_VALUES, 'Distribution', value);
}
exports.checkDistribution = checkDistribution;
var Initializer = (function (_super) {
    __extends(Initializer, _super);
    function Initializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Initializer.prototype.fromConfigUsesCustomObjects = function () {
        return false;
    };
    Initializer.prototype.getConfig = function () {
        return {};
    };
    return Initializer;
}(tfjs_core_1.serialization.Serializable));
exports.Initializer = Initializer;
var Zeros = (function (_super) {
    __extends(Zeros, _super);
    function Zeros() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Zeros.prototype.apply = function (shape, dtype) {
        return tfjs_core_1.zeros(shape, dtype);
    };
    Zeros.className = 'Zeros';
    return Zeros;
}(Initializer));
exports.Zeros = Zeros;
tfjs_core_1.serialization.registerClass(Zeros);
var Ones = (function (_super) {
    __extends(Ones, _super);
    function Ones() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Ones.prototype.apply = function (shape, dtype) {
        return tfjs_core_1.ones(shape, dtype);
    };
    Ones.className = 'Ones';
    return Ones;
}(Initializer));
exports.Ones = Ones;
tfjs_core_1.serialization.registerClass(Ones);
var Constant = (function (_super) {
    __extends(Constant, _super);
    function Constant(config) {
        var _this = _super.call(this) || this;
        if (typeof config !== 'object') {
            throw new errors_1.ValueError("Expected argument of type ConstantConfig but got " + config);
        }
        if (config.value === undefined) {
            throw new errors_1.ValueError("config must have value set but got " + config);
        }
        _this.value = config.value;
        return _this;
    }
    Constant.prototype.apply = function (shape, dtype) {
        var _this = this;
        return tfjs_core_1.tidy(function () { return tfjs_core_1.mul(tfjs_core_1.scalar(_this.value), tfjs_core_1.ones(shape, dtype)); });
    };
    Constant.prototype.getConfig = function () {
        return {
            value: this.value,
        };
    };
    Constant.className = 'Constant';
    return Constant;
}(Initializer));
exports.Constant = Constant;
tfjs_core_1.serialization.registerClass(Constant);
var RandomUniform = (function (_super) {
    __extends(RandomUniform, _super);
    function RandomUniform(config) {
        var _this = _super.call(this) || this;
        _this.DEFAULT_MINVAL = -0.05;
        _this.DEFAULT_MAXVAL = 0.05;
        _this.minval = config.minval || _this.DEFAULT_MINVAL;
        _this.maxval = config.maxval || _this.DEFAULT_MAXVAL;
        _this.seed = config.seed;
        return _this;
    }
    RandomUniform.prototype.apply = function (shape, dtype) {
        return tfjs_core_1.randomUniform(shape, this.minval, this.maxval, dtype);
    };
    RandomUniform.prototype.getConfig = function () {
        return { minval: this.minval, maxval: this.maxval, seed: this.seed };
    };
    RandomUniform.className = 'RandomUniform';
    return RandomUniform;
}(Initializer));
exports.RandomUniform = RandomUniform;
tfjs_core_1.serialization.registerClass(RandomUniform);
var RandomNormal = (function (_super) {
    __extends(RandomNormal, _super);
    function RandomNormal(config) {
        var _this = _super.call(this) || this;
        _this.DEFAULT_MEAN = 0.;
        _this.DEFAULT_STDDEV = 0.05;
        _this.mean = config.mean || _this.DEFAULT_MEAN;
        _this.stddev = config.stddev || _this.DEFAULT_STDDEV;
        _this.seed = config.seed;
        return _this;
    }
    RandomNormal.prototype.apply = function (shape, dtype) {
        dtype = dtype || 'float32';
        if (dtype !== 'float32' && dtype !== 'int32') {
            throw new errors_1.NotImplementedError("randomNormal does not support dType " + dtype + ".");
        }
        return K.randomNormal(shape, this.mean, this.stddev, dtype, this.seed);
    };
    RandomNormal.prototype.getConfig = function () {
        return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    };
    RandomNormal.className = 'RandomNormal';
    return RandomNormal;
}(Initializer));
exports.RandomNormal = RandomNormal;
tfjs_core_1.serialization.registerClass(RandomNormal);
var TruncatedNormal = (function (_super) {
    __extends(TruncatedNormal, _super);
    function TruncatedNormal(config) {
        var _this = _super.call(this) || this;
        _this.DEFAULT_MEAN = 0.;
        _this.DEFAULT_STDDEV = 0.05;
        _this.mean = config.mean || _this.DEFAULT_MEAN;
        _this.stddev = config.stddev || _this.DEFAULT_STDDEV;
        _this.seed = config.seed;
        return _this;
    }
    TruncatedNormal.prototype.apply = function (shape, dtype) {
        dtype = dtype || 'float32';
        if (dtype !== 'float32' && dtype !== 'int32') {
            throw new errors_1.NotImplementedError("truncatedNormal does not support dType " + dtype + ".");
        }
        return tfjs_core_1.truncatedNormal(shape, this.mean, this.stddev, dtype, this.seed);
    };
    TruncatedNormal.prototype.getConfig = function () {
        return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    };
    TruncatedNormal.className = 'TruncatedNormal';
    return TruncatedNormal;
}(Initializer));
exports.TruncatedNormal = TruncatedNormal;
tfjs_core_1.serialization.registerClass(TruncatedNormal);
var Identity = (function (_super) {
    __extends(Identity, _super);
    function Identity(config) {
        var _this = _super.call(this) || this;
        _this.gain = config.gain != null ? tfjs_core_1.scalar(config.gain) : state_1.getScalar(1.0);
        return _this;
    }
    Identity.prototype.apply = function (shape, dtype) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (shape.length !== 2 || shape[0] !== shape[1]) {
                throw new errors_1.ValueError('Identity matrix initializer can only be used for' +
                    ' 2D square matrices.');
            }
            else {
                return tfjs_core_1.mul(_this.gain, tfjs_core_1.eye(shape[0]));
            }
        });
    };
    Identity.prototype.getConfig = function () {
        return { gain: this.gain.get() };
    };
    Identity.className = 'Identity';
    return Identity;
}(Initializer));
exports.Identity = Identity;
tfjs_core_1.serialization.registerClass(Identity);
function computeFans(shape, dataFormat) {
    if (dataFormat === void 0) { dataFormat = 'channelsLast'; }
    var fanIn;
    var fanOut;
    common_1.checkDataFormat(dataFormat);
    if (shape.length === 2) {
        fanIn = shape[0];
        fanOut = shape[1];
    }
    else if ([3, 4, 5].indexOf(shape.length) !== -1) {
        if (dataFormat === 'channelsFirst') {
            var receptiveFieldSize = math_utils_1.arrayProd(shape, 2);
            fanIn = shape[1] * receptiveFieldSize;
            fanOut = shape[0] * receptiveFieldSize;
        }
        else if (dataFormat === 'channelsLast') {
            var receptiveFieldSize = math_utils_1.arrayProd(shape, 0, shape.length - 2);
            fanIn = shape[shape.length - 2] * receptiveFieldSize;
            fanOut = shape[shape.length - 1] * receptiveFieldSize;
        }
    }
    else {
        var shapeProd = math_utils_1.arrayProd(shape);
        fanIn = Math.sqrt(shapeProd);
        fanOut = Math.sqrt(shapeProd);
    }
    return [fanIn, fanOut];
}
var VarianceScaling = (function (_super) {
    __extends(VarianceScaling, _super);
    function VarianceScaling(config) {
        var _this = _super.call(this) || this;
        if (config.scale < 0.0) {
            throw new errors_1.ValueError("scale must be a positive float. Got: " + config.scale);
        }
        _this.scale = config.scale == null ? 1.0 : config.scale;
        _this.mode = config.mode;
        checkFanMode(_this.mode);
        _this.distribution = config.distribution;
        checkDistribution(_this.distribution);
        _this.seed = config.seed;
        return _this;
    }
    VarianceScaling.prototype.apply = function (shape, dtype) {
        var fans = computeFans(shape);
        var fanIn = fans[0];
        var fanOut = fans[1];
        var scale = this.scale;
        if (this.mode === 'fanIn') {
            scale /= Math.max(1, fanIn);
        }
        else if (this.mode === 'fanOut') {
            scale /= Math.max(1, fanOut);
        }
        else {
            scale /= Math.max(1, (fanIn + fanOut) / 2);
        }
        if (this.distribution === 'normal') {
            var stddev = Math.sqrt(scale);
            dtype = dtype || 'float32';
            if (dtype !== 'float32' && dtype !== 'int32') {
                throw new errors_1.NotImplementedError(this.getClassName() + " does not support dType " + dtype + ".");
            }
            return tfjs_core_1.truncatedNormal(shape, 0, stddev, dtype, this.seed);
        }
        else {
            var limit = Math.sqrt(3 * scale);
            return tfjs_core_1.randomUniform(shape, -limit, limit, dtype);
        }
    };
    VarianceScaling.prototype.getConfig = function () {
        return {
            scale: this.scale,
            mode: this.mode,
            distribution: this.distribution,
            seed: this.seed
        };
    };
    VarianceScaling.className = 'VarianceScaling';
    return VarianceScaling;
}(Initializer));
exports.VarianceScaling = VarianceScaling;
tfjs_core_1.serialization.registerClass(VarianceScaling);
var GlorotUniform = (function (_super) {
    __extends(GlorotUniform, _super);
    function GlorotUniform(config) {
        return _super.call(this, {
            scale: 1.0,
            mode: 'fanAvg',
            distribution: 'uniform',
            seed: config == null ? null : config.seed
        }) || this;
    }
    GlorotUniform.prototype.getClassName = function () {
        return VarianceScaling.className;
    };
    return GlorotUniform;
}(VarianceScaling));
exports.GlorotUniform = GlorotUniform;
var GlorotNormal = (function (_super) {
    __extends(GlorotNormal, _super);
    function GlorotNormal(config) {
        return _super.call(this, {
            scale: 1.0,
            mode: 'fanAvg',
            distribution: 'normal',
            seed: config == null ? null : config.seed
        }) || this;
    }
    GlorotNormal.prototype.getClassName = function () {
        return VarianceScaling.className;
    };
    return GlorotNormal;
}(VarianceScaling));
exports.GlorotNormal = GlorotNormal;
var HeNormal = (function (_super) {
    __extends(HeNormal, _super);
    function HeNormal(config) {
        return _super.call(this, {
            scale: 2.0,
            mode: 'fanIn',
            distribution: 'normal',
            seed: config == null ? null : config.seed
        }) || this;
    }
    HeNormal.prototype.getClassName = function () {
        return VarianceScaling.className;
    };
    return HeNormal;
}(VarianceScaling));
exports.HeNormal = HeNormal;
var LeCunNormal = (function (_super) {
    __extends(LeCunNormal, _super);
    function LeCunNormal(config) {
        return _super.call(this, {
            scale: 1.0,
            mode: 'fanIn',
            distribution: 'normal',
            seed: config == null ? null : config.seed
        }) || this;
    }
    LeCunNormal.prototype.getClassName = function () {
        return VarianceScaling.className;
    };
    return LeCunNormal;
}(VarianceScaling));
exports.LeCunNormal = LeCunNormal;
var Orthogonal = (function (_super) {
    __extends(Orthogonal, _super);
    function Orthogonal(config) {
        var _this = _super.call(this) || this;
        _this.DEFAULT_GAIN = 1;
        _this.gain = config.gain == null ? _this.DEFAULT_GAIN : config.gain;
        _this.seed = config.seed;
        if (_this.seed != null) {
            throw new errors_1.NotImplementedError('Random seed is not implemented for Orthogonal Initializer yet.');
        }
        return _this;
    }
    Orthogonal.prototype.apply = function (shape, dtype) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (shape.length !== 2) {
                throw new errors_1.NotImplementedError('The Orthogonal Initializer does not support non-2D shapes yet.');
            }
            if (shape[0] * shape[1] > 2000) {
                console.warn("Orthogonal initializer is being called on a matrix with more " +
                    ("than 2000 (" + shape[0] * shape[1] + ") elements: ") +
                    "Slowness may result.");
            }
            var normalizedShape = shape[0] > shape[1] ? [shape[1], shape[0]] : shape;
            var a = K.randomNormal(normalizedShape, 0, 1, 'float32');
            var q = tfjs_core_1.linalg.gramSchmidt(a);
            if (shape[0] > shape[1]) {
                q = q.transpose();
            }
            return tfjs_core_1.mul(state_1.getScalar(_this.gain), q);
        });
    };
    Orthogonal.prototype.getConfig = function () {
        return {
            gain: this.gain,
            seed: this.seed,
        };
    };
    Orthogonal.className = 'Orthogonal';
    return Orthogonal;
}(Initializer));
exports.Orthogonal = Orthogonal;
tfjs_core_1.serialization.registerClass(Orthogonal);
exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    'constant': 'Constant',
    'glorotNormal': 'GlorotNormal',
    'glorotUniform': 'GlorotUniform',
    'heNormal': 'HeNormal',
    'identity': 'Identity',
    'leCunNormal': 'LeCunNormal',
    'ones': 'Ones',
    'orthogonal': 'Orthogonal',
    'randomNormal': 'RandomNormal',
    'randomUniform': 'RandomUniform',
    'truncatedNormal': 'TruncatedNormal',
    'varianceScaling': 'VarianceScaling',
    'zeros': 'Zeros'
};
function deserializeInitializer(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'initializer');
}
function serializeInitializer(initializer) {
    return generic_utils_1.serializeKerasObject(initializer);
}
exports.serializeInitializer = serializeInitializer;
function getInitializer(identifier) {
    if (typeof identifier === 'string') {
        var className = identifier in exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ?
            exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :
            identifier;
        if (className === 'GlorotUniform') {
            return new GlorotUniform();
        }
        else if (className === 'GlorotNormal') {
            return new GlorotNormal();
        }
        else if (className === 'HeNormal') {
            return new HeNormal();
        }
        else if (className === 'LeCunNormal') {
            return new LeCunNormal();
        }
        else {
            var config = { className: className, config: {} };
            return deserializeInitializer(config);
        }
    }
    else if (identifier instanceof Initializer) {
        return identifier;
    }
    else {
        return deserializeInitializer(identifier);
    }
}
exports.getInitializer = getInitializer;

},{"./backend/state":208,"./backend/tfjs_backend":209,"./common":212,"./errors":222,"./utils/generic_utils":250,"./utils/math_utils":252,"@tensorflow/tfjs-core":64}],231:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var activations_1 = require("../activations");
var tfjs_backend_1 = require("../backend/tfjs_backend");
var topology_1 = require("../engine/topology");
var state_1 = require("../backend/state");
var errors_1 = require("../errors");
var types_utils_1 = require("../utils/types_utils");
var ReLU = (function (_super) {
    __extends(ReLU, _super);
    function ReLU(config) {
        var _this = _super.call(this, config == null ? {} : config) || this;
        _this.supportsMasking = true;
        if (config != null) {
            _this.maxValue = config.maxValue;
        }
        return _this;
    }
    ReLU.prototype.call = function (inputs, kwargs) {
        inputs = types_utils_1.getExactlyOneTensor(inputs);
        var output = tfjs_core_1.relu(inputs);
        if (this.maxValue != null) {
            output = tfjs_core_1.clipByValue(output, 0, this.maxValue);
        }
        return output;
    };
    ReLU.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    ReLU.prototype.getConfig = function () {
        var config = { maxValue: this.maxValue };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    ReLU.className = 'ReLU';
    return ReLU;
}(topology_1.Layer));
exports.ReLU = ReLU;
tfjs_core_1.serialization.registerClass(ReLU);
var LeakyReLU = (function (_super) {
    __extends(LeakyReLU, _super);
    function LeakyReLU(config) {
        var _this = _super.call(this, config == null ? {} : config) || this;
        _this.DEFAULT_ALPHA = 0.3;
        if (config == null) {
            config = {};
        }
        _this.alpha = config.alpha == null ? _this.DEFAULT_ALPHA : config.alpha;
        return _this;
    }
    LeakyReLU.prototype.call = function (inputs, kwargs) {
        var x = types_utils_1.getExactlyOneTensor(inputs);
        return tfjs_core_1.leakyRelu(x, this.alpha);
    };
    LeakyReLU.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    LeakyReLU.prototype.getConfig = function () {
        var config = { alpha: this.alpha };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    LeakyReLU.className = 'LeakyReLU';
    return LeakyReLU;
}(topology_1.Layer));
exports.LeakyReLU = LeakyReLU;
tfjs_core_1.serialization.registerClass(LeakyReLU);
var ELU = (function (_super) {
    __extends(ELU, _super);
    function ELU(config) {
        var _this = _super.call(this, config == null ? {} : config) || this;
        _this.DEFAULT_ALPHA = 1.0;
        if (config == null) {
            config = {};
        }
        if (config.alpha != null && config.alpha !== _this.DEFAULT_ALPHA) {
            throw new errors_1.NotImplementedError("Non-default alpha value (" + config.alpha + ") is not supported by the " +
                "ELU layer yet.");
        }
        _this.alpha = config.alpha == null ? _this.DEFAULT_ALPHA : config.alpha;
        return _this;
    }
    ELU.prototype.call = function (inputs, kwargs) {
        var x = types_utils_1.getExactlyOneTensor(inputs);
        return tfjs_core_1.elu(x);
    };
    ELU.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    ELU.prototype.getConfig = function () {
        var config = { alpha: this.alpha };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    ELU.className = 'ELU';
    return ELU;
}(topology_1.Layer));
exports.ELU = ELU;
tfjs_core_1.serialization.registerClass(ELU);
var ThresholdedReLU = (function (_super) {
    __extends(ThresholdedReLU, _super);
    function ThresholdedReLU(config) {
        var _this = _super.call(this, config == null ? {} : config) || this;
        _this.DEFAULT_THETA = 1.0;
        if (config == null) {
            config = {};
        }
        _this.theta = config.theta == null ? _this.DEFAULT_THETA : config.theta;
        _this.thetaTensor = state_1.getScalar(_this.theta);
        return _this;
    }
    ThresholdedReLU.prototype.call = function (inputs, kwargs) {
        var x = types_utils_1.getExactlyOneTensor(inputs);
        return x.mul(tfjs_backend_1.cast(x.greater(this.thetaTensor), 'float32'));
    };
    ThresholdedReLU.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    ThresholdedReLU.prototype.getConfig = function () {
        var config = { theta: this.theta };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    ThresholdedReLU.className = 'ThresholdedReLU';
    return ThresholdedReLU;
}(topology_1.Layer));
exports.ThresholdedReLU = ThresholdedReLU;
tfjs_core_1.serialization.registerClass(ThresholdedReLU);
var Softmax = (function (_super) {
    __extends(Softmax, _super);
    function Softmax(config) {
        var _this = _super.call(this, config == null ? {} : config) || this;
        _this.DEFAULT_AXIS = 1.0;
        if (config == null) {
            config = {};
        }
        _this.softmax = new activations_1.Softmax().apply;
        _this.axis = config.axis == null ? _this.DEFAULT_AXIS : config.axis;
        return _this;
    }
    Softmax.prototype.call = function (inputs, kwargs) {
        var x = types_utils_1.getExactlyOneTensor(inputs);
        return this.softmax(x, this.axis);
    };
    Softmax.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    Softmax.prototype.getConfig = function () {
        var config = { axis: this.axis };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Softmax.className = 'Softmax';
    return Softmax;
}(topology_1.Layer));
exports.Softmax = Softmax;
tfjs_core_1.serialization.registerClass(Softmax);

},{"../activations":206,"../backend/state":208,"../backend/tfjs_backend":209,"../engine/topology":218,"../errors":222,"../utils/types_utils":254,"@tensorflow/tfjs-core":64}],232:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var activations_1 = require("../activations");
var common_1 = require("../backend/common");
var K = require("../backend/tfjs_backend");
var common_2 = require("../common");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var conv_utils_1 = require("../utils/conv_utils");
var generic_utils = require("../utils/generic_utils");
var types_utils_1 = require("../utils/types_utils");
function preprocessConv2DInput(x, dataFormat) {
    return tfjs_core_1.tidy(function () {
        common_2.checkDataFormat(dataFormat);
        if (dataFormat === 'channelsFirst') {
            return tfc.transpose(x, [0, 2, 3, 1]);
        }
        else {
            return x;
        }
    });
}
exports.preprocessConv2DInput = preprocessConv2DInput;
function conv1dWithBias(x, kernel, bias, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = 1; }
    if (padding === void 0) { padding = 'valid'; }
    if (dilationRate === void 0) { dilationRate = 1; }
    return tfjs_core_1.tidy(function () {
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        common_2.checkDataFormat(dataFormat);
        if (x.shape.length !== 3) {
            throw new errors_1.ValueError("The input of a conv1dWithBias operation should be 3, but is " +
                (x.shape.length + " instead."));
        }
        if (kernel.shape.length !== 3) {
            throw new errors_1.ValueError("The kernel for a conv1dWithBias operation should be 3, but is " +
                (kernel.shape.length + " instead"));
        }
        if (bias != null && bias.shape.length !== 1) {
            throw new errors_1.ValueError("The bias for a conv1dWithBias operation should be 1, but is " +
                (kernel.shape.length + " instead"));
        }
        if (dataFormat === 'channelsFirst') {
            x = tfc.transpose(x, [0, 2, 1]);
        }
        if (padding === 'causal') {
            throw new errors_1.NotImplementedError('The support for CAUSAL padding mode in conv1dWithBias is not ' +
                'implemented yet.');
        }
        var y = tfc.conv1d(x, kernel, strides, padding === 'same' ? 'same' : 'valid', 'NWC', dilationRate);
        if (bias != null) {
            y = K.biasAdd(y, bias);
        }
        return y;
    });
}
exports.conv1dWithBias = conv1dWithBias;
function conv1d(x, kernel, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = 1; }
    if (padding === void 0) { padding = 'valid'; }
    if (dilationRate === void 0) { dilationRate = 1; }
    return tfjs_core_1.tidy(function () {
        common_2.checkDataFormat(dataFormat);
        return conv1dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate);
    });
}
exports.conv1d = conv1d;
function conv2d(x, kernel, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = [1, 1]; }
    if (padding === void 0) { padding = 'valid'; }
    return tfjs_core_1.tidy(function () {
        common_2.checkDataFormat(dataFormat);
        return conv2dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate);
    });
}
exports.conv2d = conv2d;
function conv2dWithBias(x, kernel, bias, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = [1, 1]; }
    if (padding === void 0) { padding = 'valid'; }
    return tfjs_core_1.tidy(function () {
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        common_2.checkDataFormat(dataFormat);
        if (x.rank !== 3 && x.rank !== 4) {
            throw new errors_1.ValueError("conv2dWithBias expects input to be of rank 3 or 4, but received " +
                (x.rank + "."));
        }
        if (kernel.rank !== 3 && kernel.rank !== 4) {
            throw new errors_1.ValueError("conv2dWithBias expects kernel to be of rank 3 or 4, but received " +
                (x.rank + "."));
        }
        var y = preprocessConv2DInput(x, dataFormat);
        if (padding === 'causal') {
            throw new errors_1.NotImplementedError('The support for CAUSAL padding mode in conv1dWithBias is not ' +
                'implemented yet.');
        }
        y = tfc.conv2d(y, kernel, strides, padding === 'same' ? 'same' : 'valid', 'NHWC', dilationRate);
        if (bias != null) {
            y = K.biasAdd(y, bias);
        }
        if (dataFormat === 'channelsFirst') {
            y = tfc.transpose(y, [0, 3, 1, 2]);
        }
        return y;
    });
}
exports.conv2dWithBias = conv2dWithBias;
var BaseConv = (function (_super) {
    __extends(BaseConv, _super);
    function BaseConv(rank, config) {
        var _this = _super.call(this, config) || this;
        _this.bias = null;
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        BaseConv.verifyConfig(config);
        _this.rank = rank;
        if (_this.rank !== 1 && _this.rank !== 2) {
            throw new errors_1.NotImplementedError("Convolution layer for rank other than 1 or 2 (" + _this.rank + ") is " +
                "not implemented yet.");
        }
        _this.kernelSize = conv_utils_1.normalizeArray(config.kernelSize, rank, 'kernelSize');
        _this.strides = conv_utils_1.normalizeArray(config.strides == null ? 1 : config.strides, rank, 'strides');
        _this.padding = config.padding == null ? 'valid' : config.padding;
        common_2.checkPaddingMode(_this.padding);
        _this.dataFormat =
            config.dataFormat == null ? 'channelsLast' : config.dataFormat;
        common_2.checkDataFormat(_this.dataFormat);
        _this.activation = activations_1.getActivation(config.activation);
        _this.useBias = config.useBias == null ? true : config.useBias;
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);
        _this.dilationRate = conv_utils_1.normalizeArray(config.dilationRate == null ? 1 : config.dilationRate, rank, 'dilationRate');
        if (_this.rank === 1 &&
            (Array.isArray(_this.dilationRate) &&
                _this.dilationRate.length !== 1)) {
            throw new errors_1.ValueError("dilationRate must be a number or an array of a single number " +
                "for 1D convolution, but received " +
                ("" + JSON.stringify(_this.dilationRate)));
        }
        if (_this.rank === 2) {
            if (typeof _this.dilationRate === 'number') {
                _this.dilationRate = [_this.dilationRate, _this.dilationRate];
            }
            else if (_this.dilationRate.length !== 2) {
                throw new errors_1.ValueError("dilationRate must be a number or array of two numbers for 2D " +
                    ("convolution, but received " + JSON.stringify(_this.dilationRate)));
            }
        }
        return _this;
    }
    BaseConv.verifyConfig = function (config) {
        generic_utils.assert('kernelSize' in config, "required key 'kernelSize' not in config");
        if (typeof config.kernelSize !== 'number' &&
            !generic_utils.checkArrayTypeAndLength(config.kernelSize, 'number', 1, 2))
            throw new errors_1.ValueError("BaseConv expects config.kernelSize to be number or number[] with " +
                ("length 1 or 2, but received " + JSON.stringify(config.kernelSize) + "."));
    };
    BaseConv.prototype.getConfig = function () {
        var config = {
            kernelSize: this.kernelSize,
            strides: this.strides,
            padding: this.padding,
            dataFormat: this.dataFormat,
            dilationRate: this.dilationRate,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint)
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    return BaseConv;
}(topology_1.Layer));
exports.BaseConv = BaseConv;
var Conv = (function (_super) {
    __extends(Conv, _super);
    function Conv(rank, config) {
        var _this = _super.call(this, rank, config) || this;
        _this.kernel = null;
        Conv.verifyConfig(config);
        _this.filters = config.filters;
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        return _this;
    }
    Conv.prototype.build = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;
        if (inputShape[channelAxis] == null) {
            throw new errors_1.ValueError("The channel dimension of the input should be defined. " +
                ("Found " + inputShape[channelAxis]));
        }
        var inputDim = inputShape[channelAxis];
        var kernelShape = this.kernelSize.concat([inputDim, this.filters]);
        this.kernel = this.addWeight('kernel', kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        this.inputSpec = [{ ndim: this.rank + 2, axes: (_a = {}, _a[channelAxis] = inputDim, _a) }];
        this.built = true;
        var _a;
    };
    Conv.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = types_utils_1.getExactlyOneTensor(inputs);
            var outputs;
            var biasValue = _this.bias == null ? null : _this.bias.read();
            if (_this.rank === 1) {
                outputs = conv1dWithBias(inputs, _this.kernel.read(), biasValue, _this.strides[0], _this.padding, _this.dataFormat, _this.dilationRate[0]);
            }
            else if (_this.rank === 2) {
                outputs = conv2dWithBias(inputs, _this.kernel.read(), biasValue, _this.strides, _this.padding, _this.dataFormat, _this.dilationRate);
            }
            else if (_this.rank === 3) {
                throw new errors_1.NotImplementedError('3D convolution is not implemented yet.');
            }
            if (_this.activation != null) {
                outputs = _this.activation.apply(outputs);
            }
            return outputs;
        });
    };
    Conv.prototype.computeOutputShape = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var newSpace = [];
        var space = (this.dataFormat === 'channelsLast') ?
            inputShape.slice(1, inputShape.length - 1) :
            inputShape.slice(2);
        for (var i = 0; i < space.length; ++i) {
            var newDim = conv_utils_1.convOutputLength(space[i], this.kernelSize[i], this.padding, this.strides[i], typeof this.dilationRate === 'number' ? this.dilationRate :
                this.dilationRate[i]);
            newSpace.push(newDim);
        }
        var outputShape = [inputShape[0]];
        if (this.dataFormat === 'channelsLast') {
            outputShape = outputShape.concat(newSpace);
            outputShape.push(this.filters);
        }
        else {
            outputShape.push(this.filters);
            outputShape = outputShape.concat(newSpace);
        }
        return outputShape;
    };
    Conv.prototype.getConfig = function () {
        var config = {
            filters: this.filters,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint)
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Conv.verifyConfig = function (config) {
        if (!('filters' in config) || typeof config.filters !== 'number' ||
            config.filters < 1) {
            throw new errors_1.ValueError("Convolution layer expected config.filters to be a 'number' > 0 " +
                ("but got " + JSON.stringify(config.filters)));
        }
    };
    return Conv;
}(BaseConv));
exports.Conv = Conv;
var Conv2D = (function (_super) {
    __extends(Conv2D, _super);
    function Conv2D(config) {
        var _this = _super.call(this, 2, config) || this;
        Conv2D.verifyConfig(config);
        return _this;
    }
    Conv2D.prototype.getConfig = function () {
        var config = _super.prototype.getConfig.call(this);
        delete config['rank'];
        return config;
    };
    Conv2D.verifyConfig = function (config) {
        if ((typeof config.kernelSize !== 'number') &&
            !generic_utils.checkArrayTypeAndLength(config.kernelSize, 'number', 1, 2))
            throw new errors_1.ValueError("Conv2D expects config.kernelSize to be number or number[] with " +
                ("length 1 or 2, but received " + JSON.stringify(config.kernelSize) + "."));
    };
    Conv2D.className = 'Conv2D';
    return Conv2D;
}(Conv));
exports.Conv2D = Conv2D;
tfjs_core_1.serialization.registerClass(Conv2D);
var Conv2DTranspose = (function (_super) {
    __extends(Conv2DTranspose, _super);
    function Conv2DTranspose(config) {
        var _this = _super.call(this, config) || this;
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 4 })];
        if (_this.padding !== 'same' && _this.padding !== 'valid') {
            throw new errors_1.ValueError("Conv2DTranspose currently supports only padding modes 'same' " +
                ("and 'valid', but received padding mode " + _this.padding));
        }
        return _this;
    }
    Conv2DTranspose.prototype.build = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        if (inputShape.length !== 4) {
            throw new errors_1.ValueError('Input should have rank 4; Received input shape: ' +
                JSON.stringify(inputShape));
        }
        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;
        if (inputShape[channelAxis] == null) {
            throw new errors_1.ValueError('The channel dimension of the inputs should be defined. ' +
                'Found `None`.');
        }
        var inputDim = inputShape[channelAxis];
        var kernelShape = this.kernelSize.concat([this.filters, inputDim]);
        this.kernel = this.addWeight('kernel', kernelShape, 'float32', this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.filters], 'float32', this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        this.inputSpec =
            [new topology_1.InputSpec({ ndim: 4, axes: (_a = {}, _a[channelAxis] = inputDim, _a) })];
        this.built = true;
        var _a;
    };
    Conv2DTranspose.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfc.tidy(function () {
            var input = types_utils_1.getExactlyOneTensor(inputs);
            if (input.shape.length !== 4) {
                throw new errors_1.ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but " +
                    ("received a tensor of rank-" + input.shape.length));
            }
            var inputShape = input.shape;
            var batchSize = inputShape[0];
            var hAxis;
            var wAxis;
            if (_this.dataFormat === 'channelsFirst') {
                hAxis = 2;
                wAxis = 3;
            }
            else {
                hAxis = 1;
                wAxis = 2;
            }
            var height = inputShape[hAxis];
            var width = inputShape[wAxis];
            var kernelH = _this.kernelSize[0];
            var kernelW = _this.kernelSize[1];
            var strideH = _this.strides[0];
            var strideW = _this.strides[1];
            var outHeight = conv_utils_1.deconvLength(height, strideH, kernelH, _this.padding);
            var outWidth = conv_utils_1.deconvLength(width, strideW, kernelW, _this.padding);
            var outputShape = [batchSize, outHeight, outWidth, _this.filters];
            if (_this.dataFormat !== 'channelsLast') {
                input = tfc.transpose(input, [0, 2, 3, 1]);
            }
            var outputs = tfc.conv2dTranspose(input, _this.kernel.read(), outputShape, _this.strides, _this.padding);
            if (_this.dataFormat !== 'channelsLast') {
                outputs = tfc.transpose(outputs, [0, 3, 1, 2]);
            }
            if (_this.bias != null) {
                outputs =
                    K.biasAdd(outputs, _this.bias.read(), _this.dataFormat);
            }
            if (_this.activation != null) {
                outputs = _this.activation.apply(outputs);
            }
            return outputs;
        });
    };
    Conv2DTranspose.prototype.computeOutputShape = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var outputShape = inputShape.slice();
        var channelAxis;
        var heightAxis;
        var widthAxis;
        if (this.dataFormat === 'channelsFirst') {
            channelAxis = 1;
            heightAxis = 2;
            widthAxis = 3;
        }
        else {
            channelAxis = 3;
            heightAxis = 1;
            widthAxis = 2;
        }
        var kernelH = this.kernelSize[0];
        var kernelW = this.kernelSize[1];
        var strideH = this.strides[0];
        var strideW = this.strides[1];
        outputShape[channelAxis] = this.filters;
        outputShape[heightAxis] =
            conv_utils_1.deconvLength(outputShape[heightAxis], strideH, kernelH, this.padding);
        outputShape[widthAxis] =
            conv_utils_1.deconvLength(outputShape[widthAxis], strideW, kernelW, this.padding);
        return outputShape;
    };
    Conv2DTranspose.prototype.getConfig = function () {
        var config = _super.prototype.getConfig.call(this);
        delete config['dilationRate'];
        return config;
    };
    Conv2DTranspose.className = 'Conv2DTranspose';
    return Conv2DTranspose;
}(Conv2D));
exports.Conv2DTranspose = Conv2DTranspose;
tfjs_core_1.serialization.registerClass(Conv2DTranspose);
var SeparableConv = (function (_super) {
    __extends(SeparableConv, _super);
    function SeparableConv(rank, config) {
        var _this = _super.call(this, rank, config) || this;
        _this.DEFAULT_DEPTHWISE_INITIALIZER = 'glorotUniform';
        _this.DEFAULT_POINTWISE_INITIALIZER = 'glorotUniform';
        _this.depthwiseKernel = null;
        _this.pointwiseKernel = null;
        if (config.filters == null) {
            throw new errors_1.ValueError('The `filters` configuration field is required by SeparableConv, ' +
                'but is unspecified.');
        }
        if (config.kernelInitializer != null || config.kernelRegularizer != null ||
            config.kernelConstraint != null) {
            throw new errors_1.ValueError('Fields kernelInitializer, kernelRegularizer and kernelConstraint ' +
                'are invalid for SeparableConv2D. Use depthwiseInitializer, ' +
                'depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, ' +
                'pointwiseRegularizer and pointwiseConstraint instead.');
        }
        if (config.padding != null && config.padding !== 'same' &&
            config.padding !== 'valid') {
            throw new errors_1.ValueError("SeparableConv" + _this.rank + "D supports only padding modes: " +
                ("'same' and 'valid', but received " + JSON.stringify(config.padding)));
        }
        _this.depthMultiplier =
            config.depthMultiplier == null ? 1 : config.depthMultiplier;
        _this.depthwiseInitializer = initializers_1.getInitializer(config.depthwiseInitializer || _this.DEFAULT_DEPTHWISE_INITIALIZER);
        _this.depthwiseRegularizer = regularizers_1.getRegularizer(config.depthwiseRegularizer);
        _this.depthwiseConstraint = constraints_1.getConstraint(config.depthwiseConstraint);
        _this.pointwiseInitializer = initializers_1.getInitializer(config.depthwiseInitializer || _this.DEFAULT_POINTWISE_INITIALIZER);
        _this.pointwiseRegularizer = regularizers_1.getRegularizer(config.pointwiseRegularizer);
        _this.pointwiseConstraint = constraints_1.getConstraint(config.pointwiseConstraint);
        return _this;
    }
    SeparableConv.prototype.build = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        if (inputShape.length < this.rank + 2) {
            throw new errors_1.ValueError("Inputs to SeparableConv" + this.rank + "D should have rank " +
                (this.rank + 2 + ", but received input shape: ") +
                ("" + JSON.stringify(inputShape)));
        }
        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;
        if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
            throw new errors_1.ValueError("The channel dimension of the inputs should be defined, " +
                ("but found " + JSON.stringify(inputShape[channelAxis])));
        }
        var inputDim = inputShape[channelAxis];
        var depthwiseKernelShape = this.kernelSize.concat([inputDim, this.depthMultiplier]);
        var pointwiseKernelShape = [];
        for (var i = 0; i < this.rank; ++i) {
            pointwiseKernelShape.push(1);
        }
        pointwiseKernelShape.push(inputDim * this.depthMultiplier, this.filters);
        var trainable = true;
        this.depthwiseKernel = this.addWeight('depthwise_kernel', depthwiseKernelShape, 'float32', this.depthwiseInitializer, this.depthwiseRegularizer, trainable, this.depthwiseConstraint);
        this.pointwiseKernel = this.addWeight('pointwise_kernel', pointwiseKernelShape, 'float32', this.pointwiseInitializer, this.pointwiseRegularizer, trainable, this.pointwiseConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.filters], 'float32', this.biasInitializer, this.biasRegularizer, trainable, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.inputSpec =
            [new topology_1.InputSpec({ ndim: this.rank + 2, axes: (_a = {}, _a[channelAxis] = inputDim, _a) })];
        this.built = true;
        var _a;
    };
    SeparableConv.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = types_utils_1.getExactlyOneTensor(inputs);
            var output;
            if (_this.rank === 1) {
                throw new errors_1.NotImplementedError('1D separable convolution is not implemented yet.');
            }
            else if (_this.rank === 2) {
                if (_this.dataFormat === 'channelsFirst') {
                    inputs = tfc.transpose(inputs, [0, 2, 3, 1]);
                }
                output = tfc.separableConv2d(inputs, _this.depthwiseKernel.read(), _this.pointwiseKernel.read(), _this.strides, _this.padding, _this.dilationRate, 'NHWC');
            }
            if (_this.useBias) {
                output = K.biasAdd(output, _this.bias.read(), _this.dataFormat);
            }
            if (_this.activation != null) {
                output = _this.activation.apply(output);
            }
            if (_this.dataFormat === 'channelsFirst') {
                output = tfc.transpose(output, [0, 3, 1, 2]);
            }
            return output;
        });
    };
    SeparableConv.prototype.getConfig = function () {
        var config = _super.prototype.getConfig.call(this);
        delete config['rank'];
        delete config['kernelInitializer'];
        delete config['kernelRegularizer'];
        delete config['kernelConstraint'];
        config['depthwiseInitializer'] =
            initializers_1.serializeInitializer(this.depthwiseInitializer);
        config['pointwiseInitializer'] =
            initializers_1.serializeInitializer(this.pointwiseInitializer);
        config['depthwiseRegularizer'] =
            regularizers_1.serializeRegularizer(this.depthwiseRegularizer);
        config['pointwiseRegularizer'] =
            regularizers_1.serializeRegularizer(this.pointwiseRegularizer);
        config['depthwiseConstraint'] =
            constraints_1.serializeConstraint(this.depthwiseConstraint);
        config['pointwiseConstraint'] =
            constraints_1.serializeConstraint(this.pointwiseConstraint);
        return config;
    };
    SeparableConv.className = 'SeparableConv';
    return SeparableConv;
}(Conv));
exports.SeparableConv = SeparableConv;
var SeparableConv2D = (function (_super) {
    __extends(SeparableConv2D, _super);
    function SeparableConv2D(config) {
        return _super.call(this, 2, config) || this;
    }
    SeparableConv2D.className = 'SeparableConv2D';
    return SeparableConv2D;
}(SeparableConv));
exports.SeparableConv2D = SeparableConv2D;
tfjs_core_1.serialization.registerClass(SeparableConv2D);
var Conv1D = (function (_super) {
    __extends(Conv1D, _super);
    function Conv1D(config) {
        var _this = _super.call(this, 1, config) || this;
        Conv1D.verifyConfig(config);
        _this.inputSpec = [{ ndim: 3 }];
        return _this;
    }
    Conv1D.prototype.getConfig = function () {
        var config = _super.prototype.getConfig.call(this);
        delete config['rank'];
        delete config['dataFormat'];
        return config;
    };
    Conv1D.verifyConfig = function (config) {
        if (typeof config.kernelSize !== 'number' &&
            !generic_utils.checkArrayTypeAndLength(config.kernelSize, 'number', 1, 1))
            throw new errors_1.ValueError("Conv1D expects config.kernelSize to be number or number[] with " +
                ("length 1, but received " + JSON.stringify(config.kernelSize) + "."));
    };
    Conv1D.className = 'Conv1D';
    return Conv1D;
}(Conv));
exports.Conv1D = Conv1D;
tfjs_core_1.serialization.registerClass(Conv1D);
var Cropping2D = (function (_super) {
    __extends(Cropping2D, _super);
    function Cropping2D(config) {
        var _this = _super.call(this, config) || this;
        if (typeof config.cropping === 'number')
            _this.cropping = [
                [config.cropping, config.cropping], [config.cropping, config.cropping]
            ];
        else if (typeof config.cropping[0] === 'number')
            _this.cropping = [
                [config.cropping[0], config.cropping[0]],
                [config.cropping[1], config.cropping[1]]
            ];
        else
            _this.cropping = config.cropping;
        _this.dataFormat =
            config.dataFormat === undefined ? 'channelsLast' : config.dataFormat;
        _this.inputSpec = [{ ndim: 4 }];
        return _this;
    }
    Cropping2D.prototype.computeOutputShape = function (inputShape) {
        if (this.dataFormat === 'channelsFirst')
            return [
                inputShape[0],
                inputShape[1],
                inputShape[2] - this.cropping[0][0] - this.cropping[0][1],
                inputShape[3] - this.cropping[1][0] - this.cropping[1][1]
            ];
        else
            return [
                inputShape[0],
                inputShape[1] - this.cropping[0][0] - this.cropping[0][1],
                inputShape[2] - this.cropping[1][0] - this.cropping[1][1],
                inputShape[3]
            ];
    };
    Cropping2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = types_utils_1.getExactlyOneTensor(inputs);
            if (_this.dataFormat === 'channelsLast') {
                var hSliced = K.sliceAlongAxis(inputs, _this.cropping[0][0], inputs.shape[1] - _this.cropping[0][0] - _this.cropping[0][1], 2);
                return K.sliceAlongAxis(hSliced, _this.cropping[1][0], inputs.shape[2] - _this.cropping[1][1] - _this.cropping[1][0], 3);
            }
            else {
                var hSliced = K.sliceAlongAxis(inputs, _this.cropping[0][0], inputs.shape[2] - _this.cropping[0][0] - _this.cropping[0][1], 3);
                return K.sliceAlongAxis(hSliced, _this.cropping[1][0], inputs.shape[3] - _this.cropping[1][1] - _this.cropping[1][0], 4);
            }
        });
    };
    Cropping2D.prototype.getConfig = function () {
        var config = { cropping: this.cropping, dataFormat: this.dataFormat };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Cropping2D.className = 'Cropping2D';
    return Cropping2D;
}(topology_1.Layer));
exports.Cropping2D = Cropping2D;
tfjs_core_1.serialization.registerClass(Cropping2D);
var UpSampling2D = (function (_super) {
    __extends(UpSampling2D, _super);
    function UpSampling2D(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_SIZE = [2, 2];
        _this.inputSpec = [{ ndim: 4 }];
        _this.size = config.size == null ? _this.DEFAULT_SIZE : config.size;
        _this.dataFormat =
            config.dataFormat == null ? 'channelsLast' : config.dataFormat;
        return _this;
    }
    UpSampling2D.prototype.computeOutputShape = function (inputShape) {
        if (this.dataFormat === 'channelsFirst') {
            var height = inputShape[2] == null ? null : this.size[0] * inputShape[2];
            var width = inputShape[3] == null ? null : this.size[1] * inputShape[3];
            return [inputShape[0], inputShape[1], height, width];
        }
        else {
            var height = inputShape[1] == null ? null : this.size[0] * inputShape[1];
            var width = inputShape[2] == null ? null : this.size[1] * inputShape[2];
            return [inputShape[0], height, width, inputShape[3]];
        }
    };
    UpSampling2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfc.tidy(function () {
            var input = types_utils_1.getExactlyOneTensor(inputs);
            var inputShape = input.shape;
            if (_this.dataFormat === 'channelsFirst') {
                input = tfc.transpose(input, [0, 2, 3, 1]);
                var height = _this.size[0] * inputShape[2];
                var width = _this.size[1] * inputShape[3];
                var resized = input.resizeNearestNeighbor([height, width]);
                return tfc.transpose(resized, [0, 3, 1, 2]);
            }
            else {
                var height = _this.size[0] * inputShape[1];
                var width = _this.size[1] * inputShape[2];
                return input.resizeNearestNeighbor([height, width]);
            }
        });
    };
    UpSampling2D.prototype.getConfig = function () {
        var config = { size: this.size, dataFormat: this.dataFormat };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    UpSampling2D.className = 'UpSampling2D';
    return UpSampling2D;
}(topology_1.Layer));
exports.UpSampling2D = UpSampling2D;
tfjs_core_1.serialization.registerClass(UpSampling2D);

},{"../activations":206,"../backend/common":207,"../backend/tfjs_backend":209,"../common":212,"../constraints":213,"../engine/topology":218,"../errors":222,"../initializers":230,"../regularizers":248,"../utils/conv_utils":249,"../utils/generic_utils":250,"../utils/types_utils":254,"@tensorflow/tfjs-core":64}],233:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("../backend/common");
var K = require("../backend/tfjs_backend");
var common_2 = require("../common");
var constraints_1 = require("../constraints");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var conv_utils_1 = require("../utils/conv_utils");
var types_utils_1 = require("../utils/types_utils");
var convolutional_1 = require("./convolutional");
function depthwiseConv2d(x, depthwiseKernel, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = [1, 1]; }
    if (padding === void 0) { padding = 'valid'; }
    return tfjs_core_1.tidy(function () {
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        common_2.checkDataFormat(dataFormat);
        var y = convolutional_1.preprocessConv2DInput(x, dataFormat);
        if (x.rank !== 4) {
            throw new errors_1.ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead " +
                (x.rank + "-D"));
        }
        if (depthwiseKernel.rank !== 4) {
            throw new errors_1.ValueError("depthwiseKernel is required to be 4-D, but is instead " +
                (depthwiseKernel.rank + "-D"));
        }
        y = tfc.depthwiseConv2d(y, depthwiseKernel, strides, padding === 'same' ? 'same' : 'valid', 'NHWC', dilationRate);
        if (dataFormat === 'channelsFirst') {
            y = tfc.transpose(y, [0, 3, 1, 2]);
        }
        return y;
    });
}
exports.depthwiseConv2d = depthwiseConv2d;
var DepthwiseConv2D = (function (_super) {
    __extends(DepthwiseConv2D, _super);
    function DepthwiseConv2D(config) {
        var _this = _super.call(this, 2, config) || this;
        _this.depthwiseKernel = null;
        _this.depthMultiplier =
            config.depthMultiplier == null ? 1 : config.depthMultiplier;
        _this.depthwiseInitializer = initializers_1.getInitializer(config.depthwiseInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.depthwiseConstraint = constraints_1.getConstraint(config.depthwiseConstraint);
        _this.depthwiseRegularizer = regularizers_1.getRegularizer(config.depthwiseRegularizer);
        return _this;
    }
    DepthwiseConv2D.prototype.build = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        if (inputShape.length < 4) {
            throw new errors_1.ValueError("Inputs to DepthwiseConv2D should have rank 4. " +
                ("Received input shape: " + JSON.stringify(inputShape) + "."));
        }
        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : 3;
        if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
            throw new errors_1.ValueError('The channel dimension of the inputs to DepthwiseConv2D should ' +
                ("be defined, but is not (" + inputShape[channelAxis] + ")."));
        }
        var inputDim = inputShape[channelAxis];
        var depthwiseKernelShape = [
            this.kernelSize[0], this.kernelSize[1], inputDim, this.depthMultiplier
        ];
        this.depthwiseKernel = this.addWeight('depthwise_kernel', depthwiseKernelShape, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [inputDim * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.built = true;
    };
    DepthwiseConv2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = types_utils_1.getExactlyOneTensor(inputs);
            var outputs = depthwiseConv2d(inputs, _this.depthwiseKernel.read(), _this.strides, _this.padding, _this.dataFormat, null);
            if (_this.useBias) {
                outputs = K.biasAdd(outputs, _this.bias.read(), _this.dataFormat);
            }
            if (_this.activation != null) {
                outputs = _this.activation.apply(outputs);
            }
            return outputs;
        });
    };
    DepthwiseConv2D.prototype.computeOutputShape = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];
        var cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];
        var outFilters = this.dataFormat === 'channelsFirst' ?
            inputShape[1] * this.depthMultiplier :
            inputShape[3] * this.depthMultiplier;
        var outRows = conv_utils_1.convOutputLength(rows, this.kernelSize[0], this.padding, this.strides[0]);
        var outCols = conv_utils_1.convOutputLength(cols, this.kernelSize[1], this.padding, this.strides[1]);
        if (this.dataFormat === 'channelsFirst') {
            return [inputShape[0], outFilters, outRows, outCols];
        }
        else {
            return [inputShape[0], outRows, outCols, outFilters];
        }
    };
    DepthwiseConv2D.prototype.getConfig = function () {
        var config = _super.prototype.getConfig.call(this);
        config['depthMultiplier'] = this.depthMultiplier;
        config['depthwiseInitializer'] =
            initializers_1.serializeInitializer(this.depthwiseInitializer);
        config['depthwiseRegularizer'] =
            regularizers_1.serializeRegularizer(this.depthwiseRegularizer);
        config['depthwiseConstraint'] =
            constraints_1.serializeConstraint(this.depthwiseRegularizer);
        return config;
    };
    DepthwiseConv2D.className = 'DepthwiseConv2D';
    return DepthwiseConv2D;
}(convolutional_1.BaseConv));
exports.DepthwiseConv2D = DepthwiseConv2D;
tfjs_core_1.serialization.registerClass(DepthwiseConv2D);

},{"../backend/common":207,"../backend/tfjs_backend":209,"../common":212,"../constraints":213,"../errors":222,"../initializers":230,"../regularizers":248,"../utils/conv_utils":249,"../utils/types_utils":254,"./convolutional":232,"@tensorflow/tfjs-core":64}],234:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var activations_1 = require("../activations");
var state_1 = require("../backend/state");
var K = require("../backend/tfjs_backend");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var math_utils_1 = require("../utils/math_utils");
var types_utils_1 = require("../utils/types_utils");
var Dropout = (function (_super) {
    __extends(Dropout, _super);
    function Dropout(config) {
        var _this = _super.call(this, config) || this;
        _this.rate = Math.max(Math.min(config.rate, 1), 0);
        _this.rateScalar = state_1.getScalar(_this.rate);
        _this.noiseShape = config.noiseShape;
        _this.seed = config.seed;
        if (_this.seed != null) {
            throw new errors_1.NotImplementedError('Non-default seed is not implemented in Dropout layer yet: ' +
                _this.seed);
        }
        _this.supportsMasking = true;
        return _this;
    }
    Dropout.prototype.getNoiseShape = function (input) {
        if (this.noiseShape == null) {
            return this.noiseShape;
        }
        var inputShape = input.shape;
        var noiseShape = [];
        for (var i = 0; i < this.noiseShape.length; ++i) {
            noiseShape.push(this.noiseShape[i] == null ? inputShape[i] : this.noiseShape[i]);
        }
        return noiseShape;
    };
    Dropout.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = types_utils_1.getExactlyOneTensor(inputs);
            if (_this.noiseShape != null &&
                !tfjs_core_1.util.arraysEqual(input.shape, _this.noiseShape)) {
                throw new errors_1.NotImplementedError('Non-default noise shape is not implemented in Dropout ' +
                    'layer yet: ' + JSON.stringify(_this.noiseShape));
            }
            if (0 < _this.rate && _this.rate < 1) {
                var training = kwargs['training'] == null ? false : kwargs['training'];
                var noiseShape_1 = _this.getNoiseShape(input);
                var output = K.inTrainPhase(function () { return K.dropout(input, _this.rateScalar, noiseShape_1, _this.seed); }, function () { return input; }, training);
                return output;
            }
            return inputs;
        });
    };
    Dropout.prototype.getConfig = function () {
        var config = {
            rate: this.rate,
            noiseShape: this.noiseShape,
            seed: this.seed,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Dropout.className = 'Dropout';
    return Dropout;
}(topology_1.Layer));
exports.Dropout = Dropout;
tfjs_core_1.serialization.registerClass(Dropout);
var Dense = (function (_super) {
    __extends(Dense, _super);
    function Dense(config) {
        var _this = _super.call(this, config) || this;
        _this.activation = null;
        _this.useBias = true;
        _this.kernel = null;
        _this.bias = null;
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        if (config.batchInputShape == null && config.inputShape == null &&
            config.inputDim != null) {
            var batchSize = null;
            if (config.batchSize != null) {
                batchSize = config.batchSize;
            }
            _this.batchInputShape = [batchSize, config.inputDim];
        }
        _this.units = config.units;
        _this.activation = activations_1.getActivation(config.activation);
        if (config.useBias != null) {
            _this.useBias = config.useBias;
        }
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);
        _this.inputSpec = [{ minNDim: 2 }];
        return _this;
    }
    Dense.prototype.build = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var inputLastDim = inputShape[inputShape.length - 1];
        if (this.kernel == null) {
            this.kernel = this.addWeight('kernel', [inputLastDim, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
            if (this.useBias) {
                this.bias = this.addWeight('bias', [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
            }
        }
        this.inputSpec = [{ minNDim: 2, axes: (_a = {}, _a[-1] = inputLastDim, _a) }];
        this.built = true;
        var _a;
    };
    Dense.prototype.computeOutputShape = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var outputShape = inputShape.slice();
        outputShape[outputShape.length - 1] = this.units;
        return outputShape;
    };
    Dense.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = types_utils_1.getExactlyOneTensor(inputs);
            var output = K.dot(input, _this.kernel.read());
            if (_this.bias != null) {
                output = K.biasAdd(output, _this.bias.read());
            }
            if (_this.activation != null) {
                output = _this.activation.apply(output);
            }
            return output;
        });
    };
    Dense.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint)
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Dense.className = 'Dense';
    return Dense;
}(topology_1.Layer));
exports.Dense = Dense;
tfjs_core_1.serialization.registerClass(Dense);
var Flatten = (function (_super) {
    __extends(Flatten, _super);
    function Flatten(config) {
        var _this = _super.call(this, config || {}) || this;
        _this.inputSpec = [{ minNDim: 3 }];
        return _this;
    }
    Flatten.prototype.computeOutputShape = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        for (var _i = 0, _a = inputShape.slice(1); _i < _a.length; _i++) {
            var dim = _a[_i];
            if (dim == null) {
                throw new errors_1.ValueError("The shape of the input to \"Flatten\" is not fully defined " +
                    ("(got " + inputShape.slice(1) + "). Make sure to pass a complete ") +
                    "\"input_shape\" or \"batch_input_shape\" argument to the first " +
                    "layer in your model.");
            }
        }
        return [inputShape[0], math_utils_1.arrayProd(inputShape, 1)];
    };
    Flatten.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            return K.batchFlatten(types_utils_1.getExactlyOneTensor(inputs));
        });
    };
    Flatten.className = 'Flatten';
    return Flatten;
}(topology_1.Layer));
exports.Flatten = Flatten;
tfjs_core_1.serialization.registerClass(Flatten);
var Activation = (function (_super) {
    __extends(Activation, _super);
    function Activation(config) {
        var _this = _super.call(this, config) || this;
        _this.supportsMasking = true;
        _this.activation = activations_1.getActivation(config.activation);
        return _this;
    }
    Activation.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = types_utils_1.getExactlyOneTensor(inputs);
            return _this.activation.apply(input);
        });
    };
    Activation.prototype.getConfig = function () {
        var config = { activation: activations_1.serializeActivation(this.activation) };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Activation.className = 'Activation';
    return Activation;
}(topology_1.Layer));
exports.Activation = Activation;
tfjs_core_1.serialization.registerClass(Activation);
var RepeatVector = (function (_super) {
    __extends(RepeatVector, _super);
    function RepeatVector(config) {
        var _this = _super.call(this, config) || this;
        _this.n = config.n;
        _this.inputSpec = [{ ndim: 2 }];
        return _this;
    }
    RepeatVector.prototype.computeOutputShape = function (inputShape) {
        return [inputShape[0], this.n, inputShape[1]];
    };
    RepeatVector.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = types_utils_1.getExactlyOneTensor(inputs);
            return K.repeat(inputs, _this.n);
        });
    };
    RepeatVector.prototype.getConfig = function () {
        var config = {
            n: this.n,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    RepeatVector.className = 'RepeatVector';
    return RepeatVector;
}(topology_1.Layer));
exports.RepeatVector = RepeatVector;
tfjs_core_1.serialization.registerClass(RepeatVector);
var Reshape = (function (_super) {
    __extends(Reshape, _super);
    function Reshape(config) {
        var _this = _super.call(this, config) || this;
        _this.targetShape = config.targetShape;
        for (var i = 0; i < _this.targetShape.length; ++i) {
            if (_this.isUnknown(_this.targetShape[i])) {
                _this.targetShape[i] = null;
            }
        }
        return _this;
    }
    Reshape.prototype.isUnknown = function (dim) {
        return dim < 0 || dim == null;
    };
    Reshape.prototype.fixUnknownDimension = function (inputShape, outputShape) {
        var errorMsg = 'Total size of new array must be unchanged.';
        var finalShape = outputShape.slice();
        var known = 1;
        var unknown = null;
        for (var i = 0; i < finalShape.length; ++i) {
            var dim = finalShape[i];
            if (this.isUnknown(dim)) {
                if (unknown === null) {
                    unknown = i;
                }
                else {
                    throw new errors_1.ValueError('Can only specifiy one unknown dimension.');
                }
            }
            else {
                known *= dim;
            }
        }
        var originalSize = math_utils_1.arrayProd(inputShape);
        if (unknown !== null) {
            if (known === 0 || originalSize % known !== 0) {
                throw new errors_1.ValueError(errorMsg);
            }
            finalShape[unknown] = originalSize / known;
        }
        else if (originalSize !== known) {
            throw new errors_1.ValueError(errorMsg);
        }
        return finalShape;
    };
    Reshape.prototype.computeOutputShape = function (inputShape) {
        var anyUnknownDims = false;
        for (var i = 0; i < inputShape.length; ++i) {
            if (this.isUnknown(inputShape[i])) {
                anyUnknownDims = true;
                break;
            }
        }
        if (anyUnknownDims) {
            return inputShape.slice(0, 1).concat(this.targetShape);
        }
        else {
            return inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));
        }
    };
    Reshape.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = types_utils_1.getExactlyOneTensor(inputs);
            var inputShape = input.shape;
            var outputShape = inputShape.slice(0, 1).concat(_this.fixUnknownDimension(inputShape.slice(1), _this.targetShape));
            return input.reshape(outputShape);
        });
    };
    Reshape.prototype.getConfig = function () {
        var config = {
            targetShape: this.targetShape,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Reshape.className = 'Reshape';
    return Reshape;
}(topology_1.Layer));
exports.Reshape = Reshape;
tfjs_core_1.serialization.registerClass(Reshape);
var Permute = (function (_super) {
    __extends(Permute, _super);
    function Permute(config) {
        var _this = _super.call(this, config) || this;
        if (config.dims == null) {
            throw new Error('Required configuration field `dims` is missing during Permute ' +
                'constructor call.');
        }
        if (!Array.isArray(config.dims)) {
            throw new Error('Permute constructor requires `dims` to be an Array, but received ' +
                (config.dims + " instead."));
        }
        var expectedSortedIndices = math_utils_1.range(1, config.dims.length + 1);
        if (!tfjs_core_1.util.arraysEqual(config.dims.slice().sort(), expectedSortedIndices)) {
            throw new Error('Invalid permutation `dims`: ' + JSON.stringify(config.dims) +
                ' `dims` must contain consecutive integers starting from 1.');
        }
        _this.dims = config.dims;
        _this.dimsIncludingBatch = [0].concat(_this.dims);
        _this.inputSpec = [new topology_1.InputSpec({ ndim: _this.dims.length + 1 })];
        return _this;
    }
    Permute.prototype.computeOutputShape = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var outputShape = inputShape.slice();
        this.dims.forEach(function (dim, i) {
            outputShape[i + 1] = inputShape[dim];
        });
        return outputShape;
    };
    Permute.prototype.call = function (inputs, kwargs) {
        return tfjs_core_1.transpose(types_utils_1.getExactlyOneTensor(inputs), this.dimsIncludingBatch);
    };
    Permute.prototype.getConfig = function () {
        var config = {
            dims: this.dims,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Permute.className = 'Permute';
    return Permute;
}(topology_1.Layer));
exports.Permute = Permute;
tfjs_core_1.serialization.registerClass(Permute);

},{"../activations":206,"../backend/state":208,"../backend/tfjs_backend":209,"../constraints":213,"../engine/topology":218,"../errors":222,"../initializers":230,"../regularizers":248,"../utils/math_utils":252,"../utils/types_utils":254,"@tensorflow/tfjs-core":64}],235:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("../backend/tfjs_backend");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var generic_utils = require("../utils/generic_utils");
var types_utils_1 = require("../utils/types_utils");
var Embedding = (function (_super) {
    __extends(Embedding, _super);
    function Embedding(config) {
        var _this = _super.call(this, config) || this;
        _this.embeddings = null;
        _this.DEFAULT_EMBEDDINGS_INITIALIZER = 'randomUniform';
        if (config.batchInputShape == null && config.inputShape == null) {
            var batchSize = null;
            if (config.batchSize != null) {
                batchSize = config.batchSize;
            }
            if (config.inputLength == null) {
                _this.batchInputShape = [batchSize, null];
            }
            else {
                _this.batchInputShape =
                    [batchSize].concat(generic_utils.toList(config.inputLength));
            }
        }
        _this.inputDim = config.inputDim;
        _this.outputDim = config.outputDim;
        _this.embeddingsInitializer = initializers_1.getInitializer(config.embeddingsInitializer || _this.DEFAULT_EMBEDDINGS_INITIALIZER);
        _this.embeddingsRegularizer = regularizers_1.getRegularizer(config.embeddingsRegularizer);
        _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);
        _this.embeddingsConstraint = constraints_1.getConstraint(config.embeddingsConstraint);
        _this.maskZero = config.maskZero;
        _this.inputLength = config.inputLength;
        return _this;
    }
    Embedding.prototype.build = function (inputShape) {
        this.embeddings = this.addWeight('embeddings', [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint);
        this.built = true;
    };
    Embedding.prototype.warnOnIncompatibleInputShape = function (inputShape) { };
    Embedding.prototype.computeMask = function (inputs, mask) {
        throw new errors_1.NotImplementedError('computeMask has not been implemented for Embedding yet');
    };
    Embedding.prototype.computeOutputShape = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        if (this.inputLength == null) {
            return inputShape.concat([this.outputDim]);
        }
        var inLens = generic_utils.toList(this.inputLength);
        if (inLens.length !== inputShape.length - 1) {
            throw new errors_1.ValueError("\"inputLength\" is " + this.inputLength + ", but received " +
                ("input shape has shape " + inputShape));
        }
        else {
            var i = 0;
            for (var k = 0; k < inLens.length; ++k) {
                var s1 = inLens[k];
                var s2 = inputShape[k + 1];
                if ((s1 != null) && (s2 != null) && (s1 !== s2)) {
                    throw new errors_1.ValueError("\"inputLength\" is " + this.inputLength + ", but received " +
                        ("input shape has shape " + inputShape));
                }
                else if (s1 == null) {
                    inLens[i] = s2;
                }
                i++;
            }
        }
        return [inputShape[0]].concat(inLens, [this.outputDim]);
    };
    Embedding.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = types_utils_1.getExactlyOneTensor(inputs);
            if (input.dtype !== 'int32') {
                input = K.cast(input, 'int32');
            }
            var output = K.gather(_this.embeddings.read(), input.as1D());
            return output.reshape(types_utils_1.getExactlyOneShape(_this.computeOutputShape(input.shape)));
        });
    };
    Embedding.prototype.getConfig = function () {
        var config = {
            inputDim: this.inputDim,
            outputDim: this.outputDim,
            embeddingsInitializer: initializers_1.serializeInitializer(this.embeddingsInitializer),
            embeddingsRegularizer: regularizers_1.serializeRegularizer(this.embeddingsRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            embeddingsConstraint: constraints_1.serializeConstraint(this.embeddingsConstraint),
            maskZero: this.maskZero,
            inputLength: this.inputLength
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Embedding.className = 'Embedding';
    return Embedding;
}(topology_1.Layer));
exports.Embedding = Embedding;
tfjs_core_1.serialization.registerClass(Embedding);

},{"../backend/tfjs_backend":209,"../constraints":213,"../engine/topology":218,"../errors":222,"../initializers":230,"../regularizers":248,"../utils/generic_utils":250,"../utils/types_utils":254,"@tensorflow/tfjs-core":64}],236:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var state_1 = require("../backend/state");
var K = require("../backend/tfjs_backend");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var losses_1 = require("../losses");
var generic_utils = require("../utils/generic_utils");
var mathUtils = require("../utils/math_utils");
var types_utils_1 = require("../utils/types_utils");
var Merge = (function (_super) {
    __extends(Merge, _super);
    function Merge(config) {
        var _this = _super.call(this, config || {}) || this;
        _this.supportsMasking = true;
        return _this;
    }
    Merge.prototype.mergeFunction = function (inputs) {
        throw new errors_1.NotImplementedError();
    };
    Merge.prototype.computeElementwiseOpOutputShape = function (shape1, shape2) {
        if (shape1 == null || shape2 == null) {
            return null;
        }
        else if (shape1.length < shape2.length) {
            return this.computeElementwiseOpOutputShape(shape2, shape1);
        }
        else if (shape2.length === 0) {
            return shape1;
        }
        var outputShape = shape1.slice(0, shape1.length - shape2.length);
        for (var k = 0; k < shape2.length; ++k) {
            var i = shape1[shape1.length - shape2.length + k];
            var j = shape2[k];
            if (i == null || j == null || i < 0 || j < 0) {
                outputShape.push(null);
            }
            else if (i === 1) {
                outputShape.push(j);
            }
            else if (j === 1) {
                outputShape.push(i);
            }
            else {
                if (i !== j) {
                    throw new errors_1.ValueError('Operands could not be broadcast together with shapes ' +
                        JSON.stringify(shape1) + ' ' + JSON.stringify(shape2));
                }
                outputShape.push(i);
            }
        }
        return outputShape;
    };
    Merge.prototype.build = function (inputShape) {
        if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {
            inputShape = [types_utils_1.getExactlyOneShape(inputShape)];
        }
        inputShape = inputShape;
        if (inputShape.length < 2) {
            throw new errors_1.ValueError('A merge layer should be called on an Array of at least 2 inputs.' +
                (" Got " + inputShape.length + " input(s)."));
        }
        var batchSizes = [];
        for (var _i = 0, inputShape_1 = inputShape; _i < inputShape_1.length; _i++) {
            var shape = inputShape_1[_i];
            if (shape != null && shape[0] !== null) {
                batchSizes.push(shape[0]);
            }
        }
        batchSizes = generic_utils.unique(batchSizes);
        if (batchSizes.length > 1) {
            throw new errors_1.ValueError("Can not merge tensors with different batch sizes. " +
                ("Got tensors with shapes: " + JSON.stringify(inputShape) + "."));
        }
        var outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);
        for (var i = 1; i < inputShape.length; ++i) {
            var shape = inputShape[i] == null ? null : inputShape[i].slice(1);
            outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
        }
        var allRanks = inputShape.map(function (shape) { return shape.length; });
        if (inputShape.indexOf(null) === -1 &&
            generic_utils.unique(allRanks).length === 1) {
            this.reshapeRequired = false;
        }
        else {
            this.reshapeRequired = true;
        }
    };
    Merge.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = inputs;
            if (_this.reshapeRequired) {
                var reshapedInputs = [];
                var inputDims = inputs.map(function (input) { return input.rank; });
                if (inputDims.indexOf(null) === -1) {
                    var maxNDim = mathUtils.max(inputDims);
                    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
                        var x = inputs_1[_i];
                        var xNDim = x.rank;
                        for (var k = 0; k < maxNDim - xNDim; ++k) {
                            x = K.expandDims(x, 1);
                        }
                        reshapedInputs.push(x);
                    }
                    return _this.mergeFunction(reshapedInputs);
                }
                else {
                    var transposed = false;
                    for (var _a = 0, inputs_2 = inputs; _a < inputs_2.length; _a++) {
                        var x = inputs_2[_a];
                        var xNDim = x.rank;
                        if (xNDim == null) {
                            var xShape = x.shape;
                            var batchSize = xShape[0];
                            var newShape = xShape.slice(1).concat([batchSize]);
                            var xTransposed = x.reshape([batchSize].concat(mathUtils.arrayProd(xShape.slice(1))));
                            xTransposed = tfc.transpose(xTransposed, [1, 0]);
                            xTransposed = xTransposed.reshape(newShape);
                            reshapedInputs.push(xTransposed);
                            transposed = true;
                        }
                        else if (xNDim > 1) {
                            var dims = mathUtils.range(1, xNDim).concat([0]);
                            reshapedInputs.push(tfc.transpose(x, dims));
                            transposed = true;
                        }
                        else {
                            reshapedInputs.push(x);
                        }
                    }
                    var y = _this.mergeFunction(reshapedInputs);
                    var yNDim = y.rank;
                    if (transposed) {
                        if (yNDim == null) {
                            var yShape = y.shape;
                            var yNDim_1 = yShape.length;
                            var batchSize = yShape[yNDim_1 - 1];
                            var newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));
                            y = tfc.transpose(y.reshape([-1, batchSize]), [1, 0])
                                .reshape(newShape);
                        }
                        else if (yNDim > 1) {
                            var dims = [yNDim - 1].concat(mathUtils.range(0, yNDim - 1));
                            y = tfc.transpose(y, dims);
                        }
                    }
                    return y;
                }
            }
            else {
                return _this.mergeFunction(inputs);
            }
        });
    };
    Merge.prototype.computeOutputShape = function (inputShape) {
        inputShape = inputShape;
        var outputShape;
        if (inputShape[0] == null) {
            outputShape = null;
        }
        else {
            outputShape = inputShape[0].slice(1);
        }
        for (var i = 1; i < inputShape.length; ++i) {
            var shape = inputShape[i] == null ? null : inputShape[i].slice(1);
            outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
        }
        var batchSizes = [];
        for (var _i = 0, inputShape_2 = inputShape; _i < inputShape_2.length; _i++) {
            var shape = inputShape_2[_i];
            if (shape != null && shape[0] !== null) {
                batchSizes.push(shape[0]);
            }
        }
        batchSizes = generic_utils.unique(batchSizes);
        if (batchSizes.length === 1) {
            outputShape = batchSizes.concat(outputShape);
        }
        else {
            outputShape = [null].concat(outputShape);
        }
        return outputShape;
    };
    Merge.prototype.computeMask = function (inputs, mask) {
        throw new errors_1.NotImplementedError('computeMask has not been implemented for Merge yet');
    };
    return Merge;
}(topology_1.Layer));
exports.Merge = Merge;
var Add = (function (_super) {
    __extends(Add, _super);
    function Add(config) {
        return _super.call(this, config) || this;
    }
    Add.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = inputs[0].clone();
            for (var i = 1; i < inputs.length; ++i) {
                output = tfc.add(output, inputs[i]);
            }
            return output;
        });
    };
    Add.className = 'Add';
    return Add;
}(Merge));
exports.Add = Add;
tfjs_core_1.serialization.registerClass(Add);
function add(config) {
    if (Array.isArray(config)) {
        var layer = new Add({});
        return layer.apply(config);
    }
    else {
        return new Add(config);
    }
}
exports.add = add;
var Multiply = (function (_super) {
    __extends(Multiply, _super);
    function Multiply(config) {
        return _super.call(this, config) || this;
    }
    Multiply.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = inputs[0].clone();
            for (var i = 1; i < inputs.length; ++i) {
                output = tfc.mul(output, inputs[i]);
            }
            return output;
        });
    };
    Multiply.className = 'Multiply';
    return Multiply;
}(Merge));
exports.Multiply = Multiply;
tfjs_core_1.serialization.registerClass(Multiply);
function multiply(config) {
    if (Array.isArray(config)) {
        var layer = new Multiply({});
        return layer.apply(config);
    }
    else {
        return new Multiply(config);
    }
}
exports.multiply = multiply;
var Average = (function (_super) {
    __extends(Average, _super);
    function Average(config) {
        return _super.call(this, config) || this;
    }
    Average.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = inputs[0].clone();
            for (var i = 1; i < inputs.length; ++i) {
                output = tfc.add(output, inputs[i]);
            }
            return tfc.mul(state_1.getScalar(1 / inputs.length), output);
        });
    };
    Average.className = 'Average';
    return Average;
}(Merge));
exports.Average = Average;
tfjs_core_1.serialization.registerClass(Average);
function average(config) {
    if (Array.isArray(config)) {
        var layer = new Average({});
        return layer.apply(config);
    }
    else {
        return new Average(config);
    }
}
exports.average = average;
var Maximum = (function (_super) {
    __extends(Maximum, _super);
    function Maximum(config) {
        return _super.call(this, config) || this;
    }
    Maximum.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = inputs[0];
            for (var i = 1; i < inputs.length; ++i) {
                output = tfc.maximum(output, inputs[i]);
            }
            return output;
        });
    };
    Maximum.className = 'Maximum';
    return Maximum;
}(Merge));
exports.Maximum = Maximum;
tfjs_core_1.serialization.registerClass(Maximum);
function maximum(config) {
    if (Array.isArray(config)) {
        var layer = new Maximum({});
        return layer.apply(config);
    }
    else {
        return new Maximum(config);
    }
}
exports.maximum = maximum;
var Minimum = (function (_super) {
    __extends(Minimum, _super);
    function Minimum(config) {
        return _super.call(this, config) || this;
    }
    Minimum.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = inputs[0];
            for (var i = 1; i < inputs.length; ++i) {
                output = tfc.minimum(output, inputs[i]);
            }
            return output;
        });
    };
    Minimum.className = 'Minimum';
    return Minimum;
}(Merge));
exports.Minimum = Minimum;
tfjs_core_1.serialization.registerClass(Minimum);
function minimum(config) {
    if (Array.isArray(config)) {
        var layer = new Minimum({});
        return layer.apply(config);
    }
    else {
        return new Minimum(config);
    }
}
exports.minimum = minimum;
var Concatenate = (function (_super) {
    __extends(Concatenate, _super);
    function Concatenate(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_AXIS = -1;
        if (config == null) {
            config = {};
        }
        _this.axis = config.axis == null ? _this.DEFAULT_AXIS : config.axis;
        _this.supportsMasking = true;
        _this.reshapeRequired = false;
        return _this;
    }
    Concatenate.prototype.build = function (inputShape) {
        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) ||
            inputShape.length === 1) {
            throw new errors_1.ValueError('A `Concatenate` layer should be called on a list of at least 2 ' +
                'inputs');
        }
        inputShape = inputShape;
        var allNoneShape = true;
        for (var _i = 0, inputShape_3 = inputShape; _i < inputShape_3.length; _i++) {
            var shape = inputShape_3[_i];
            if (shape != null) {
                allNoneShape = false;
                break;
            }
        }
        if (allNoneShape) {
            return;
        }
        var shapeSet = [];
        for (var i = 0; i < inputShape.length; ++i) {
            var shapeWithoutConcatAxis = inputShape[i].slice();
            shapeWithoutConcatAxis.splice(this.axis, 1);
            var exists = false;
            for (var _a = 0, shapeSet_1 = shapeSet; _a < shapeSet_1.length; _a++) {
                var shape = shapeSet_1[_a];
                if (tfjs_core_1.util.arraysEqual(shape, shapeWithoutConcatAxis)) {
                    exists = true;
                    break;
                }
            }
            if (!exists) {
                shapeSet.push(shapeWithoutConcatAxis);
            }
        }
        if (shapeSet.length > 1) {
            throw new errors_1.ValueError('A `Concatenate` layer requires inputs with matching shapes ' +
                'except for the concat axis. Got input shapes: ' +
                JSON.stringify(inputShape));
        }
    };
    Concatenate.prototype.mergeFunction = function (inputs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            return K.concatenate(inputs, _this.axis);
        });
    };
    Concatenate.prototype.computeOutputShape = function (inputShape) {
        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {
            throw new errors_1.ValueError('A `Concatenate` layer should be called on a list of inputs.');
        }
        var inputShapes = inputShape;
        var outputShape = inputShapes[0].slice();
        var axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;
        for (var _i = 0, _a = inputShapes.slice(1); _i < _a.length; _i++) {
            var shape = _a[_i];
            if (outputShape[axis] == null || shape[axis] == null) {
                outputShape[axis] = null;
                break;
            }
            outputShape[axis] += shape[axis];
        }
        return outputShape;
    };
    Concatenate.prototype.computeMask = function (inputs, mask) {
        throw new errors_1.NotImplementedError('computeMask has not been implemented for Concatenate yet');
    };
    Concatenate.prototype.getConfig = function () {
        var config = {
            'axis': this.axis,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Concatenate.className = 'Concatenate';
    return Concatenate;
}(Merge));
exports.Concatenate = Concatenate;
tfjs_core_1.serialization.registerClass(Concatenate);
function concatenate(config) {
    if (Array.isArray(config)) {
        var layer = new Concatenate({});
        return layer.apply(config);
    }
    else {
        return new Concatenate(config);
    }
}
exports.concatenate = concatenate;
function interpretAxis(axis, dim) {
    while (axis < 0) {
        axis += dim;
    }
    return axis;
}
function batchDot(x, y, axes) {
    if (x.shape.length > 3 || y.shape.length > 3) {
        throw new errors_1.NotImplementedError('batchDot is not implemented for tensors of 4D or higher rank yet');
    }
    tfc.util.assert(x.shape.length >= 2, "batchDot requires the rank of x to be >= 2, " +
        ("but got " + x.shape.length));
    tfc.util.assert(x.shape.length >= 2, "batchDot requires the rank of y to be >= 2, " +
        ("but got " + y.shape.length));
    if (typeof axes === 'number') {
        axes = [axes, axes];
    }
    if (x.dtype === 'complex64' || y.dtype === 'complex64') {
        throw new errors_1.NotImplementedError('batchDot is not implemented for complex64-type Tensors yet.');
    }
    var xNDim = x.shape.length;
    var yNDim = y.shape.length;
    if (axes == null) {
        axes = [xNDim - 1, yNDim - 2];
    }
    var axesArray = axes;
    return tfc.tidy(function () {
        var diff;
        if (xNDim > yNDim) {
            diff = xNDim - yNDim;
            var diffShape = [];
            for (var i = 0; i < diff; ++i) {
                diffShape.push(1);
            }
            y = y.reshape(y.shape.concat(diffShape));
        }
        else if (yNDim > xNDim) {
            diff = yNDim - xNDim;
            var diffShape = [];
            for (var i = 0; i < diff; ++i) {
                diffShape.push(1);
            }
            x = x.reshape(x.shape.concat(diffShape));
        }
        else {
            diff = 0;
        }
        var out;
        if (x.shape.length === 2 && y.shape.length === 2) {
            if (axesArray[0] === axesArray[1]) {
                out = x.mulStrict(y).sum(axesArray[0]);
            }
            else {
                out = x.transpose([1, 0]).mulStrict(y).sum(axesArray[1]);
            }
        }
        else {
            var adjX = axesArray[0] === x.shape.length - 1 ? null : true;
            var adjY = axesArray[1] === y.shape.length - 1 ? true : null;
            out = x.matMul(y, adjX, adjY);
        }
        if (diff > 0) {
            var idx = void 0;
            if (xNDim > yNDim) {
                idx = xNDim + yNDim - 3;
            }
            else {
                idx = xNDim - 1;
            }
            var squeezeAxes = [];
            for (var i = idx; i < idx + diff; ++i) {
                squeezeAxes.push(i);
            }
            out = out.squeeze(squeezeAxes);
        }
        if (out.shape.length === 1) {
            out = out.expandDims(1);
        }
        return out;
    });
}
var Dot = (function (_super) {
    __extends(Dot, _super);
    function Dot(config) {
        var _this = _super.call(this, config) || this;
        _this.axes = config.axes;
        _this.normalize = config.normalize == null ? false : config.normalize;
        _this.supportsMasking = true;
        _this.reshapeRequired = false;
        return _this;
    }
    Dot.prototype.build = function (inputShape) {
        tfc.util.assert(Array.isArray(inputShape) && inputShape.length === 2 &&
            Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), 'A `Dot` layer should be called on a list of exactly 2 inputs.');
        var shape1 = inputShape[0];
        var shape2 = inputShape[1];
        if (shape1.length > 3 || shape2.length > 3) {
            throw new errors_1.NotImplementedError('Dot layer does not support tensors of 4D or higher rank yet.');
        }
        var axes = this.interpretAxes(shape1, shape2);
        if (shape1[axes[0]] !== shape2[axes[1]]) {
            throw new errors_1.ValueError("Dimension incompatibility: " +
                (shape1[axes[0]] + " !== " + shape2[axes[1]]));
        }
    };
    Dot.prototype.mergeFunction = function (inputs) {
        if (inputs.length !== 2) {
            throw new errors_1.ValueError('A `Dot` layer must be called on exactly 2 inputs, ' +
                ("but received " + inputs.length + " input(s)."));
        }
        var x1 = inputs[0];
        var x2 = inputs[1];
        var axes;
        if (!Array.isArray(this.axes)) {
            axes = [
                interpretAxis(this.axes, x1.shape.length),
                interpretAxis(this.axes, x2.shape.length)
            ];
        }
        else {
            axes = this.axes.map(function (axis, i) { return interpretAxis(axis, inputs[i].shape.length); });
        }
        if (this.normalize) {
            x1 = losses_1.l2Normalize(x1, axes[0]);
            x2 = losses_1.l2Normalize(x2, axes[1]);
        }
        return batchDot(x1, x2, axes);
    };
    Dot.prototype.interpretAxes = function (shape1, shape2) {
        var axes;
        if (!Array.isArray(this.axes)) {
            axes = [
                interpretAxis(this.axes, shape1.length),
                interpretAxis(this.axes, shape2.length)
            ];
        }
        else {
            axes = this.axes;
        }
        return axes;
    };
    Dot.prototype.computeOutputShape = function (inputShape) {
        tfc.util.assert(Array.isArray(inputShape) && inputShape.length === 2 &&
            Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), 'A `Dot` layer should be called on a list of exactly 2 inputs.');
        var shape1 = inputShape[0];
        var shape2 = inputShape[1];
        if (shape1.length > 3 || shape2.length > 3) {
            throw new errors_1.NotImplementedError('Dot layer does not support tensors of 4D or higher rank yet.');
        }
        var axes = this.interpretAxes(shape1, shape2);
        shape1.splice(axes[0], 1);
        shape2.splice(axes[1], 1);
        shape2.splice(0, 1);
        var outputShape = shape1.concat(shape2);
        if (outputShape.length === 1) {
            outputShape.push(1);
        }
        return outputShape;
    };
    Dot.prototype.computeMask = function (inputs, mask) {
        throw new errors_1.NotImplementedError('computeMask has not been implemented for Dot yet');
    };
    Dot.prototype.getConfig = function () {
        var config = {
            'axes': this.axes,
            'normalize': this.normalize
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Dot.className = 'Dot';
    return Dot;
}(Merge));
exports.Dot = Dot;
tfjs_core_1.serialization.registerClass(Dot);

},{"../backend/state":208,"../backend/tfjs_backend":209,"../engine/topology":218,"../errors":222,"../losses":244,"../utils/generic_utils":250,"../utils/math_utils":252,"../utils/types_utils":254,"@tensorflow/tfjs-core":64}],237:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var state_1 = require("../backend/state");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var generic_utils = require("../utils/generic_utils");
var math_utils = require("../utils/math_utils");
var types_utils_1 = require("../utils/types_utils");
function batchNormalization(x, mean, variance, beta, gamma, epsilon) {
    if (epsilon === void 0) { epsilon = 1e-3; }
    var out;
    if (x.rank === 2) {
        out = tfc.batchNormalization2d(x, mean, variance, epsilon, gamma, beta);
    }
    else if (x.rank === 3) {
        out = tfc.batchNormalization3d(x, mean, variance, epsilon, gamma, beta);
    }
    else if (x.rank === 4) {
        out = tfc.batchNormalization4d(x, mean, variance, epsilon, gamma, beta);
    }
    else {
        throw new errors_1.NotImplementedError("batchNormalization is not implememnted for array of rank " + x.rank + " " +
            "yet");
    }
    return out;
}
exports.batchNormalization = batchNormalization;
function regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon) {
    if (epsilon === void 0) { epsilon = 1e-3; }
    return tfjs_core_1.tidy(function () {
        var meanAndVariance = tfc.moments(x, reductionAxes);
        var mean = meanAndVariance.mean;
        var variance = meanAndVariance.variance;
        var normed = batchNormalization(x, mean, variance, beta, gamma, epsilon);
        return [normed, mean, variance];
    });
}
function broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon) {
    if (epsilon === void 0) { epsilon = 1e-3; }
    return tfjs_core_1.tidy(function () {
        var meanAndVariance = tfc.moments(x, reductionAxes);
        var mean = meanAndVariance.mean;
        var variance = meanAndVariance.variance;
        var targetShape = [];
        for (var _i = 0, _a = math_utils.range(0, x.rank); _i < _a.length; _i++) {
            var axis = _a[_i];
            if (reductionAxes.indexOf(axis) !== -1) {
                targetShape.push(1);
            }
            else {
                targetShape.push(x.shape[axis]);
            }
        }
        var broadcastMean = mean.reshape(targetShape);
        var broadcastVariance = variance.reshape(targetShape);
        var broadcastGamma = gamma == null ? null : gamma.reshape(targetShape);
        var broadcastBeta = beta == null ? null : beta.reshape(targetShape);
        var normed = batchNormalization(x, broadcastMean, broadcastVariance, broadcastBeta, broadcastGamma, epsilon);
        return [normed, mean, variance];
    });
}
function normalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon) {
    if (epsilon === void 0) { epsilon = 1e-3; }
    if (tfjs_core_1.util.arraysEqual(reductionAxes.slice().sort(), math_utils.range(0, x.rank - 1))) {
        return regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon);
    }
    else {
        return broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon);
    }
}
exports.normalizeBatchInTraining = normalizeBatchInTraining;
var BatchNormalization = (function (_super) {
    __extends(BatchNormalization, _super);
    function BatchNormalization(config) {
        var _this = this;
        if (config == null) {
            config = {};
        }
        _this = _super.call(this, config) || this;
        _this.supportsMasking = true;
        _this.axis = config.axis == null ? -1 : config.axis;
        _this.momentum = config.momentum == null ? 0.99 : config.momentum;
        _this.epsilon = config.epsilon == null ? 1e-3 : config.epsilon;
        _this.center = config.center == null ? true : config.center;
        _this.scale = config.scale == null ? true : config.scale;
        _this.betaInitializer = initializers_1.getInitializer(config.betaInitializer || 'zeros');
        _this.gammaInitializer = initializers_1.getInitializer(config.gammaInitializer || 'ones');
        _this.movingMeanInitializer =
            initializers_1.getInitializer(config.movingMeanInitializer || 'zeros');
        _this.movingVarianceInitializer =
            initializers_1.getInitializer(config.movingVarianceInitializer || 'ones');
        _this.betaConstraint = constraints_1.getConstraint(config.betaConstraint);
        _this.gammaConstraint = constraints_1.getConstraint(config.gammaConstraint);
        _this.betaRegularizer = regularizers_1.getRegularizer(config.betaRegularizer);
        _this.gammaRegularizer = regularizers_1.getRegularizer(config.gammaRegularizer);
        _this.stepCount = 0;
        return _this;
    }
    BatchNormalization.prototype.build = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var axis = this.axis >= 0 ? this.axis : (this.axis + inputShape.length);
        var dim = inputShape[axis];
        if (dim == null) {
            throw new errors_1.ValueError("Axis " + axis + " of input tensor should have a defined dimension but " +
                "the layer received an input with shape " +
                (JSON.stringify(inputShape) + "."));
        }
        this.inputSpec =
            [new topology_1.InputSpec({ ndim: inputShape.length, axes: (_a = {}, _a[axis] = dim, _a) })];
        var shape = [dim];
        if (this.scale) {
            this.gamma = this.addWeight('gamma', shape, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint);
        }
        if (this.center) {
            this.beta = this.addWeight('beta', shape, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint);
        }
        this.movingMean = this.addWeight('moving_mean', shape, null, this.movingMeanInitializer, null, false);
        this.movingVariance = this.addWeight('moving_variance', shape, null, this.movingVarianceInitializer, null, false);
        this.built = true;
        var _a;
    };
    BatchNormalization.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var training = kwargs['training'] == null ? false : kwargs['training'];
            var input = types_utils_1.getExactlyOneTensor(inputs);
            var inputShape = input.shape;
            var ndim = inputShape.length;
            var reductionAxes = math_utils.range(0, ndim);
            var axis = _this.axis >= 0 ? _this.axis : (_this.axis + ndim);
            reductionAxes.splice(axis, 1);
            var broadcastShape = generic_utils.pyListRepeat(1, ndim);
            broadcastShape[axis] = inputShape[axis];
            var sortedReductionAxes = reductionAxes.slice();
            sortedReductionAxes.sort();
            var needsBroadcasting = !tfjs_core_1.util.arraysEqual(sortedReductionAxes, math_utils.range(0, ndim).slice(0, ndim - 1));
            var normalizeInference = function () {
                if (needsBroadcasting) {
                    var broadcastMovingMean = _this.movingMean.read().reshape(broadcastShape);
                    var broadcastMovingVariance = _this.movingVariance.read().reshape(broadcastShape);
                    var broadcastBeta = _this.center ? _this.beta.read().reshape(broadcastShape) : null;
                    var broadcastGamma = _this.scale ? _this.gamma.read().reshape(broadcastShape) : null;
                    return batchNormalization(input, broadcastMovingMean, broadcastMovingVariance, broadcastBeta, broadcastGamma, _this.epsilon);
                }
                else {
                    return batchNormalization(input, _this.movingMean.read(), _this.movingVariance.read(), _this.beta == null ? null : _this.beta.read(), _this.gamma == null ? null : _this.gamma.read(), _this.epsilon);
                }
            };
            if (!training) {
                return normalizeInference();
            }
            var _a = normalizeBatchInTraining(input, _this.gamma.read(), _this.beta.read(), reductionAxes, _this.epsilon), normedTraining = _a[0], mean = _a[1], variance = _a[2];
            var sampleSize = math_utils.arrayProd(reductionAxes.map(function (axis) { return input.shape[axis]; }));
            var varianceDebiased = variance.mul(state_1.getScalar(sampleSize / (sampleSize - (1 + _this.epsilon))));
            var updateMovingMeanAndVariance = function () {
                _this.stepCount++;
                var newMovingMean = tfc.movingAverage(_this.movingMean.read(), mean, _this.momentum, _this.stepCount);
                _this.movingMean.write(newMovingMean);
                var newMovingVariance = tfc.movingAverage(_this.movingVariance.read(), varianceDebiased, _this.momentum, _this.stepCount);
                _this.movingVariance.write(newMovingVariance);
            };
            updateMovingMeanAndVariance();
            return normedTraining;
        });
    };
    BatchNormalization.prototype.getConfig = function () {
        var config = {
            axis: this.axis,
            momentum: this.momentum,
            epsilon: this.epsilon,
            center: this.center,
            scale: this.scale,
            betaInitializer: initializers_1.serializeInitializer(this.betaInitializer),
            gammaInitializer: initializers_1.serializeInitializer(this.gammaInitializer),
            movingMeanInitializer: initializers_1.serializeInitializer(this.movingMeanInitializer),
            movingVarianceInitializer: initializers_1.serializeInitializer(this.movingVarianceInitializer),
            betaRegularizer: regularizers_1.serializeRegularizer(this.betaRegularizer),
            gammaRegularizer: regularizers_1.serializeRegularizer(this.gammaRegularizer),
            betaConstraint: constraints_1.serializeConstraint(this.betaConstraint),
            gammaConstraint: constraints_1.serializeConstraint(this.gammaConstraint)
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    BatchNormalization.className = 'BatchNormalization';
    return BatchNormalization;
}(topology_1.Layer));
exports.BatchNormalization = BatchNormalization;
tfjs_core_1.serialization.registerClass(BatchNormalization);

},{"../backend/state":208,"../constraints":213,"../engine/topology":218,"../errors":222,"../initializers":230,"../regularizers":248,"../utils/generic_utils":250,"../utils/math_utils":252,"../utils/types_utils":254,"@tensorflow/tfjs-core":64}],238:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("../backend/common");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var types_utils_1 = require("../utils/types_utils");
function temporalPadding(x, padding) {
    return tfjs_core_1.tidy(function () {
        if (x.rank !== 3) {
            throw new errors_1.ValueError("temporalPadding expects input tensor to be 3-D, but received a " +
                (x.rank + "-D tensor."));
        }
        if (padding == null) {
            padding = [1, 1];
        }
        if (padding.length !== 2) {
            throw new errors_1.ValueError("temporalPadding expects input padding pattern to be a length-2 " +
                ("array, but received a length-" + padding.length + " array."));
        }
        var pattern = [[0, 0], padding, [0, 0]];
        return tfc.pad(x, pattern);
    });
}
exports.temporalPadding = temporalPadding;
function spatial2dPadding(x, padding, dataFormat) {
    return tfjs_core_1.tidy(function () {
        if (x.rank !== 4) {
            throw new errors_1.ValueError("temporalPadding expects input tensor to be 4-D, but received a " +
                (x.rank + "-D tensor."));
        }
        if (padding == null) {
            padding = [[1, 1], [1, 1]];
        }
        if (padding.length !== 2 || padding[0].length !== 2 ||
            padding[1].length !== 2) {
            throw new errors_1.ValueError('spatial2dPadding expects `padding` to be an Array of two Arrays, ' +
                'each of which is an Array of two integers.');
        }
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        if (dataFormat !== 'channelsLast' && dataFormat !== 'channelsFirst') {
            throw new errors_1.ValueError("Unknown data format: " + dataFormat + ". " +
                "Supported data formats are 'channelsLast' and 'channelsFirst.");
        }
        var pattern;
        if (dataFormat === 'channelsFirst') {
            pattern = [[0, 0], [0, 0], padding[0], padding[1]];
        }
        else {
            pattern = [[0, 0], padding[0], padding[1], [0, 0]];
        }
        return tfc.pad(x, pattern);
    });
}
exports.spatial2dPadding = spatial2dPadding;
var ZeroPadding2D = (function (_super) {
    __extends(ZeroPadding2D, _super);
    function ZeroPadding2D(config) {
        var _this = this;
        if (config == null) {
            config = {};
        }
        _this = _super.call(this, config) || this;
        _this.dataFormat =
            config.dataFormat == null ? common_1.imageDataFormat() : config.dataFormat;
        if (config.padding == null) {
            _this.padding = [[1, 1], [1, 1]];
        }
        else if (typeof config.padding === 'number') {
            _this.padding =
                [[config.padding, config.padding], [config.padding, config.padding]];
        }
        else {
            config.padding = config.padding;
            if (config.padding.length !== 2) {
                throw new errors_1.ValueError("ZeroPadding2D expects padding to be a length-2 array, but " +
                    ("received a length-" + config.padding.length + " array."));
            }
            var heightPadding = void 0;
            var widthPadding = void 0;
            if (typeof config.padding[0] === 'number') {
                heightPadding =
                    [config.padding[0], config.padding[0]];
                widthPadding =
                    [config.padding[1], config.padding[1]];
            }
            else {
                config.padding = config.padding;
                if (config.padding[0].length !== 2) {
                    throw new errors_1.ValueError("ZeroPadding2D expects height padding to be a length-2 array, " +
                        ("but received a length-" + config.padding[0].length + " array."));
                }
                heightPadding = config.padding[0];
                if (config.padding[1].length !== 2) {
                    throw new errors_1.ValueError("ZeroPadding2D expects width padding to be a length-2 array, " +
                        ("but received a length-" + config.padding[1].length + " array."));
                }
                widthPadding = config.padding[1];
            }
            _this.padding = [heightPadding, widthPadding];
        }
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 4 })];
        return _this;
    }
    ZeroPadding2D.prototype.computeOutputShape = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var rows;
        var cols;
        if (this.dataFormat === 'channelsFirst') {
            if (inputShape[2] != null && inputShape[2] >= 0) {
                rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];
            }
            else {
                rows = null;
            }
            if (inputShape[3] != null && inputShape[3] >= 0) {
                cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];
            }
            else {
                cols = null;
            }
            return [inputShape[0], inputShape[1], rows, cols];
        }
        else {
            if (inputShape[1] != null && inputShape[1] >= 0) {
                rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];
            }
            else {
                rows = null;
            }
            if (inputShape[2] != null && inputShape[2] >= 0) {
                cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];
            }
            else {
                cols = null;
            }
            return [inputShape[0], rows, cols, inputShape[3]];
        }
    };
    ZeroPadding2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () { return spatial2dPadding(types_utils_1.getExactlyOneTensor(inputs), _this.padding, _this.dataFormat); });
    };
    ZeroPadding2D.prototype.getConfig = function () {
        var config = {
            padding: this.padding,
            dataFormat: this.dataFormat,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    ZeroPadding2D.className = 'ZeroPadding2D';
    return ZeroPadding2D;
}(topology_1.Layer));
exports.ZeroPadding2D = ZeroPadding2D;
tfjs_core_1.serialization.registerClass(ZeroPadding2D);

},{"../backend/common":207,"../engine/topology":218,"../errors":222,"../utils/types_utils":254,"@tensorflow/tfjs-core":64}],239:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("../backend/common");
var K = require("../backend/tfjs_backend");
var common_2 = require("../common");
var topology_1 = require("../engine/topology");
var topology_2 = require("../engine/topology");
var errors_1 = require("../errors");
var conv_utils_1 = require("../utils/conv_utils");
var types_utils_1 = require("../utils/types_utils");
var convolutional_1 = require("./convolutional");
function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {
    return tfjs_core_1.tidy(function () {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPoolMode(poolMode);
        common_2.checkPaddingMode(padding);
        if (strides == null) {
            strides = [1, 1];
        }
        if (padding == null) {
            padding = 'valid';
        }
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        if (poolMode == null) {
            poolMode = 'max';
        }
        x = convolutional_1.preprocessConv2DInput(x, dataFormat);
        var y;
        var paddingString = (padding === 'same') ? 'same' : 'valid';
        if (poolMode === 'max') {
            y = tfc.maxPool(x, poolSize, strides, paddingString);
        }
        else {
            y = tfc.avgPool(x, poolSize, strides, paddingString);
        }
        if (dataFormat === 'channelsFirst') {
            y = tfc.transpose(y, [0, 3, 1, 2]);
        }
        return y;
    });
}
exports.pool2d = pool2d;
var Pooling1D = (function (_super) {
    __extends(Pooling1D, _super);
    function Pooling1D(config) {
        var _this = this;
        if (config.poolSize == null) {
            config.poolSize = 2;
        }
        _this = _super.call(this, config) || this;
        if (typeof config.poolSize === 'number') {
            _this.poolSize = [config.poolSize];
        }
        else if (Array.isArray(config.poolSize) &&
            config.poolSize.length === 1 &&
            typeof config.poolSize[0] === 'number') {
            _this.poolSize = config.poolSize;
        }
        else {
            throw new errors_1.ValueError("poolSize for 1D convolutional layer must be a number or an " +
                "Array of a single number, but received " +
                ("" + JSON.stringify(config.poolSize)));
        }
        if (config.strides == null) {
            _this.strides = _this.poolSize;
        }
        else {
            if (typeof config.strides === 'number') {
                _this.strides = [config.strides];
            }
            else if (Array.isArray(config.strides) &&
                config.strides.length === 1 &&
                typeof config.strides[0] === 'number') {
                _this.strides = config.strides;
            }
            else {
                throw new errors_1.ValueError("strides for 1D convolutional layer must be a number or an " +
                    "Array of a single number, but received " +
                    ("" + JSON.stringify(config.strides)));
            }
        }
        _this.padding = config.padding == null ? 'valid' : config.padding;
        common_2.checkPaddingMode(_this.padding);
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 3 })];
        return _this;
    }
    Pooling1D.prototype.computeOutputShape = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var length = conv_utils_1.convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);
        return [inputShape[0], length, inputShape[2]];
    };
    Pooling1D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            inputs = K.expandDims(types_utils_1.getExactlyOneTensor(inputs), 2);
            var output = _this.poolingFunction(types_utils_1.getExactlyOneTensor(inputs), [_this.poolSize[0], 1], [_this.strides[0], 1], _this.padding, 'channelsLast');
            return tfc.squeeze(output, [2]);
        });
    };
    Pooling1D.prototype.getConfig = function () {
        var config = {
            poolSize: this.poolSize,
            padding: this.padding,
            strides: this.strides,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    return Pooling1D;
}(topology_2.Layer));
exports.Pooling1D = Pooling1D;
var MaxPooling1D = (function (_super) {
    __extends(MaxPooling1D, _super);
    function MaxPooling1D(config) {
        return _super.call(this, config) || this;
    }
    MaxPooling1D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');
    };
    MaxPooling1D.className = 'MaxPooling1D';
    return MaxPooling1D;
}(Pooling1D));
exports.MaxPooling1D = MaxPooling1D;
tfjs_core_1.serialization.registerClass(MaxPooling1D);
var AveragePooling1D = (function (_super) {
    __extends(AveragePooling1D, _super);
    function AveragePooling1D(config) {
        return _super.call(this, config) || this;
    }
    AveragePooling1D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');
    };
    AveragePooling1D.className = 'AveragePooling1D';
    return AveragePooling1D;
}(Pooling1D));
exports.AveragePooling1D = AveragePooling1D;
tfjs_core_1.serialization.registerClass(AveragePooling1D);
var Pooling2D = (function (_super) {
    __extends(Pooling2D, _super);
    function Pooling2D(config) {
        var _this = this;
        if (config.poolSize == null) {
            config.poolSize = [2, 2];
        }
        _this = _super.call(this, config) || this;
        _this.poolSize = Array.isArray(config.poolSize) ?
            config.poolSize :
            [config.poolSize, config.poolSize];
        if (config.strides == null) {
            _this.strides = _this.poolSize;
        }
        else if (Array.isArray(config.strides)) {
            if (config.strides.length !== 2) {
                throw new errors_1.ValueError("If the strides property of a 2D pooling layer is an Array, " +
                    "it is expected to have a length of 2, but received length " +
                    (config.strides.length + "."));
            }
            _this.strides = config.strides;
        }
        else {
            _this.strides = [config.strides, config.strides];
        }
        _this.padding = config.padding == null ? 'valid' : config.padding;
        _this.dataFormat =
            config.dataFormat == null ? 'channelsLast' : config.dataFormat;
        common_2.checkDataFormat(_this.dataFormat);
        common_2.checkPaddingMode(_this.padding);
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 4 })];
        return _this;
    }
    Pooling2D.prototype.computeOutputShape = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];
        var cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];
        rows =
            conv_utils_1.convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);
        cols =
            conv_utils_1.convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);
        if (this.dataFormat === 'channelsFirst') {
            return [inputShape[0], inputShape[1], rows, cols];
        }
        else {
            return [inputShape[0], rows, cols, inputShape[3]];
        }
    };
    Pooling2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            return _this.poolingFunction(types_utils_1.getExactlyOneTensor(inputs), _this.poolSize, _this.strides, _this.padding, _this.dataFormat);
        });
    };
    Pooling2D.prototype.getConfig = function () {
        var config = {
            poolSize: this.poolSize,
            padding: this.padding,
            strides: this.strides,
            dataFormat: this.dataFormat
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    return Pooling2D;
}(topology_2.Layer));
exports.Pooling2D = Pooling2D;
var MaxPooling2D = (function (_super) {
    __extends(MaxPooling2D, _super);
    function MaxPooling2D(config) {
        return _super.call(this, config) || this;
    }
    MaxPooling2D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');
    };
    MaxPooling2D.className = 'MaxPooling2D';
    return MaxPooling2D;
}(Pooling2D));
exports.MaxPooling2D = MaxPooling2D;
tfjs_core_1.serialization.registerClass(MaxPooling2D);
var AveragePooling2D = (function (_super) {
    __extends(AveragePooling2D, _super);
    function AveragePooling2D(config) {
        return _super.call(this, config) || this;
    }
    AveragePooling2D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');
    };
    AveragePooling2D.className = 'AveragePooling2D';
    return AveragePooling2D;
}(Pooling2D));
exports.AveragePooling2D = AveragePooling2D;
tfjs_core_1.serialization.registerClass(AveragePooling2D);
var GlobalPooling1D = (function (_super) {
    __extends(GlobalPooling1D, _super);
    function GlobalPooling1D(config) {
        var _this = _super.call(this, config) || this;
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 3 })];
        return _this;
    }
    GlobalPooling1D.prototype.computeOutputShape = function (inputShape) {
        return [inputShape[0], inputShape[2]];
    };
    GlobalPooling1D.prototype.call = function (inputs, kwargs) {
        throw new errors_1.NotImplementedError();
    };
    return GlobalPooling1D;
}(topology_2.Layer));
exports.GlobalPooling1D = GlobalPooling1D;
var GlobalAveragePooling1D = (function (_super) {
    __extends(GlobalAveragePooling1D, _super);
    function GlobalAveragePooling1D(config) {
        return _super.call(this, config) || this;
    }
    GlobalAveragePooling1D.prototype.call = function (inputs, kwargs) {
        return tfjs_core_1.tidy(function () {
            var input = types_utils_1.getExactlyOneTensor(inputs);
            return tfc.mean(input, 1);
        });
    };
    GlobalAveragePooling1D.className = 'GlobalAveragePooling1D';
    return GlobalAveragePooling1D;
}(GlobalPooling1D));
exports.GlobalAveragePooling1D = GlobalAveragePooling1D;
tfjs_core_1.serialization.registerClass(GlobalAveragePooling1D);
var GlobalMaxPooling1D = (function (_super) {
    __extends(GlobalMaxPooling1D, _super);
    function GlobalMaxPooling1D(config) {
        return _super.call(this, config) || this;
    }
    GlobalMaxPooling1D.prototype.call = function (inputs, kwargs) {
        return tfjs_core_1.tidy(function () {
            var input = types_utils_1.getExactlyOneTensor(inputs);
            return tfc.max(input, 1);
        });
    };
    GlobalMaxPooling1D.className = 'GlobalMaxPooling1D';
    return GlobalMaxPooling1D;
}(GlobalPooling1D));
exports.GlobalMaxPooling1D = GlobalMaxPooling1D;
tfjs_core_1.serialization.registerClass(GlobalMaxPooling1D);
var GlobalPooling2D = (function (_super) {
    __extends(GlobalPooling2D, _super);
    function GlobalPooling2D(config) {
        var _this = _super.call(this, config) || this;
        _this.dataFormat =
            config.dataFormat == null ? 'channelsLast' : config.dataFormat;
        common_2.checkDataFormat(_this.dataFormat);
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 4 })];
        return _this;
    }
    GlobalPooling2D.prototype.computeOutputShape = function (inputShape) {
        inputShape = inputShape;
        if (this.dataFormat === 'channelsLast') {
            return [inputShape[0], inputShape[3]];
        }
        else {
            return [inputShape[0], inputShape[1]];
        }
    };
    GlobalPooling2D.prototype.call = function (inputs, kwargs) {
        throw new errors_1.NotImplementedError();
    };
    GlobalPooling2D.prototype.getConfig = function () {
        var config = { dataFormat: this.dataFormat };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    return GlobalPooling2D;
}(topology_2.Layer));
exports.GlobalPooling2D = GlobalPooling2D;
var GlobalAveragePooling2D = (function (_super) {
    __extends(GlobalAveragePooling2D, _super);
    function GlobalAveragePooling2D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GlobalAveragePooling2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var input = types_utils_1.getExactlyOneTensor(inputs);
            if (_this.dataFormat === 'channelsLast') {
                return tfc.mean(input, [1, 2]);
            }
            else {
                return tfc.mean(input, [2, 3]);
            }
        });
    };
    GlobalAveragePooling2D.className = 'GlobalAveragePooling2D';
    return GlobalAveragePooling2D;
}(GlobalPooling2D));
exports.GlobalAveragePooling2D = GlobalAveragePooling2D;
tfjs_core_1.serialization.registerClass(GlobalAveragePooling2D);
var GlobalMaxPooling2D = (function (_super) {
    __extends(GlobalMaxPooling2D, _super);
    function GlobalMaxPooling2D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GlobalMaxPooling2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var input = types_utils_1.getExactlyOneTensor(inputs);
            if (_this.dataFormat === 'channelsLast') {
                return tfc.max(input, [1, 2]);
            }
            else {
                return tfc.max(input, [2, 3]);
            }
        });
    };
    GlobalMaxPooling2D.className = 'GlobalMaxPooling2D';
    return GlobalMaxPooling2D;
}(GlobalPooling2D));
exports.GlobalMaxPooling2D = GlobalMaxPooling2D;
tfjs_core_1.serialization.registerClass(GlobalMaxPooling2D);

},{"../backend/common":207,"../backend/tfjs_backend":209,"../common":212,"../engine/topology":218,"../errors":222,"../utils/conv_utils":249,"../utils/types_utils":254,"./convolutional":232,"@tensorflow/tfjs-core":64}],240:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var activations_1 = require("../activations");
var state_1 = require("../backend/state");
var K = require("../backend/tfjs_backend");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var topology_2 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var math_utils = require("../utils/math_utils");
var types_utils_1 = require("../utils/types_utils");
var variables_1 = require("../variables");
var serialization_1 = require("./serialization");
function standardizeArgs(inputs, initialState, constants, numConstants) {
    if (Array.isArray(inputs)) {
        if (initialState != null || constants != null) {
            throw new errors_1.ValueError('When inputs is an array, neither initialState or constants ' +
                'should be provided');
        }
        if (numConstants != null) {
            constants = inputs.slice(inputs.length - numConstants, inputs.length);
            inputs = inputs.slice(0, inputs.length - numConstants);
        }
        if (inputs.length > 1) {
            initialState = inputs.slice(1, inputs.length);
        }
        inputs = inputs[0];
    }
    function toListOrNull(x) {
        if (x == null || Array.isArray(x)) {
            return x;
        }
        else {
            return [x];
        }
    }
    initialState = toListOrNull(initialState);
    constants = toListOrNull(constants);
    return { inputs: inputs, initialState: initialState, constants: constants };
}
exports.standardizeArgs = standardizeArgs;
function rnn(stepFunction, inputs, initialStates, goBackwards, mask, constants, unroll, needPerStepOutputs) {
    if (goBackwards === void 0) { goBackwards = false; }
    if (unroll === void 0) { unroll = false; }
    if (needPerStepOutputs === void 0) { needPerStepOutputs = false; }
    var ndim = inputs.shape.length;
    if (ndim < 3) {
        throw new errors_1.ValueError("Input should be at least 3D, but is " + ndim + "D.");
    }
    var axes = [1, 0].concat(math_utils.range(2, ndim));
    inputs = tfc.transpose(inputs, axes);
    if (mask != null) {
        throw new errors_1.NotImplementedError('The rnn() function of the deeplearn.js backend does not support ' +
            'masking yet.');
    }
    if (constants != null) {
        throw new errors_1.NotImplementedError('The rnn() functoin of the deeplearn.js backend does not support ' +
            'constants yet.');
    }
    if (unroll) {
        console.warn('Backend rnn(): the unroll = true option is not applicable to the ' +
            'imperative deeplearn.js backend.');
    }
    if (goBackwards) {
        inputs = tfc.reverse(inputs, 0);
    }
    var outputs;
    var lastOutput;
    var states = initialStates;
    var timeSteps = inputs.shape[0];
    var _loop_1 = function (t) {
        var currentInput = K.sliceAlongFirstAxis(inputs, t, 1);
        currentInput = currentInput.reshape(currentInput.shape.slice(1));
        var stepOutputs = tfc.tidy(function () { return stepFunction(currentInput, states); });
        lastOutput = stepOutputs[0];
        if (needPerStepOutputs) {
            if (t === 0) {
                outputs = lastOutput.expandDims(1);
            }
            else {
                var newOutputs = tfc.concat([outputs, lastOutput.expandDims(1)], 1);
                outputs.dispose();
                outputs = newOutputs;
            }
        }
        states = stepOutputs[1];
    };
    for (var t = 0; t < timeSteps; ++t) {
        _loop_1(t);
    }
    return [lastOutput, outputs, states];
}
exports.rnn = rnn;
var RNN = (function (_super) {
    __extends(RNN, _super);
    function RNN(config) {
        var _this = _super.call(this, config) || this;
        var cell;
        if (config.cell == null) {
            throw new errors_1.ValueError('cell property is missing for the constructor of RNN.');
        }
        else if (Array.isArray(config.cell)) {
            cell = new StackedRNNCells({ cells: config.cell });
        }
        else {
            cell = config.cell;
        }
        if (cell.stateSize == null) {
            throw new errors_1.ValueError('The RNN cell should have an attribute `stateSize` (tuple of ' +
                'integers, one integer per RNN state).');
        }
        _this.cell = cell;
        _this.returnSequences =
            config.returnSequences == null ? false : config.returnSequences;
        _this.returnState = config.returnState == null ? false : config.returnState;
        _this.goBackwards = config.goBackwards == null ? false : config.goBackwards;
        _this._stateful = config.stateful == null ? false : config.stateful;
        _this.unroll = config.unroll == null ? false : config.unroll;
        _this.supportsMasking = true;
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 3 })];
        _this.stateSpec = null;
        _this.states = null;
        _this.numConstants = null;
        _this.keptStates = [];
        return _this;
    }
    RNN.prototype.getStates = function () {
        if (this.states == null) {
            var numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
            return math_utils.range(0, numStates).map(function (x) { return null; });
        }
        else {
            return this.states;
        }
    };
    RNN.prototype.setStates = function (states) {
        this.states = states;
    };
    RNN.prototype.computeOutputShape = function (inputShape) {
        if (types_utils_1.isArrayOfShapes(inputShape)) {
            inputShape = inputShape[0];
        }
        inputShape = inputShape;
        var stateSize = this.cell.stateSize;
        if (!Array.isArray(stateSize)) {
            stateSize = [stateSize];
        }
        var outputDim = stateSize[0];
        var outputShape;
        if (this.returnSequences) {
            outputShape = [inputShape[0], inputShape[1], outputDim];
        }
        else {
            outputShape = [inputShape[0], outputDim];
        }
        if (this.returnState) {
            var stateShape = [];
            for (var _i = 0, stateSize_1 = stateSize; _i < stateSize_1.length; _i++) {
                var dim = stateSize_1[_i];
                stateShape.push([inputShape[0], dim]);
            }
            return [outputShape].concat(stateShape);
        }
        else {
            return outputShape;
        }
    };
    RNN.prototype.computeMask = function (inputs, mask) {
        throw new errors_1.NotImplementedError('computeMask has not been implemented for RNN yet');
    };
    RNN.prototype.build = function (inputShape) {
        var constantShape = null;
        if (this.numConstants != null) {
            throw new errors_1.NotImplementedError('Constants support is not implemented in RNN yet.');
        }
        if (types_utils_1.isArrayOfShapes(inputShape)) {
            inputShape = inputShape[0];
        }
        inputShape = inputShape;
        var batchSize = this.stateful ? inputShape[0] : null;
        var inputDim = inputShape[inputShape.length - 1];
        this.inputSpec[0] = new topology_1.InputSpec({ shape: [batchSize, null, inputDim] });
        var stepInputShape = [inputShape[0]].concat(inputShape.slice(2));
        if (constantShape != null) {
            throw new errors_1.NotImplementedError('Constants support is not implemented in RNN yet.');
        }
        else {
            this.cell.build(stepInputShape);
        }
        var stateSize;
        if (Array.isArray(this.cell.stateSize)) {
            stateSize = this.cell.stateSize;
        }
        else {
            stateSize = [this.cell.stateSize];
        }
        if (this.stateSpec != null) {
            if (!tfjs_core_1.util.arraysEqual(this.stateSpec.map(function (spec) { return spec.shape[spec.shape.length - 1]; }), stateSize)) {
                throw new errors_1.ValueError("An initialState was passed that is not compatible with " +
                    ("cell.stateSize. Received stateSpec=" + this.stateSpec + "; ") +
                    ("However cell.stateSize is " + this.cell.stateSize));
            }
        }
        else {
            this.stateSpec =
                stateSize.map(function (dim) { return new topology_1.InputSpec({ shape: [null, dim] }); });
        }
        if (this.stateful) {
            this.resetStates();
        }
    };
    RNN.prototype.resetStates = function (states) {
        var _this = this;
        tfjs_core_1.tidy(function () {
            if (!_this.stateful) {
                throw new errors_1.AttributeError('Cannot call resetStates() on an RNN Layer that is not stateful.');
            }
            var batchSize = _this.inputSpec[0].shape[0];
            if (batchSize == null) {
                throw new errors_1.ValueError('If an RNN is stateful, it needs to know its batch size. Specify ' +
                    'the batch size of your input tensors: \n' +
                    '- If using a Sequential model, specify the batch size by ' +
                    'passing a `batchInputShape` option to your first layer.\n' +
                    '- If using the functional API, specify the batch size by ' +
                    'passing a `batchShape` option to your Input layer.');
            }
            if (_this.states == null) {
                if (Array.isArray(_this.cell.stateSize)) {
                    _this.states =
                        _this.cell.stateSize.map(function (dim) { return tfc.zeros([batchSize, dim]); });
                }
                else {
                    _this.states = [tfc.zeros([batchSize, _this.cell.stateSize])];
                }
            }
            else if (states == null) {
                tfc.dispose(_this.states);
                if (_this.keptStates != null) {
                    tfc.dispose(_this.keptStates);
                    _this.keptStates = [];
                }
                if (Array.isArray(_this.cell.stateSize)) {
                    _this.states =
                        _this.cell.stateSize.map(function (dim) { return tfc.zeros([batchSize, dim]); });
                }
                else {
                    _this.states[0] = tfc.zeros([batchSize, _this.cell.stateSize]);
                }
            }
            else {
                _this.keptStates.push(_this.states.slice());
                if (!Array.isArray(states)) {
                    states = [states];
                }
                if (states.length !== _this.states.length) {
                    throw new errors_1.ValueError("Layer " + _this.name + " expects " + _this.states.length + " state(s), " +
                        ("but it received " + states.length + " state value(s). Input ") +
                        ("received: " + states));
                }
                for (var index = 0; index < _this.states.length; ++index) {
                    var value = states[index];
                    var dim = Array.isArray(_this.cell.stateSize) ?
                        _this.cell.stateSize[index] :
                        _this.cell.stateSize;
                    var expectedShape = [batchSize, dim];
                    if (!tfjs_core_1.util.arraysEqual(value.shape, expectedShape)) {
                        throw new errors_1.ValueError("State " + index + " is incompatible with layer " + _this.name + ": " +
                            ("expected shape=" + expectedShape + ", received shape=" + value.shape));
                    }
                    _this.states[index] = value;
                }
            }
            _this.states.forEach(function (state) { return tfc.keep(state); });
        });
    };
    RNN.prototype.apply = function (inputs, kwargs) {
        var initialState = kwargs == null ? null : kwargs['initialState'];
        var constants = kwargs == null ? null : kwargs['constants'];
        if (kwargs == null) {
            kwargs = {};
        }
        var standardized = standardizeArgs(inputs, initialState, constants, this.numConstants);
        inputs = standardized.inputs;
        initialState = standardized.initialState;
        constants = standardized.constants;
        var additionalInputs = [];
        var additionalSpecs = [];
        if (initialState != null) {
            kwargs['initialState'] = initialState;
            additionalInputs = additionalInputs.concat(initialState);
            this.stateSpec = [];
            for (var _i = 0, initialState_1 = initialState; _i < initialState_1.length; _i++) {
                var state = initialState_1[_i];
                this.stateSpec.push(new topology_1.InputSpec({ shape: state.shape }));
            }
            additionalSpecs = additionalSpecs.concat(this.stateSpec);
        }
        if (constants != null) {
            kwargs['constants'] = constants;
            additionalInputs = additionalInputs.concat(constants);
            this.numConstants = constants.length;
        }
        var isTensor = additionalInputs[0] instanceof topology_1.SymbolicTensor;
        if (isTensor) {
            var fullInput = [inputs].concat(additionalInputs);
            var fullInputSpec = this.inputSpec.concat(additionalSpecs);
            var originalInputSpec = this.inputSpec;
            this.inputSpec = fullInputSpec;
            var output = _super.prototype.apply.call(this, fullInput, kwargs);
            this.inputSpec = originalInputSpec;
            return output;
        }
        else {
            return _super.prototype.apply.call(this, inputs, kwargs);
        }
    };
    RNN.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var mask = kwargs == null ? null : kwargs['mask'];
            var training = kwargs == null ? null : kwargs['training'];
            var initialState = kwargs == null ? null : kwargs['initialState'];
            inputs = types_utils_1.getExactlyOneTensor(inputs);
            if (initialState == null) {
                if (_this.stateful) {
                    initialState = _this.states;
                }
                else {
                    initialState = _this.getInitialState(inputs);
                }
            }
            if (mask != null) {
                throw new errors_1.NotImplementedError('Masking is not implemented for RNN yet');
            }
            var numStates = Array.isArray(_this.cell.stateSize) ? _this.cell.stateSize.length : 1;
            if (initialState.length !== numStates) {
                throw new errors_1.ValueError("RNN Layer has " + numStates + " state(s) but was passed " +
                    (initialState.length + " initial state(s)."));
            }
            if (_this.unroll) {
                console.warn('Ignoring unroll = true for RNN layer, due to imperative backend.');
            }
            var cellCallKwargs = { training: training };
            var step = function (inputs, states) {
                var outputs = _this.cell.call([inputs].concat(states), cellCallKwargs);
                return [outputs[0], outputs.slice(1)];
            };
            var rnnOutputs = rnn(step, inputs, initialState, _this.goBackwards, null, null, _this.unroll, _this.returnSequences);
            var lastOutput = rnnOutputs[0];
            var outputs = rnnOutputs[1];
            var states = rnnOutputs[2];
            if (_this.stateful) {
                _this.resetStates(states);
            }
            var output = _this.returnSequences ? outputs : lastOutput;
            if (_this.returnState) {
                return [output].concat(states);
            }
            else {
                return output;
            }
        });
    };
    RNN.prototype.getInitialState = function (inputs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var initialState = tfc.zeros(inputs.shape);
            initialState = tfc.sum(initialState, [1, 2]);
            initialState = K.expandDims(initialState);
            if (Array.isArray(_this.cell.stateSize)) {
                return _this.cell.stateSize.map(function (dim) { return dim > 1 ? K.tile(initialState, [1, dim]) : initialState; });
            }
            else {
                return _this.cell.stateSize > 1 ?
                    [K.tile(initialState, [1, _this.cell.stateSize])] :
                    [initialState];
            }
        });
    };
    Object.defineProperty(RNN.prototype, "trainableWeights", {
        get: function () {
            if (!this.trainable) {
                return [];
            }
            return this.cell.trainableWeights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RNN.prototype, "nonTrainableWeights", {
        get: function () {
            if (!this.trainable) {
                return this.cell.weights;
            }
            return this.cell.nonTrainableWeights;
        },
        enumerable: true,
        configurable: true
    });
    RNN.prototype.getConfig = function () {
        var config = {
            returnSequences: this.returnSequences,
            returnState: this.returnState,
            goBackwards: this.goBackwards,
            stateful: this.stateful,
            unroll: this.unroll,
        };
        if (this.numConstants != null) {
            config.numConstants = this.numConstants;
        }
        var cellConfig = this.cell.getConfig();
        config.cell = {
            className: this.cell.getClassName(),
            config: cellConfig,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    RNN.className = 'RNN';
    return RNN;
}(topology_2.Layer));
exports.RNN = RNN;
tfjs_core_1.serialization.registerClass(RNN);
var RNNCell = (function (_super) {
    __extends(RNNCell, _super);
    function RNNCell() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RNNCell;
}(topology_2.Layer));
exports.RNNCell = RNNCell;
var SimpleRNNCell = (function (_super) {
    __extends(SimpleRNNCell, _super);
    function SimpleRNNCell(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_ACTIVATION = 'tanh';
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        _this.units = config.units;
        _this.activation = activations_1.getActivation(config.activation == null ? _this.DEFAULT_ACTIVATION :
            config.activation);
        _this.useBias = config.useBias == null ? true : config.useBias;
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.recurrentInitializer = initializers_1.getInitializer(config.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.recurrentRegularizer = regularizers_1.getRegularizer(config.recurrentRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.recurrentConstraint = constraints_1.getConstraint(config.recurrentConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.dropout = math_utils.min([1, math_utils.max([0, config.dropout == null ? 0 : config.dropout])]);
        _this.recurrentDropout = math_utils.min([
            1,
            math_utils.max([0, config.recurrentDropout == null ? 0 : config.recurrentDropout])
        ]);
        _this.stateSize = _this.units;
        _this.dropoutMask = null;
        _this.recurrentDropoutMask = null;
        return _this;
    }
    SimpleRNNCell.prototype.build = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        this.kernel = this.addWeight('kernel', [inputShape[inputShape.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.built = true;
    };
    SimpleRNNCell.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = inputs;
            if (inputs.length !== 2) {
                throw new errors_1.ValueError("SimpleRNNCell expects 2 input Tensors, got " + inputs.length + ".");
            }
            var prevOutput = inputs[1];
            inputs = inputs[0];
            var training = kwargs['training'] == null ? false : kwargs['training'];
            if (0 < _this.dropout && _this.dropout < 1 && _this.dropoutMask == null) {
                _this.dropoutMask = generateDropoutMask(function () { return tfc.onesLike(inputs); }, _this.dropout, training);
            }
            if (0 < _this.recurrentDropout && _this.recurrentDropout < 1 &&
                _this.recurrentDropoutMask == null) {
                _this.recurrentDropoutMask =
                    generateDropoutMask(function () { return tfc.onesLike(prevOutput); }, _this.recurrentDropout, training);
            }
            var h;
            var dpMask = _this.dropoutMask;
            var recDpMask = _this.recurrentDropoutMask;
            if (dpMask != null) {
                h = K.dot(tfc.mul(inputs, dpMask), _this.kernel.read());
            }
            else {
                h = K.dot(inputs, _this.kernel.read());
            }
            if (_this.bias != null) {
                h = K.biasAdd(h, _this.bias.read());
            }
            if (recDpMask != null) {
                prevOutput = tfc.mul(prevOutput, recDpMask);
            }
            var output = tfc.add(h, K.dot(prevOutput, _this.recurrentKernel.read()));
            if (_this.activation != null) {
                output = _this.activation.apply(output);
            }
            return [output, output];
        });
    };
    SimpleRNNCell.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    SimpleRNNCell.className = 'SimpleRNNCell';
    return SimpleRNNCell;
}(RNNCell));
exports.SimpleRNNCell = SimpleRNNCell;
tfjs_core_1.serialization.registerClass(SimpleRNNCell);
var SimpleRNN = (function (_super) {
    __extends(SimpleRNN, _super);
    function SimpleRNN(config) {
        var _this = this;
        config.cell = new SimpleRNNCell(config);
        _this = _super.call(this, config) || this;
        return _this;
    }
    SimpleRNN.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (_this.cell.dropoutMask != null) {
                tfc.dispose(_this.cell.dropoutMask);
                _this.cell.dropoutMask = null;
            }
            if (_this.cell.recurrentDropoutMask != null) {
                tfc.dispose(_this.cell.recurrentDropoutMask);
                _this.cell.recurrentDropoutMask = null;
            }
            var mask = kwargs == null ? null : kwargs['mask'];
            var training = kwargs == null ? null : kwargs['training'];
            var initialState = kwargs == null ? null : kwargs['initialState'];
            return _super.prototype.call.call(_this, inputs, { mask: mask, training: training, initialState: initialState });
        });
    };
    Object.defineProperty(SimpleRNN.prototype, "units", {
        get: function () {
            return this.cell.units;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "activation", {
        get: function () {
            return this.cell.activation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "useBias", {
        get: function () {
            return this.cell.useBias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "kernelInitializer", {
        get: function () {
            return this.cell.kernelInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "recurrentInitializer", {
        get: function () {
            return this.cell.recurrentInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "biasInitializer", {
        get: function () {
            return this.cell.biasInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "kernelRegularizer", {
        get: function () {
            return this.cell.kernelRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "recurrentRegularizer", {
        get: function () {
            return this.cell.recurrentRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "biasRegularizer", {
        get: function () {
            return this.cell.biasRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "kernelConstraint", {
        get: function () {
            return this.cell.kernelConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "recurrentConstraint", {
        get: function () {
            return this.cell.recurrentConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "biasConstraint", {
        get: function () {
            return this.cell.biasConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "dropout", {
        get: function () {
            return this.cell.dropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "recurrentDropout", {
        get: function () {
            return this.cell.recurrentDropout;
        },
        enumerable: true,
        configurable: true
    });
    SimpleRNN.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        delete baseConfig['cell'];
        Object.assign(config, baseConfig);
        return config;
    };
    SimpleRNN.className = 'SimpleRNN';
    return SimpleRNN;
}(RNN));
exports.SimpleRNN = SimpleRNN;
tfjs_core_1.serialization.registerClass(SimpleRNN);
var GRUCell = (function (_super) {
    __extends(GRUCell, _super);
    function GRUCell(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_ACTIVATION = 'tanh';
        _this.DEFAULT_RECURRENT_ACTIVATION = 'hardSigmoid';
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        _this.units = config.units;
        _this.activation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_ACTIVATION :
            config.activation);
        _this.recurrentActivation = activations_1.getActivation(config.recurrentActivation === undefined ?
            _this.DEFAULT_RECURRENT_ACTIVATION :
            config.recurrentActivation);
        _this.useBias = config.useBias == null ? true : config.useBias;
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.recurrentInitializer = initializers_1.getInitializer(config.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.recurrentRegularizer = regularizers_1.getRegularizer(config.recurrentRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.recurrentConstraint = constraints_1.getConstraint(config.recurrentConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.dropout = math_utils.min([1, math_utils.max([0, config.dropout == null ? 0 : config.dropout])]);
        _this.recurrentDropout = math_utils.min([
            1,
            math_utils.max([0, config.recurrentDropout == null ? 0 : config.recurrentDropout])
        ]);
        _this.implementation = config.implementation;
        _this.stateSize = _this.units;
        _this.dropoutMask = null;
        _this.recurrentDropoutMask = null;
        return _this;
    }
    GRUCell.prototype.build = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var inputDim = inputShape[inputShape.length - 1];
        this.kernel = this.addWeight('kernel', [inputDim, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.built = true;
    };
    GRUCell.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = inputs;
            if (inputs.length !== 2) {
                throw new errors_1.ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got " +
                    (inputs.length + "."));
            }
            var training = kwargs['training'] == null ? false : kwargs['training'];
            var hTMinus1 = inputs[1];
            inputs = inputs[0];
            if (0 < _this.dropout && _this.dropout < 1 && _this.dropoutMask == null) {
                _this.dropoutMask = generateDropoutMask(function () { return tfc.onesLike(inputs); }, _this.dropout, training, 3);
            }
            if (0 < _this.recurrentDropout && _this.recurrentDropout < 1 &&
                _this.recurrentDropoutMask == null) {
                _this.recurrentDropoutMask =
                    generateDropoutMask(function () { return tfc.onesLike(hTMinus1); }, _this.recurrentDropout, training, 3);
            }
            var dpMask = _this.dropoutMask;
            var recDpMask = _this.recurrentDropoutMask;
            var z;
            var r;
            var hh;
            if (_this.implementation === 1) {
                var kernelZ = K.sliceAlongLastAxis(_this.kernel.read(), 0, _this.units);
                var kernelR = K.sliceAlongLastAxis(_this.kernel.read(), _this.units, _this.units);
                var kernelH = K.sliceAlongLastAxis(_this.kernel.read(), _this.units * 2, _this.units);
                var recurrentKernelZ = K.sliceAlongLastAxis(_this.recurrentKernel.read(), 0, _this.units);
                var recurrentKernelR = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units, _this.units);
                var recurrentKernelH = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units * 2, _this.units);
                var inputsZ = void 0, inputsR = void 0, inputsH = void 0;
                if (0 < _this.dropout && _this.dropout < 1) {
                    inputsZ = tfc.mul(inputs, dpMask[0]);
                    inputsR = tfc.mul(inputs, dpMask[1]);
                    inputsH = tfc.mul(inputs, dpMask[2]);
                }
                else {
                    inputsZ = inputs;
                    inputsR = inputs;
                    inputsH = inputs;
                }
                var xZ = K.dot(inputsZ, kernelZ);
                var xR = K.dot(inputsR, kernelR);
                var xH = K.dot(inputsH, kernelH);
                if (_this.useBias) {
                    var biasZ = K.sliceAlongFirstAxis(_this.bias.read(), 0, _this.units);
                    var biasR = K.sliceAlongFirstAxis(_this.bias.read(), _this.units, _this.units);
                    var biasH = K.sliceAlongFirstAxis(_this.bias.read(), _this.units * 2, _this.units);
                    xZ = K.biasAdd(xZ, biasZ);
                    xR = K.biasAdd(xR, biasR);
                    xH = K.biasAdd(xH, biasH);
                }
                var hTMinus1Z = void 0;
                var hTMinus1R = void 0;
                var hTMinus1H = void 0;
                if (0 < _this.recurrentDropout && _this.recurrentDropout < 1) {
                    hTMinus1Z = tfc.mul(hTMinus1, recDpMask[0]);
                    hTMinus1R = tfc.mul(hTMinus1, recDpMask[1]);
                    hTMinus1H = tfc.mul(hTMinus1, recDpMask[2]);
                }
                else {
                    hTMinus1Z = hTMinus1;
                    hTMinus1R = hTMinus1;
                    hTMinus1H = hTMinus1;
                }
                z = _this.recurrentActivation.apply(tfc.add(xZ, K.dot(hTMinus1Z, recurrentKernelZ)));
                r = _this.recurrentActivation.apply(tfc.add(xR, K.dot(hTMinus1R, recurrentKernelR)));
                hh = _this.activation.apply(tfc.add(xH, K.dot(tfc.mul(r, hTMinus1H), recurrentKernelH)));
            }
            else {
                if (0 < _this.dropout && _this.dropout < 1) {
                    inputs = tfc.mul(inputs, dpMask[0]);
                }
                var matrixX = K.dot(inputs, _this.kernel.read());
                if (_this.useBias) {
                    matrixX = K.biasAdd(matrixX, _this.bias.read());
                }
                if (0 < _this.dropout && _this.dropout < 1) {
                    hTMinus1 = tfc.mul(hTMinus1, recDpMask[0]);
                }
                var matrixInner = K.dot(hTMinus1, K.sliceAlongLastAxis(_this.recurrentKernel.read(), 0, 2 * _this.units));
                var xZ = K.sliceAlongLastAxis(matrixX, 0, _this.units);
                var xR = K.sliceAlongLastAxis(matrixX, _this.units, _this.units);
                var recurrentZ = K.sliceAlongLastAxis(matrixInner, 0, _this.units);
                var recurrentR = K.sliceAlongLastAxis(matrixInner, _this.units, _this.units);
                z = _this.recurrentActivation.apply(tfc.add(xZ, recurrentZ));
                r = _this.recurrentActivation.apply(tfc.add(xR, recurrentR));
                var xH = K.sliceAlongLastAxis(matrixX, 2 * _this.units, _this.units);
                var recurrentH = K.dot(tfc.mul(r, hTMinus1), K.sliceAlongLastAxis(_this.recurrentKernel.read(), 2 * _this.units, _this.units));
                hh = _this.activation.apply(tfc.add(xH, recurrentH));
            }
            var h = tfc.add(tfc.mul(z, hTMinus1), tfc.mul(tfc.add(state_1.getScalar(1), tfc.neg(z)), hh));
            return [h, h];
        });
    };
    GRUCell.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            recurrentActivation: activations_1.serializeActivation(this.recurrentActivation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    GRUCell.className = 'GRUCell';
    return GRUCell;
}(RNNCell));
exports.GRUCell = GRUCell;
tfjs_core_1.serialization.registerClass(GRUCell);
var GRU = (function (_super) {
    __extends(GRU, _super);
    function GRU(config) {
        var _this = this;
        if (config.implementation === 0) {
            console.warn('`implementation=0` has been deprecated, and now defaults to ' +
                '`implementation=1`. Please update your layer call.');
        }
        config.cell = new GRUCell(config);
        _this = _super.call(this, config) || this;
        return _this;
    }
    GRU.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (_this.cell.dropoutMask != null) {
                tfc.dispose(_this.cell.dropoutMask);
                _this.cell.dropoutMask = null;
            }
            if (_this.cell.recurrentDropoutMask != null) {
                tfc.dispose(_this.cell.recurrentDropoutMask);
                _this.cell.recurrentDropoutMask = null;
            }
            var mask = kwargs == null ? null : kwargs['mask'];
            var training = kwargs == null ? null : kwargs['training'];
            var initialState = kwargs == null ? null : kwargs['initialState'];
            return _super.prototype.call.call(_this, inputs, { mask: mask, training: training, initialState: initialState });
        });
    };
    Object.defineProperty(GRU.prototype, "units", {
        get: function () {
            return this.cell.units;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "activation", {
        get: function () {
            return this.cell.activation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "recurrentActivation", {
        get: function () {
            return this.cell.recurrentActivation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "useBias", {
        get: function () {
            return this.cell.useBias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "kernelInitializer", {
        get: function () {
            return this.cell.kernelInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "recurrentInitializer", {
        get: function () {
            return this.cell.recurrentInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "biasInitializer", {
        get: function () {
            return this.cell.biasInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "kernelRegularizer", {
        get: function () {
            return this.cell.kernelRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "recurrentRegularizer", {
        get: function () {
            return this.cell.recurrentRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "biasRegularizer", {
        get: function () {
            return this.cell.biasRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "kernelConstraint", {
        get: function () {
            return this.cell.kernelConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "recurrentConstraint", {
        get: function () {
            return this.cell.recurrentConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "biasConstraint", {
        get: function () {
            return this.cell.biasConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "dropout", {
        get: function () {
            return this.cell.dropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "recurrentDropout", {
        get: function () {
            return this.cell.recurrentDropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "implementation", {
        get: function () {
            return this.cell.implementation;
        },
        enumerable: true,
        configurable: true
    });
    GRU.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            recurrentActivation: activations_1.serializeActivation(this.recurrentActivation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        delete baseConfig['cell'];
        Object.assign(config, baseConfig);
        return config;
    };
    GRU.fromConfig = function (cls, config) {
        if (config['implmentation'] === 0) {
            config['implementation'] = 1;
        }
        return new cls(config);
    };
    GRU.className = 'GRU';
    return GRU;
}(RNN));
exports.GRU = GRU;
tfjs_core_1.serialization.registerClass(GRU);
var LSTMCell = (function (_super) {
    __extends(LSTMCell, _super);
    function LSTMCell(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_ACTIVATION = 'tanh';
        _this.DEFAULT_RECURRENT_ACTIVATION = 'hardSigmoid';
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        _this.units = config.units;
        _this.activation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_ACTIVATION :
            config.activation);
        _this.recurrentActivation = activations_1.getActivation(config.recurrentActivation === undefined ?
            _this.DEFAULT_RECURRENT_ACTIVATION :
            config.recurrentActivation);
        _this.useBias = config.useBias == null ? true : config.useBias;
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.recurrentInitializer = initializers_1.getInitializer(config.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.unitForgetBias = config.unitForgetBias;
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.recurrentRegularizer = regularizers_1.getRegularizer(config.recurrentRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.recurrentConstraint = constraints_1.getConstraint(config.recurrentConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.dropout = math_utils.min([1, math_utils.max([0, config.dropout == null ? 0 : config.dropout])]);
        _this.recurrentDropout = math_utils.min([
            1,
            math_utils.max([0, config.recurrentDropout == null ? 0 : config.recurrentDropout])
        ]);
        _this.implementation = config.implementation;
        _this.stateSize = [_this.units, _this.units];
        _this.dropoutMask = null;
        _this.recurrentDropoutMask = null;
        return _this;
    }
    LSTMCell.prototype.build = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var inputDim = inputShape[inputShape.length - 1];
        this.kernel = this.addWeight('kernel', [inputDim, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        var biasInitializer;
        if (this.useBias) {
            if (this.unitForgetBias) {
                var capturedBiasInit_1 = this.biasInitializer;
                var capturedUnits_1 = this.units;
                biasInitializer = new (_a = (function (_super) {
                        __extends(CustomInit, _super);
                        function CustomInit() {
                            return _super !== null && _super.apply(this, arguments) || this;
                        }
                        CustomInit.prototype.apply = function (shape, dtype) {
                            var bI = capturedBiasInit_1.apply([capturedUnits_1]);
                            var bF = (new initializers_1.Ones()).apply([capturedUnits_1]);
                            var bCAndH = capturedBiasInit_1.apply([capturedUnits_1 * 2]);
                            return K.concatAlongFirstAxis(K.concatAlongFirstAxis(bI, bF), bCAndH);
                        };
                        return CustomInit;
                    }(initializers_1.Initializer)),
                    _a.className = 'CustomInit',
                    _a)();
            }
            else {
                biasInitializer = this.biasInitializer;
            }
            this.bias = this.addWeight('bias', [this.units * 4], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.built = true;
        var _a;
    };
    LSTMCell.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var training = kwargs['training'] == null ? false : kwargs['training'];
            inputs = inputs;
            if (inputs.length !== 3) {
                throw new errors_1.ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got " +
                    (inputs.length + "."));
            }
            var hTMinus1 = inputs[1];
            var cTMinus1 = inputs[2];
            inputs = inputs[0];
            if (0 < _this.dropout && _this.dropout < 1 && _this.dropoutMask == null) {
                _this.dropoutMask = generateDropoutMask(function () { return tfc.onesLike(inputs); }, _this.dropout, training, 4);
            }
            if (0 < _this.recurrentDropout && _this.recurrentDropout < 1 &&
                _this.recurrentDropoutMask == null) {
                _this.recurrentDropoutMask =
                    generateDropoutMask(function () { return tfc.onesLike(hTMinus1); }, _this.recurrentDropout, training, 4);
            }
            var dpMask = _this.dropoutMask;
            var recDpMask = _this.recurrentDropoutMask;
            var i;
            var f;
            var c;
            var o;
            if (_this.implementation === 1) {
                var kernelI = K.sliceAlongLastAxis(_this.kernel.read(), 0, _this.units);
                var kernelF = K.sliceAlongLastAxis(_this.kernel.read(), _this.units, _this.units);
                var kernelC = K.sliceAlongLastAxis(_this.kernel.read(), _this.units * 2, _this.units);
                var kernelO = K.sliceAlongLastAxis(_this.kernel.read(), _this.units * 3, _this.units);
                var recurrentKernelI = K.sliceAlongLastAxis(_this.recurrentKernel.read(), 0, _this.units);
                var recurrentKernelF = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units, _this.units);
                var recurrentKernelC = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units * 2, _this.units);
                var recurrentKernelO = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units * 3, _this.units);
                var inputsI = void 0, inputsF = void 0, inputsC = void 0, inputsO = void 0;
                if (0 < _this.dropout && _this.dropout < 1) {
                    inputsI = tfc.mul(inputs, dpMask[0]);
                    inputsF = tfc.mul(inputs, dpMask[1]);
                    inputsC = tfc.mul(inputs, dpMask[2]);
                    inputsO = tfc.mul(inputs, dpMask[3]);
                }
                else {
                    inputsI = inputs;
                    inputsF = inputs;
                    inputsC = inputs;
                    inputsO = inputs;
                }
                var xI = K.dot(inputsI, kernelI);
                var xF = K.dot(inputsF, kernelF);
                var xC = K.dot(inputsC, kernelC);
                var xO = K.dot(inputsO, kernelO);
                if (_this.useBias) {
                    var biasI = K.sliceAlongFirstAxis(_this.bias.read(), 0, _this.units);
                    var biasF = K.sliceAlongFirstAxis(_this.bias.read(), _this.units, _this.units);
                    var biasC = K.sliceAlongFirstAxis(_this.bias.read(), _this.units * 2, _this.units);
                    var biasO = K.sliceAlongFirstAxis(_this.bias.read(), _this.units * 3, _this.units);
                    xI = K.biasAdd(xI, biasI);
                    xF = K.biasAdd(xF, biasF);
                    xC = K.biasAdd(xC, biasC);
                    xO = K.biasAdd(xO, biasO);
                }
                var hTMinus1I = void 0, hTMinus1F = void 0, hTMinus1C = void 0, hTMinus1O = void 0;
                if (0 < _this.recurrentDropout && _this.recurrentDropout < 1) {
                    hTMinus1I = tfc.mul(hTMinus1, recDpMask[0]);
                    hTMinus1F = tfc.mul(hTMinus1, recDpMask[1]);
                    hTMinus1C = tfc.mul(hTMinus1, recDpMask[2]);
                    hTMinus1O = tfc.mul(hTMinus1, recDpMask[3]);
                }
                else {
                    hTMinus1I = hTMinus1;
                    hTMinus1F = hTMinus1;
                    hTMinus1C = hTMinus1;
                    hTMinus1O = hTMinus1;
                }
                i = _this.recurrentActivation.apply(tfc.add(xI, K.dot(hTMinus1I, recurrentKernelI)));
                f = _this.recurrentActivation.apply(tfc.add(xF, K.dot(hTMinus1F, recurrentKernelF)));
                c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, _this.activation.apply(tfc.add(xC, K.dot(hTMinus1C, recurrentKernelC)))));
                o = _this.recurrentActivation.apply(tfc.add(xO, K.dot(hTMinus1O, recurrentKernelO)));
            }
            else {
                if (0 < _this.dropout && _this.dropout < 1) {
                    inputs = tfc.mul(inputs, dpMask[0]);
                }
                var z = K.dot(inputs, _this.kernel.read());
                if (0 < _this.recurrentDropout && _this.recurrentDropout < 1) {
                    hTMinus1 = tfc.mul(hTMinus1, recDpMask[0]);
                }
                z = tfc.add(z, K.dot(hTMinus1, _this.recurrentKernel.read()));
                if (_this.useBias) {
                    z = K.biasAdd(z, _this.bias.read());
                }
                var z0 = K.sliceAlongLastAxis(z, 0, _this.units);
                var z1 = K.sliceAlongLastAxis(z, _this.units, _this.units);
                var z2 = K.sliceAlongLastAxis(z, _this.units * 2, _this.units);
                var z3 = K.sliceAlongLastAxis(z, _this.units * 3, _this.units);
                i = _this.recurrentActivation.apply(z0);
                f = _this.recurrentActivation.apply(z1);
                c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, _this.activation.apply(z2)));
                o = _this.recurrentActivation.apply(z3);
            }
            var h = tfc.mul(o, _this.activation.apply(c));
            return [h, h, c];
        });
    };
    LSTMCell.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            recurrentActivation: activations_1.serializeActivation(this.recurrentActivation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            unitForgetBias: this.unitForgetBias,
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    LSTMCell.className = 'LSTMCell';
    return LSTMCell;
}(RNNCell));
exports.LSTMCell = LSTMCell;
tfjs_core_1.serialization.registerClass(LSTMCell);
var LSTM = (function (_super) {
    __extends(LSTM, _super);
    function LSTM(config) {
        var _this = this;
        if (config.implementation === 0) {
            console.warn('`implementation=0` has been deprecated, and now defaults to ' +
                '`implementation=1`. Please update your layer call.');
        }
        config.cell = new LSTMCell(config);
        _this = _super.call(this, config) || this;
        return _this;
    }
    LSTM.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (_this.cell.dropoutMask != null) {
                tfc.dispose(_this.cell.dropoutMask);
                _this.cell.dropoutMask = null;
            }
            if (_this.cell.recurrentDropoutMask != null) {
                tfc.dispose(_this.cell.recurrentDropoutMask);
                _this.cell.recurrentDropoutMask = null;
            }
            var mask = kwargs == null ? null : kwargs['mask'];
            var training = kwargs == null ? null : kwargs['training'];
            var initialState = kwargs == null ? null : kwargs['initialState'];
            return _super.prototype.call.call(_this, inputs, { mask: mask, training: training, initialState: initialState });
        });
    };
    Object.defineProperty(LSTM.prototype, "units", {
        get: function () {
            return this.cell.units;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "activation", {
        get: function () {
            return this.cell.activation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "recurrentActivation", {
        get: function () {
            return this.cell.recurrentActivation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "useBias", {
        get: function () {
            return this.cell.useBias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "kernelInitializer", {
        get: function () {
            return this.cell.kernelInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "recurrentInitializer", {
        get: function () {
            return this.cell.recurrentInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "biasInitializer", {
        get: function () {
            return this.cell.biasInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "unitForgetBias", {
        get: function () {
            return this.cell.unitForgetBias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "kernelRegularizer", {
        get: function () {
            return this.cell.kernelRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "recurrentRegularizer", {
        get: function () {
            return this.cell.recurrentRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "biasRegularizer", {
        get: function () {
            return this.cell.biasRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "kernelConstraint", {
        get: function () {
            return this.cell.kernelConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "recurrentConstraint", {
        get: function () {
            return this.cell.recurrentConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "biasConstraint", {
        get: function () {
            return this.cell.biasConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "dropout", {
        get: function () {
            return this.cell.dropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "recurrentDropout", {
        get: function () {
            return this.cell.recurrentDropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "implementation", {
        get: function () {
            return this.cell.implementation;
        },
        enumerable: true,
        configurable: true
    });
    LSTM.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            recurrentActivation: activations_1.serializeActivation(this.recurrentActivation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            unitForgetBias: this.unitForgetBias,
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        delete baseConfig['cell'];
        Object.assign(config, baseConfig);
        return config;
    };
    LSTM.fromConfig = function (cls, config) {
        if (config['implmentation'] === 0) {
            config['implementation'] = 1;
        }
        return new cls(config);
    };
    LSTM.className = 'LSTM';
    return LSTM;
}(RNN));
exports.LSTM = LSTM;
tfjs_core_1.serialization.registerClass(LSTM);
var StackedRNNCells = (function (_super) {
    __extends(StackedRNNCells, _super);
    function StackedRNNCells(config) {
        var _this = _super.call(this, config) || this;
        _this.cells = config.cells;
        return _this;
    }
    Object.defineProperty(StackedRNNCells.prototype, "stateSize", {
        get: function () {
            var stateSize = [];
            for (var _i = 0, _a = this.cells.slice().reverse(); _i < _a.length; _i++) {
                var cell = _a[_i];
                if (Array.isArray(cell.stateSize)) {
                    stateSize.push.apply(stateSize, cell.stateSize);
                }
                else {
                    stateSize.push(cell.stateSize);
                }
            }
            return stateSize;
        },
        enumerable: true,
        configurable: true
    });
    StackedRNNCells.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = inputs;
            var states = inputs.slice(1);
            var nestedStates = [];
            for (var _i = 0, _a = _this.cells.slice().reverse(); _i < _a.length; _i++) {
                var cell = _a[_i];
                if (Array.isArray(cell.stateSize)) {
                    nestedStates.push(states.splice(0, cell.stateSize.length));
                }
                else {
                    nestedStates.push(states.splice(0, 1));
                }
            }
            nestedStates.reverse();
            var newNestedStates = [];
            var callInputs;
            for (var i = 0; i < _this.cells.length; ++i) {
                var cell = _this.cells[i];
                states = nestedStates[i];
                if (i === 0) {
                    callInputs = [inputs[0]].concat(states);
                }
                else {
                    callInputs = [callInputs[0]].concat(states);
                }
                callInputs = cell.call(callInputs, kwargs);
                newNestedStates.push(callInputs.slice(1));
            }
            states = [];
            for (var _b = 0, _c = newNestedStates.slice().reverse(); _b < _c.length; _b++) {
                var cellStates = _c[_b];
                states.push.apply(states, cellStates);
            }
            return [callInputs[0]].concat(states);
        });
    };
    StackedRNNCells.prototype.build = function (inputShape) {
        if (types_utils_1.isArrayOfShapes(inputShape)) {
            inputShape = inputShape[0];
        }
        inputShape = inputShape;
        var outputDim;
        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
            var cell = _a[_i];
            cell.build(inputShape);
            if (Array.isArray(cell.stateSize)) {
                outputDim = cell.stateSize[0];
            }
            else {
                outputDim = cell.stateSize;
            }
            inputShape = [inputShape[0], outputDim];
        }
        this.built = true;
    };
    StackedRNNCells.prototype.getConfig = function () {
        var cellConfigs = [];
        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
            var cell = _a[_i];
            cellConfigs.push({
                'className': this.getClassName(),
                'config': cell.getConfig(),
            });
        }
        var config = { 'cells': cellConfigs };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    StackedRNNCells.fromConfig = function (cls, config, customObjects) {
        if (customObjects === void 0) { customObjects = {}; }
        var cells = [];
        for (var _i = 0, _a = config['cells']; _i < _a.length; _i++) {
            var cellConfig = _a[_i];
            cells.push(serialization_1.deserialize(cellConfig, customObjects));
        }
        return new cls({ cells: cells });
    };
    Object.defineProperty(StackedRNNCells.prototype, "trainableWeights", {
        get: function () {
            if (!this.trainable) {
                return [];
            }
            var weights = [];
            for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
                var cell = _a[_i];
                weights.push.apply(weights, cell.trainableWeights);
            }
            return weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StackedRNNCells.prototype, "nonTrainableWeights", {
        get: function () {
            var weights = [];
            for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
                var cell = _a[_i];
                weights.push.apply(weights, cell.nonTrainableWeights);
            }
            if (!this.trainable) {
                var trainableWeights = [];
                for (var _b = 0, _c = this.cells; _b < _c.length; _b++) {
                    var cell = _c[_b];
                    trainableWeights.push.apply(trainableWeights, cell.trainableWeights);
                }
                return trainableWeights.concat(weights);
            }
            return weights;
        },
        enumerable: true,
        configurable: true
    });
    StackedRNNCells.prototype.getWeights = function () {
        var weights = [];
        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
            var cell = _a[_i];
            weights.push.apply(weights, cell.weights);
        }
        return variables_1.batchGetValue(weights);
    };
    StackedRNNCells.prototype.setWeights = function (weights) {
        var tuples = [];
        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
            var cell = _a[_i];
            var numParams = cell.weights.length;
            var inputWeights = weights.splice(numParams);
            for (var i = 0; i < cell.weights.length; ++i) {
                tuples.push([cell.weights[i], inputWeights[i]]);
            }
        }
        variables_1.batchSetValue(tuples);
    };
    StackedRNNCells.className = 'StackedRNNCells';
    return StackedRNNCells;
}(RNNCell));
exports.StackedRNNCells = StackedRNNCells;
tfjs_core_1.serialization.registerClass(StackedRNNCells);
function generateDropoutMask(ones, rate, training, count) {
    if (training === void 0) { training = null; }
    if (count === void 0) { count = 1; }
    function droppedInputs() {
        return K.dropout(ones(), state_1.getScalar(rate));
    }
    if (count > 1) {
        var mask = [];
        for (var i = 0; i < count; i++) {
            mask.push(K.inTrainPhase(droppedInputs, ones, training));
        }
        mask.forEach(function (m) { return tfc.keep(m); });
        return mask;
    }
    else {
        return tfc.keep(K.inTrainPhase(droppedInputs, ones, training));
    }
}

},{"../activations":206,"../backend/state":208,"../backend/tfjs_backend":209,"../constraints":213,"../engine/topology":218,"../errors":222,"../initializers":230,"../regularizers":248,"../utils/math_utils":252,"../utils/types_utils":254,"../variables":256,"./serialization":241,"@tensorflow/tfjs-core":64}],241:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var generic_utils_1 = require("../utils/generic_utils");
function deserialize(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'layer');
}
exports.deserialize = deserialize;

},{"../utils/generic_utils":250,"@tensorflow/tfjs-core":64}],242:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var state_1 = require("../backend/state");
var K = require("../backend/tfjs_backend");
var common_1 = require("../common");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var generic_utils = require("../utils/generic_utils");
var types_utils_1 = require("../utils/types_utils");
var recurrent_1 = require("./recurrent");
var serialization_1 = require("./serialization");
var Wrapper = (function (_super) {
    __extends(Wrapper, _super);
    function Wrapper(config) {
        var _this = _super.call(this, config) || this;
        _this.layer = config.layer;
        return _this;
    }
    Wrapper.prototype.build = function (inputShape) {
        this.built = true;
    };
    Object.defineProperty(Wrapper.prototype, "trainable", {
        get: function () {
            if (this.layer != null) {
                return this.layer.trainable;
            }
            else {
                return false;
            }
        },
        set: function (value) {
            if (this.layer != null) {
                this.layer.trainable = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wrapper.prototype, "trainableWeights", {
        get: function () {
            return this.layer.trainableWeights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wrapper.prototype, "nonTrainableWeights", {
        get: function () {
            return this.layer.nonTrainableWeights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wrapper.prototype, "updates", {
        get: function () {
            return this.layer._updates;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wrapper.prototype, "losses", {
        get: function () {
            return this.layer.losses;
        },
        enumerable: true,
        configurable: true
    });
    Wrapper.prototype.getWeights = function () {
        return this.layer.getWeights();
    };
    Wrapper.prototype.setWeights = function (weights) {
        this.layer.setWeights(weights);
    };
    Wrapper.prototype.getConfig = function () {
        var config = {
            'layer': {
                'className': this.layer.getClassName(),
                'config': this.layer.getConfig(),
            }
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Wrapper.fromConfig = function (cls, config, customObjects) {
        if (customObjects === void 0) { customObjects = {}; }
        var layerConfig = config['layer'];
        var layer = serialization_1.deserialize(layerConfig, customObjects);
        delete config['layer'];
        var newConfig = { layer: layer };
        Object.assign(newConfig, config);
        return new cls(newConfig);
    };
    return Wrapper;
}(topology_1.Layer));
exports.Wrapper = Wrapper;
var TimeDistributed = (function (_super) {
    __extends(TimeDistributed, _super);
    function TimeDistributed(config) {
        var _this = _super.call(this, config) || this;
        _this.supportsMasking = true;
        return _this;
    }
    TimeDistributed.prototype.build = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        if (inputShape.length < 3) {
            throw new errors_1.ValueError("TimeDistributed layer expects an input shape >= 3D, but received " +
                ("input shape " + JSON.stringify(inputShape)));
        }
        this.inputSpec = [{ shape: inputShape }];
        var childInputShape = [inputShape[0]].concat(inputShape.slice(2));
        if (!this.layer.built) {
            this.layer.build(childInputShape);
            this.layer.built = true;
        }
        _super.prototype.build.call(this, inputShape);
    };
    TimeDistributed.prototype.computeOutputShape = function (inputShape) {
        inputShape = types_utils_1.getExactlyOneShape(inputShape);
        var childInputShape = [inputShape[0]].concat(inputShape.slice(2));
        var childOutputShape = this.layer.computeOutputShape(childInputShape);
        var timesteps = inputShape[1];
        return [childOutputShape[0], timesteps].concat(childOutputShape.slice(1));
    };
    TimeDistributed.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = types_utils_1.getExactlyOneTensor(inputs);
            var step = function (inputs, states) {
                var output = types_utils_1.getExactlyOneTensor(_this.layer.call(inputs, kwargs));
                return [output, []];
            };
            var rnnOutputs = recurrent_1.rnn(step, inputs, [], false, null, null, false, true);
            var y = rnnOutputs[1];
            return y;
        });
    };
    TimeDistributed.className = 'TimeDistributed';
    return TimeDistributed;
}(Wrapper));
exports.TimeDistributed = TimeDistributed;
tfjs_core_1.serialization.registerClass(TimeDistributed);
exports.VALID_BIDIRECTIONAL_MERGE_MODES = ['sum', 'mul', 'concat', 'ave'];
function checkBidirectionalMergeMode(value) {
    generic_utils.checkStringTypeUnionValue(exports.VALID_BIDIRECTIONAL_MERGE_MODES, 'BidirectionalMergeMode', value);
}
exports.checkBidirectionalMergeMode = checkBidirectionalMergeMode;
var Bidirectional = (function (_super) {
    __extends(Bidirectional, _super);
    function Bidirectional(config) {
        var _this = _super.call(this, config) || this;
        var layerConfig = config.layer.getConfig();
        _this.forwardLayer =
            serialization_1.deserialize({ className: config.layer.getClassName(), config: layerConfig });
        layerConfig['goBackwards'] =
            layerConfig['goBackwards'] === true ? false : true;
        _this.backwardLayer =
            serialization_1.deserialize({ className: config.layer.getClassName(), config: layerConfig });
        _this.forwardLayer.name = 'forward_' + _this.forwardLayer.name;
        _this.backwardLayer.name = 'backward_' + _this.backwardLayer.name;
        checkBidirectionalMergeMode(config.mergeMode);
        _this.mergeMode = config.mergeMode;
        if (config.weights) {
            throw new errors_1.NotImplementedError('weights support is not implemented for Bidirectional layer yet.');
        }
        _this._stateful = config.layer.stateful;
        _this.returnSequences = config.layer.returnSequences;
        _this.returnState = config.layer.returnState;
        _this.supportsMasking = true;
        _this._trainable = true;
        _this.inputSpec = config.layer.inputSpec;
        _this.numConstants = null;
        return _this;
    }
    Object.defineProperty(Bidirectional.prototype, "trainable", {
        get: function () {
            return this._trainable;
        },
        set: function (value) {
            this._trainable = value;
            if (this.forwardLayer != null) {
                this.forwardLayer.trainable = value;
            }
            if (this.backwardLayer != null) {
                this.backwardLayer.trainable = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Bidirectional.prototype.getWeights = function () {
        return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
    };
    Bidirectional.prototype.setWeights = function (weights) {
        var numWeights = weights.length;
        var numeightsOver2 = Math.floor(numWeights / 2);
        this.forwardLayer.setWeights(weights.slice(0, numeightsOver2));
        this.backwardLayer.setWeights(weights.slice(numeightsOver2));
    };
    Bidirectional.prototype.computeOutputShape = function (inputShape) {
        var layerShapes = this.forwardLayer.computeOutputShape(inputShape);
        if (!(Array.isArray(layerShapes) && Array.isArray(layerShapes[0]))) {
            layerShapes = [layerShapes];
        }
        layerShapes = layerShapes;
        var outputShape;
        var outputShapes;
        var stateShape;
        if (this.returnState) {
            stateShape = layerShapes.slice(1);
            outputShape = layerShapes[0];
        }
        else {
            outputShape = layerShapes[0];
        }
        outputShape = outputShape;
        if (this.mergeMode === 'concat') {
            outputShape[outputShape.length - 1] *= 2;
            outputShapes = [outputShape];
        }
        else if (this.mergeMode == null) {
            outputShapes = [outputShape, outputShape.slice()];
        }
        else {
            outputShapes = [outputShape];
        }
        if (this.returnState) {
            if (this.mergeMode == null) {
                return outputShapes.concat(stateShape).concat(stateShape.slice());
            }
            return [outputShape].concat(stateShape).concat(stateShape.slice());
        }
        return generic_utils.singletonOrArray(outputShapes);
    };
    Bidirectional.prototype.apply = function (inputs, kwargs) {
        var initialState = kwargs == null ? null : kwargs['initialState'];
        var constants = kwargs == null ? null : kwargs['constants'];
        if (kwargs == null) {
            kwargs = {};
        }
        var standardized = recurrent_1.standardizeArgs(inputs, initialState, constants, this.numConstants);
        inputs = standardized.inputs;
        initialState = standardized.initialState;
        constants = standardized.constants;
        if (Array.isArray(inputs)) {
            initialState = inputs.slice(1);
            inputs = inputs[0];
        }
        if ((initialState == null || initialState.length === 0) &&
            constants == null) {
            return _super.prototype.apply.call(this, inputs, kwargs);
        }
        var additionalInputs = [];
        var additionalSpecs = [];
        if (initialState != null) {
            var numStates = initialState.length;
            if (numStates % 2 > 0) {
                throw new errors_1.ValueError('When passing `initialState` to a Bidrectional RNN, ' +
                    'the state should be an Array containing the states of ' +
                    'the underlying RNNs.');
            }
            kwargs['initialState'] = initialState;
            additionalInputs.push.apply(additionalInputs, initialState);
            var stateSpecs = initialState
                .map(function (state) { return new topology_1.InputSpec({ shape: state.shape }); });
            this.forwardLayer.stateSpec = stateSpecs.slice(0, numStates / 2);
            this.backwardLayer.stateSpec = stateSpecs.slice(numStates / 2);
            additionalSpecs.push.apply(additionalSpecs, stateSpecs);
        }
        if (constants != null) {
            throw new errors_1.NotImplementedError('Support for constants in Bidirectional layers is not ' +
                'implemented yet.');
        }
        var isSymbolicTensor = additionalInputs[0] instanceof topology_1.SymbolicTensor;
        for (var _i = 0, additionalInputs_1 = additionalInputs; _i < additionalInputs_1.length; _i++) {
            var tensor = additionalInputs_1[_i];
            if (tensor instanceof topology_1.SymbolicTensor !== isSymbolicTensor) {
                throw new errors_1.ValueError('The initial state of a Bidirectional layer cannot be ' +
                    'specified as a mix of symbolic and non-symbolic tensors');
            }
        }
        if (isSymbolicTensor) {
            var fullInput = [inputs].concat(additionalInputs);
            var fullInputSpec = this.inputSpec.concat(additionalSpecs);
            var originalInputSpec = this.inputSpec;
            this.inputSpec = fullInputSpec;
            var output = _super.prototype.apply.call(this, fullInput, kwargs);
            this.inputSpec = originalInputSpec;
            return output;
        }
        else {
            return _super.prototype.apply.call(this, inputs, kwargs);
        }
    };
    Bidirectional.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (kwargs['mask'] != null) {
                throw new errors_1.NotImplementedError('The support for masking is not implemented for ' +
                    'Bidirectional layers yet.');
            }
            var initialState = kwargs['initialState'];
            var y;
            var yRev;
            if (initialState == null) {
                y = _this.forwardLayer.call(inputs, kwargs);
                yRev = _this.backwardLayer.call(inputs, kwargs);
            }
            else {
                var forwardState = initialState.slice(0, initialState.length / 2);
                var backwardState = initialState.slice(initialState.length / 2);
                y = _this.forwardLayer.call(inputs, Object.assign(kwargs, { initialState: forwardState }));
                yRev = _this.backwardLayer.call(inputs, Object.assign(kwargs, { initialState: backwardState }));
            }
            var states;
            if (_this.returnState) {
                if (Array.isArray(y)) {
                    states = y.slice(1).concat(yRev.slice(1));
                }
                else {
                }
                y = y[0];
                yRev = yRev[0];
            }
            if (_this.returnSequences) {
                yRev = tfc.reverse(yRev, 1);
            }
            var output;
            if (_this.mergeMode === 'concat') {
                output = K.concatenate([y, yRev]);
            }
            else if (_this.mergeMode === 'sum') {
                output = tfc.add(y, yRev);
            }
            else if (_this.mergeMode === 'ave') {
                output = tfc.mul(state_1.getScalar(0.5), tfc.add(y, yRev));
            }
            else if (_this.mergeMode === 'mul') {
                output = tfc.mul(y, yRev);
            }
            else if (_this.mergeMode == null) {
                output = [y, yRev];
            }
            if (_this.returnState) {
                if (_this.mergeMode == null) {
                    return output.concat(states);
                }
                return [output].concat(states);
            }
            return output;
        });
    };
    Bidirectional.prototype.resetStates = function (states) {
        this.forwardLayer.resetStates();
        this.backwardLayer.resetStates();
    };
    Bidirectional.prototype.build = function (inputShape) {
        var _this = this;
        common_1.nameScope(this.forwardLayer.name, function () {
            _this.forwardLayer.build(inputShape);
        });
        common_1.nameScope(this.backwardLayer.name, function () {
            _this.backwardLayer.build(inputShape);
        });
        this.built = true;
    };
    Object.defineProperty(Bidirectional.prototype, "trainableWeights", {
        get: function () {
            return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Bidirectional.prototype, "nonTrainableWeights", {
        get: function () {
            return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
        },
        enumerable: true,
        configurable: true
    });
    Bidirectional.prototype.getConfig = function () {
        var config = {
            'mergeMode': this.mergeMode,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Bidirectional.fromConfig = function (cls, config) {
        var rnnLayer = serialization_1.deserialize(config['layer']);
        delete config['layer'];
        if (config['numConstants'] != null) {
            throw new errors_1.NotImplementedError("Deserialization of a Bidirectional layer with numConstants " +
                "present is not supported yet.");
        }
        var newConfig = config;
        newConfig['layer'] = rnnLayer;
        return new cls(newConfig);
    };
    Bidirectional.className = 'Bidirectional';
    return Bidirectional;
}(Wrapper));
exports.Bidirectional = Bidirectional;
tfjs_core_1.serialization.registerClass(Bidirectional);

},{"../backend/state":208,"../backend/tfjs_backend":209,"../common":212,"../engine/topology":218,"../errors":222,"../utils/generic_utils":250,"../utils/types_utils":254,"./recurrent":240,"./serialization":241,"@tensorflow/tfjs-core":64}],243:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
function resolveScalarsInLogs(logs) {
    return __awaiter(this, void 0, void 0, function () {
        var promises, keys, scalarsToDispose, key, value, valueScalar, values, i;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (logs == null) {
                        return [2];
                    }
                    promises = [];
                    keys = [];
                    scalarsToDispose = [];
                    for (key in logs) {
                        value = logs[key];
                        if (typeof value !== 'number') {
                            valueScalar = value;
                            promises.push(valueScalar.data());
                            keys.push(key);
                            scalarsToDispose.push(valueScalar);
                        }
                    }
                    return [4, Promise.all(promises)];
                case 1:
                    values = _a.sent();
                    for (i = 0; i < values.length; ++i) {
                        logs[keys[i]] = values[i][0];
                    }
                    tfjs_core_1.dispose(scalarsToDispose);
                    return [2];
            }
        });
    });
}
exports.resolveScalarsInLogs = resolveScalarsInLogs;
function disposeTensorsInLogs(logs) {
    if (logs == null) {
        return;
    }
    for (var key in logs) {
        var value = logs[key];
        if (typeof value !== 'number') {
            value.dispose();
        }
    }
}
exports.disposeTensorsInLogs = disposeTensorsInLogs;

},{"@tensorflow/tfjs-core":64}],244:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("./backend/common");
var state_1 = require("./backend/state");
var K = require("./backend/tfjs_backend");
var errors_1 = require("./errors");
function l2Normalize(x, axis) {
    return tfjs_core_1.tidy(function () {
        var squareSum = tfc.sum(K.square(x), axis, true);
        var epsilonTensor = tfc.mul(tfjs_core_1.scalar(common_1.epsilon()), tfc.onesLike(x));
        var norm = tfc.sqrt(tfc.maximum(squareSum, epsilonTensor));
        return tfc.div(x, norm);
    });
}
exports.l2Normalize = l2Normalize;
function meanSquaredError(yTrue, yPred) {
    return tfjs_core_1.tidy(function () { return tfc.mean(K.square(tfc.sub(yPred, yTrue)), -1); });
}
exports.meanSquaredError = meanSquaredError;
function meanAbsoluteError(yTrue, yPred) {
    return tfjs_core_1.tidy(function () { return tfc.mean(tfc.abs(tfc.sub(yPred, yTrue)), -1); });
}
exports.meanAbsoluteError = meanAbsoluteError;
function meanAbsolutePercentageError(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var diff = tfc.sub(yTrue, yPred);
        var clippedTrue = tfc.clipByValue(tfc.abs(yTrue), common_1.epsilon(), Number.MAX_VALUE);
        var absResult = tfc.abs(tfc.div(diff, clippedTrue));
        return tfc.mul(state_1.getScalar(100.0), tfc.mean(absResult, -1));
    });
}
exports.meanAbsolutePercentageError = meanAbsolutePercentageError;
function meanSquaredLogarithmicError(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var one = state_1.getScalar(1.0);
        var clippedPred = tfc.clipByValue(yPred, common_1.epsilon(), Number.MAX_VALUE);
        var firstLog = tfc.log(tfc.add(one, clippedPred));
        var clippedTrue = tfc.clipByValue(yTrue, common_1.epsilon(), Number.MAX_VALUE);
        var secondLog = tfc.log(tfc.add(one, clippedTrue));
        return tfc.mean(K.square(tfc.sub(firstLog, secondLog)), -1);
    });
}
exports.meanSquaredLogarithmicError = meanSquaredLogarithmicError;
function squaredHinge(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var zeroTensor = state_1.getScalar(0.0);
        var one = state_1.getScalar(1.0);
        var maxResult = tfc.maximum(zeroTensor, tfc.sub(one, tfc.mul(yTrue, yPred)));
        return tfc.mean(K.square(maxResult), -1);
    });
}
exports.squaredHinge = squaredHinge;
function hinge(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var zeroTensor = state_1.getScalar(0.0);
        var one = state_1.getScalar(1.0);
        var maxResult = tfc.maximum(zeroTensor, tfc.sub(one, tfc.mul(yTrue, yPred)));
        return tfc.mean(maxResult, -1);
    });
}
exports.hinge = hinge;
function categoricalHinge(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var zeroTensor = state_1.getScalar(0.0);
        var one = state_1.getScalar(1.0);
        var pos = tfc.sum(tfc.mul(yTrue, yPred), -1);
        var neg = tfc.max(tfc.mul(tfc.sub(one, yTrue), yPred), -1);
        return tfc.maximum(zeroTensor, tfc.add(one, tfc.sub(neg, pos)));
    });
}
exports.categoricalHinge = categoricalHinge;
function logcosh(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var log2 = state_1.getScalar(Math.log(2.0));
        var predictionDiff = tfc.sub(yPred, yTrue);
        var logcoshResult = tfc.sub(tfc.add(predictionDiff, tfc.softplus(tfc.mul(state_1.getScalar(-2.0), predictionDiff))), log2);
        return tfc.mean(logcoshResult, -1);
    });
}
exports.logcosh = logcosh;
function categoricalCrossentropy(target, output, fromLogits) {
    if (fromLogits === void 0) { fromLogits = false; }
    return tfjs_core_1.tidy(function () {
        if (fromLogits) {
            output = tfc.softmax(output);
        }
        else {
            var outputSum = tfc.sum(output, output.shape.length - 1, true);
            output = tfc.div(output, outputSum);
        }
        output = tfc.clipByValue(output, common_1.epsilon(), 1 - common_1.epsilon());
        return tfc.neg(tfc.sum(tfc.mul(target.toFloat(), tfc.log(output)), output.shape.length - 1));
    });
}
exports.categoricalCrossentropy = categoricalCrossentropy;
function sparseCategoricalCrossentropy(target, output, fromLogits) {
    if (fromLogits === void 0) { fromLogits = false; }
    return tfjs_core_1.tidy(function () {
        var flatTarget = tfc.floor(K.flatten(target)).toInt();
        var outputShape = output.shape;
        var oneHotTarget = tfc.oneHot(flatTarget, outputShape[outputShape.length - 1])
            .reshape(outputShape);
        return categoricalCrossentropy(oneHotTarget, output, fromLogits);
    });
}
exports.sparseCategoricalCrossentropy = sparseCategoricalCrossentropy;
function sigmoidCrossEntropyWithLogits(target, output) {
    return tfjs_core_1.tidy(function () {
        var maxOutput = tfc.maximum(output, tfc.zerosLike(output));
        var outputXTarget = tfc.mul(output, target);
        var sigmoidOutput = tfc.log(tfc.add(state_1.getScalar(1), tfc.exp(tfc.neg(tfc.abs(output)))));
        var result = tfc.add(tfc.sub(maxOutput, outputXTarget), sigmoidOutput);
        return result;
    });
}
exports.sigmoidCrossEntropyWithLogits = sigmoidCrossEntropyWithLogits;
function binaryCrossentropy(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var y;
        y = tfc.clipByValue(yPred, common_1.epsilon(), 1 - common_1.epsilon());
        y = tfc.log(tfc.div(y, tfc.sub(tfc.onesLike(y), y)));
        return tfc.mean(sigmoidCrossEntropyWithLogits(yTrue, y), -1);
    });
}
exports.binaryCrossentropy = binaryCrossentropy;
function kullbackLeiblerDivergence(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var clippedTrue = tfc.clipByValue(yTrue, common_1.epsilon(), 1);
        var clippedPred = tfc.clipByValue(yPred, common_1.epsilon(), 1);
        return tfc.sum(tfc.mul(yTrue, tfc.log(tfc.div(clippedTrue, clippedPred))), -1);
    });
}
exports.kullbackLeiblerDivergence = kullbackLeiblerDivergence;
function poisson(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var logPred = tfc.log(tfc.add(state_1.getScalar(common_1.epsilon()), yPred));
        return tfc.mean(tfc.sub(yPred, tfc.mul(yTrue, logPred)), -1);
    });
}
exports.poisson = poisson;
function cosineProximity(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var trueNormalized = l2Normalize(yTrue, -1);
        var predNormalized = l2Normalize(yPred, -1);
        var trueXPred = tfc.mul(trueNormalized, predNormalized);
        return tfc.neg(tfc.sum(trueXPred, -1));
    });
}
exports.cosineProximity = cosineProximity;
exports.mse = meanSquaredError;
exports.MSE = meanSquaredError;
exports.mae = meanAbsoluteError;
exports.MAE = meanAbsoluteError;
exports.mape = meanAbsolutePercentageError;
exports.MAPE = meanAbsolutePercentageError;
exports.msle = meanSquaredLogarithmicError;
exports.MSLE = meanSquaredLogarithmicError;
exports.kld = kullbackLeiblerDivergence;
exports.KLD = kullbackLeiblerDivergence;
exports.cosine = cosineProximity;
function get(identifierOrFn) {
    var lossesMap = {
        meanSquaredError: meanSquaredError,
        meanAbsoluteError: meanAbsoluteError,
        meanAbsolutePercentageError: meanAbsolutePercentageError,
        meanSquaredLogarithmicError: meanSquaredLogarithmicError,
        squaredHinge: squaredHinge,
        hinge: hinge,
        categoricalHinge: categoricalHinge,
        logcosh: logcosh,
        categoricalCrossentropy: categoricalCrossentropy,
        sparseCategoricalCrossentropy: sparseCategoricalCrossentropy,
        binaryCrossentropy: binaryCrossentropy,
        kullbackLeiblerDivergence: kullbackLeiblerDivergence,
        poisson: poisson,
        cosineProximity: cosineProximity
    };
    if (typeof identifierOrFn === 'string') {
        if (identifierOrFn in lossesMap) {
            return lossesMap[identifierOrFn];
        }
        var errMsg = "Unknown loss " + identifierOrFn;
        if (identifierOrFn.toLowerCase().includes('softmaxcrossentropy')) {
            errMsg = "Unknown loss " + identifierOrFn + ". " +
                'Use "categoricalCrossentropy" as the string name for ' +
                'tf.losses.softmaxCrossEntropy';
        }
        throw new errors_1.ValueError(errMsg);
    }
    else {
        return identifierOrFn;
    }
}
exports.get = get;

},{"./backend/common":207,"./backend/state":208,"./backend/tfjs_backend":209,"./errors":222,"@tensorflow/tfjs-core":64}],245:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var state_1 = require("./backend/state");
var K = require("./backend/tfjs_backend");
var errors_1 = require("./errors");
var losses_1 = require("./losses");
var losses_2 = require("./losses");
function binaryAccuracy(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var threshold = tfc.mul(state_1.getScalar(0.5), tfc.onesLike(yPred));
        var yPredThresholded = K.cast(tfc.greater(yPred, threshold), yTrue.dtype);
        return tfc.mean(tfc.equal(yTrue, yPredThresholded), -1);
    });
}
exports.binaryAccuracy = binaryAccuracy;
function categoricalAccuracy(yTrue, yPred) {
    return tfjs_core_1.tidy(function () { return K.cast(tfc.equal(tfc.argMax(yTrue, -1), tfc.argMax(yPred, -1)), 'float32'); });
}
exports.categoricalAccuracy = categoricalAccuracy;
function truePositives(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var one = state_1.getScalar(1);
        return tfc.logicalAnd(yTrue.equal(one), yPred.equal(one))
            .sum()
            .cast('float32');
    });
}
function falseNegatives(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var one = state_1.getScalar(1);
        var zero = state_1.getScalar(0);
        return tfc.logicalAnd(yTrue.equal(one), yPred.equal(zero))
            .sum()
            .cast('float32');
    });
}
function falsePositives(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var one = state_1.getScalar(1);
        var zero = state_1.getScalar(0);
        return tfc.logicalAnd(yTrue.equal(zero), yPred.equal(one))
            .sum()
            .cast('float32');
    });
}
function precision(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var zero = state_1.getScalar(0);
        var tp = truePositives(yTrue, yPred);
        var fp = falsePositives(yTrue, yPred);
        var denominator = tp.add(fp);
        return tfc.where(tfc.greater(denominator, zero), tp.div(denominator), zero)
            .cast('float32');
    });
}
exports.precision = precision;
function recall(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var zero = state_1.getScalar(0);
        var tp = truePositives(yTrue, yPred);
        var fn = falseNegatives(yTrue, yPred);
        var denominator = tp.add(fn);
        return tfc.where(tfc.greater(denominator, zero), tp.div(denominator), zero)
            .cast('float32');
    });
}
exports.recall = recall;
function binaryCrossentropy(yTrue, yPred) {
    return losses_2.binaryCrossentropy(yTrue, yPred);
}
exports.binaryCrossentropy = binaryCrossentropy;
function sparseCategoricalAccuracy(yTrue, yPred) {
    throw new errors_1.NotImplementedError();
}
exports.sparseCategoricalAccuracy = sparseCategoricalAccuracy;
function topKCategoricalAccuracy(yTrue, yPred) {
    throw new errors_1.NotImplementedError();
}
exports.topKCategoricalAccuracy = topKCategoricalAccuracy;
function sparseTopKCategoricalAccuracy(yTrue, yPred) {
    throw new errors_1.NotImplementedError();
}
exports.sparseTopKCategoricalAccuracy = sparseTopKCategoricalAccuracy;
exports.mse = losses_1.meanSquaredError;
exports.MSE = losses_1.meanSquaredError;
exports.mae = losses_1.meanAbsoluteError;
exports.MAE = losses_1.meanAbsoluteError;
exports.mape = losses_1.meanAbsolutePercentageError;
exports.MAPE = losses_1.meanAbsolutePercentageError;
exports.categoricalCrossentropy = losses_1.categoricalCrossentropy;
exports.cosine = losses_1.cosineProximity;
exports.sparseCategoricalCrossentropy = losses_1.sparseCategoricalCrossentropy;
function get(identifier) {
    var metricsMap = {
        binaryAccuracy: binaryAccuracy,
        categoricalAccuracy: categoricalAccuracy,
        precision: precision,
        categoricalCrossentropy: exports.categoricalCrossentropy,
        sparseCategoricalCrossentropy: exports.sparseCategoricalCrossentropy,
        mse: exports.mse,
        MSE: exports.MSE,
        mae: exports.mae,
        MAE: exports.MAE,
        mape: exports.mape,
        MAPE: exports.MAPE,
        cosine: exports.cosine,
    };
    if (typeof identifier === 'string' && identifier in metricsMap) {
        return metricsMap[identifier];
    }
    else if (typeof identifier !== 'string' && identifier != null) {
        return identifier;
    }
    else {
        throw new errors_1.ValueError("Unknown metric " + identifier);
    }
}
exports.get = get;

},{"./backend/state":208,"./backend/tfjs_backend":209,"./errors":222,"./losses":244,"@tensorflow/tfjs-core":64}],246:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var state_1 = require("./backend/state");
var input_layer_1 = require("./engine/input_layer");
var topology_1 = require("./engine/topology");
var training_1 = require("./engine/training");
var errors_1 = require("./errors");
var serialization_1 = require("./layers/serialization");
var generic_utils = require("./utils/generic_utils");
var serialization_utils_1 = require("./utils/serialization_utils");
var types_utils_1 = require("./utils/types_utils");
function modelFromJSON(modelAndWeightsConfig, customObjects) {
    return __awaiter(this, void 0, void 0, function () {
        var modelTopology, tsConfig, model, weightValues, uniqueWeightValues, _i, _a, weight, skipMismatches, isNamedTensorMap;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    modelTopology = modelAndWeightsConfig.modelTopology;
                    if (modelTopology['model_config'] != null) {
                        modelTopology = modelTopology['model_config'];
                    }
                    tsConfig = serialization_utils_1.convertPythonicToTs(modelTopology);
                    model = serialization_1.deserialize(tsConfig, customObjects);
                    if (!(modelAndWeightsConfig.weightsManifest != null)) return [3, 2];
                    return [4, tfjs_core_1.io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(function (weight) { return weight.originalName; }))];
                case 1:
                    weightValues = _b.sent();
                    uniqueWeightValues = {};
                    for (_i = 0, _a = model.weights; _i < _a.length; _i++) {
                        weight = _a[_i];
                        uniqueWeightValues[weight.originalName] =
                            weightValues[weight.originalName];
                    }
                    skipMismatches = null;
                    isNamedTensorMap = true;
                    model.loadWeights(uniqueWeightValues, skipMismatches, isNamedTensorMap);
                    _b.label = 2;
                case 2: return [2, model];
            }
        });
    });
}
exports.modelFromJSON = modelFromJSON;
function loadModelInternal(pathOrIOHandler, strict) {
    if (strict === void 0) { strict = true; }
    return __awaiter(this, void 0, void 0, function () {
        var handlers;
        return __generator(this, function (_a) {
            if (typeof pathOrIOHandler === 'string') {
                handlers = tfjs_core_1.io.getLoadHandlers(pathOrIOHandler);
                if (handlers.length === 0) {
                    handlers.push(tfjs_core_1.io.browserHTTPRequest(pathOrIOHandler));
                }
                else if (handlers.length > 1) {
                    throw new errors_1.ValueError("Found more than one (" + handlers.length + ") load handlers for " +
                        ("URL '" + pathOrIOHandler + "'"));
                }
                pathOrIOHandler = handlers[0];
            }
            return [2, loadModelFromIOHandler(pathOrIOHandler, undefined, strict)];
        });
    });
}
exports.loadModelInternal = loadModelInternal;
function loadModelFromIOHandler(handler, customObjects, strict) {
    if (strict === void 0) { strict = true; }
    return __awaiter(this, void 0, void 0, function () {
        var artifacts, modelTopology, model, skipMismatch, isNamedTensorMap;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (handler.load == null) {
                        throw new errors_1.ValueError('Cannot proceed with model loading because the IOHandler provided ' +
                            'does not have the `load` method implemented.');
                    }
                    return [4, handler.load()];
                case 1:
                    artifacts = _a.sent();
                    modelTopology = artifacts.modelTopology;
                    if (modelTopology['model_config'] != null) {
                        modelTopology = modelTopology['model_config'];
                    }
                    model = serialization_1.deserialize(serialization_utils_1.convertPythonicToTs(modelTopology), customObjects);
                    if (artifacts.weightData != null) {
                        if (artifacts.weightSpecs == null) {
                            throw new errors_1.ValueError('Model artifacts contains weight data, but not weight specs. ' +
                                'Therefore loading of weights cannot proceed.');
                        }
                        skipMismatch = false;
                        isNamedTensorMap = true;
                        model.loadWeights(tfjs_core_1.io.decodeWeights(artifacts.weightData, artifacts.weightSpecs), skipMismatch, isNamedTensorMap, strict);
                    }
                    return [2, model];
            }
        });
    });
}
exports.loadModelFromIOHandler = loadModelFromIOHandler;
var Sequential = (function (_super) {
    __extends(Sequential, _super);
    function Sequential(config) {
        var _this = _super.call(this, { inputs: [], outputs: [] }) || this;
        config = config || {};
        _this.trainable = true;
        _this._updatable = true;
        _this.built = false;
        _this.name = (config.name != null) ? config.name : state_1.getUid('sequential_');
        if (config.layers != null) {
            for (var _i = 0, _a = config.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                _this.add(layer);
            }
        }
        return _this;
    }
    Sequential.prototype.checkShape = function (layer) {
        var shape = layer.inboundNodes[0].outputTensors[0].shape;
        if (shape.some(function (x) { return x < 0; })) {
            throw new errors_1.ValueError('Negative dimension size caused by adding layer ' +
                (layer.name + " with input shape [") +
                (layer.inboundNodes[0].inputTensors[0].shape + "]"));
        }
    };
    Sequential.prototype.add = function (layer) {
        var isLayerModelInstance = layer instanceof Sequential || layer instanceof training_1.Model;
        var modelLayer;
        if (isLayerModelInstance) {
            modelLayer = layer;
            if (modelLayer.outputs.length !== 1) {
                throw new errors_1.ValueError('All layers in a Sequential model ' +
                    'should have a single output tensor. ' +
                    'For multi-output layers, ' +
                    'use the functional API.');
            }
            if (modelLayer.inputs.length !== 1) {
                throw new errors_1.ValueError('All layers in a Sequential model ' +
                    'should have a single input tensor. ' +
                    'For multi-input layers, ' +
                    'use the functional API.');
            }
        }
        if (this.outputs.length === 0) {
            if (layer.inboundNodes.length === 0) {
                if (layer.batchInputShape == null) {
                    throw new errors_1.ValueError('The first layer in a Sequential model must ' +
                        'get an `inputShape` or `batchInputShape` argument.');
                }
                var x = input_layer_1.Input({
                    batchShape: layer.batchInputShape,
                    dtype: layer.dtype,
                    name: layer.name + '_input'
                });
                layer.apply(x);
            }
            if (isLayerModelInstance) {
                this.outputs = modelLayer.outputs;
                this.inputs = modelLayer.inputs;
            }
            else {
                if (layer.inboundNodes.length !== 1) {
                    throw new errors_1.ValueError('A layer added to a Sequential model must not already be ' +
                        ("connected somewhere else. Model received layer " + layer.name + " ") +
                        ("which has " + layer.inboundNodes.length + " pre-existing inbound ") +
                        'connections.');
                }
                if (layer.inboundNodes[0].outputTensors.length !== 1) {
                    throw new errors_1.ValueError('All layers in a Sequential model ' +
                        'should have a single output tensor. ' +
                        'For multi-output layers, ' +
                        'use the functional API.');
                }
                this.checkShape(layer);
                this.outputs = [layer.inboundNodes[0].outputTensors[0]];
                this.inputs = topology_1.getSourceInputs(this.outputs[0]);
            }
            this.inboundNodes = [];
            new topology_1.Node({
                outboundLayer: this,
                inboundLayers: [],
                nodeIndices: [],
                tensorIndices: [],
                inputTensors: this.inputs,
                outputTensors: this.outputs,
                inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),
                outputMasks: [null],
                inputShapes: this.inputs.map(function (x) { return x.shape; }),
                outputShapes: this.outputs[0].shape
            });
        }
        else {
            var outputTensor = layer.apply(this.outputs[0]);
            if (Array.isArray(outputTensor)) {
                throw new TypeError('All layers in a Sequential model ' +
                    'should have a single output tensor. ' +
                    'For multi-output layers, ' +
                    'use the functional API.');
            }
            this.checkShape(layer);
            this.outputs = [outputTensor];
            this.inboundNodes[0].outputTensors = this.outputs;
            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
        }
        this.layers.push(layer);
        this.built = false;
    };
    Sequential.prototype.pop = function () {
        if (this.layers.length === 0) {
            throw new TypeError('There are no layers in the model.');
        }
        this.layers.pop();
        if (this.layers.length === 0) {
            this.outputs = [];
            this.inboundNodes = [];
            this.outboundNodes = [];
        }
        else {
            var lastLayerIndex = this.layers.length - 1;
            this.layers[lastLayerIndex].outboundNodes = [];
            this.outputs = [this.layers[lastLayerIndex].output];
            this.inboundNodes[0].outputTensors = this.outputs;
            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
        }
    };
    Sequential.prototype.call = function (inputs, kwargs) {
        if (this.model == null) {
            this.build();
        }
        return this.model.call(inputs, kwargs);
    };
    Sequential.prototype.build = function (inputShape) {
        types_utils_1.getExactlyOneShape(inputShape);
        if (this.inputs.length === 0 || this.outputs.length === 0) {
            throw new TypeError('Sequential model cannot be built: model is empty.' +
                ' Add some layers first.');
        }
        this.model = new training_1.Model({
            inputs: this.inputs,
            outputs: this.outputs[0],
            name: this.name + '_model'
        });
        this.model.trainable = this.trainable;
        this.model.updatable = this.updatable;
        this.supportsMasking = this.model.supportsMasking;
        this.inputLayers = this.model.inputLayers;
        this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;
        this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;
        this.outputLayers = this.model.outputLayers;
        this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;
        this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;
        this.nodesByDepth = this.model.nodesByDepth;
        this.containerNodes = this.model.containerNodes;
        this.outputNames = this.model.outputNames;
        this.inputNames = this.model.inputNames;
        this.built = true;
    };
    Sequential.prototype.countParams = function () {
        if (!this.built) {
            this.build();
        }
        return _super.prototype.countParams.call(this);
    };
    Sequential.prototype.summary = function (lineLength, positions, printFn) {
        if (printFn === void 0) { printFn = console.log; }
        if (!this.built) {
            this.build();
        }
        _super.prototype.summary.call(this, lineLength, positions, printFn);
    };
    Sequential.prototype.setWeights = function (weights) {
        if (this.model == null) {
            this.build();
        }
        this.model.setWeights(weights);
    };
    Object.defineProperty(Sequential.prototype, "updatable", {
        get: function () {
            return this._updatable;
        },
        set: function (value) {
            if (this.built) {
                this.model.updatable = value;
            }
            this._updatable = value;
        },
        enumerable: true,
        configurable: true
    });
    Sequential.prototype.evaluate = function (x, y, config) {
        if (config === void 0) { config = {}; }
        if (!this.built) {
            throw new errors_1.RuntimeError('The model needs to be compiled before being used.');
        }
        return this.model.evaluate(x, y, config);
    };
    Sequential.prototype.evaluateDataset = function (dataset, config) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!this.built) {
                    throw new errors_1.RuntimeError('The model needs to be compiled before being used.');
                }
                return [2, this.model.evaluateDataset(dataset, config)];
            });
        });
    };
    Sequential.prototype.predict = function (x, config) {
        if (config === void 0) { config = {}; }
        if (this.model == null) {
            this.build();
        }
        return this.model.predict(x, config);
    };
    Sequential.prototype.predictOnBatch = function (x) {
        if (this.model == null) {
            this.build();
        }
        return this.model.predictOnBatch(x);
    };
    Sequential.prototype.compile = function (config) {
        this.build();
        this.model.compile(config);
        this.optimizer = this.model.optimizer;
        this.loss = this.model.loss;
        this.metrics = this.model.metrics;
        this.metricsTensors = this.model.metricsTensors;
        this.metricsNames = this.model.metricsNames;
    };
    Sequential.prototype.fit = function (x, y, config) {
        if (config === void 0) { config = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!this.built) {
                    throw new errors_1.RuntimeError('The model needs to be compiled before ' +
                        'being used.');
                }
                return [2, this.model.fit(x, y, config)];
            });
        });
    };
    Sequential.prototype.fitDataset = function (dataset, config) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!this.built) {
                    throw new errors_1.RuntimeError('The model needs to be compiled before ' +
                        'being used.');
                }
                return [2, this.model.fitDataset(dataset, config)];
            });
        });
    };
    Sequential.fromConfig = function (cls, config) {
        var configArray;
        var extraModelConfig = {};
        if (config instanceof Array) {
            if (!(config[0].className != null) ||
                config[0]['className'] === 'Merge') {
                throw new errors_1.ValueError('Legacy serialization format not supported yet.');
            }
            configArray = config;
        }
        else {
            tfjs_core_1.util.assert(config['layers'] != null, "When the config data for a Sequential model is not an Array, " +
                "it must be an Object that contains the 'layers' field.");
            configArray = config['layers'];
            delete config['layers'];
            extraModelConfig = config;
        }
        var model = new cls(extraModelConfig);
        if (!(model instanceof Sequential)) {
            throw new errors_1.NotImplementedError("Sequential.fromConfig called on non-Sequential input: " + model);
        }
        for (var _i = 0, configArray_1 = configArray; _i < configArray_1.length; _i++) {
            var conf = configArray_1[_i];
            var layer = serialization_1.deserialize(conf);
            model.add(layer);
        }
        return model;
    };
    Object.defineProperty(Sequential.prototype, "stopTraining", {
        set: function (stop) {
            this.model.stopTraining = stop;
        },
        enumerable: true,
        configurable: true
    });
    Sequential.prototype.getConfig = function () {
        var config = [];
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            config.push({
                className: layer.getClassName(),
                config: layer.getConfig(),
            });
        }
        return config;
    };
    Sequential.className = 'Sequential';
    return Sequential;
}(training_1.Model));
exports.Sequential = Sequential;
tfjs_core_1.serialization.registerClass(Sequential);

},{"./backend/state":208,"./engine/input_layer":217,"./engine/topology":218,"./engine/training":219,"./errors":222,"./layers/serialization":241,"./utils/generic_utils":250,"./utils/serialization_utils":253,"./utils/types_utils":254,"@tensorflow/tfjs-core":64}],247:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("./backend/common");
var errors_1 = require("./errors");
function getOptimizer(identifier) {
    var optimizerMap = {
        'Adagrad': function () { return tfjs_core_1.train.adagrad(0.01); },
        'Adadelta': function () { return tfjs_core_1.train.adadelta(1, 0.95, common_1.epsilon()); },
        'Adam': function () { return tfjs_core_1.train.adam(0.001, 0.9, 0.999, common_1.epsilon()); },
        'Adamax': function () { return tfjs_core_1.train.adamax(0.002, 0.9, 0.999, common_1.epsilon(), 0); },
        'RMSProp': function () { return tfjs_core_1.train.rmsprop(0.001, 0.9, 0, common_1.epsilon()); },
        'SGD': function () { return tfjs_core_1.train.sgd(0.01); }
    };
    optimizerMap['adagrad'] = optimizerMap['Adagrad'];
    optimizerMap['adadelta'] = optimizerMap['Adadelta'];
    optimizerMap['adam'] = optimizerMap['Adam'];
    optimizerMap['adamax'] = optimizerMap['Adamax'];
    optimizerMap['rmsprop'] = optimizerMap['RMSProp'];
    optimizerMap['sgd'] = optimizerMap['SGD'];
    if (identifier in optimizerMap) {
        return optimizerMap[identifier]();
    }
    throw new errors_1.ValueError("Unknown Optimizer " + identifier);
}
exports.getOptimizer = getOptimizer;

},{"./backend/common":207,"./errors":222,"@tensorflow/tfjs-core":64}],248:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var state_1 = require("./backend/state");
var K = require("./backend/tfjs_backend");
var generic_utils_1 = require("./utils/generic_utils");
var Regularizer = (function (_super) {
    __extends(Regularizer, _super);
    function Regularizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Regularizer;
}(tfjs_core_1.serialization.Serializable));
exports.Regularizer = Regularizer;
var L1L2 = (function (_super) {
    __extends(L1L2, _super);
    function L1L2(config) {
        var _this = _super.call(this) || this;
        var l1 = config == null || config.l1 == null ? 0.01 : config.l1;
        var l2 = config == null || config.l2 == null ? 0.01 : config.l2;
        _this.hasL1 = l1 !== 0;
        _this.hasL2 = l2 !== 0;
        _this.l1 = state_1.getScalar(l1);
        _this.l2 = state_1.getScalar(l2);
        return _this;
    }
    L1L2.prototype.apply = function (x) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var regularization = tfjs_core_1.zeros([1]);
            if (_this.hasL1) {
                regularization = tfjs_core_1.add(regularization, tfjs_core_1.sum(tfc.mul(_this.l1, tfjs_core_1.abs(x))));
            }
            if (_this.hasL2) {
                regularization =
                    tfjs_core_1.add(regularization, tfjs_core_1.sum(tfc.mul(_this.l2, K.square(x))));
            }
            return regularization.asScalar();
        });
    };
    L1L2.prototype.getConfig = function () {
        return { 'l1': this.l1.dataSync()[0], 'l2': this.l2.dataSync()[0] };
    };
    L1L2.fromConfig = function (cls, config) {
        return new cls({ l1: config.l1, l2: config.l2 });
    };
    L1L2.className = 'L1L2';
    return L1L2;
}(Regularizer));
exports.L1L2 = L1L2;
tfjs_core_1.serialization.registerClass(L1L2);
function l1(config) {
    return new L1L2({ l1: config != null ? config.l1 : null, l2: 0 });
}
exports.l1 = l1;
function l2(config) {
    return new L1L2({ l2: config != null ? config.l2 : null, l1: 0 });
}
exports.l2 = l2;
exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    'l1l2': 'L1L2'
};
function serializeRegularizer(constraint) {
    return generic_utils_1.serializeKerasObject(constraint);
}
exports.serializeRegularizer = serializeRegularizer;
function deserializeRegularizer(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'regularizer');
}
exports.deserializeRegularizer = deserializeRegularizer;
function getRegularizer(identifier) {
    if (identifier == null) {
        return null;
    }
    if (typeof identifier === 'string') {
        var className = identifier in exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ?
            exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :
            identifier;
        var config = { className: className, config: {} };
        return deserializeRegularizer(config);
    }
    else if (identifier instanceof Regularizer) {
        return identifier;
    }
    else {
        return deserializeRegularizer(identifier);
    }
}
exports.getRegularizer = getRegularizer;

},{"./backend/state":208,"./backend/tfjs_backend":209,"./utils/generic_utils":250,"@tensorflow/tfjs-core":64}],249:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("../errors");
var generic_utils_1 = require("./generic_utils");
var math_utils_1 = require("./math_utils");
function normalizeArray(value, n, name) {
    if (typeof value === 'number') {
        return generic_utils_1.pyListRepeat(value, n);
    }
    else {
        if (value.length !== n) {
            throw new errors_1.ValueError("The " + name + " argument must be a tuple of " + n + " integers. Received: " +
                (value.length + " elements."));
        }
        for (var i = 0; i < n; ++i) {
            var singleValue = value[i];
            if (!math_utils_1.isInteger(singleValue)) {
                throw new errors_1.ValueError("The " + name + " argument must be a tuple of " + n + " integers. Received: " +
                    (JSON.stringify(value) + " including a non-integer number ") +
                    ("" + singleValue));
            }
        }
        return value;
    }
}
exports.normalizeArray = normalizeArray;
function convOutputLength(inputLength, filterSize, padding, stride, dilation) {
    if (dilation === void 0) { dilation = 1; }
    if (inputLength == null) {
        return inputLength;
    }
    var dilatedFilterSize = filterSize + (filterSize - 1) * (dilation - 1);
    var outputLength;
    if (padding === 'same') {
        outputLength = inputLength;
    }
    else {
        outputLength = inputLength - dilatedFilterSize + 1;
    }
    return Math.floor((outputLength + stride - 1) / stride);
}
exports.convOutputLength = convOutputLength;
function deconvLength(dimSize, strideSize, kernelSize, padding) {
    if (dimSize == null) {
        return null;
    }
    if (padding === 'valid') {
        dimSize = dimSize * strideSize + math_utils_1.max([kernelSize - strideSize, 0]);
    }
    else if (padding === 'same') {
        dimSize = dimSize * strideSize;
    }
    else {
        throw new errors_1.ValueError("Unsupport padding mode: " + padding + ".");
    }
    return dimSize;
}
exports.deconvLength = deconvLength;

},{"../errors":222,"./generic_utils":250,"./math_utils":252}],250:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("../errors");
function pyListRepeat(value, numValues) {
    if (Array.isArray(value)) {
        var newArray = [];
        for (var i = 0; i < numValues; i++) {
            newArray = newArray.concat(value);
        }
        return newArray;
    }
    else {
        var newArray = new Array(numValues);
        newArray.fill(value);
        return newArray;
    }
}
exports.pyListRepeat = pyListRepeat;
function assert(val, message) {
    if (!val) {
        throw new errors_1.AssertionError(message);
    }
}
exports.assert = assert;
function count(array, refernce) {
    var counter = 0;
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var item = array_1[_i];
        if (item === refernce) {
            counter++;
        }
    }
    return counter;
}
exports.count = count;
function singletonOrArray(xs) {
    if (xs.length === 1) {
        return xs[0];
    }
    return xs;
}
exports.singletonOrArray = singletonOrArray;
function toList(x) {
    if (Array.isArray(x)) {
        return x;
    }
    return [x];
}
exports.toList = toList;
function objectListUid(objs) {
    var objectList = toList(objs);
    var retVal = '';
    for (var _i = 0, objectList_1 = objectList; _i < objectList_1.length; _i++) {
        var obj = objectList_1[_i];
        if (obj.id == null) {
            throw new errors_1.ValueError("Object " + obj + " passed to objectListUid without an id");
        }
        if (retVal !== '') {
            retVal = retVal + ', ';
        }
        retVal = retVal + Math.abs(obj.id);
    }
    return retVal;
}
exports.objectListUid = objectListUid;
function toSnakeCase(name) {
    var intermediate = name.replace(/(.)([A-Z][a-z0-9]+)/g, '$1_$2');
    var insecure = intermediate.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();
    if (insecure[0] !== '_') {
        return insecure;
    }
    return 'private' + insecure;
}
exports.toSnakeCase = toSnakeCase;
function toCamelCase(identifier) {
    if (identifier.length <= 1) {
        return identifier;
    }
    if (identifier.indexOf('_') === -1) {
        return identifier;
    }
    return identifier.replace(/[_]+(\w|$)/g, function (m, p1) { return p1.toUpperCase(); });
}
exports.toCamelCase = toCamelCase;
var _GLOBAL_CUSTOM_OBJECTS = {};
function serializeKerasObject(instance) {
    if (instance === null || instance === undefined) {
        return null;
    }
    return { className: instance.getClassName(), config: instance.getConfig() };
}
exports.serializeKerasObject = serializeKerasObject;
function deserializeKerasObject(identifier, moduleObjects, customObjects, printableModuleName) {
    if (moduleObjects === void 0) { moduleObjects = {}; }
    if (customObjects === void 0) { customObjects = {}; }
    if (printableModuleName === void 0) { printableModuleName = 'object'; }
    if (typeof identifier === 'string') {
        var functionName = identifier;
        var fn = void 0;
        if (functionName in customObjects) {
            fn = customObjects[functionName];
        }
        else if (functionName in _GLOBAL_CUSTOM_OBJECTS) {
            fn = _GLOBAL_CUSTOM_OBJECTS[functionName];
        }
        else {
            fn = moduleObjects[functionName];
            if (fn == null) {
                throw new errors_1.ValueError("Unknown " + printableModuleName + ": " + identifier + ". " +
                    "This may be due to one of the following reasons:\n" +
                    ("1. The " + printableModuleName + " is defined in Python, in which ") +
                    "case it needs to be ported to TensorFlow.js or your JavaScript " +
                    "code.\n" +
                    ("2. The custom " + printableModuleName + " is defined in JavaScript, ") +
                    "but is not registered properly with " +
                    "tf.serialization.registerClass().");
            }
        }
        return fn;
    }
    else {
        var config = identifier;
        if (config.className == null || config.config == null) {
            throw new errors_1.ValueError(printableModuleName + ": Improper config format: " +
                (JSON.stringify(config) + ".\n") +
                "'className' and 'config' must set.");
        }
        var className = config.className;
        var cls = void 0, fromConfig = void 0;
        if (className in customObjects) {
            _a = customObjects.get(className), cls = _a[0], fromConfig = _a[1];
        }
        else if (className in _GLOBAL_CUSTOM_OBJECTS) {
            _b = _GLOBAL_CUSTOM_OBJECTS.className, cls = _b[0], fromConfig = _b[1];
        }
        else if (className in moduleObjects) {
            _c = moduleObjects[className], cls = _c[0], fromConfig = _c[1];
        }
        if (cls == null) {
            throw new errors_1.ValueError("Unknown " + printableModuleName + ": " + className + ". " +
                "This may be due to one of the following reasons:\n" +
                ("1. The " + printableModuleName + " is defined in Python, in which ") +
                "case it needs to be ported to TensorFlow.js or your JavaScript " +
                "code.\n" +
                ("2. The custom " + printableModuleName + " is defined in JavaScript, ") +
                "but is not registered properly with " +
                "tf.serialization.registerClass().");
        }
        if (fromConfig != null) {
            var customObjectsCombined = {};
            for (var _i = 0, _d = Object.keys(_GLOBAL_CUSTOM_OBJECTS); _i < _d.length; _i++) {
                var key = _d[_i];
                customObjectsCombined[key] = _GLOBAL_CUSTOM_OBJECTS[key];
            }
            for (var _e = 0, _f = Object.keys(customObjects); _e < _f.length; _e++) {
                var key = _f[_e];
                customObjectsCombined[key] = customObjects[key];
            }
            var nestedConfig = config.config;
            nestedConfig.customObjects = customObjectsCombined;
            var backupCustomObjects = __assign({}, _GLOBAL_CUSTOM_OBJECTS);
            for (var _g = 0, _h = Object.keys(customObjects); _g < _h.length; _g++) {
                var key = _h[_g];
                _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
            }
            var returnObj = fromConfig(cls, config.config);
            _GLOBAL_CUSTOM_OBJECTS = __assign({}, backupCustomObjects);
            return returnObj;
        }
        else {
            var backupCustomObjects = __assign({}, _GLOBAL_CUSTOM_OBJECTS);
            for (var _j = 0, _k = Object.keys(customObjects); _j < _k.length; _j++) {
                var key = _k[_j];
                _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
            }
            var returnObj = new cls(config.config);
            _GLOBAL_CUSTOM_OBJECTS = __assign({}, backupCustomObjects);
            return returnObj;
        }
    }
    var _a, _b, _c;
}
exports.deserializeKerasObject = deserializeKerasObject;
function numberCompare(a, b) {
    return (a < b) ? -1 : ((a > b) ? 1 : 0);
}
exports.numberCompare = numberCompare;
function reverseNumberCompare(a, b) {
    return -1 * numberCompare(a, b);
}
exports.reverseNumberCompare = reverseNumberCompare;
function stringToDType(dtype) {
    switch (dtype) {
        case 'float32':
            return 'float32';
        default:
            throw new errors_1.ValueError("Invalid dtype: " + dtype);
    }
}
exports.stringToDType = stringToDType;
function stringsEqual(xs, ys) {
    if (xs == null || ys == null) {
        return xs === ys;
    }
    if (xs.length !== ys.length) {
        return false;
    }
    for (var i = 0; i < xs.length; ++i) {
        if (xs[i] !== ys[i]) {
            return false;
        }
    }
    return true;
}
exports.stringsEqual = stringsEqual;
function unique(xs) {
    if (xs == null) {
        return xs;
    }
    var out = [];
    for (var _i = 0, xs_1 = xs; _i < xs_1.length; _i++) {
        var x = xs_1[_i];
        if (out.indexOf(x) === -1) {
            out.push(x);
        }
    }
    return out;
}
exports.unique = unique;
function isObjectEmpty(obj) {
    if (obj == null) {
        throw new errors_1.ValueError("Invalid value in obj: " + JSON.stringify(obj));
    }
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
}
exports.isObjectEmpty = isObjectEmpty;
function checkStringTypeUnionValue(values, label, value) {
    if (value == null) {
        return;
    }
    if (values.indexOf(value) < 0) {
        throw new errors_1.ValueError(value + " is not a valid " + label + ".  Valid values are " + values + " or null/undefined.");
    }
}
exports.checkStringTypeUnionValue = checkStringTypeUnionValue;
function checkArrayTypeAndLength(x, expectedType, minLength, maxLength) {
    if (minLength === void 0) { minLength = 0; }
    if (maxLength === void 0) { maxLength = Infinity; }
    assert(minLength >= 0);
    assert(maxLength >= minLength);
    return (Array.isArray(x) && x.length >= minLength && x.length <= maxLength &&
        x.every(function (e) { return typeof e === expectedType; }));
}
exports.checkArrayTypeAndLength = checkArrayTypeAndLength;

},{"../errors":222}],251:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var variable_utils_1 = require("./variable_utils");
function printSummary(model, lineLength, positions, printFn) {
    if (printFn === void 0) { printFn = console.log; }
    var sequentialLike = isModelSequentialLike(model);
    var toDisplay = ['Layer (type)', 'Output shape', 'Param #'];
    if (sequentialLike) {
        lineLength = lineLength || 65;
        positions = positions || [0.45, 0.85, 1];
    }
    else {
        lineLength = lineLength || 98;
        positions = positions || [0.33, 0.55, 0.67, 1];
    }
    if (positions[positions.length - 1] <= 1) {
        positions = positions.map(function (p) { return Math.floor(lineLength * p); });
    }
    var relevantNodes;
    if (!sequentialLike) {
        toDisplay.push('Receives inputs');
        relevantNodes = [];
        for (var depth in model.nodesByDepth) {
            relevantNodes.push.apply(relevantNodes, model.nodesByDepth[depth]);
        }
    }
    printFn('_'.repeat(lineLength));
    printRow(toDisplay, positions, printFn);
    printFn('='.repeat(lineLength));
    var layers = model.layers;
    for (var i = 0; i < layers.length; ++i) {
        if (sequentialLike) {
            printLayerSummary(layers[i], positions, printFn);
        }
        else {
            printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);
        }
        printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));
    }
    model.checkTrainableWeightsConsistency();
    var trainableCount = countTrainableParams(model);
    var nonTrainableCount = variable_utils_1.countParamsInWeights(model.nonTrainableWeights);
    printFn("Total params: " + (trainableCount + nonTrainableCount));
    printFn("Trainable params: " + trainableCount);
    printFn("Non-trainable params: " + nonTrainableCount);
    printFn('_'.repeat(lineLength));
}
exports.printSummary = printSummary;
function countTrainableParams(model) {
    var trainableCount;
    if (model.collectedTrainableWeights != null) {
        trainableCount =
            variable_utils_1.countParamsInWeights(model.collectedTrainableWeights);
    }
    else {
        trainableCount = variable_utils_1.countParamsInWeights(model.trainableWeights);
    }
    return trainableCount;
}
function isModelSequentialLike(model) {
    var sequentialLike = true;
    var nodesByDepth = [];
    var nodes = [];
    for (var depth in model.nodesByDepth) {
        nodesByDepth.push(model.nodesByDepth[depth]);
    }
    for (var _i = 0, nodesByDepth_1 = nodesByDepth; _i < nodesByDepth_1.length; _i++) {
        var depthNodes = nodesByDepth_1[_i];
        if (depthNodes.length > 1 ||
            depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {
            sequentialLike = false;
            break;
        }
        nodes.push.apply(nodes, depthNodes);
    }
    if (sequentialLike) {
        for (var _a = 0, _b = model.layers; _a < _b.length; _a++) {
            var layer = _b[_a];
            var flag = false;
            for (var _c = 0, _d = layer.inboundNodes; _c < _d.length; _c++) {
                var node = _d[_c];
                if (nodes.indexOf(node) !== -1) {
                    if (flag) {
                        sequentialLike = false;
                        break;
                    }
                    else {
                        flag = true;
                    }
                }
            }
            if (!sequentialLike) {
                break;
            }
        }
    }
    return sequentialLike;
}
function printRow(fields, positions, printFn) {
    if (printFn === void 0) { printFn = console.log; }
    var line = '';
    for (var i = 0; i < fields.length; ++i) {
        if (i > 0) {
            line = line.slice(0, line.length - 1) + ' ';
        }
        line += fields[i];
        line = line.slice(0, positions[i]);
        line += ' '.repeat(positions[i] - line.length);
    }
    printFn(line);
}
function printLayerSummary(layer, positions, printFn) {
    var outputShape;
    try {
        outputShape = JSON.stringify(layer.outputShape);
    }
    catch (err) {
        outputShape = 'multiple';
    }
    var name = layer.name;
    var className = layer.getClassName();
    var fields = [name + " (" + className + ")", outputShape, layer.countParams().toString()];
    printRow(fields, positions, printFn);
}
function printLayerSummaryWithConnections(layer, positions, relevantNodes, printFn) {
    var outputShape;
    try {
        outputShape = JSON.stringify(layer.outputShape);
    }
    catch (err) {
        outputShape = 'multiple';
    }
    var connections = [];
    for (var _i = 0, _a = layer.inboundNodes; _i < _a.length; _i++) {
        var node = _a[_i];
        if (relevantNodes != null && relevantNodes.length > 0 &&
            relevantNodes.indexOf(node) === -1) {
            continue;
        }
        for (var i = 0; i < node.inboundLayers.length; ++i) {
            var inboundLayer = node.inboundLayers[i].name;
            var inboundLayerIndex = node.nodeIndices[i];
            var inboundTensorIndex = node.tensorIndices[i];
            connections.push(inboundLayer + "[" + inboundLayerIndex + "][" + inboundTensorIndex + "]");
        }
    }
    var name = layer.name;
    var className = layer.getClassName();
    var firstConnection = connections.length === 0 ? '' : connections[0];
    var fields = [
        name + " (" + className + ")", outputShape, layer.countParams().toString(),
        firstConnection
    ];
    printRow(fields, positions, printFn);
    for (var i = 1; i < connections.length; ++i) {
        printRow(['', '', '', connections[i]], positions, printFn);
    }
}

},{"./variable_utils":255}],252:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var errors_1 = require("../errors");
function isInteger(x) {
    return x === parseInt(x.toString(), 10);
}
exports.isInteger = isInteger;
function arrayProd(array, begin, end) {
    if (begin == null) {
        begin = 0;
    }
    if (end == null) {
        end = array.length;
    }
    var prod = 1;
    for (var i = begin; i < end; ++i) {
        prod *= array[i];
    }
    return prod;
}
exports.arrayProd = arrayProd;
function toArray1D(array) {
    array = Array.isArray(array) ? new Float32Array(array) : array;
    return tfjs_core_1.tensor1d(array);
}
function min(array) {
    return tfc.min(toArray1D(array)).dataSync()[0];
}
exports.min = min;
function max(array) {
    return tfc.max(toArray1D(array)).dataSync()[0];
}
exports.max = max;
function sum(array) {
    return tfc.sum(toArray1D(array)).dataSync()[0];
}
exports.sum = sum;
function mean(array) {
    return sum(array) / array.length;
}
exports.mean = mean;
function variance(array) {
    var demeaned = tfc.sub(toArray1D(array), tfjs_core_1.scalar(mean(array)));
    var sumSquare = tfc.sum(tfc.mulStrict(demeaned, demeaned)).dataSync()[0];
    return sumSquare / array.length;
}
exports.variance = variance;
function median(array) {
    var arraySorted = array.slice().sort(function (a, b) { return a - b; });
    var lowIdx = Math.floor((arraySorted.length - 1) / 2);
    var highIdx = Math.ceil((arraySorted.length - 1) / 2);
    if (lowIdx === highIdx) {
        return arraySorted[lowIdx];
    }
    return (arraySorted[lowIdx] + arraySorted[highIdx]) / 2;
}
exports.median = median;
function range(begin, end) {
    if (end < begin) {
        throw new errors_1.ValueError("end (" + end + ") < begin (" + begin + ") is forbidden.");
    }
    var out = [];
    for (var i = begin; i < end; ++i) {
        out.push(i);
    }
    return out;
}
exports.range = range;

},{"../errors":222,"@tensorflow/tfjs-core":64}],253:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var generic_utils = require("../utils/generic_utils");
function isArrayItemInputOrOutputName(key, index, value) {
    return (key === 'inboundNodes' || key === 'outputLayers' ||
        key === 'inputLayers') &&
        index === 0 && typeof value === 'string';
}
function convertPythonicToTs(pythonicConfig, key) {
    if (pythonicConfig === null) {
        return null;
    }
    else if (typeof pythonicConfig === 'string') {
        return generic_utils.toCamelCase(pythonicConfig);
    }
    else if ((typeof pythonicConfig === 'number') ||
        (typeof pythonicConfig === 'boolean')) {
        return pythonicConfig;
    }
    else if (pythonicConfig instanceof Array) {
        var tsArray = [];
        var arrayLength = pythonicConfig.length;
        for (var i = 0; i < arrayLength; ++i) {
            var item = pythonicConfig[i];
            if (isArrayItemInputOrOutputName(key, i, item)) {
                tsArray.push(item);
            }
            else {
                tsArray.push(convertPythonicToTs(item, key));
            }
        }
        return tsArray;
    }
    else {
        var tsDict = {};
        for (var _i = 0, _a = Object.keys(pythonicConfig); _i < _a.length; _i++) {
            var pythonicKey = _a[_i];
            var pythonicValue = pythonicConfig[pythonicKey];
            if (pythonicKey === 'name' && typeof pythonicValue === 'string') {
                tsDict[pythonicKey] = pythonicValue;
            }
            else {
                var tsKey = generic_utils.toCamelCase(pythonicKey);
                tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);
            }
        }
        return tsDict;
    }
}
exports.convertPythonicToTs = convertPythonicToTs;
function convertTsToPythonic(tsConfig, key) {
    if (tsConfig === null || tsConfig === undefined) {
        return null;
    }
    else if (typeof tsConfig === 'string') {
        return generic_utils.toSnakeCase(tsConfig);
    }
    else if ((typeof tsConfig === 'number') || (typeof tsConfig === 'boolean')) {
        return tsConfig;
    }
    else if (tsConfig instanceof Array) {
        var pyArray = [];
        var arrayLength = tsConfig.length;
        for (var i = 0; i < arrayLength; ++i) {
            var item = tsConfig[i];
            if (isArrayItemInputOrOutputName(key, i, item)) {
                pyArray.push(item);
            }
            else {
                pyArray.push(convertTsToPythonic(item, key));
            }
        }
        return pyArray;
    }
    else {
        var pyDict = {};
        for (var _i = 0, _a = Object.keys(tsConfig); _i < _a.length; _i++) {
            var tsKey = _a[_i];
            var tsValue = tsConfig[tsKey];
            var pyKey = generic_utils.toSnakeCase(tsKey);
            if ((tsKey === 'name' || tsKey === 'className') &&
                typeof tsValue === 'string') {
                pyDict[pyKey] = tsValue;
            }
            else {
                pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);
            }
        }
        return pyDict;
    }
}
exports.convertTsToPythonic = convertTsToPythonic;

},{"../utils/generic_utils":250}],254:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("../errors");
function isArrayOfShapes(x) {
    return Array.isArray(x) && Array.isArray(x[0]);
}
exports.isArrayOfShapes = isArrayOfShapes;
function normalizeShapeList(x) {
    if (x.length === 0) {
        return [];
    }
    if (!Array.isArray(x[0])) {
        return [x];
    }
    return x;
}
exports.normalizeShapeList = normalizeShapeList;
function getExactlyOneTensor(xs) {
    var x;
    if (Array.isArray(xs)) {
        if (xs.length !== 1) {
            throw new errors_1.ValueError("Expected Tensor length to be 1; got " + xs.length);
        }
        x = xs[0];
    }
    else {
        x = xs;
    }
    return x;
}
exports.getExactlyOneTensor = getExactlyOneTensor;
function getExactlyOneShape(shapes) {
    if (Array.isArray(shapes) && Array.isArray(shapes[0])) {
        if (shapes.length === 1) {
            shapes = shapes;
            return shapes[0];
        }
        else {
            throw new errors_1.ValueError("Expected exactly 1 Shape; got " + shapes.length);
        }
    }
    else {
        return shapes;
    }
}
exports.getExactlyOneShape = getExactlyOneShape;

},{"../errors":222}],255:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function countParamsInWeights(weights) {
    var count = 0;
    for (var _i = 0, weights_1 = weights; _i < weights_1.length; _i++) {
        var weight = weights_1[_i];
        if (weight.shape.length === 0) {
            count += 1;
        }
        else {
            count += weight.shape.reduce(function (a, b) { return a * b; });
        }
    }
    return count;
}
exports.countParamsInWeights = countParamsInWeights;

},{}],256:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var state_1 = require("./backend/state");
var common_1 = require("./common");
var errors_1 = require("./errors");
var DEFAULT_VARIABLE_NAME_PREFIX = 'Variable';
var LayerVariable = (function () {
    function LayerVariable(val, dtype, name, trainable, constraint) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (name === void 0) { name = DEFAULT_VARIABLE_NAME_PREFIX; }
        if (trainable === void 0) { trainable = true; }
        if (constraint === void 0) { constraint = null; }
        this.dtype = dtype == null ? 'float32' : dtype;
        this.shape = val.shape;
        this.id = state_1.getNextUniqueTensorId();
        name = name == null ? DEFAULT_VARIABLE_NAME_PREFIX : name;
        this.originalName = common_1.getScopedTensorName(name);
        this.name = common_1.getUniqueTensorName(this.originalName);
        this.trainable = trainable;
        this.constraint = constraint;
        this.val = tfc.variable(val, this.trainable, this.name, this.dtype);
    }
    LayerVariable.prototype.read = function () {
        this.assertNotDisposed();
        return this.val;
    };
    LayerVariable.prototype.write = function (newVal) {
        this.assertNotDisposed();
        checkShapesMatch(this.val, newVal);
        if (this.val.id !== newVal.id) {
            this.val.assign(newVal);
            if (this.constraint != null) {
                this.val.assign(this.constraint.apply(this.val));
            }
        }
        return this;
    };
    LayerVariable.prototype.dispose = function () {
        this.assertNotDisposed();
        this.val.dispose();
    };
    LayerVariable.prototype.assertNotDisposed = function () {
        if (this.val.isDisposed) {
            throw new Error("LayersVariable " + this.name + " is already disposed.");
        }
    };
    return LayerVariable;
}());
exports.LayerVariable = LayerVariable;
function checkShapesMatch(x, y) {
    if (x.shape.toString() !== y.shape.toString()) {
        throw new Error('Shape mismatch: ' + JSON.stringify(x.shape) + ' vs. ' +
            JSON.stringify(y.shape));
    }
}
function variable(x, dtype, name, constraint) {
    return new LayerVariable(x, dtype, name, true, constraint);
}
exports.variable = variable;
function zerosVariable(shape, dtype, name) {
    return new LayerVariable(tfc.zeros(shape), dtype, name);
}
exports.zerosVariable = zerosVariable;
function zerosLike(x, dtype, name) {
    return new LayerVariable(tfc.zerosLike(x), dtype, name);
}
exports.zerosLike = zerosLike;
function onesVariable(shape, dtype, name) {
    var allocated = tfc.ones(shape);
    return new LayerVariable(allocated, dtype, name);
}
exports.onesVariable = onesVariable;
function onesLike(x, dtype, name) {
    var allocated = tfc.onesLike(x);
    return new LayerVariable(allocated, dtype, name);
}
exports.onesLike = onesLike;
function eyeVariable(size, dtype, name) {
    return new LayerVariable(tfc.eye(size), dtype, name);
}
exports.eyeVariable = eyeVariable;
function randomUniformVariable(shape, minval, maxval, dtype, seed, name) {
    if (name === void 0) { name = 'randomUniform'; }
    return new LayerVariable(tfc.randomUniform(shape, minval, maxval, dtype), dtype, name);
}
exports.randomUniformVariable = randomUniformVariable;
function truncatedNormalVariable(shape, mean, stddev, dtype, seed, name) {
    if (mean === void 0) { mean = 0.0; }
    if (stddev === void 0) { stddev = 1.0; }
    if (name === void 0) { name = 'truncatedNormal'; }
    dtype = dtype || 'float32';
    if (dtype !== 'float32' && dtype !== 'int32') {
        throw new errors_1.NotImplementedError("randomNormal does not support dType " + dtype + ".");
    }
    return new LayerVariable(tfc.truncatedNormal(shape, mean, stddev, dtype, seed), dtype, name);
}
exports.truncatedNormalVariable = truncatedNormalVariable;
function randomNormalVariable(shape, mean, stddev, dtype, seed, name) {
    if (mean === void 0) { mean = 0.0; }
    if (stddev === void 0) { stddev = 1.0; }
    if (name === void 0) { name = 'randomNormal'; }
    dtype = dtype || 'float32';
    if (dtype !== 'float32' && dtype !== 'int32') {
        throw new errors_1.NotImplementedError("randomNormalVariable does not support dType " + dtype + ".");
    }
    return new LayerVariable(tfc.randomNormal(shape, mean, stddev, dtype, seed), dtype, name);
}
exports.randomNormalVariable = randomNormalVariable;
function update(x, xNew) {
    return x.write(xNew);
}
exports.update = update;
function updateAdd(x, increment) {
    return x.write(tfc.add(x.read(), increment));
}
exports.updateAdd = updateAdd;
function updateSub(x, decrement) {
    return x.write(tfc.sub(x.read(), decrement));
}
exports.updateSub = updateSub;
function batchGetValue(xs) {
    return xs.map(function (x) { return x.read(); });
}
exports.batchGetValue = batchGetValue;
function batchSetValue(variablesAndValues) {
    variablesAndValues.map(function (variableAndValue) {
        var variable = variableAndValue[0];
        variable.write(variableAndValue[1]);
    });
}
exports.batchSetValue = batchSetValue;
function gradients(lossFn, variables) {
    var variableList = variables.map(function (variable) { return variable.read(); });
    var valudAndGrads = tfjs_core_1.variableGrads(lossFn, variableList);
    return variables.map(function (variable) { return valudAndGrads.grads[variable.name]; });
}
exports.gradients = gradients;

},{"./backend/state":208,"./common":212,"./errors":222,"@tensorflow/tfjs-core":64}],257:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.8.2';
exports.version = version;

},{}],258:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("@tensorflow/tfjs-core"));
__export(require("@tensorflow/tfjs-layers"));
__export(require("@tensorflow/tfjs-converter"));
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var tfjs_layers_1 = require("@tensorflow/tfjs-layers");
var tfjs_converter_1 = require("@tensorflow/tfjs-converter");
var version_1 = require("./version");
exports.version = {
    'tfjs-core': tfjs_core_1.version_core,
    'tfjs-layers': tfjs_layers_1.version_layers,
    'tfjs-converter': tfjs_converter_1.version_converter,
    'tfjs': version_1.version
};

},{"./version":259,"@tensorflow/tfjs-converter":22,"@tensorflow/tfjs-core":64,"@tensorflow/tfjs-layers":229}],259:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.13.2';
exports.version = version;

},{}],260:[function(require,module,exports){
// since we are requiring the top level of faker, load all locales by default
var Faker = require('./lib');
var faker = new Faker({ locales: require('./lib/locales') });
module['exports'] = faker;
},{"./lib":272,"./lib/locales":274}],261:[function(require,module,exports){
/**
 *
 * @namespace faker.address
 */
function Address (faker) {
  var f = faker.fake,
      Helpers = faker.helpers;

  /**
   * Generates random zipcode from format. If format is not specified, the
   * locale's zip format is used.
   *
   * @method faker.address.zipCode
   * @param {String} format
   */
  this.zipCode = function(format) {
    // if zip format is not specified, use the zip format defined for the locale
    if (typeof format === 'undefined') {
      var localeFormat = faker.definitions.address.postcode;
      if (typeof localeFormat === 'string') {
        format = localeFormat;
      } else {
        format = faker.random.arrayElement(localeFormat);
      }
    }
    return Helpers.replaceSymbols(format);
  }

  /**
   * Generates a random localized city name. The format string can contain any
   * method provided by faker wrapped in `{{}}`, e.g. `{{name.firstName}}` in
   * order to build the city name.
   *
   * If no format string is provided one of the following is randomly used:
   * 
   * * `{{address.cityPrefix}} {{name.firstName}}{{address.citySuffix}}`
   * * `{{address.cityPrefix}} {{name.firstName}}`
   * * `{{name.firstName}}{{address.citySuffix}}`
   * * `{{name.lastName}}{{address.citySuffix}}`
   *
   * @method faker.address.city
   * @param {String} format
   */
  this.city = function (format) {
    var formats = [
      '{{address.cityPrefix}} {{name.firstName}}{{address.citySuffix}}',
      '{{address.cityPrefix}} {{name.firstName}}',
      '{{name.firstName}}{{address.citySuffix}}',
      '{{name.lastName}}{{address.citySuffix}}'
    ];

    if (typeof format !== "number") {
      format = faker.random.number(formats.length - 1);
    }

    return f(formats[format]);

  }

  /**
   * Return a random localized city prefix
   * @method faker.address.cityPrefix
   */
  this.cityPrefix = function () {
    return faker.random.arrayElement(faker.definitions.address.city_prefix);
  }

  /**
   * Return a random localized city suffix
   *
   * @method faker.address.citySuffix
   */
  this.citySuffix = function () {
    return faker.random.arrayElement(faker.definitions.address.city_suffix);
  }

  /**
   * Returns a random localized street name
   *
   * @method faker.address.streetName
   */
  this.streetName = function () {
      var result;
      var suffix = faker.address.streetSuffix();
      if (suffix !== "") {
          suffix = " " + suffix
      }

      switch (faker.random.number(1)) {
      case 0:
          result = faker.name.lastName() + suffix;
          break;
      case 1:
          result = faker.name.firstName() + suffix;
          break;
      }
      return result;
  }

  //
  // TODO: change all these methods that accept a boolean to instead accept an options hash.
  //
  /**
   * Returns a random localized street address
   *
   * @method faker.address.streetAddress
   * @param {Boolean} useFullAddress
   */
  this.streetAddress = function (useFullAddress) {
      if (useFullAddress === undefined) { useFullAddress = false; }
      var address = "";
      switch (faker.random.number(2)) {
      case 0:
          address = Helpers.replaceSymbolWithNumber("#####") + " " + faker.address.streetName();
          break;
      case 1:
          address = Helpers.replaceSymbolWithNumber("####") +  " " + faker.address.streetName();
          break;
      case 2:
          address = Helpers.replaceSymbolWithNumber("###") + " " + faker.address.streetName();
          break;
      }
      return useFullAddress ? (address + " " + faker.address.secondaryAddress()) : address;
  }

  /**
   * streetSuffix
   *
   * @method faker.address.streetSuffix
   */
  this.streetSuffix = function () {
      return faker.random.arrayElement(faker.definitions.address.street_suffix);
  }
  
  /**
   * streetPrefix
   *
   * @method faker.address.streetPrefix
   */
  this.streetPrefix = function () {
      return faker.random.arrayElement(faker.definitions.address.street_prefix);
  }

  /**
   * secondaryAddress
   *
   * @method faker.address.secondaryAddress
   */
  this.secondaryAddress = function () {
      return Helpers.replaceSymbolWithNumber(faker.random.arrayElement(
          [
              'Apt. ###',
              'Suite ###'
          ]
      ));
  }

  /**
   * county
   *
   * @method faker.address.county
   */
  this.county = function () {
    return faker.random.arrayElement(faker.definitions.address.county);
  }

  /**
   * country
   *
   * @method faker.address.country
   */
  this.country = function () {
    return faker.random.arrayElement(faker.definitions.address.country);
  }

  /**
   * countryCode
   *
   * @method faker.address.countryCode
   */
  this.countryCode = function () {
    return faker.random.arrayElement(faker.definitions.address.country_code);
  }

  /**
   * state
   *
   * @method faker.address.state
   * @param {Boolean} useAbbr
   */
  this.state = function (useAbbr) {
      return faker.random.arrayElement(faker.definitions.address.state);
  }

  /**
   * stateAbbr
   *
   * @method faker.address.stateAbbr
   */
  this.stateAbbr = function () {
      return faker.random.arrayElement(faker.definitions.address.state_abbr);
  }

  /**
   * latitude
   *
   * @method faker.address.latitude
   */
  this.latitude = function () {
      return (faker.random.number(180 * 10000) / 10000.0 - 90.0).toFixed(4);
  }

  /**
   * longitude
   *
   * @method faker.address.longitude
   */
  this.longitude = function () {
      return (faker.random.number(360 * 10000) / 10000.0 - 180.0).toFixed(4);
  }
  
  return this;
}


module.exports = Address;

},{}],262:[function(require,module,exports){
/**
 *
 * @namespace faker.commerce
 */
var Commerce = function (faker) {
  var self = this;

  /**
   * color
   *
   * @method faker.commerce.color
   */
  self.color = function() {
      return faker.random.arrayElement(faker.definitions.commerce.color);
  };

  /**
   * department
   *
   * @method faker.commerce.department
   */
  self.department = function() {
      return faker.random.arrayElement(faker.definitions.commerce.department);
  };

  /**
   * productName
   *
   * @method faker.commerce.productName
   */
  self.productName = function() {
      return faker.commerce.productAdjective() + " " +
              faker.commerce.productMaterial() + " " +
              faker.commerce.product();
  };

  /**
   * price
   *
   * @method faker.commerce.price
   * @param {number} min
   * @param {number} max
   * @param {number} dec
   * @param {string} symbol
   *
   * @return {string}
   */
  self.price = function(min, max, dec, symbol) {
      min = min || 0;
      max = max || 1000;
      dec = dec === undefined ? 2 : dec;
      symbol = symbol || '';

      if (min < 0 || max < 0) {
          return symbol + 0.00;
      }

      var randValue = faker.random.number({ max: max, min: min });

      return symbol + (Math.round(randValue * Math.pow(10, dec)) / Math.pow(10, dec)).toFixed(dec);
  };

  /*
  self.categories = function(num) {
      var categories = [];

      do {
          var category = faker.random.arrayElement(faker.definitions.commerce.department);
          if(categories.indexOf(category) === -1) {
              categories.push(category);
          }
      } while(categories.length < num);

      return categories;
  };

  */
  /*
  self.mergeCategories = function(categories) {
      var separator = faker.definitions.separator || " &";
      // TODO: find undefined here
      categories = categories || faker.definitions.commerce.categories;
      var commaSeparated = categories.slice(0, -1).join(', ');

      return [commaSeparated, categories[categories.length - 1]].join(separator + " ");
  };
  */

  /**
   * productAdjective
   *
   * @method faker.commerce.productAdjective
   */
  self.productAdjective = function() {
      return faker.random.arrayElement(faker.definitions.commerce.product_name.adjective);
  };

  /**
   * productMaterial
   *
   * @method faker.commerce.productMaterial
   */
  self.productMaterial = function() {
      return faker.random.arrayElement(faker.definitions.commerce.product_name.material);
  };

  /**
   * product
   *
   * @method faker.commerce.product
   */
  self.product = function() {
      return faker.random.arrayElement(faker.definitions.commerce.product_name.product);
  };

  return self;
};

module['exports'] = Commerce;

},{}],263:[function(require,module,exports){
/**
 *
 * @namespace faker.company
 */
var Company = function (faker) {
  
  var self = this;
  var f = faker.fake;
  
  /**
   * suffixes
   *
   * @method faker.company.suffixes
   */
  this.suffixes = function () {
    // Don't want the source array exposed to modification, so return a copy
    return faker.definitions.company.suffix.slice(0);
  }

  /**
   * companyName
   *
   * @method faker.company.companyName
   * @param {string} format
   */
  this.companyName = function (format) {

    var formats = [
      '{{name.lastName}} {{company.companySuffix}}',
      '{{name.lastName}} - {{name.lastName}}',
      '{{name.lastName}}, {{name.lastName}} and {{name.lastName}}'
    ];

    if (typeof format !== "number") {
      format = faker.random.number(formats.length - 1);
    }

    return f(formats[format]);
  }

  /**
   * companySuffix
   *
   * @method faker.company.companySuffix
   */
  this.companySuffix = function () {
      return faker.random.arrayElement(faker.company.suffixes());
  }

  /**
   * catchPhrase
   *
   * @method faker.company.catchPhrase
   */
  this.catchPhrase = function () {
    return f('{{company.catchPhraseAdjective}} {{company.catchPhraseDescriptor}} {{company.catchPhraseNoun}}')
  }

  /**
   * bs
   *
   * @method faker.company.bs
   */
  this.bs = function () {
    return f('{{company.bsAdjective}} {{company.bsBuzz}} {{company.bsNoun}}');
  }

  /**
   * catchPhraseAdjective
   *
   * @method faker.company.catchPhraseAdjective
   */
  this.catchPhraseAdjective = function () {
      return faker.random.arrayElement(faker.definitions.company.adjective);
  }

  /**
   * catchPhraseDescriptor
   *
   * @method faker.company.catchPhraseDescriptor
   */
  this.catchPhraseDescriptor = function () {
      return faker.random.arrayElement(faker.definitions.company.descriptor);
  }

  /**
   * catchPhraseNoun
   *
   * @method faker.company.catchPhraseNoun
   */
  this.catchPhraseNoun = function () {
      return faker.random.arrayElement(faker.definitions.company.noun);
  }

  /**
   * bsAdjective
   *
   * @method faker.company.bsAdjective
   */
  this.bsAdjective = function () {
      return faker.random.arrayElement(faker.definitions.company.bs_adjective);
  }

  /**
   * bsBuzz
   *
   * @method faker.company.bsBuzz
   */
  this.bsBuzz = function () {
      return faker.random.arrayElement(faker.definitions.company.bs_verb);
  }

  /**
   * bsNoun
   *
   * @method faker.company.bsNoun
   */
  this.bsNoun = function () {
      return faker.random.arrayElement(faker.definitions.company.bs_noun);
  }
  
}

module['exports'] = Company;
},{}],264:[function(require,module,exports){
/**
 *
 * @namespace faker.database
 */
var Database = function (faker) {
  var self = this;
  /**
   * column
   *
   * @method faker.database.column
   */
  self.column = function () {
      return faker.random.arrayElement(faker.definitions.database.column);
  };

  self.column.schema = {
    "description": "Generates a column name.",
    "sampleResults": ["id", "title", "createdAt"]
  };

  /**
   * type
   *
   * @method faker.database.type
   */
  self.type = function () {
      return faker.random.arrayElement(faker.definitions.database.type);
  };

  self.type.schema = {
    "description": "Generates a column type.",
    "sampleResults": ["byte", "int", "varchar", "timestamp"]
  };

  /**
   * collation
   *
   * @method faker.database.collation
   */
  self.collation = function () {
      return faker.random.arrayElement(faker.definitions.database.collation);
  };

  self.collation.schema = {
    "description": "Generates a collation.",
    "sampleResults": ["utf8_unicode_ci", "utf8_bin"]
  };

  /**
   * engine
   *
   * @method faker.database.engine
   */
  self.engine = function () {
      return faker.random.arrayElement(faker.definitions.database.engine);
  };

  self.engine.schema = {
    "description": "Generates a storage engine.",
    "sampleResults": ["MyISAM", "InnoDB"]
  };
};

module["exports"] = Database;

},{}],265:[function(require,module,exports){
/**
 *
 * @namespace faker.date
 */
var _Date = function (faker) {
  var self = this;
  /**
   * past
   *
   * @method faker.date.past
   * @param {number} years
   * @param {date} refDate
   */
  self.past = function (years, refDate) {
      var date = (refDate) ? new Date(Date.parse(refDate)) : new Date();
      var range = {
        min: 1000,
        max: (years || 1) * 365 * 24 * 3600 * 1000
      };

      var past = date.getTime();
      past -= faker.random.number(range); // some time from now to N years ago, in milliseconds
      date.setTime(past);

      return date;
  };

  /**
   * future
   *
   * @method faker.date.future
   * @param {number} years
   * @param {date} refDate
   */
  self.future = function (years, refDate) {
      var date = (refDate) ? new Date(Date.parse(refDate)) : new Date();
      var range = {
        min: 1000,
        max: (years || 1) * 365 * 24 * 3600 * 1000
      };

      var future = date.getTime();
      future += faker.random.number(range); // some time from now to N years later, in milliseconds
      date.setTime(future);

      return date;
  };

  /**
   * between
   *
   * @method faker.date.between
   * @param {date} from
   * @param {date} to
   */
  self.between = function (from, to) {
      var fromMilli = Date.parse(from);
      var dateOffset = faker.random.number(Date.parse(to) - fromMilli);

      var newDate = new Date(fromMilli + dateOffset);

      return newDate;
  };

  /**
   * recent
   *
   * @method faker.date.recent
   * @param {number} days
   */
  self.recent = function (days) {
      var date = new Date();
      var range = {
        min: 1000,
        max: (days || 1) * 24 * 3600 * 1000
      };

      var future = date.getTime();
      future -= faker.random.number(range); // some time from now to N days ago, in milliseconds
      date.setTime(future);

      return date;
  };

  /**
   * month
   *
   * @method faker.date.month
   * @param {object} options
   */
  self.month = function (options) {
      options = options || {};

      var type = 'wide';
      if (options.abbr) {
          type = 'abbr';
      }
      if (options.context && typeof faker.definitions.date.month[type + '_context'] !== 'undefined') {
          type += '_context';
      }

      var source = faker.definitions.date.month[type];

      return faker.random.arrayElement(source);
  };

  /**
   * weekday
   *
   * @param {object} options
   * @method faker.date.weekday
   */
  self.weekday = function (options) {
      options = options || {};

      var type = 'wide';
      if (options.abbr) {
          type = 'abbr';
      }
      if (options.context && typeof faker.definitions.date.weekday[type + '_context'] !== 'undefined') {
          type += '_context';
      }

      var source = faker.definitions.date.weekday[type];

      return faker.random.arrayElement(source);
  };
  
  return self;
  
};

module['exports'] = _Date;
},{}],266:[function(require,module,exports){
/*
  fake.js - generator method for combining faker methods based on string input

*/

function Fake (faker) {
  
  /**
   * Generator method for combining faker methods based on string input
   *
   * __Example:__
   *
   * ```
   * console.log(faker.fake('{{name.lastName}}, {{name.firstName}} {{name.suffix}}'));
   * //outputs: "Marks, Dean Sr."
   * ```
   *
   * This will interpolate the format string with the value of methods
   * [name.lastName]{@link faker.name.lastName}, [name.firstName]{@link faker.name.firstName},
   * and [name.suffix]{@link faker.name.suffix}
   *
   * @method faker.fake
   * @param {string} str
   */
  this.fake = function fake (str) {
    // setup default response as empty string
    var res = '';

    // if incoming str parameter is not provided, return error message
    if (typeof str !== 'string' || str.length === 0) {
      res = 'string parameter is required!';
      return res;
    }

    // find first matching {{ and }}
    var start = str.search('{{');
    var end = str.search('}}');

    // if no {{ and }} is found, we are done
    if (start === -1 && end === -1) {
      return str;
    }

    // console.log('attempting to parse', str);

    // extract method name from between the {{ }} that we found
    // for example: {{name.firstName}}
    var token = str.substr(start + 2,  end - start - 2);
    var method = token.replace('}}', '').replace('{{', '');

    // console.log('method', method)

    // extract method parameters
    var regExp = /\(([^)]+)\)/;
    var matches = regExp.exec(method);
    var parameters = '';
    if (matches) {
      method = method.replace(regExp, '');
      parameters = matches[1];
    }

    // split the method into module and function
    var parts = method.split('.');

    if (typeof faker[parts[0]] === "undefined") {
      throw new Error('Invalid module: ' + parts[0]);
    }

    if (typeof faker[parts[0]][parts[1]] === "undefined") {
      throw new Error('Invalid method: ' + parts[0] + "." + parts[1]);
    }

    // assign the function from the module.function namespace
    var fn = faker[parts[0]][parts[1]];

    // If parameters are populated here, they are always going to be of string type
    // since we might actually be dealing with an object or array,
    // we always attempt to the parse the incoming parameters into JSON
    var params;
    // Note: we experience a small performance hit here due to JSON.parse try / catch
    // If anyone actually needs to optimize this specific code path, please open a support issue on github
    try {
      params = JSON.parse(parameters)
    } catch (err) {
      // since JSON.parse threw an error, assume parameters was actually a string
      params = parameters;
    }

    var result;
    if (typeof params === "string" && params.length === 0) {
      result = fn.call(this);
    } else {
      result = fn.call(this, params);
    }

    // replace the found tag with the returned fake value
    res = str.replace('{{' + token + '}}', result);

    // return the response recursively until we are done finding all tags
    return fake(res);    
  }
  
  return this;
  
  
}

module['exports'] = Fake;
},{}],267:[function(require,module,exports){
/**
 * @namespace faker.finance
 */
var Finance = function (faker) {
  var ibanLib = require("./iban");
  var Helpers = faker.helpers,
      self = this;

  /**
   * account
   *
   * @method faker.finance.account
   * @param {number} length
   */
  self.account = function (length) {

      length = length || 8;

      var template = '';

      for (var i = 0; i < length; i++) {
          template = template + '#';
      }
      length = null;
      return Helpers.replaceSymbolWithNumber(template);
  };

  /**
   * accountName
   *
   * @method faker.finance.accountName
   */
  self.accountName = function () {

      return [Helpers.randomize(faker.definitions.finance.account_type), 'Account'].join(' ');
  };

  /**
   * mask
   *
   * @method faker.finance.mask
   * @param {number} length
   * @param {boolean} parens
   * @param {boolean} ellipsis
   */
  self.mask = function (length, parens, ellipsis) {

      //set defaults
      length = (length == 0 || !length || typeof length == 'undefined') ? 4 : length;
      parens = (parens === null) ? true : parens;
      ellipsis = (ellipsis === null) ? true : ellipsis;

      //create a template for length
      var template = '';

      for (var i = 0; i < length; i++) {
          template = template + '#';
      }

      //prefix with ellipsis
      template = (ellipsis) ? ['...', template].join('') : template;

      template = (parens) ? ['(', template, ')'].join('') : template;

      //generate random numbers
      template = Helpers.replaceSymbolWithNumber(template);

      return template;
  };

  //min and max take in minimum and maximum amounts, dec is the decimal place you want rounded to, symbol is $, , , etc
  //NOTE: this returns a string representation of the value, if you want a number use parseFloat and no symbol

  /**
   * amount
   *
   * @method faker.finance.amount
   * @param {number} min
   * @param {number} max
   * @param {number} dec
   * @param {string} symbol
   *
   * @return {string}
   */
  self.amount = function (min, max, dec, symbol) {

      min = min || 0;
      max = max || 1000;
      dec = dec === undefined ? 2 : dec;
      symbol = symbol || '';
      var randValue = faker.random.number({ max: max, min: min, precision: Math.pow(10, -dec) });

      return symbol + randValue.toFixed(dec);
  };

  /**
   * transactionType
   *
   * @method faker.finance.transactionType
   */
  self.transactionType = function () {
      return Helpers.randomize(faker.definitions.finance.transaction_type);
  };

  /**
   * currencyCode
   *
   * @method faker.finance.currencyCode
   */
  self.currencyCode = function () {
      return faker.random.objectElement(faker.definitions.finance.currency)['code'];
  };

  /**
   * currencyName
   *
   * @method faker.finance.currencyName
   */
  self.currencyName = function () {
      return faker.random.objectElement(faker.definitions.finance.currency, 'key');
  };

  /**
   * currencySymbol
   *
   * @method faker.finance.currencySymbol
   */
  self.currencySymbol = function () {
      var symbol;

      while (!symbol) {
          symbol = faker.random.objectElement(faker.definitions.finance.currency)['symbol'];
      }
      return symbol;
  };

  /**
   * bitcoinAddress
   *
   * @method  faker.finance.bitcoinAddress
   */
  self.bitcoinAddress = function () {
    var addressLength = faker.random.number({ min: 27, max: 34 });

    var address = faker.random.arrayElement(['1', '3']);

    for (var i = 0; i < addressLength - 1; i++)
      address += faker.random.alphaNumeric().toUpperCase();

    return address;
  };

  /**
   * iban
   *
   * @method  faker.finance.iban
   */
  self.iban = function (formatted) {
      var ibanFormat = faker.random.arrayElement(ibanLib.formats);
      var s = "";
      var count = 0;
      for (var b = 0; b < ibanFormat.bban.length; b++) {
          var bban = ibanFormat.bban[b];
          var c = bban.count;
          count += bban.count;
          while (c > 0) {
              if (bban.type == "a") {
                  s += faker.random.arrayElement(ibanLib.alpha);
              } else if (bban.type == "c") {
                  if (faker.random.number(100) < 80) {
                      s += faker.random.number(9);
                  } else {
                      s += faker.random.arrayElement(ibanLib.alpha);
                  }
              } else {
                  if (c >= 3 && faker.random.number(100) < 30) {
                      if (faker.random.boolean()) {
                          s += faker.random.arrayElement(ibanLib.pattern100);
                          c -= 2;
                      } else {
                          s += faker.random.arrayElement(ibanLib.pattern10);
                          c--;
                      }
                  } else {
                      s += faker.random.number(9);
                  }
              }
              c--;
          }
          s = s.substring(0, count);
      }
      var checksum = 98 - ibanLib.mod97(ibanLib.toDigitString(s + ibanFormat.country + "00"));
      if (checksum < 10) {
          checksum = "0" + checksum;
      }
      var iban = ibanFormat.country + checksum + s;
      return formatted ? iban.match(/.{1,4}/g).join(" ") : iban;
  };

  /**
   * bic
   *
   * @method  faker.finance.bic
   */
  self.bic = function () {
      var vowels = ["A", "E", "I", "O", "U"];
      var prob = faker.random.number(100);
      return Helpers.replaceSymbols("???") +
          faker.random.arrayElement(vowels) +
          faker.random.arrayElement(ibanLib.iso3166) +
          Helpers.replaceSymbols("?") + "1" +
          (prob < 10 ?
              Helpers.replaceSymbols("?" + faker.random.arrayElement(vowels) + "?") :
          prob < 40 ?
              Helpers.replaceSymbols("###") : "");
  };
};

module['exports'] = Finance;

},{"./iban":270}],268:[function(require,module,exports){
/**
 *
 * @namespace faker.hacker
 */
var Hacker = function (faker) {
  var self = this;
  
  /**
   * abbreviation
   *
   * @method faker.hacker.abbreviation
   */
  self.abbreviation = function () {
    return faker.random.arrayElement(faker.definitions.hacker.abbreviation);
  };

  /**
   * adjective
   *
   * @method faker.hacker.adjective
   */
  self.adjective = function () {
    return faker.random.arrayElement(faker.definitions.hacker.adjective);
  };

  /**
   * noun
   *
   * @method faker.hacker.noun
   */
  self.noun = function () {
    return faker.random.arrayElement(faker.definitions.hacker.noun);
  };

  /**
   * verb
   *
   * @method faker.hacker.verb
   */
  self.verb = function () {
    return faker.random.arrayElement(faker.definitions.hacker.verb);
  };

  /**
   * ingverb
   *
   * @method faker.hacker.ingverb
   */
  self.ingverb = function () {
    return faker.random.arrayElement(faker.definitions.hacker.ingverb);
  };

  /**
   * phrase
   *
   * @method faker.hacker.phrase
   */
  self.phrase = function () {

    var data = {
      abbreviation: self.abbreviation,
      adjective: self.adjective,
      ingverb: self.ingverb,
      noun: self.noun,
      verb: self.verb
    };

    var phrase = faker.random.arrayElement([ "If we {{verb}} the {{noun}}, we can get to the {{abbreviation}} {{noun}} through the {{adjective}} {{abbreviation}} {{noun}}!",
      "We need to {{verb}} the {{adjective}} {{abbreviation}} {{noun}}!",
      "Try to {{verb}} the {{abbreviation}} {{noun}}, maybe it will {{verb}} the {{adjective}} {{noun}}!",
      "You can't {{verb}} the {{noun}} without {{ingverb}} the {{adjective}} {{abbreviation}} {{noun}}!",
      "Use the {{adjective}} {{abbreviation}} {{noun}}, then you can {{verb}} the {{adjective}} {{noun}}!",
      "The {{abbreviation}} {{noun}} is down, {{verb}} the {{adjective}} {{noun}} so we can {{verb}} the {{abbreviation}} {{noun}}!",
      "{{ingverb}} the {{noun}} won't do anything, we need to {{verb}} the {{adjective}} {{abbreviation}} {{noun}}!",
      "I'll {{verb}} the {{adjective}} {{abbreviation}} {{noun}}, that should {{noun}} the {{abbreviation}} {{noun}}!"
   ]);

   return faker.helpers.mustache(phrase, data);

  };
  
  return self;
};

module['exports'] = Hacker;
},{}],269:[function(require,module,exports){
/**
 *
 * @namespace faker.helpers
 */
var Helpers = function (faker) {

  var self = this;

  /**
   * backword-compatibility
   *
   * @method faker.helpers.randomize
   * @param {array} array
   */
  self.randomize = function (array) {
      array = array || ["a", "b", "c"];
      return faker.random.arrayElement(array);
  };

  /**
   * slugifies string
   *
   * @method faker.helpers.slugify
   * @param {string} string
   */
  self.slugify = function (string) {
      string = string || "";
      return string.replace(/ /g, '-').replace(/[^\w\.\-]+/g, '');
  };

  /**
   * parses string for a symbol and replace it with a random number from 1-10
   *
   * @method faker.helpers.replaceSymbolWithNumber
   * @param {string} string
   * @param {string} symbol defaults to `"#"`
   */
  self.replaceSymbolWithNumber = function (string, symbol) {
      string = string || "";
      // default symbol is '#'
      if (symbol === undefined) {
          symbol = '#';
      }

      var str = '';
      for (var i = 0; i < string.length; i++) {
          if (string.charAt(i) == symbol) {
              str += faker.random.number(9);
          } else {
              str += string.charAt(i);
          }
      }
      return str;
  };

  /**
   * parses string for symbols (numbers or letters) and replaces them appropriately
   *
   * @method faker.helpers.replaceSymbols
   * @param {string} string
   */
  self.replaceSymbols = function (string) {
      string = string || "";
      var alpha = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
      var str = '';

      for (var i = 0; i < string.length; i++) {
          if (string.charAt(i) == "#") {
              str += faker.random.number(9);
          } else if (string.charAt(i) == "?") {
              str += faker.random.arrayElement(alpha);
          } else {
              str += string.charAt(i);
          }
      }
      return str;
  };

  /**
   * takes an array and returns it randomized
   *
   * @method faker.helpers.shuffle
   * @param {array} o
   */
  self.shuffle = function (o) {
      if (typeof o === 'undefined' || o.length === 0) {
        return [];
      }
      o = o || ["a", "b", "c"];
      for (var j, x, i = o.length-1; i; j = faker.random.number(i), x = o[--i], o[i] = o[j], o[j] = x);
      return o;
  };

  /**
   * mustache
   *
   * @method faker.helpers.mustache
   * @param {string} str
   * @param {object} data
   */
  self.mustache = function (str, data) {
    if (typeof str === 'undefined') {
      return '';
    }
    for(var p in data) {
      var re = new RegExp('{{' + p + '}}', 'g')
      str = str.replace(re, data[p]);
    }
    return str;
  };

  /**
   * createCard
   *
   * @method faker.helpers.createCard
   */
  self.createCard = function () {
      return {
          "name": faker.name.findName(),
          "username": faker.internet.userName(),
          "email": faker.internet.email(),
          "address": {
              "streetA": faker.address.streetName(),
              "streetB": faker.address.streetAddress(),
              "streetC": faker.address.streetAddress(true),
              "streetD": faker.address.secondaryAddress(),
              "city": faker.address.city(),
              "state": faker.address.state(),
              "country": faker.address.country(),
              "zipcode": faker.address.zipCode(),
              "geo": {
                  "lat": faker.address.latitude(),
                  "lng": faker.address.longitude()
              }
          },
          "phone": faker.phone.phoneNumber(),
          "website": faker.internet.domainName(),
          "company": {
              "name": faker.company.companyName(),
              "catchPhrase": faker.company.catchPhrase(),
              "bs": faker.company.bs()
          },
          "posts": [
              {
                  "words": faker.lorem.words(),
                  "sentence": faker.lorem.sentence(),
                  "sentences": faker.lorem.sentences(),
                  "paragraph": faker.lorem.paragraph()
              },
              {
                  "words": faker.lorem.words(),
                  "sentence": faker.lorem.sentence(),
                  "sentences": faker.lorem.sentences(),
                  "paragraph": faker.lorem.paragraph()
              },
              {
                  "words": faker.lorem.words(),
                  "sentence": faker.lorem.sentence(),
                  "sentences": faker.lorem.sentences(),
                  "paragraph": faker.lorem.paragraph()
              }
          ],
          "accountHistory": [faker.helpers.createTransaction(), faker.helpers.createTransaction(), faker.helpers.createTransaction()]
      };
  };

  /**
   * contextualCard
   *
   * @method faker.helpers.contextualCard
   */
  self.contextualCard = function () {
    var name = faker.name.firstName(),
        userName = faker.internet.userName(name);
    return {
        "name": name,
        "username": userName,
        "avatar": faker.internet.avatar(),
        "email": faker.internet.email(userName),
        "dob": faker.date.past(50, new Date("Sat Sep 20 1992 21:35:02 GMT+0200 (CEST)")),
        "phone": faker.phone.phoneNumber(),
        "address": {
            "street": faker.address.streetName(true),
            "suite": faker.address.secondaryAddress(),
            "city": faker.address.city(),
            "zipcode": faker.address.zipCode(),
            "geo": {
                "lat": faker.address.latitude(),
                "lng": faker.address.longitude()
            }
        },
        "website": faker.internet.domainName(),
        "company": {
            "name": faker.company.companyName(),
            "catchPhrase": faker.company.catchPhrase(),
            "bs": faker.company.bs()
        }
    };
  };


  /**
   * userCard
   *
   * @method faker.helpers.userCard
   */
  self.userCard = function () {
      return {
          "name": faker.name.findName(),
          "username": faker.internet.userName(),
          "email": faker.internet.email(),
          "address": {
              "street": faker.address.streetName(true),
              "suite": faker.address.secondaryAddress(),
              "city": faker.address.city(),
              "zipcode": faker.address.zipCode(),
              "geo": {
                  "lat": faker.address.latitude(),
                  "lng": faker.address.longitude()
              }
          },
          "phone": faker.phone.phoneNumber(),
          "website": faker.internet.domainName(),
          "company": {
              "name": faker.company.companyName(),
              "catchPhrase": faker.company.catchPhrase(),
              "bs": faker.company.bs()
          }
      };
  };

  /**
   * createTransaction
   *
   * @method faker.helpers.createTransaction
   */
  self.createTransaction = function(){
    return {
      "amount" : faker.finance.amount(),
      "date" : new Date(2012, 1, 2),  //TODO: add a ranged date method
      "business": faker.company.companyName(),
      "name": [faker.finance.accountName(), faker.finance.mask()].join(' '),
      "type" : self.randomize(faker.definitions.finance.transaction_type),
      "account" : faker.finance.account()
    };
  };

  return self;

};


/*
String.prototype.capitalize = function () { //v1.0
    return this.replace(/\w+/g, function (a) {
        return a.charAt(0).toUpperCase() + a.substr(1).toLowerCase();
    });
};
*/

module['exports'] = Helpers;

},{}],270:[function(require,module,exports){
module["exports"] = {
  alpha: [
    'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'
  ],
  pattern10: [
    "01", "02", "03", "04", "05", "06", "07", "08", "09"
  ],
  pattern100: [
    "001", "002", "003", "004", "005", "006", "007", "008", "009"
  ],
  toDigitString: function (str) {
      return str.replace(/[A-Z]/gi, function(match) {
          return match.toUpperCase().charCodeAt(0) - 55;
      });
  },
  mod97: function (digitStr) {
      var m = 0;
      for (var i = 0; i < digitStr.length; i++) {
          m = ((m * 10) + (digitStr[i] |0)) % 97;
      }
      return m;
  },
  formats: [
    {
      country: "AL",
      total: 28,
      bban: [
        {
          type: "n",
          count: 8
        },
        {
          type: "c",
          count: 16
        }
      ],
      format: "ALkk bbbs sssx cccc cccc cccc cccc"
    },
    {
      country: "AD",
      total: 24,
      bban: [
        {
          type: "n",
          count: 8
        },
        {
          type: "c",
          count: 12
        }
      ],
      format: "ADkk bbbb ssss cccc cccc cccc"
    },
    {
      country: "AT",
      total: 20,
      bban: [
        {
          type: "n",
          count: 5
        },
        {
          type: "n",
          count: 11
        }
      ],
      format: "ATkk bbbb bccc cccc cccc"
    },
    {
      country: "AZ",
      total: 28,
      bban: [
        {
          type: "c",
          count: 4
        },
        {
          type: "n",
          count: 20
        }
      ],
      format: "AZkk bbbb cccc cccc cccc cccc cccc"
    },
    {
      country: "BH",
      total: 22,
      bban: [
        {
          type: "a",
          count: 4
        },
        {
          type: "c",
          count: 14
        }
      ],
      format: "BHkk bbbb cccc cccc cccc cc"
    },
    {
      country: "BE",
      total: 16,
      bban: [
        {
          type: "n",
          count: 3
        },
        {
          type: "n",
          count: 9
        }
      ],
      format: "BEkk bbbc cccc ccxx"
    },
    {
      country: "BA",
      total: 20,
      bban: [
        {
          type: "n",
          count: 6
        },
        {
          type: "n",
          count: 10
        }
      ],
      format: "BAkk bbbs sscc cccc ccxx"
    },
    {
      country: "BR",
      total: 29,
      bban: [
        {
          type: "n",
          count: 13
        },
        {
          type: "n",
          count: 10
        },
        {
          type: "a",
          count: 1
        },
        {
          type: "c",
          count: 1
        }
      ],
      format: "BRkk bbbb bbbb ssss sccc cccc ccct n"
    },
    {
      country: "BG",
      total: 22,
      bban: [
        {
          type: "a",
          count: 4
        },
        {
          type: "n",
          count: 6
        },
        {
          type: "c",
          count: 8
        }
      ],
      format: "BGkk bbbb ssss ddcc cccc cc"
    },
    {
      country: "CR",
      total: 21,
      bban: [
        {
          type: "n",
          count: 3
        },
        {
          type: "n",
          count: 14
        }
      ],
      format: "CRkk bbbc cccc cccc cccc c"
    },
    {
      country: "HR",
      total: 21,
      bban: [
        {
          type: "n",
          count: 7
        },
        {
          type: "n",
          count: 10
        }
      ],
      format: "HRkk bbbb bbbc cccc cccc c"
    },
    {
      country: "CY",
      total: 28,
      bban: [
        {
          type: "n",
          count: 8
        },
        {
          type: "c",
          count: 16
        }
      ],
      format: "CYkk bbbs ssss cccc cccc cccc cccc"
    },
    {
      country: "CZ",
      total: 24,
      bban: [
        {
          type: "n",
          count: 10
        },
        {
          type: "n",
          count: 10
        }
      ],
      format: "CZkk bbbb ssss sscc cccc cccc"
    },
    {
      country: "DK",
      total: 18,
      bban: [
        {
          type: "n",
          count: 4
        },
        {
          type: "n",
          count: 10
        }
      ],
      format: "DKkk bbbb cccc cccc cc"
    },
    {
      country: "DO",
      total: 28,
      bban: [
        {
          type: "a",
          count: 4
        },
        {
          type: "n",
          count: 20
        }
      ],
      format: "DOkk bbbb cccc cccc cccc cccc cccc"
    },
    {
      country: "TL",
      total: 23,
      bban: [
        {
          type: "n",
          count: 3
        },
        {
          type: "n",
          count: 16
        }
      ],
      format: "TLkk bbbc cccc cccc cccc cxx"
    },
    {
      country: "EE",
      total: 20,
      bban: [
        {
          type: "n",
          count: 4
        },
        {
          type: "n",
          count: 12
        }
      ],
      format: "EEkk bbss cccc cccc cccx"
    },
    {
      country: "FO",
      total: 18,
      bban: [
        {
          type: "n",
          count: 4
        },
        {
          type: "n",
          count: 10
        }
      ],
      format: "FOkk bbbb cccc cccc cx"
    },
    {
      country: "FI",
      total: 18,
      bban: [
        {
          type: "n",
          count: 6
        },
        {
          type: "n",
          count: 8
        }
      ],
      format: "FIkk bbbb bbcc cccc cx"
    },
    {
      country: "FR",
      total: 27,
      bban: [
        {
          type: "n",
          count: 10
        },
        {
          type: "c",
          count: 11
        },
        {
          type: "n",
          count: 2
        }
      ],
      format: "FRkk bbbb bggg ggcc cccc cccc cxx"
    },
    {
      country: "GE",
      total: 22,
      bban: [
        {
          type: "c",
          count: 2
        },
        {
          type: "n",
          count: 16
        }
      ],
      format: "GEkk bbcc cccc cccc cccc cc"
    },
    {
      country: "DE",
      total: 22,
      bban: [
        {
          type: "n",
          count: 8
        },
        {
          type: "n",
          count: 10
        }
      ],
      format: "DEkk bbbb bbbb cccc cccc cc"
    },
    {
      country: "GI",
      total: 23,
      bban: [
        {
          type: "a",
          count: 4
        },
        {
          type: "c",
          count: 15
        }
      ],
      format: "GIkk bbbb cccc cccc cccc ccc"
    },
    {
      country: "GR",
      total: 27,
      bban: [
        {
          type: "n",
          count: 7
        },
        {
          type: "c",
          count: 16
        }
      ],
      format: "GRkk bbbs sssc cccc cccc cccc ccc"
    },
    {
      country: "GL",
      total: 18,
      bban: [
        {
          type: "n",
          count: 4
        },
        {
          type: "n",
          count: 10
        }
      ],
      format: "GLkk bbbb cccc cccc cc"
    },
    {
      country: "GT",
      total: 28,
      bban: [
        {
          type: "c",
          count: 4
        },
        {
          type: "c",
          count: 4
        },
        {
          type: "c",
          count: 16
        }
      ],
      format: "GTkk bbbb mmtt cccc cccc cccc cccc"
    },
    {
      country: "HU",
      total: 28,
      bban: [
        {
          type: "n",
          count: 8
        },
        {
          type: "n",
          count: 16
        }
      ],
      format: "HUkk bbbs sssk cccc cccc cccc cccx"
    },
    {
      country: "IS",
      total: 26,
      bban: [
        {
          type: "n",
          count: 6
        },
        {
          type: "n",
          count: 16
        }
      ],
      format: "ISkk bbbb sscc cccc iiii iiii ii"
    },
    {
      country: "IE",
      total: 22,
      bban: [
        {
          type: "c",
          count: 4
        },
        {
          type: "n",
          count: 6
        },
        {
          type: "n",
          count: 8
        }
      ],
      format: "IEkk aaaa bbbb bbcc cccc cc"
    },
    {
      country: "IL",
      total: 23,
      bban: [
        {
          type: "n",
          count: 6
        },
        {
          type: "n",
          count: 13
        }
      ],
      format: "ILkk bbbn nncc cccc cccc ccc"
    },
    {
      country: "IT",
      total: 27,
      bban: [
        {
          type: "a",
          count: 1
        },
        {
          type: "n",
          count: 10
        },
        {
          type: "c",
          count: 12
        }
      ],
      format: "ITkk xaaa aabb bbbc cccc cccc ccc"
    },
    {
      country: "JO",
      total: 30,
      bban: [
        {
          type: "a",
          count: 4
        },
        {
          type: "n",
          count: 4
        },
        {
          type: "n",
          count: 18
        }
      ],
      format: "JOkk bbbb nnnn cccc cccc cccc cccc cc"
    },
    {
      country: "KZ",
      total: 20,
      bban: [
        {
          type: "n",
          count: 3
        },
        {
          type: "c",
          count: 13
        }
      ],
      format: "KZkk bbbc cccc cccc cccc"
    },
    {
      country: "XK",
      total: 20,
      bban: [
        {
          type: "n",
          count: 4
        },
        {
          type: "n",
          count: 12
        }
      ],
      format: "XKkk bbbb cccc cccc cccc"
    },
    {
      country: "KW",
      total: 30,
      bban: [
        {
          type: "a",
          count: 4
        },
        {
          type: "c",
          count: 22
        }
      ],
      format: "KWkk bbbb cccc cccc cccc cccc cccc cc"
    },
    {
      country: "LV",
      total: 21,
      bban: [
        {
          type: "a",
          count: 4
        },
        {
          type: "c",
          count: 13
        }
      ],
      format: "LVkk bbbb cccc cccc cccc c"
    },
    {
      country: "LB",
      total: 28,
      bban: [
        {
          type: "n",
          count: 4
        },
        {
          type: "c",
          count: 20
        }
      ],
      format: "LBkk bbbb cccc cccc cccc cccc cccc"
    },
    {
      country: "LI",
      total: 21,
      bban: [
        {
          type: "n",
          count: 5
        },
        {
          type: "c",
          count: 12
        }
      ],
      format: "LIkk bbbb bccc cccc cccc c"
    },
    {
      country: "LT",
      total: 20,
      bban: [
        {
          type: "n",
          count: 5
        },
        {
          type: "n",
          count: 11
        }
      ],
      format: "LTkk bbbb bccc cccc cccc"
    },
    {
      country: "LU",
      total: 20,
      bban: [
        {
          type: "n",
          count: 3
        },
        {
          type: "c",
          count: 13
        }
      ],
      format: "LUkk bbbc cccc cccc cccc"
    },
    {
      country: "MK",
      total: 19,
      bban: [
        {
          type: "n",
          count: 3
        },
        {
          type: "c",
          count: 10
        },
        {
          type: "n",
          count: 2
        }
      ],
      format: "MKkk bbbc cccc cccc cxx"
    },
    {
      country: "MT",
      total: 31,
      bban: [
        {
          type: "a",
          count: 4
        },
        {
          type: "n",
          count: 5
        },
        {
          type: "c",
          count: 18
        }
      ],
      format: "MTkk bbbb ssss sccc cccc cccc cccc ccc"
    },
    {
      country: "MR",
      total: 27,
      bban: [
        {
          type: "n",
          count: 10
        },
        {
          type: "n",
          count: 13
        }
      ],
      format: "MRkk bbbb bsss sscc cccc cccc cxx"
    },
    {
      country: "MU",
      total: 30,
      bban: [
        {
          type: "a",
          count: 4
        },
        {
          type: "n",
          count: 4
        },
        {
          type: "n",
          count: 15
        },
        {
          type: "a",
          count: 3
        }
      ],
      format: "MUkk bbbb bbss cccc cccc cccc 000d dd"
    },
    {
      country: "MC",
      total: 27,
      bban: [
        {
          type: "n",
          count: 10
        },
        {
          type: "c",
          count: 11
        },
        {
          type: "n",
          count: 2
        }
      ],
      format: "MCkk bbbb bsss sscc cccc cccc cxx"
    },
    {
      country: "MD",
      total: 24,
      bban: [
        {
          type: "c",
          count: 2
        },
        {
          type: "c",
          count: 18
        }
      ],
      format: "MDkk bbcc cccc cccc cccc cccc"
    },
    {
      country: "ME",
      total: 22,
      bban: [
        {
          type: "n",
          count: 3
        },
        {
          type: "n",
          count: 15
        }
      ],
      format: "MEkk bbbc cccc cccc cccc xx"
    },
    {
      country: "NL",
      total: 18,
      bban: [
        {
          type: "a",
          count: 4
        },
        {
          type: "n",
          count: 10
        }
      ],
      format: "NLkk bbbb cccc cccc cc"
    },
    {
      country: "NO",
      total: 15,
      bban: [
        {
          type: "n",
          count: 4
        },
        {
          type: "n",
          count: 7
        }
      ],
      format: "NOkk bbbb cccc ccx"
    },
    {
      country: "PK",
      total: 24,
      bban: [
        {
          type: "c",
          count: 4
        },
        {
          type: "n",
          count: 16
        }
      ],
      format: "PKkk bbbb cccc cccc cccc cccc"
    },
    {
      country: "PS",
      total: 29,
      bban: [
        {
          type: "c",
          count: 4
        },
        {
          type: "n",
          count: 9
        },
        {
          type: "n",
          count: 12
        }
      ],
      format: "PSkk bbbb xxxx xxxx xccc cccc cccc c"
    },
    {
      country: "PL",
      total: 28,
      bban: [
        {
          type: "n",
          count: 8
        },
        {
          type: "n",
          count: 16
        }
      ],
      format: "PLkk bbbs sssx cccc cccc cccc cccc"
    },
    {
      country: "PT",
      total: 25,
      bban: [
        {
          type: "n",
          count: 8
        },
        {
          type: "n",
          count: 13
        }
      ],
      format: "PTkk bbbb ssss cccc cccc cccx x"
    },
    {
      country: "QA",
      total: 29,
      bban: [
        {
          type: "a",
          count: 4
        },
        {
          type: "c",
          count: 21
        }
      ],
      format: "QAkk bbbb cccc cccc cccc cccc cccc c"
    },
    {
      country: "RO",
      total: 24,
      bban: [
        {
          type: "a",
          count: 4
        },
        {
          type: "c",
          count: 16
        }
      ],
      format: "ROkk bbbb cccc cccc cccc cccc"
    },
    {
      country: "SM",
      total: 27,
      bban: [
        {
          type: "a",
          count: 1
        },
        {
          type: "n",
          count: 10
        },
        {
          type: "c",
          count: 12
        }
      ],
      format: "SMkk xaaa aabb bbbc cccc cccc ccc"
    },
    {
      country: "SA",
      total: 24,
      bban: [
        {
          type: "n",
          count: 2
        },
        {
          type: "c",
          count: 18
        }
      ],
      format: "SAkk bbcc cccc cccc cccc cccc"
    },
    {
      country: "RS",
      total: 22,
      bban: [
        {
          type: "n",
          count: 3
        },
        {
          type: "n",
          count: 15
        }
      ],
      format: "RSkk bbbc cccc cccc cccc xx"
    },
    {
      country: "SK",
      total: 24,
      bban: [
        {
          type: "n",
          count: 10
        },
        {
          type: "n",
          count: 10
        }
      ],
      format: "SKkk bbbb ssss sscc cccc cccc"
    },
    {
      country: "SI",
      total: 19,
      bban: [
        {
          type: "n",
          count: 5
        },
        {
          type: "n",
          count: 10
        }
      ],
      format: "SIkk bbss sccc cccc cxx"
    },
    {
      country: "ES",
      total: 24,
      bban: [
        {
          type: "n",
          count: 10
        },
        {
          type: "n",
          count: 10
        }
      ],
      format: "ESkk bbbb gggg xxcc cccc cccc"
    },
    {
      country: "SE",
      total: 24,
      bban: [
        {
          type: "n",
          count: 3
        },
        {
          type: "n",
          count: 17
        }
      ],
      format: "SEkk bbbc cccc cccc cccc cccc"
    },
    {
      country: "CH",
      total: 21,
      bban: [
        {
          type: "n",
          count: 5
        },
        {
          type: "c",
          count: 12
        }
      ],
      format: "CHkk bbbb bccc cccc cccc c"
    },
    {
      country: "TN",
      total: 24,
      bban: [
        {
          type: "n",
          count: 5
        },
        {
          type: "n",
          count: 15
        }
      ],
      format: "TNkk bbss sccc cccc cccc cccc"
    },
    {
      country: "TR",
      total: 26,
      bban: [
        {
          type: "n",
          count: 5
        },
        {
          type: "c",
          count: 1
        },
        {
          type: "c",
          count: 16
        }
      ],
      format: "TRkk bbbb bxcc cccc cccc cccc cc"
    },
    {
      country: "AE",
      total: 23,
      bban: [
        {
          type: "n",
          count: 3
        },
        {
          type: "n",
          count: 16
        }
      ],
      format: "AEkk bbbc cccc cccc cccc ccc"
    },
    {
      country: "GB",
      total: 22,
      bban: [
        {
          type: "a",
          count: 4
        },
        {
          type: "n",
          count: 6
        },
        {
          type: "n",
          count: 8
        }
      ],
      format: "GBkk bbbb ssss sscc cccc cc"
    },
    {
      country: "VG",
      total: 24,
      bban: [
        {
          type: "c",
          count: 4
        },
        {
          type: "n",
          count: 16
        }
      ],
      format: "VGkk bbbb cccc cccc cccc cccc"
    }
  ],
  iso3166: [
    "AC", "AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN", "AO", "AQ", "AR", "AS",
    "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI",
    "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BU", "BV", "BW", "BY",
    "BZ", "CA", "CC", "CD", "CE", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN",
    "CO", "CP", "CR", "CS", "CS", "CU", "CV", "CW", "CX", "CY", "CZ", "DD", "DE",
    "DG", "DJ", "DK", "DM", "DO", "DZ", "EA", "EC", "EE", "EG", "EH", "ER", "ES",
    "ET", "EU", "FI", "FJ", "FK", "FM", "FO", "FR", "FX", "GA", "GB", "GD", "GE",
    "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU",
    "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "IC", "ID", "IE", "IL", "IM",
    "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH",
    "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK",
    "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH",
    "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW",
    "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR",
    "NT", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN",
    "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB",
    "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR",
    "SS", "ST", "SU", "SV", "SX", "SY", "SZ", "TA", "TC", "TD", "TF", "TG", "TH",
    "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG",
    "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS",
    "YE", "YT", "YU", "ZA", "ZM", "ZR", "ZW"
  ]
}
},{}],271:[function(require,module,exports){
/**
 *
 * @namespace faker.image
 */
var Image = function (faker) {

  var self = this;

  /**
   * image
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.image
   */
  self.image = function (width, height, randomize) {
    var categories = ["abstract", "animals", "business", "cats", "city", "food", "nightlife", "fashion", "people", "nature", "sports", "technics", "transport"];
    return self[faker.random.arrayElement(categories)](width, height, randomize);
  };
  /**
   * avatar
   *
   * @method faker.image.avatar
   */
  self.avatar = function () {
    return faker.internet.avatar();
  };
  /**
   * imageUrl
   *
   * @param {number} width
   * @param {number} height
   * @param {string} category
   * @param {boolean} randomize
   * @method faker.image.imageUrl
   */
  self.imageUrl = function (width, height, category, randomize, https) {
      var width = width || 640;
      var height = height || 480;
      var protocol = 'http://';
      if (typeof https !== 'undefined' && https === true) {
        protocol = 'https://';
      }
      var url = protocol + 'lorempixel.com/' + width + '/' + height;
      if (typeof category !== 'undefined') {
        url += '/' + category;
      }

      if (randomize) {
        url += '?' + faker.random.number()
      }

      return url;
  };
  /**
   * abstract
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.abstract
   */
  self.abstract = function (width, height, randomize) {
    return faker.image.imageUrl(width, height, 'abstract', randomize);
  };
  /**
   * animals
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.animals
   */
  self.animals = function (width, height, randomize) {
    return faker.image.imageUrl(width, height, 'animals', randomize);
  };
  /**
   * business
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.business
   */
  self.business = function (width, height, randomize) {
    return faker.image.imageUrl(width, height, 'business', randomize);
  };
  /**
   * cats
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.cats
   */
  self.cats = function (width, height, randomize) {
    return faker.image.imageUrl(width, height, 'cats', randomize);
  };
  /**
   * city
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.city
   */
  self.city = function (width, height, randomize) {
    return faker.image.imageUrl(width, height, 'city', randomize);
  };
  /**
   * food
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.food
   */
  self.food = function (width, height, randomize) {
    return faker.image.imageUrl(width, height, 'food', randomize);
  };
  /**
   * nightlife
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.nightlife
   */
  self.nightlife = function (width, height, randomize) {
    return faker.image.imageUrl(width, height, 'nightlife', randomize);
  };
  /**
   * fashion
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.fashion
   */
  self.fashion = function (width, height, randomize) {
    return faker.image.imageUrl(width, height, 'fashion', randomize);
  };
  /**
   * people
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.people
   */
  self.people = function (width, height, randomize) {
    return faker.image.imageUrl(width, height, 'people', randomize);
  };
  /**
   * nature
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.nature
   */
  self.nature = function (width, height, randomize) {
    return faker.image.imageUrl(width, height, 'nature', randomize);
  };
  /**
   * sports
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.sports
   */
  self.sports = function (width, height, randomize) {
    return faker.image.imageUrl(width, height, 'sports', randomize);
  };
  /**
   * technics
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.technics
   */
  self.technics = function (width, height, randomize) {
    return faker.image.imageUrl(width, height, 'technics', randomize);
  };
  /**
   * transport
   *
   * @param {number} width
   * @param {number} height
   * @param {boolean} randomize
   * @method faker.image.transport
   */
  self.transport = function (width, height, randomize) {
    return faker.image.imageUrl(width, height, 'transport', randomize);
  };
  /**
   * dataUri
   *
   * @param {number} width
   * @param {number} height
   * @method faker.image.dataurl
   */
  self.dataUri = function (width, height) {
    var rawPrefix = 'data:image/svg+xml;charset=UTF-8,';
    var svgString = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" baseProfile="full" width="' + width + '" height="' + height + '"> <rect width="100%" height="100%" fill="grey"/>  <text x="0" y="20" font-size="20" text-anchor="start" fill="white">' + width + 'x' + height + '</text> </svg>';
    return rawPrefix + encodeURIComponent(svgString);
  };
}

module["exports"] = Image;
},{}],272:[function(require,module,exports){
/*

   this index.js file is used for including the faker library as a CommonJS module, instead of a bundle

   you can include the faker library into your existing node.js application by requiring the entire /faker directory

    var faker = require(./faker);
    var randomName = faker.name.findName();

   you can also simply include the "faker.js" file which is the auto-generated bundled version of the faker library

    var faker = require(./customAppPath/faker);
    var randomName = faker.name.findName();


  if you plan on modifying the faker library you should be performing your changes in the /lib/ directory

*/

/**
 *
 * @namespace faker
 */
function Faker (opts) {

  var self = this;

  opts = opts || {};

  // assign options
  var locales = self.locales || opts.locales || {};
  var locale = self.locale || opts.locale || "en";
  var localeFallback = self.localeFallback || opts.localeFallback || "en";

  self.locales = locales;
  self.locale = locale;
  self.localeFallback = localeFallback;

  self.definitions = {};

  function bindAll(obj) {
      Object.keys(obj).forEach(function(meth) {
          if (typeof obj[meth] === 'function') {
              obj[meth] = obj[meth].bind(obj);
          }
      });
      return obj;
  }

  var Fake = require('./fake');
  self.fake = new Fake(self).fake;

  var Random = require('./random');
  self.random = bindAll(new Random(self));

  var Helpers = require('./helpers');
  self.helpers = new Helpers(self);

  var Name = require('./name');
  self.name = bindAll(new Name(self));

  var Address = require('./address');
  self.address = bindAll(new Address(self));

  var Company = require('./company');
  self.company = bindAll(new Company(self));

  var Finance = require('./finance');
  self.finance = bindAll(new Finance(self));

  var Image = require('./image');
  self.image = bindAll(new Image(self));

  var Lorem = require('./lorem');
  self.lorem = bindAll(new Lorem(self));

  var Hacker = require('./hacker');
  self.hacker = bindAll(new Hacker(self));

  var Internet = require('./internet');
  self.internet = bindAll(new Internet(self));

  var Database = require('./database');
  self.database = bindAll(new Database(self));

  var Phone = require('./phone_number');
  self.phone = bindAll(new Phone(self));

  var _Date = require('./date');
  self.date = bindAll(new _Date(self));

  var Commerce = require('./commerce');
  self.commerce = bindAll(new Commerce(self));

  var System = require('./system');
  self.system = bindAll(new System(self));

  var _definitions = {
    "name": ["first_name", "last_name", "prefix", "suffix", "title", "male_first_name", "female_first_name", "male_middle_name", "female_middle_name", "male_last_name", "female_last_name"],
    "address": ["city_prefix", "city_suffix", "street_suffix", "county", "country", "country_code", "state", "state_abbr", "street_prefix", "postcode"],
    "company": ["adjective", "noun", "descriptor", "bs_adjective", "bs_noun", "bs_verb", "suffix"],
    "lorem": ["words"],
    "hacker": ["abbreviation", "adjective", "noun", "verb", "ingverb"],
    "phone_number": ["formats"],
    "finance": ["account_type", "transaction_type", "currency", "iban"],
    "internet": ["avatar_uri", "domain_suffix", "free_email", "example_email", "password"],
    "commerce": ["color", "department", "product_name", "price", "categories"],
    "database": ["collation", "column", "engine", "type"],
    "system": ["mimeTypes"],
    "date": ["month", "weekday"],
    "title": "",
    "separator": ""
  };

  // Create a Getter for all definitions.foo.bar properties
  Object.keys(_definitions).forEach(function(d){
    if (typeof self.definitions[d] === "undefined") {
      self.definitions[d] = {};
    }

    if (typeof _definitions[d] === "string") {
        self.definitions[d] = _definitions[d];
      return;
    }

    _definitions[d].forEach(function(p){
      Object.defineProperty(self.definitions[d], p, {
        get: function () {
          if (typeof self.locales[self.locale][d] === "undefined" || typeof self.locales[self.locale][d][p] === "undefined") {
            // certain localization sets contain less data then others.
            // in the case of a missing definition, use the default localeFallback to substitute the missing set data
            // throw new Error('unknown property ' + d + p)
            return self.locales[localeFallback][d][p];
          } else {
            // return localized data
            return self.locales[self.locale][d][p];
          }
        }
      });
    });
  });

};

Faker.prototype.seed = function(value) {
  var Random = require('./random');
  this.seedValue = value;
  this.random = new Random(this, this.seedValue);
}
module['exports'] = Faker;

},{"./address":261,"./commerce":262,"./company":263,"./database":264,"./date":265,"./fake":266,"./finance":267,"./hacker":268,"./helpers":269,"./image":271,"./internet":273,"./lorem":1301,"./name":1302,"./phone_number":1303,"./random":1304,"./system":1305}],273:[function(require,module,exports){
var random_ua = require('../vendor/user-agent');

/**
 *
 * @namespace faker.internet
 */
var Internet = function (faker) {
  var self = this;
  /**
   * avatar
   *
   * @method faker.internet.avatar
   */
  self.avatar = function () {
      return faker.random.arrayElement(faker.definitions.internet.avatar_uri);
  };

  self.avatar.schema = {
    "description": "Generates a URL for an avatar.",
    "sampleResults": ["https://s3.amazonaws.com/uifaces/faces/twitter/igorgarybaldi/128.jpg"]
  };

  /**
   * email
   *
   * @method faker.internet.email
   * @param {string} firstName
   * @param {string} lastName
   * @param {string} provider
   */
  self.email = function (firstName, lastName, provider) {
      provider = provider || faker.random.arrayElement(faker.definitions.internet.free_email);
      return  faker.helpers.slugify(faker.internet.userName(firstName, lastName)) + "@" + provider;
  };

  self.email.schema = {
    "description": "Generates a valid email address based on optional input criteria",
    "sampleResults": ["foo.bar@gmail.com"],
    "properties": {
      "firstName": {
        "type": "string",
        "required": false,
        "description": "The first name of the user"
      },
      "lastName": {
        "type": "string",
        "required": false,
        "description": "The last name of the user"
      },
      "provider": {
        "type": "string",
        "required": false,
        "description": "The domain of the user"
      }
    }
  };
  /**
   * exampleEmail
   *
   * @method faker.internet.exampleEmail
   * @param {string} firstName
   * @param {string} lastName
   */
  self.exampleEmail = function (firstName, lastName) {
      var provider = faker.random.arrayElement(faker.definitions.internet.example_email);
      return self.email(firstName, lastName, provider);
  };

  /**
   * userName
   *
   * @method faker.internet.userName
   * @param {string} firstName
   * @param {string} lastName
   */
  self.userName = function (firstName, lastName) {
      var result;
      firstName = firstName || faker.name.firstName();
      lastName = lastName || faker.name.lastName();
      switch (faker.random.number(2)) {
      case 0:
          result = firstName + faker.random.number(99);
          break;
      case 1:
          result = firstName + faker.random.arrayElement([".", "_"]) + lastName;
          break;
      case 2:
          result = firstName + faker.random.arrayElement([".", "_"]) + lastName + faker.random.number(99);
          break;
      }
      result = result.toString().replace(/'/g, "");
      result = result.replace(/ /g, "");
      return result;
  };

  self.userName.schema = {
    "description": "Generates a username based on one of several patterns. The pattern is chosen randomly.",
    "sampleResults": [
      "Kirstin39",
      "Kirstin.Smith",
      "Kirstin.Smith39",
      "KirstinSmith",
      "KirstinSmith39",
    ],
    "properties": {
      "firstName": {
        "type": "string",
        "required": false,
        "description": "The first name of the user"
      },
      "lastName": {
        "type": "string",
        "required": false,
        "description": "The last name of the user"
      }
    }
  };

  /**
   * protocol
   *
   * @method faker.internet.protocol
   */
  self.protocol = function () {
      var protocols = ['http','https'];
      return faker.random.arrayElement(protocols);
  };

  self.protocol.schema = {
    "description": "Randomly generates http or https",
    "sampleResults": ["https", "http"]
  };

  /**
   * url
   *
   * @method faker.internet.url
   */
  self.url = function () {
      return faker.internet.protocol() + '://' + faker.internet.domainName();
  };

  self.url.schema = {
    "description": "Generates a random URL. The URL could be secure or insecure.",
    "sampleResults": [
      "http://rashawn.name",
      "https://rashawn.name"
    ]
  };

  /**
   * domainName
   *
   * @method faker.internet.domainName
   */
  self.domainName = function () {
      return faker.internet.domainWord() + "." + faker.internet.domainSuffix();
  };

  self.domainName.schema = {
    "description": "Generates a random domain name.",
    "sampleResults": ["marvin.org"]
  };

  /**
   * domainSuffix
   *
   * @method faker.internet.domainSuffix
   */
  self.domainSuffix = function () {
      return faker.random.arrayElement(faker.definitions.internet.domain_suffix);
  };

  self.domainSuffix.schema = {
    "description": "Generates a random domain suffix.",
    "sampleResults": ["net"]
  };

  /**
   * domainWord
   *
   * @method faker.internet.domainWord
   */
  self.domainWord = function () {
      return faker.name.firstName().replace(/([\\~#&*{}/:<>?|\"'])/ig, '').toLowerCase();
  };

  self.domainWord.schema = {
    "description": "Generates a random domain word.",
    "sampleResults": ["alyce"]
  };

  /**
   * ip
   *
   * @method faker.internet.ip
   */
  self.ip = function () {
      var randNum = function () {
          return (faker.random.number(255)).toFixed(0);
      };

      var result = [];
      for (var i = 0; i < 4; i++) {
          result[i] = randNum();
      }

      return result.join(".");
  };

  self.ip.schema = {
    "description": "Generates a random IP.",
    "sampleResults": ["97.238.241.11"]
  };

  /**
   * ipv6
   *
   * @method faker.internet.ipv6
   */
  self.ipv6 = function () {
      var randHash = function () {
          var result = "";
          for (var i = 0; i < 4; i++) {
            result += (faker.random.arrayElement(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"]));
          }
          return result
      };

      var result = [];
      for (var i = 0; i < 8; i++) {
        result[i] = randHash();
      }
      return result.join(":");
  };

  self.ipv6.schema = {
    "description": "Generates a random IPv6 address.",
    "sampleResults": ["2001:0db8:6276:b1a7:5213:22f1:25df:c8a0"]
  };

  /**
   * userAgent
   *
   * @method faker.internet.userAgent
   */
  self.userAgent = function () {
    return random_ua.generate();
  };

  self.userAgent.schema = {
    "description": "Generates a random user agent.",
    "sampleResults": ["Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10_7_5 rv:6.0; SL) AppleWebKit/532.0.1 (KHTML, like Gecko) Version/7.1.6 Safari/532.0.1"]
  };

  /**
   * color
   *
   * @method faker.internet.color
   * @param {number} baseRed255
   * @param {number} baseGreen255
   * @param {number} baseBlue255
   */
  self.color = function (baseRed255, baseGreen255, baseBlue255) {
      baseRed255 = baseRed255 || 0;
      baseGreen255 = baseGreen255 || 0;
      baseBlue255 = baseBlue255 || 0;
      // based on awesome response : http://stackoverflow.com/questions/43044/algorithm-to-randomly-generate-an-aesthetically-pleasing-color-palette
      var red = Math.floor((faker.random.number(256) + baseRed255) / 2);
      var green = Math.floor((faker.random.number(256) + baseGreen255) / 2);
      var blue = Math.floor((faker.random.number(256) + baseBlue255) / 2);
      var redStr = red.toString(16);
      var greenStr = green.toString(16);
      var blueStr = blue.toString(16);
      return '#' +
        (redStr.length === 1 ? '0' : '') + redStr +
        (greenStr.length === 1 ? '0' : '') + greenStr +
        (blueStr.length === 1 ? '0': '') + blueStr;

  };

  self.color.schema = {
    "description": "Generates a random hexadecimal color.",
    "sampleResults": ["#06267f"],
    "properties": {
      "baseRed255": {
        "type": "number",
        "required": false,
        "description": "The red value. Valid values are 0 - 255."
      },
      "baseGreen255": {
        "type": "number",
        "required": false,
        "description": "The green value. Valid values are 0 - 255."
      },
      "baseBlue255": {
        "type": "number",
        "required": false,
        "description": "The blue value. Valid values are 0 - 255."
      }
    }
  };

  /**
   * mac
   *
   * @method faker.internet.mac
   */
  self.mac = function(){
      var i, mac = "";
      for (i=0; i < 12; i++) {
          mac+= faker.random.number(15).toString(16);
          if (i%2==1 && i != 11) {
              mac+=":";
          }
      }
      return mac;
  };

  self.mac.schema = {
    "description": "Generates a random mac address.",
    "sampleResults": ["78:06:cc:ae:b3:81"]
  };

  /**
   * password
   *
   * @method faker.internet.password
   * @param {number} len
   * @param {boolean} memorable
   * @param {string} pattern
   * @param {string} prefix
   */
   self.password = function (len, memorable, pattern, prefix) {
     len = len || 15;
     if (typeof memorable === "undefined") {
       memorable = false;
     }
     /*
      * password-generator ( function )
      * Copyright(c) 2011-2013 Bermi Ferrer <bermi@bermilabs.com>
      * MIT Licensed
      */
     var consonant, letter, password, vowel;
     letter = /[a-zA-Z]$/;
     vowel = /[aeiouAEIOU]$/;
     consonant = /[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]$/;
     var _password = function (length, memorable, pattern, prefix) {
       var char, n;
       if (length == null) {
         length = 10;
       }
       if (memorable == null) {
         memorable = true;
       }
       if (pattern == null) {
         pattern = /\w/;
       }
       if (prefix == null) {
         prefix = '';
       }
       if (prefix.length >= length) {
         return prefix;
       }
       if (memorable) {
         if (prefix.match(consonant)) {
           pattern = vowel;
         } else {
           pattern = consonant;
         }
       }
       n = faker.random.number(94) + 33;
       char = String.fromCharCode(n);
       if (memorable) {
         char = char.toLowerCase();
       }
       if (!char.match(pattern)) {
         return _password(length, memorable, pattern, prefix);
       }
       return _password(length, memorable, pattern, "" + prefix + char);
     };
     return _password(len, memorable, pattern, prefix);
   }

  self.password.schema = {
    "description": "Generates a random password.",
    "sampleResults": [
      "AM7zl6Mg",
      "susejofe"
    ],
    "properties": {
      "length": {
        "type": "number",
        "required": false,
        "description": "The number of characters in the password."
      },
      "memorable": {
        "type": "boolean",
        "required": false,
        "description": "Whether a password should be easy to remember."
      },
      "pattern": {
        "type": "regex",
        "required": false,
        "description": "A regex to match each character of the password against. This parameter will be negated if the memorable setting is turned on."
      },
      "prefix": {
        "type": "string",
        "required": false,
        "description": "A value to prepend to the generated password. The prefix counts towards the length of the password."
      }
    }
  };

};


module["exports"] = Internet;

},{"../vendor/user-agent":1307}],274:[function(require,module,exports){
exports['az'] = require('./locales/az');
exports['cz'] = require('./locales/cz');
exports['de'] = require('./locales/de');
exports['de_AT'] = require('./locales/de_AT');
exports['de_CH'] = require('./locales/de_CH');
exports['en'] = require('./locales/en');
exports['en_AU'] = require('./locales/en_AU');
exports['en_BORK'] = require('./locales/en_BORK');
exports['en_CA'] = require('./locales/en_CA');
exports['en_GB'] = require('./locales/en_GB');
exports['en_IE'] = require('./locales/en_IE');
exports['en_IND'] = require('./locales/en_IND');
exports['en_US'] = require('./locales/en_US');
exports['en_au_ocker'] = require('./locales/en_au_ocker');
exports['es'] = require('./locales/es');
exports['es_MX'] = require('./locales/es_MX');
exports['fa'] = require('./locales/fa');
exports['fr'] = require('./locales/fr');
exports['fr_CA'] = require('./locales/fr_CA');
exports['ge'] = require('./locales/ge');
exports['id_ID'] = require('./locales/id_ID');
exports['it'] = require('./locales/it');
exports['ja'] = require('./locales/ja');
exports['ko'] = require('./locales/ko');
exports['nb_NO'] = require('./locales/nb_NO');
exports['nep'] = require('./locales/nep');
exports['nl'] = require('./locales/nl');
exports['pl'] = require('./locales/pl');
exports['pt_BR'] = require('./locales/pt_BR');
exports['ru'] = require('./locales/ru');
exports['sk'] = require('./locales/sk');
exports['sv'] = require('./locales/sv');
exports['tr'] = require('./locales/tr');
exports['uk'] = require('./locales/uk');
exports['vi'] = require('./locales/vi');
exports['zh_CN'] = require('./locales/zh_CN');
exports['zh_TW'] = require('./locales/zh_TW');

},{"./locales/az":299,"./locales/cz":338,"./locales/de":376,"./locales/de_AT":409,"./locales/de_CH":428,"./locales/en":508,"./locales/en_AU":540,"./locales/en_BORK":548,"./locales/en_CA":556,"./locales/en_GB":569,"./locales/en_IE":579,"./locales/en_IND":591,"./locales/en_US":603,"./locales/en_au_ocker":623,"./locales/es":655,"./locales/es_MX":699,"./locales/fa":718,"./locales/fr":744,"./locales/fr_CA":764,"./locales/ge":790,"./locales/id_ID":819,"./locales/it":856,"./locales/ja":878,"./locales/ko":899,"./locales/nb_NO":929,"./locales/nep":949,"./locales/nl":973,"./locales/pl":1013,"./locales/pt_BR":1042,"./locales/ru":1079,"./locales/sk":1119,"./locales/sv":1166,"./locales/tr":1192,"./locales/uk":1225,"./locales/vi":1252,"./locales/zh_CN":1275,"./locales/zh_TW":1294}],275:[function(require,module,exports){
module["exports"] = [
  "###"
];

},{}],276:[function(require,module,exports){
module["exports"] = [
  "#{Address.city_name}"
];

},{}],277:[function(require,module,exports){
module["exports"] = [
  "Acabdi",
  "Adam",
  "Ada",
  "Adr",
  "Astafa",
  "Asu",
  "Astara",
  "Bak",
  "Balakn",
  "Beylqan",
  "Brd",
  "Bilsuvar",
  "Cbrayl",
  "Clilabad",
  "Culfa",
  "Daksn",
  "Dlimmmdli",
  "Fzuli",
  "Gdby",
  "Gnc",
  "Goranboy",
  "Gyay",
  "Gygl",
  "Gytp",
  "Hacqabul",
  "Horadiz",
  "Xamaz",
  "Xankndi",
  "Xocal",
  "Xocavnd",
  "Xrdalan",
  "Xz",
  "Xudat",
  "mili",
  "smayll",
  "Klbcr",
  "Krdmir",
  "Qax",
  "Qazax",
  "Qbl",
  "Qobustan",
  "Qovlar",
  "Quba",
  "Qubadl",
  "Qusar",
  "Lan",
  "Lerik",
  "Lnkran",
  "Liman",
  "Masall",
  "Mingevir",
  "Naftalan",
  "Naxvan (hr)",
  "Neftala",
  "Ouz",
  "Ordubad",
  "Saatl",
  "Sabirabad",
  "Salyan",
  "Samux",
  "Siyzn",
  "Sumqayt",
  "abran",
  "ahbuz",
  "amax",
  "ki",
  "mkir",
  "rur",
  "irvan",
  "ua",
  "Trtr",
  "Tovuz",
  "Ucar",
  "Yardml",
  "Yevlax",
  "Zaqatala",
  "Zngilan",
  "Zrdab"
];

},{}],278:[function(require,module,exports){
module["exports"] = [
  "Akrotiri v Dekeliya",
  "Aland adalar",
  "Albaniya",
  "Almaniya",
  "Amerika Samoas",
  "Andorra",
  "Angilya",
  "Anqola",
  "Antiqua v Barbuda",
  "Argentina",
  "Aruba",
  "Avstraliya",
  "Avstriya",
  "Azrbaycan",
  "Baham adalar",
  "Banqlade",
  "Barbados",
  "Belika",
  "Beliz",
  "Belarus",
  "Benin",
  "Bermud adalar",
  "B",
  "AB",
  "Boliviya",
  "Bolqarstan",
  "Bosniya v Herseqovina",
  "Botsvana",
  "Byk Britaniya",
  "Braziliya",
  "Bruney",
  "Burkina-Faso",
  "Burundi",
  "Butan",
  "Bhreyn",
  "Cersi",
  "Cbli-Tariq",
  "CAR",
  "Cnubi Sudan",
  "Cnubi Koreya",
  "Cibuti",
  "ad",
  "exiya",
  "Monteneqro",
  "ili",
  "XR",
  "Danimarka",
  "Dominika",
  "Dominikan Respublikas",
  "Efiopiya",
  "Ekvador",
  "Ekvatorial Qvineya",
  "Eritreya",
  "Ermnistan",
  "Estoniya",
  "fqanstan",
  "lczair",
  "Farer adalar",
  "Flstin Dvlti",
  "Fici",
  "Kot-dvuar",
  "Filippin",
  "Finlandiya",
  "Folklend adalar",
  "Fransa",
  "Fransa Polineziyas",
  "Gernsi",
  "Grcstan",
  "Haiti",
  "Hindistan",
  "Honduras",
  "Honkonq",
  "Xorvatiya",
  "ndoneziya",
  "ordaniya",
  "raq",
  "ran",
  "rlandiya",
  "slandiya",
  "spaniya",
  "srail",
  "sve",
  "sver",
  "taliya",
  "Kabo-Verde",
  "Kamboca",
  "Kamerun",
  "Kanada",
  "Kayman adalar",
  "Keniya",
  "Kipr",
  "Kiribati",
  "Kokos adalar",
  "Kolumbiya",
  "Komor adalar",
  "Konqo Respublikas",
  "KDR",
  "Kosovo",
  "Kosta-Rika",
  "Kuba",
  "Kuk adalar",
  "Kveyt",
  "Qabon",
  "Qambiya",
  "Qana",
  "Qtr",
  "Qayana",
  "Qazaxstan",
  "Qrbi Sahara",
  "Qrzstan",
  "Qrenada",
  "Qrenlandiya",
  "Quam",
  "Qvatemala",
  "Qvineya",
  "Qvineya-Bisau",
  "Laos",
  "Latviya",
  "Lesoto",
  "Liberiya",
  "Litva",
  "Livan",
  "Liviya",
  "Lixtenteyn",
  "Lksemburq",
  "Macarstan",
  "Madaqaskar",
  "Makao",
  "Makedoniya",
  "Malavi",
  "Malayziya",
  "Maldiv adalar",
  "Mali",
  "Malta",
  "Marall adalar",
  "Mavriki",
  "Mavritaniya",
  "Mayotta",
  "Meksika",
  "Men adas",
  "Mrake",
  "MAR",
  "Mikroneziya",
  "Milad adas",
  "Misir",
  "Myanma",
  "Moldova",
  "Monako",
  "Monqolustan",
  "Montserrat",
  "Mozambik",
  "Mqdds Yelena, Askenson v Tristan-da-Kunya adalar",
  "Namibiya",
  "Nauru",
  "Nepal",
  "Niderland",
  "Niderland Antil adalar",
  "Niger",
  "Nigeriya",
  "Nikaraqua",
  "Niue",
  "Norfolk adas",
  "Norve",
  "Oman",
  "zbkistan",
  "Pakistan",
  "Palau",
  "Panama",
  "Papua-Yeni Qvineya",
  "Paraqvay",
  "Peru",
  "Pitkern adalar",
  "Pola",
  "Portuqaliya",
  "Prednestroviya",
  "Puerto-Riko",
  "Ruanda",
  "Rumniya",
  "Rusiya",
  "Salvador",
  "Samoa",
  "San-Marino",
  "San-Tome v Prinsipi",
  "Seneqal",
  "Sen-Bartelemi",
  "Sent-Kits v Nevis",
  "Sent-Lsiya",
  "Sen-Marten",
  "Sen-Pyer v Mikelon",
  "Sent-Vinsent v Qrenadina",
  "Serbiya",
  "Seyel adalar",
  "Sudiyy rbistan",
  "Sinqapur",
  "Slovakiya",
  "Sloveniya",
  "Solomon adalar",
  "Somali",
  "Somalilend",
  "Sudan",
  "Surinam",
  "Suriya",
  "Svazilend",
  "Syerra-Leone",
  "rqi Timor",
  "imali Marian adalar",
  "pisbergen v Yan-Mayen",
  "ri-Lanka",
  "Tacikistan",
  "Tanzaniya",
  "Tailand",
  "in Respublikas",
  "Trks v Kaykos adalar",
  "Tokelau",
  "Tonqa",
  "Toqo",
  "Trinidad v Tobaqo",
  "Tunis",
  "Tuvalu",
  "Trkiy",
  "Trkmnistan",
  "Ukrayna",
  "Uollis v Futuna",
  "Uqanda",
  "Uruqvay",
  "Vanuatu",
  "Vatikan",
  "Venesuela",
  "Amerika Virgin adalar",
  "Britaniya Virgin adalar",
  "Vyetnam",
  "Yamayka",
  "Yaponiya",
  "Yeni Kaledoniya",
  "Yeni Zelandiya",
  "Ymn",
  "Yunanstan",
  "Zambiya",
  "Zimbabve"
];

},{}],279:[function(require,module,exports){
module["exports"] = [
  "Azrbaycan"
];

},{}],280:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.country = require("./country");
address.building_number = require("./building_number");
address.street_suffix = require("./street_suffix");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.state = require("./state");
address.street_title = require("./street_title");
address.city_name = require("./city_name");
address.city = require("./city");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":275,"./city":276,"./city_name":277,"./country":278,"./default_country":279,"./postcode":281,"./secondary_address":282,"./state":283,"./street_address":284,"./street_name":285,"./street_suffix":286,"./street_title":287}],281:[function(require,module,exports){
module["exports"] = [
  "AZ####"
];

},{}],282:[function(require,module,exports){
module["exports"] = [
  "m. ###"
];

},{}],283:[function(require,module,exports){
module["exports"] = [

];

},{}],284:[function(require,module,exports){
module["exports"] = [
  "#{street_name}, #{building_number}"
];

},{}],285:[function(require,module,exports){
module["exports"] = [
  "#{street_suffix} #{Address.street_title}",
  "#{Address.street_title} #{street_suffix}"
];

},{}],286:[function(require,module,exports){
module["exports"] = [
  "k.",
  "ksi",
  "prospekti",
  "pr.",
  "sahsi",
  "sh."
];

},{}],287:[function(require,module,exports){
module["exports"] = [
  "Abbas Ftullayev",
  "Abbas Mirz rifzad",
  "Abbas Shht",
  "Abdulla aiq",
  "Afiyddin Clilov",
  "Axundov",
  "Aa Nemtulla",
  "Aadada Qurbanov",
  "Akademik Hsn liyev",
  "Akademik Ltif manov",
  "Al Mustafayev",
  "Almas ldrm",
  "Asf Zeynall",
  "Asif sdullayev",
  "Aq Al",
  "Aq lsgr",
  "Azadlq prospekti",
  "Bakxanov",
  "Balababa Mcidov",
  "Balami Dadaov",
  "Behbud axtantinski",
  "Bkir obanzad",
  "Bsti Barova",
  "Bir Sfrolu",
  "Byk Qala",
  "Cabir liyev",
  "Camal Hacliyev",
  "Cavadxan",
  "Cavanir",
  "Ceyhun Slimov",
  "Ceyhunby Hacbyli",
  "Cbiyev",
  "Cfr Xndan",
  "Cfr Cabbarl",
  "Clal Qurbanov",
  "Clil Mmmdquluzad",
  "ingiz Mustafayev",
  "obanzad",
  "Dada Bnyadzad",
  "Dal Yunus",
  "Dilar liyeva",
  "Elin zimov",
  "Eldar v Abdulla libyovlar",
  "Elxan Hsnov",
  "Eln Mehdiyev",
  "Eln Sleymanov",
  "Etibar Bkirov",
  "bdlzl Dmirizad",
  "bdlhsn Anapl",
  "bdlkrim lizad",
  "hmd by Aaolu",
  "hmd Cavad",
  "hmd Cmil",
  "hmd Mehbalyev",
  "hmd Rcbli",
  "jdr Xanbabayev",
  "krm Cfrov",
  "lsgr Qaybov",
  "liaa Vahid",
  "li By Hseynzad",
  "limrdan by Topubaov",
  "liyar liyev",
  "lvst Abdulrhimov",
  "lvst Quliyev",
  "mir Barov",
  "sd hmdov",
  "rf Yunusov",
  "zim zimzad",
  "ziz liyev",
  "Heybt Heybtov",
  "Hqiqt Rzayeva",
  "Hmid Arasl",
  "Hnif lsgrova",
  "Hrbilr",
  "Hsnou",
  "Hsn Seyidbyli",
  "Htm Allahverdiyev",
  "Hzi Aslanov",
  "Hs Hacyev",
  "Hseynqulu Sarabski",
  "Ftli xan Xoyski",
  "Fzail Bayramov",
  "Fikrt mirov",
  "Fuad brahimbyov",
  "Fuad Yusifov",
  "General liaa xlinski",
  "Glay Qdirbyova",
  "Gnclik",
  "Xaqani",
  "Xan uinski",
  "Xanlar",
  "Xudu Mmmdov",
  "brahimpaa Dadaov",
  "dris Sleymanov",
  "lqar Abbasov",
  "lqar smaylov",
  "mran Qasmov",
  "nqilab smaylov",
  "sfndiyar Zlalov",
  "slam Abov",
  "slam Sfrli",
  "smayl by Qutqanl",
  "smayl Mirzglov",
  "stiqlaliyyt",
  "28 May",
  "sgndrov",
  "van Turgenev",
  "zmir",
  "zzt Hmidov",
  "zzt Orucova",
  "Kamal Rhimov",
  "Kazm Kazmzad",
  "Kazmaa Krimov",
  "Krm smaylov",
  "Kiik Qala",
  "Korolu Rhimov",
  "Qaaq Nbi",
  "Qaraba",
  "Qdirbyov",
  "Qznfr Musabyov",
  "Qznfr Vliyev",
  "Leyla Mmmdbyova",
  "Mahmud brahimov",
  "Malik Mmmdov",
  "Mehdi Abbasov",
  "Mehdi Mehdizad",
  "Mhmmd min Rsulzad",
  "Mhmmd Hadi",
  "Mhmmd Xiyabani",
  "Mhmmd ibn Hinduah Naxvani",
  "Mhsti Gncvi",
  "Mmmdyarov",
  "Mrdanov qardalar",
  "Mtlb Aayev",
  "Mdi Hilal",
  "Mzahir Rstmov",
  "Mikayl Mviq",
  "Mingevir",
  "Mirli Qaqay",
  "Mirli Seyidov",
  "Mirzaa liyev",
  "Mirz brahimov",
  "Mirz Mnsur",
  "Mirz Mustafayev",
  "Murtuza Muxtarov",
  "Mustafa Topubaov",
  "Mqtdir Aydnbyov",
  "Mslm Maqomayev",
  "Mzffr Hsnov",
  "Nabat Aurbyova",
  "Naxvani",
  "Naximov",
  "Nazim smaylov",
  "Neapol",
  "Nefti Qurban Abbasov",
  "Neftilr prospekti",
  "Ncfby Vzirov",
  "Ncfqulu Rfiyev",
  "Nriman Nrimanov",
  "Nsirddin Tusi",
  "Nigar Rfibyli",
  "Niyazi",
  "Nizami",
  "Nizami Abdullayev",
  "Nobel prospekti",
  "Novruz",
  "Novruzov qardalar",
  "Oqtay Vliyev",
  "Parlament",
  "Pukin",
  "Rafiq Aayev",
  "Ramiz Qmbrov",
  "Rid Behbudov",
  "Rid Mcidov",
  "Ruhulla Axundov",
  "Ruslan Allahverdiyev",
  "Rstm Rstmov",
  "Tahir Barov",
  "Tarzan Hac Mmmdov",
  "Tbilisi prospekti",
  "Tbriz (Bak)",
  "Tbriz Xlilbyli",
  "Tofiq Mmmdov",
  "Tolstoy",
  "Sabit Orucov",
  "Sabit Rhman",
  "Sahib Hmmtov",
  "Salatn sgrova",
  "Sarayevo",
  "Seyid zim irvani",
  "Seyid uinski",
  "Seyidov",
  "Smd by Mehmandarov",
  "Smd Vurun",
  "Sttar Bhlulzad",
  "Sona xanm Vlixanl",
  "Sbhi Salayev",
  "Sleyman hmdov",
  "Sleyman Rhimov",
  "Sleyman Rstm",
  "Sleyman Sani Axundov",
  "Sleyman Vzirov",
  "ahin Smdov",
  "amil zizbyov",
  "amil Kamilov",
  "eyx amil",
  "fayt Mehdiyev",
  "msi Bdlbyli",
  "irin Mirzyev",
  "xli Qurbanov",
  "vkt lkbrova",
  "lvi Bnyadzad",
  "zeyir Hacbyov",
  "Vasif liyev",
  "Vli Mmmdov",
  "Vladislav Plotnikov",
  "Vqar Quliyev",
  "Vunq Tau",
  "Yaqub liyev",
  "Yaar Abdullayev",
  "Yaar liyev",
  "Yavr liyev",
  "Yesenin",
  "Yhya Hseynov",
  "Ylmaz Axundzad",
  "Ysif Eyvazov",
  "Yusif Qasmov",
  "Yusif Mmmdliyev",
  "Yusif Sfrov",
  "Yusif Vzir mnzminli",
  "Zahid liyev",
  "Zahid Xlilov",
  "Zaur Krimov",
  "Zavod",
  "Zrgrpalan"
];

},{}],288:[function(require,module,exports){
module["exports"] = [
  "ala",
  "aq bnvyi",
  "a",
  "mavi",
  "boz",
  "bnvyi",
  "gy rng",
  "gm",
  "kardinal",
  "narnc",
  "qara",
  "qrmz",
  "qhvyi",
  "tnd gy",
  "tnd qrmz",
  "xlorofil",
  "yal",
  "hray"
];

},{}],289:[function(require,module,exports){
module["exports"] = [
  "Kitablar",
  "Filmlr",
  "musiqi",
  "oyunlar",
  "Elektronika",
  "Kompyuterlr",
  "Ev",
  "",
  "Shiyy",
  "gzllik",
  "Oyuncaqlar",
  "uaq n",
  "Geyim",
  "Ayyaqqab",
  "bzk",
  "dman",
  "turizm",
  "Avtomobil",
];

},{}],290:[function(require,module,exports){
var commerce = {};
module['exports'] = commerce;
commerce.color = require("./color");
commerce.department = require("./department");
commerce.product_name = require("./product_name");

},{"./color":288,"./department":289,"./product_name":291}],291:[function(require,module,exports){
module["exports"] = {
  "adjective": [
    "Balaca",
    "Ergonomik",
    "Kobud",
    "ntellektual",
    "Mhtm",
    "nanlmaz",
    "Fantastik",
    "lverili",
    "Parlaq",
    "Mkmml"
  ],
  "material": [
    "Polad",
    "Aac",
    "Beton",
    "Plastik",
    "Pambq",
    "Qranit",
    "Rezin"
  ],
  "product": [
    "Stul",
    "Avtomobil",
    "Kompyuter",
    "Beret",
    "Kulon",
    "Stol",
    "Sviter",
    "Kmr",
  ]
};

},{}],292:[function(require,module,exports){
var company = {};
module['exports'] = company;
company.prefix = require("./prefix");
company.suffix = require("./suffix");
company.name = require("./name");

},{"./name":293,"./prefix":294,"./suffix":295}],293:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{Name.female_first_name}",
  "#{prefix} #{Name.male_first_name}",
  "#{prefix} #{Name.male_last_name}",
  "#{prefix} #{suffix}#{suffix}",
  "#{prefix} #{suffix}#{suffix}#{suffix}",
  "#{prefix} #{Address.city_name}#{suffix}",
  "#{prefix} #{Address.city_name}#{suffix}#{suffix}",
  "#{prefix} #{Address.city_name}#{suffix}#{suffix}#{suffix}"
];

},{}],294:[function(require,module,exports){
module["exports"] = [
  "ASC",
  "MMC",
  "QSC",
];

},{}],295:[function(require,module,exports){
arguments[4][283][0].apply(exports,arguments)
},{"dup":283}],296:[function(require,module,exports){
var date = {};
module["exports"] = date;
date.month = require("./month");
date.weekday = require("./weekday");

},{"./month":297,"./weekday":298}],297:[function(require,module,exports){
// source: http://unicode.org/cldr/trac/browser/tags/release-27/common/main/ru.xml#L1734
module["exports"] = {
  wide: [
    "yanvar",
    "fevral",
    "mart",
    "aprel",
    "may",
    "iyun",
    "iyul",
    "avqust",
    "sentyabr",
    "oktyabr",
    "noyabr",
    "dekabr"
  ],
  wide_context: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  abbr: [
    ".",
    ".",
    "",
    ".",
    "",
    "",
    "",
    ".",
    ".",
    ".",
    ".",
    "."
  ],
  abbr_context: [
    ".",
    ".",
    "",
    ".",
    "",
    "",
    "",
    ".",
    ".",
    ".",
    ".",
    "."
  ]
};

},{}],298:[function(require,module,exports){
// source: http://unicode.org/cldr/trac/browser/tags/release-27/common/main/ru.xml#L1825
module["exports"] = {
  wide: [
    "Bazar",
    "Bazar ertsi",
    "rnb axam",
    "rnb",
    "Cm axam",
    "Cm",
    "nb"
  ],
  wide_context: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  abbr: [
    "Ba",
    "BE",
    "A",
    "",
    "CA",
    "C",
    ""
  ],
  abbr_context: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};

},{}],299:[function(require,module,exports){
var az = {};
module['exports'] = az;
az.title = "Azerbaijani";
az.separator = " v ";
az.address = require("./address");
az.internet = require("./internet");
az.name = require("./name");
az.phone_number = require("./phone_number");
az.commerce = require("./commerce");
az.company = require("./company");
az.date = require("./date");

},{"./address":280,"./commerce":290,"./company":292,"./date":296,"./internet":302,"./name":305,"./phone_number":312}],300:[function(require,module,exports){
module["exports"] = [
  "com",
  "az",
  "com.az",
  "info",
  "net",
  "org"
];

},{}],301:[function(require,module,exports){
module["exports"] = [
  "box.az",
  "mail.az",
  "gmail.com",
  "yahoo.com",
  "hotmail.com"
];

},{}],302:[function(require,module,exports){
var internet = {};
module['exports'] = internet;
internet.free_email = require("./free_email");
internet.domain_suffix = require("./domain_suffix");

},{"./domain_suffix":300,"./free_email":301}],303:[function(require,module,exports){
module["exports"] = [
  "Anna",
  "Adeliya",
  "Afaq",
  "Aft",
  "Afrim",
  "Aid",
  "Aygn",
  "Aynur",
  "Alsu",
  "Ayan",
  "Aytn",
  "Aygl",
  "Aydan",
  "Aylin",
  "Bahar",
  "Banu",
  "Byaz",
  "Billur",
  "Cansu",
  "Ceyla",
  "Damla",
  "Dniz",
  "Diana",
  "Dilar",
  "Ella",
  "Elza",
  "Elyanora",
  "Ellada",
  "Elvira",
  "Elnar",
  "Esmira",
  "Estella",
  "Fatim",
  "Fxriyy",
  "Frh",
  "Frqan",
  "Fidan",
  "Firuz",
  "Gvhr",
  "Gnay",
  "Glay",
  "Glin",
  "Glr",
  "Glsm",
  "Humay",
  "Hriy",
  "Hlya",
  "Jal",
  "Jasmin",
  "Kbra",
  "Lman",
  "Lamiy",
  "Lal",
  "Liliya",
  "Laura",
  "Leyla",
  "Maya",
  "Mehriban",
  "Mlk",
  "Nuray",
  "Nurgn",
  "Nrgiz",
  "Nigar",
  "Ofelya",
  "Pri",
  "Rya",
  "Sbin",
  "Selcan",
  "Tansu",
  "Tuba",
  "lviyy",
  "Ulduz",
  "lkr"
];

},{}],304:[function(require,module,exports){
module["exports"] = [
  "Qasmova",
  "fndiyeva",
  "Soltanova",
  "Abdullayeva",
  "Ridova",
  "lkbrova",
  "liyeva",
  "Tahirova",
  "Seyidova",
  "Vsiyeva"
];

},{}],305:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.male_first_name = require("./male_first_name");
name.male_last_name = require("./male_last_name");
name.female_first_name = require("./female_first_name");
name.female_last_name = require("./female_last_name");
name.prefix = require("./prefix");
name.suffix = require("./suffix");
name.name = require("./name");

},{"./female_first_name":303,"./female_last_name":304,"./male_first_name":306,"./male_last_name":307,"./name":308,"./prefix":309,"./suffix":310}],306:[function(require,module,exports){
module["exports"] = [
  "Anar",
  "Amid",
  "Afl",
  "Abbas",
  "Abdulla",
  "Adil",
  "Akif",
  "Aqil",
  "Bhram",
  "Nurlan",
  "Rafiq",
  "Trlan",
  "Zaur",
  "Emin",
  "Emil",
  "Kamran",
  "Elnur",
  "Natiq",
  "Rad",
  "Rid",
  "Tahir",
  "hmd",
  "Zahir",
  "lham",
  "lqar",
  "Nahid",
  "Nihad",
  "Faiq",
  "xtiyar",
  "hriyar",
  "aiq",
  "Bxtiyar",
  "Bhruz",
  "Tunar",
  "Nadir"
];

},{}],307:[function(require,module,exports){
module["exports"] = [
  "hmdov",
  "lkbrov",
  "liyev",
  "Vliyev",
  "Soltanov",
  "Quliyev",
  "Mmmdov",
  "Xlilov",
  "Nzrov",
  "Rhimov"
];

},{}],308:[function(require,module,exports){
module["exports"] = [
  "#{male_first_name}",
  "#{male_last_name} #{male_first_name}",
  "#{male_first_name} #{male_last_name}",
  "#{female_first_name}",
  "#{female_first_name} #{female_last_name}",
  "#{female_last_name} #{female_first_name}",
];

},{}],309:[function(require,module,exports){
module["exports"] = [];

},{}],310:[function(require,module,exports){
arguments[4][309][0].apply(exports,arguments)
},{"dup":309}],311:[function(require,module,exports){
module["exports"] = [
  "(9##)###-##-##"
];

},{}],312:[function(require,module,exports){
var phone_number = {};
module['exports'] = phone_number;
phone_number.formats = require("./formats");

},{"./formats":311}],313:[function(require,module,exports){
module["exports"] = [
  "#",
  "##",
  "###"
];

},{}],314:[function(require,module,exports){
module["exports"] = [
  "#{city_name}"
];

},{}],315:[function(require,module,exports){
module["exports"] = [
  "Abertamy",
  "Adamov",
  "Andlsk Hora",
  "A",
  "Bakov nad Jizerou",
  "Bavorov",
  "Bechyn",
  "Beov nad Teplou",
  "Bl nad Radbuzou",
  "Bl pod Bezdzem",
  "Bentky nad Jizerou",
  "Beneov",
  "Beneov nad Plounic",
  "Beroun",
  "Bezdruice",
  "Blina",
  "Blovec",
  "Blansko",
  "Blatn",
  "Blovice",
  "Blany",
  "Bochov",
  "Bohumn",
  "Bohuovice nad Oh",
  "Bojkovice",
  "Bor",
  "Borohrdek",
  "Borovany",
  "Boskovice",
  "Bo Dar",
  "Brands nad Labem-Star Boleslav",
  "Brands nad Orlic",
  "Brno",
  "Broumov",
  "Brtnice",
  "Brumov-Bylnice",
  "Bruntl",
  "Bruperk",
  "Beclav",
  "Beznice",
  "Bezov",
  "Bezov nad Svitavou",
  "Bidlin",
  "Buovice",
  "Budiov nad Budiovkou",
  "Budyn nad Oh",
  "Buthrad",
  "Bystr",
  "Bystice",
  "Bystice nad Perntejnem",
  "Bystice pod Hostnem",
  "Bzenec",
  "Chabaovice",
  "Cheb",
  "Chlumec",
  "Chlumec nad Cidlinou",
  "Choce",
  "Chodov",
  "Chomutov",
  "Chotbo",
  "Chrast",
  "Chrastava",
  "Chropyn",
  "Chrudim",
  "Chibsk",
  "Chvaletice",
  "Chnov",
  "Chye",
  "Cvikov",
  "slav",
  "elkovice",
  "ernoice",
  "ernon",
  "ernovice",
  "erven eice",
  "erven Kostelec",
  "esk Kamenice",
  "esk Lpa",
  "esk Skalice",
  "esk Tebov",
  "esk Budjovice",
  "esk Velenice",
  "esk Brod",
  "esk Dub",
  "esk Krumlov",
  "esk Tn",
  "Daice",
  "Daice",
  "Dn",
  "Desn",
  "Detn",
  "Dobrovice",
  "Dobruka",
  "Dobany",
  "Dobichovice",
  "Dob",
  "Doksy",
  "Doln Beneov",
  "Doln Bousov",
  "Doln Kounice",
  "Doln Poustevna",
  "Domalice",
  "Dub",
  "Dub",
  "Dubany",
  "Duchcov",
  "Dvr Krlov nad Labem",
  "Frantikovy Lzn",
  "Frentt pod Radhotm",
  "Frdek-Mstek",
  "Frdlant",
  "Frdlant nad Ostravic",
  "Frytk",
  "Fulnek",
  "Golv Jenkov",
  "Habartov",
  "Habry",
  "Hanuovice",
  "Harrachov",
  "Hartmanice",
  "Havov",
  "Havlkv Brod",
  "Hejnice",
  "Hemanv Mstec",
  "Hlinsko",
  "Hlubok nad Vltavou",
  "Hlun",
  "Hluk",
  "Hodkovice nad Mohelkou",
  "Hodonn",
  "Holeov",
  "Holice",
  "Holov",
  "Hora Svat Kateiny",
  "Horaovice",
  "Horn Beneov",
  "Horn Blatn",
  "Horn Bza",
  "Horn Cerekev",
  "Horn Jelen",
  "Horn Jietn",
  "Horn Plan",
  "Horn Slavkov",
  "Horovsk Tn",
  "Hoice",
  "Hoovice",
  "Hostinn",
  "Hostivice",
  "Hostomice",
  "Hostou",
  "Hotka",
  "Hradec Krlov",
  "Hradec nad Moravic",
  "Hrdek",
  "Hrdek nad Nisou",
  "Hranice (okres Cheb)",
  "Hranice (okres Perov)",
  "Hrob",
  "Hrochv Tnec",
  "Hronov",
  "Hrotovice",
  "Hrozntn",
  "Hruovany nad Jeviovkou",
  "Huln",
  "Humpolec",
  "Husinec",
  "Hustopee",
  "Ivanice",
  "Ivanovice na Han",
  "Jablonec nad Jizerou",
  "Jablonec nad Nisou",
  "Jablonn nad Orlic",
  "Jablonn v Podjetd",
  "Jablunkov",
  "Jchymov",
  "Janov",
  "Janovice nad hlavou",
  "Jansk Lzn",
  "Jarom",
  "Jaromice nad Rokytnou",
  "Javornk",
  "Jemnice",
  "Jesenice (okres Rakovnk)",
  "Jesenk",
  "Jevko",
  "Jeviovice",
  "Jin",
  "Jihlava",
  "Jilemnice",
  "Jlov",
  "Jlov u Prahy",
  "Jindichv Hradec",
  "Jirkov",
  "Jikov",
  "Jistebnice",
  "Kada",
  "Kamenice nad Lipou",
  "Kamenick enov",
  "Kaplice",
  "Kardaova eice",
  "Karlovy Vary",
  "Karolinka",
  "Karvin",
  "Kasejovice",
  "Kapersk Hory",
  "Kaznjov",
  "Kdyn",
  "Kel",
  "Kladno",
  "Kladruby",
  "Klterec nad Oh",
  "Klatovy",
  "Klecany",
  "Klimkovice",
  "Klobouky u Brna",
  "Kojetn",
  "Koln",
  "Konice",
  "Kopidlno",
  "Kopivnice",
  "Koryany",
  "Kosmonosy",
  "Kostelec na Han",
  "Kostelec nad ernmi lesy",
  "Kostelec nad Labem",
  "Kostelec nad Orlic",
  "Koany",
  "Kouim",
  "Kolany",
  "Krlky",
  "Kralovice",
  "Kralupy nad Vltavou",
  "Krlv Dvr",
  "Kraslice",
  "Krsn Hora nad Vltavou",
  "Krsn Lpa",
  "Krsn dol",
  "Krsno",
  "Kravae",
  "Krnov",
  "Krom",
  "Krupka",
  "Kryry",
  "Kunovice",
  "Kuntt",
  "Kuim",
  "Kutn Hora",
  "Kyjov",
  "Kynperk nad Oh",
  "Lankroun",
  "Lanhot",
  "Lzn Blohrad",
  "Lzn Bohdane",
  "Lzn Kynvart",
  "Lede nad Szavou",
  "Ledvice",
  "Letohrad",
  "Letovice",
  "Lib",
  "Libice nad Vltavou",
  "Libchov",
  "Liberec",
  "Libochovice",
  "Libun",
  "Lipnk nad Bevou",
  "Liov",
  "Litomice",
  "Litomyl",
  "Litovel",
  "Litvnov",
  "Loket",
  "Lom",
  "Lomnice nad Lunic",
  "Lomnice nad Popelkou",
  "Lotice",
  "Loun pod Klnovcem",
  "Louny",
  "Lovosice",
  "Luby",
  "Luany nad Nisou",
  "Luhaovice",
  "Lue",
  "Lys nad Labem",
  "Mantn",
  "Marinsk Lzn",
  "Maov",
  "Mn",
  "Mlnk",
  "Mstec Krlov",
  "Msto Albrechtice",
  "Msto Toukov",
  "Mezibo",
  "Mezimst",
  "Mikulovice",
  "Mikulov",
  "Miletn",
  "Milevsko",
  "Milovice",
  "Mimo",
  "Miroslav",
  "Miroov",
  "Mirotice",
  "Mirovice",
  "Mlad Boleslav",
  "Mlad Voice",
  "Mnichovice",
  "Mnichovo Hradit",
  "Mnek pod Brdy",
  "Modice",
  "Mohelnice",
  "Moravsk Tebov",
  "Moravsk Budjovice",
  "Moravsk Beroun",
  "Moravsk Krumlov",
  "Morkovice-Slany",
  "Most",
  "Meno",
  "Mto",
  "Nchod",
  "Nalovsk Hory",
  "Nm nad Oslavou",
  "Napajedla",
  "Nasavrky",
  "Nechanice",
  "Nejdek",
  "Nmice nad Hanou",
  "Nepomuk",
  "Neratovice",
  "Netolice",
  "Neveklov",
  "Nov Bystice",
  "Nov Paka",
  "Nov Role",
  "Nov Velnice",
  "Nov Hrady",
  "Nov Msto na Morav",
  "Nov Msto nad Metuj",
  "Nov Msto pod Smrkem",
  "Nov Sedlo",
  "Nov Straec",
  "Nov Bor",
  "Nov Bydov",
  "Nov Jin",
  "Nov Knn",
  "Nymburk",
  "Nrsko",
  "Nany",
  "Odolena Voda",
  "Odry",
  "Olenice",
  "Olomouc",
  "Olov",
  "Opava",
  "Opono",
  "Orlov",
  "Osen",
  "Osek",
  "Oslavany",
  "Ostrava",
  "Ostrov",
  "Otrokovice",
  "Pacov",
  "Pardubice",
  "Paskov",
  "Pec pod Snkou",
  "Peky",
  "Pelhimov",
  "Petvald",
  "Pilnkov",
  "Psek",
  "Plan",
  "Plan nad Lunic",
  "Plnice",
  "Plasy",
  "Plesn",
  "Plumlov",
  "Plze",
  "Pobovice",
  "Potky",
  "Podboany",
  "Podbrady",
  "Podivn",
  "Pohoelice",
  "Police nad Metuj",
  "Polika",
  "Poln",
  "Postoloprty",
  "Pottt",
  "Prachatice",
  "Praha",
  "Prose",
  "Prostjov",
  "Protivn",
  "Pebuz",
  "Pelou",
  "Perov",
  "Petice",
  "Pbor",
  "Pbram",
  "Pibyslav",
  "Pimda",
  "Pyely",
  "Rab",
  "Radnice",
  "Rjec-Jesteb",
  "Rajhrad",
  "Rakovnk",
  "Ralsko",
  "Raspenava",
  "Rejtejn",
  "Rokycany",
  "Rokytnice nad Jizerou",
  "Rokytnice v Orlickch horch",
  "Ronov nad Doubravou",
  "Rosice",
  "Rotava",
  "Roudnice nad Labem",
  "Rousnov",
  "Rovensko pod Troskami",
  "Roztoky",
  "Roalovice",
  "Romberk nad Vltavou",
  "Romitl pod Temnem",
  "Ronov pod Radhotm",
  "Rtyn v Podkrkono",
  "Rudn",
  "Rudolfov",
  "Rumburk",
  "Rychnov nad Knnou",
  "Rychnov u Jablonce nad Nisou",
  "Rychvald",
  "Rmaov",
  "evnice",
  "any",
  "Sadsk",
  "Szava",
  "Se",
  "Sedlany",
  "Sedlec-Price",
  "Sedlice",
  "Semily",
  "Sezemice",
  "Sezimovo st",
  "Skaln",
  "Skute",
  "Slan",
  "Slatiany",
  "Slavin",
  "Slavkov u Brna",
  "Slavonice",
  "Sluovice",
  "Smeno",
  "Smiice",
  "Smrovka",
  "Sobslav",
  "Sobotka",
  "Sokolov",
  "Solnice",
  "Splen Po",
  "Stakov",
  "Star Msto (okres umperk)",
  "Star Msto (okres Uhersk Hradit)",
  "Strkov",
  "Star Plzenec",
  "Stochov",
  "Stod",
  "Strakonice",
  "Str nad Nerkou",
  "Str pod Ralskem",
  "Strnice",
  "Strov",
  "Strmilov",
  "Stbro",
  "Studnka",
  "Suchdol nad Lunic",
  "Suice",
  "Svtl nad Szavou",
  "Svitavy",
  "Svoboda nad pou",
  "Svratka",
  "enov",
  "lapanice",
  "luknov",
  "pindlerv Mln",
  "ternberk",
  "tt",
  "tty",
  "tramberk",
  "umperk",
  "vihov",
  "Tbor",
  "Tachov",
  "Tanvald",
  "Tel",
  "Tepl",
  "Teplice",
  "Teplice nad Metuj",
  "Terezn",
  "Tinov",
  "Touim",
  "Tovaov",
  "Trhov Sviny",
  "Trhov tpnov",
  "Trmice",
  "Trutnov",
  "Tebechovice pod Orebem",
  "Tebenice",
  "Teb",
  "Tebo",
  "Temon",
  "Temonice",
  "Te",
  "Tinec",
  "Turnov",
  "Tn nad Vltavou",
  "Tnec nad Labem",
  "Tnec nad Szavou",
  "Tnit nad Orlic",
  "Uhersk Hradit",
  "Uhersk Brod",
  "Uhersk Ostroh",
  "Uhlsk Janovice",
  "jezd u Brna",
  "Unho",
  "Uniov",
  "pice",
  "sov",
  "st nad Labem",
  "st nad Orlic",
  "tk",
  "ter",
  "valy",
  "Valask Klobouky",
  "Valask Mezi",
  "Valtice",
  "Vamberk",
  "Varnsdorf",
  "Vejprty",
  "Velen",
  "Velk Bte",
  "Velk Bystice",
  "Velk Blovice",
  "Velk Hamry",
  "Velk Mezi",
  "Velk Opatovice",
  "Velk Pavlovice",
  "Velk enov",
  "Veltrusy",
  "Velvary",
  "Verneice",
  "Vesel nad Lunic",
  "Vesel nad Moravou",
  "Vidnava",
  "Vimperk",
  "Vtkov",
  "Vizovice",
  "Vlachovo Bez",
  "Vlaim",
  "Vodany",
  "Volary",
  "Volyn",
  "Votice",
  "Vracov",
  "Vratimov",
  "Vrbno pod Praddem",
  "Vrchlab",
  "Vroutek",
  "Vsetn",
  "Veruby",
  "Vslun",
  "Vysok Mto",
  "Vysok nad Jizerou",
  "Vysok Vesel",
  "Vykov",
  "Vy Brod",
  "Zbeh",
  "Zkupy",
  "Zsmuky",
  "Zbiroh",
  "Zbov",
  "Zdice",
  "Zlat Hory",
  "Zln",
  "Zliv",
  "Znojmo",
  "Zru nad Szavou",
  "Zub",
  "acl",
  "amberk",
  "andov",
  "atec",
  "dnice",
  "r nad Szavou",
  "drec nad Doubravou",
  "ebrk",
  "elezn Ruda",
  "eleznice",
  "elezn Brod",
  "idlochovice",
  "irovnice",
  "lutice",
  "ulov",
];

},{}],316:[function(require,module,exports){
module["exports"] = [
  "Afghnistn",
  "Albnie",
  "Alrsko",
  "Andorra",
  "Angola",
  "Antigua a Barbuda",
  "Argentina",
  "Armnie",
  "Austrlie",
  "zerbjdn",
  "Bahamy",
  "Bahrajn",
  "Banglad",
  "Barbados",
  "Belgie",
  "Belize",
  "Benin",
  "Blorusko",
  "Bhtn",
  "Bolvie",
  "Bosna a Hercegovina",
  "Botswana",
  "Brazlie",
  "Brunej",
  "Bulharsko",
  "Burkina Faso",
  "Burundi",
  "ad",
  "ern Hora",
  "esko",
  "na",
  "Dnsko",
  "DR Kongo",
  "Dominika",
  "Dominik",
  "Dibutsko",
  "Egypt",
  "Ekvdor",
  "Eritrea",
  "Estonsko",
  "Etiopie",
  "Fidi",
  "Filipny",
  "Finsko",
  "Francie",
  "Gabon",
  "Gambie",
  "Gruzie",
  "Nmecko",
  "Ghana",
  "Grenada",
  "Guatemala",
  "Guinea",
  "Guinea-Bissau",
  "Guyana",
  "Haiti",
  "Honduras",
  "Chile",
  "Chorvatsko",
  "Indie",
  "Indonsie",
  "Irk",
  "rn",
  "Irsko",
  "Island",
  "Itlie",
  "Izrael",
  "Jamajka",
  "Japonsko",
  "Jemen",
  "Jihoaf",
  "Jin Korea",
  "Jin Sdn",
  "Jordnsko",
  "Kamboda",
  "Kamerun",
  "Kanada",
  "Kapverdy",
  "Katar",
  "Kazachstn",
  "Kea",
  "Kiribati",
  "Kolumbie",
  "Komory",
  "Kongo",
  "Kostarika",
  "Kuba",
  "Kuvajt",
  "Kypr",
  "Kyrgyzstn",
  "Laos",
  "Lesotho",
  "Libanon",
  "Librie",
  "Libye",
  "Lichtentejnsko",
  "Litva",
  "Lotysko",
  "Lucembursko",
  "Madagaskar",
  "Maarsko",
  "Makedonie",
  "Malajsie",
  "Malawi",
  "Maledivy",
  "Mali",
  "Malta",
  "Maroko",
  "Marshallovy ostrovy",
  "Mauritnie",
  "Mauricius",
  "Mexiko",
  "Mikronsie",
  "Moldavsko",
  "Monako",
  "Mongolsko",
  "Mosambik",
  "Myanmar (Barma)",
  "Namibie",
  "Nauru",
  "Nepl",
  "Niger",
  "Nigrie",
  "Nikaragua",
  "Nizozemsko",
  "Norsko",
  "Nov Zland",
  "Omn",
  "Pkistn",
  "Palau",
  "Palestina",
  "Panama",
  "Papua-Nov Guinea",
  "Paraguay",
  "Peru",
  "Pobe slonoviny",
  "Polsko",
  "Portugalsko",
  "Rakousko",
  "Rovnkov Guinea",
  "Rumunsko",
  "Rusko",
  "Rwanda",
  "ecko",
  "Salvador",
  "Samoa",
  "San Marino",
  "Sadsk Arbie",
  "Senegal",
  "Severn Korea",
  "Seychely",
  "Sierra Leone",
  "Singapur",
  "Slovensko",
  "Slovinsko",
  "Srbsko",
  "Stedo",
  "Somlsko",
  "Surinam",
  "Sdn",
  "Svat Lucie",
  "Svat Krytof a Nevis",
  "Svat Tom a Princv ostrov",
  "Svat Vincenc a Grenadiny",
  "Svazijsko",
  "Spojen arabsk emirty",
  "Spojen krlovstv",
  "Spojen stty americk",
  "Srie",
  "alamounovy ostrovy",
  "panlsko",
  "Sr Lanka",
  "vdsko",
  "vcarsko",
  "Tdikistn",
  "Tanzanie",
  "Thajsko",
  "Togo",
  "Tonga",
  "Trinidad a Tobago",
  "Tunisko",
  "Turecko",
  "Turkmenistn",
  "Tuvalu",
  "Uganda",
  "Ukrajina",
  "Uruguay",
  "Uzbekistn",
  "Vanuatu",
  "Vatikn",
  "Venezuela",
  "Vietnam",
  "Vchodn Timor",
  "Zambie",
  "Zimbabwe",
];

},{}],317:[function(require,module,exports){
module["exports"] = [
  "esk republika"
];

},{}],318:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.country = require("./country");
address.building_number = require("./building_number");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.time_zone = require("./time_zone");
address.city_name = require("./city_name");
address.city = require("./city");
address.street = require("./street");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":313,"./city":314,"./city_name":315,"./country":316,"./default_country":317,"./postcode":319,"./secondary_address":320,"./state":321,"./state_abbr":322,"./street":323,"./street_address":324,"./street_name":325,"./time_zone":326}],319:[function(require,module,exports){
module["exports"] = [
  "#####",
  "### ##",
  "###-##"
];

},{}],320:[function(require,module,exports){
module["exports"] = [
  "Apt. ###",
  "Suite ###"
];

},{}],321:[function(require,module,exports){
arguments[4][309][0].apply(exports,arguments)
},{"dup":309}],322:[function(require,module,exports){
arguments[4][309][0].apply(exports,arguments)
},{"dup":309}],323:[function(require,module,exports){
module["exports"] = [
  "17. Listopadu",
  "17. Listopadu",
  "28. Pluku",
  "28. jna",
  "28. jna",
  "5. Kvtna",
  "5. Kvtna",
  "5. Mje",
  "7. Kvtna",
  "8. Listopadu",
  "9. Kvtna",
  "Achtov",
  "Adamova",
  "Adamovsk",
  "Adlina",
  "Africk",
  "Akademick",
  "Aksamitova",
  "Aktov",
  "Alabastrov",
  "Albertov",
  "Albrechtick",
  "Albnsk",
  "Albny Hochov",
  "Aldansk",
  "Alej eskch Exulant",
  "Aleny Santarov",
  "Aloisovsk",
  "Aloisovsk",
  "Aloisovsk",
  "Altajsk",
  "Alovo Nb.",
  "Alovo Nbe",
  "Alovy Sady",
  "Alrsk",
  "Ambroova",
  "Americk",
  "Ametystov",
  "Amforov",
  "Amortova",
  "Amprova",
  "Amursk",
  "Anastzova",
  "Anderleho",
  "Andersenova",
  "Andrtova",
  "Andlova",
  "Anensk",
  "Anensk Nm.",
  "Anensk Nmst",
  "Aneky Mal",
  "Anesk",
  "Angelovova",
  "Anglick",
  "Angolsk",
  "Anhaltova",
  "Ankarsk",
  "Anny Drabkov",
  "Anny Letensk",
  "Anny Rybnkov",
  "Anny kov",
  "Anny kov",
  "Antala Staka",
  "Antonna Hodnho",
  "Antonna ermka",
  "Antonnsk",
  "Anzov",
  "Apolinsk",
  "Arabsk",
  "Aranrsk",
  "Arbesovo Nm.",
  "Arbesovo Nmst",
  "Archangelsk",
  "Archeologick",
  "Archimdova",
  "Archivn",
  "Argentinsk",
  "Aristotelova",
  "Arkalyck",
  "Armdn",
  "Armdnho Sboru",
  "Armdy",
  "Armnsk",
  "Arnota Valenty",
  "Astlova",
  "Athnsk",
  "Atletick",
  "Aubrechtov",
  "Augustinova",
  "Augustova",
  "Austova",
  "Aviatick",
  "Axmanova",
  "Azalkov",
  "Azuritov",
  "Ask",
  "Baarova",
  "Babick",
  "Babiina",
  "Babokov",
  "Babsk",
  "Babylonsk",
  "Babkova",
  "Bachmask Nm.",
  "Bachmask Nmst",
  "Bachova",
  "Bachkova",
  "Badeniho",
  "Badeniho",
  "Bajgarova",
  "Bajkalsk",
  "Bajkonursk",
  "Bakalsk",
  "Bakovsk",
  "Bakurinova",
  "Balabnova",
  "Balbnova",
  "Banskobystrick",
  "Baranova",
  "Barchovick",
  "Bareova",
  "Barrandova",
  "Barrandovsk",
  "Bartolomjsk",
  "Bartokova",
  "Bartoova",
  "Bartokova",
  "Bartokova",
  "Bartokova",
  "Bartkova",
  "Bartkova",
  "Barunina",
  "Barvsk",
  "Barkova",
  "Basilejsk Nm.",
  "Basilejsk Nmst",
  "Bassova",
  "Batelovsk",
  "Batlikova",
  "Bavorovsk",
  "Bavorsk",
  "Bazalkov",
  "Bazovskho",
  "Baetnsk",
  "Bask",
  "Bakirsk",
  "Bateckho",
  "Batsk",
  "Baantn",
  "Beaufortova",
  "Bechlnsk",
  "Bechyova",
  "Bechysk",
  "Beckovsk",
  "Bedlov",
  "Bednsk",
  "Bedrnova",
  "Bedichovsk",
  "Beethovenova",
  "Beldova",
  "Belgick",
  "Bellova",
  "Belluova",
  "Bendlova",
  "Bendova",
  "Beneck",
  "Benediktsk",
  "Beneovsk",
  "Benick",
  "Benkova",
  "Benkova",
  "Bentsk",
  "Benanova",
  "Benkov",
  "Beranovch",
  "Bergerova",
  "Bergmanova",
  "Berkovsk",
  "Berlnsk",
  "Bermanova",
  "Bernartick",
  "Bernolkova",
  "Berounsk",
  "Bertrmov",
  "Berylov",
  "Besedn",
  "Beskydsk",
  "Betlmsk",
  "Betlmsk Nm.",
  "Betlmsk Nmst",
  "Betsk",
  "Bezdrevsk",
  "Bezdkovsk",
  "Bezinkov",
  "Bezov",
  "Bezpran",
  "Beovsk",
  "Bevova",
  "Bevsk",
  "Bevsk",
  "Bekovick",
  "Bekova",
  "Bieblova",
  "Binarova",
  "Biskupcova",
  "Biskupsk",
  "Biskupsk Dvr",
  "Blachutova",
  "Blahnkova",
  "Blahoslavova",
  "Blanick",
  "Blatensk",
  "Blatnick",
  "Blatovsk",
  "Blatsk",
  "Blattnho",
  "Blaimsk",
  "Blakova",
  "Blakova",
  "Blenovsk",
  "Blodkova",
  "Bludovick",
  "Blriotova",
  "Blaneck",
  "Bobkova",
  "Bochovsk",
  "Bodlkov",
  "Bohdalec",
  "Bohdalec",
  "Bohdaleck",
  "Bohdaleck",
  "Bohdanesk",
  "Bohdansk",
  "Bohnick",
  "Bohrova",
  "Bohumnsk",
  "Bohuslava Martin",
  "Bohuslava Martin",
  "Bohuslava Ze vamberka",
  "Bohuslavick",
  "Bohuovick",
  "Bohuovick",
  "Bohova",
  "Bohova",
  "Bojanovick",
  "Bojasova",
  "Bojetick",
  "Bojeick",
  "Bojkovick",
  "Bojovsk",
  "Bojnkov",
  "Bojenkova",
  "Bolebosk",
  "Boleratick",
  "Boleslavova",
  "Boleslavsk",
  "Boletick",
  "Boleveck",
  "Bolinsk",
  "Bolosk",
  "Bolzanova",
  "Bolvarova",
  "Boreck",
  "Borekova",
  "Borodinsk",
  "Borotnsk",
  "Borovansk",
  "Borovanskho",
  "Borovnick",
  "Borovsk",
  "Borov",
  "Boroova",
  "Borsk",
  "Borskho",
  "Borov",
  "Borovsk",
  "Borvkov",
  "Bosesk",
  "Botevova",
  "Botisk",
  "Botisk",
  "Boudova",
  "Bousovsk",
  "Boukova",
  "Bouilova",
  "Bouova",
  "Bozdchova",
  "Bon I",
  "Bon Ii",
  "Boanovick",
  "Boetick",
  "Boetnsk",
  "Boivojova",
  "Boivojova",
  "Bokova",
  "Boick",
  "Boileck",
  "Bonsk",
  "Boanovsk",
  "Boeck",
  "Boejovick",
  "Boeny Hofmeisterov",
  "Boeny Jandlov",
  "Boeny Nmcov",
  "Boeny Nmcov",
  "Boeny Strkov",
  "Boetick",
  "Boetchova",
  "Bokova",
  "Bokovsk",
  "Bodarsk",
  "Brabcova",
  "Brambokov",
  "Branaldova",
  "Brandejsova",
  "Brandejsovo Nm.",
  "Brandejsovo Nmst",
  "Brandlova",
  "Brandsk",
  "Branick",
  "Branick",
  "Branick Nm.",
  "Branick Nmst",
  "Branislavova",
  "Braniovsk",
  "Bransk",
  "Bratislavsk",
  "Bratranc Veverkovch",
  "Brat Dohalskch",
  "Brat Venclk",
  "Brat apk",
  "Bratkovsk",
  "Braunerova",
  "Braunova",
  "Brakovsk",
  "Brdeck",
  "Brdikova",
  "Brdlkova",
  "Brechtova",
  "Brechtova",
  "Brehmova",
  "Breitcetlova",
  "Brichtova",
  "Brigdnick",
  "Brigdnk",
  "Brixiho",
  "Brodeck",
  "Brodeck",
  "Brodskho",
  "Bromova",
  "Bronzov",
  "Broskvoov",
  "Broumarsk",
  "Broumovsk",
  "Broznsk",
  "Brokova",
  "Brteck",
  "Brtnick",
  "Brumovick",
  "Brunclkova",
  "Brunelova",
  "Brunnerova",
  "Bruselsk",
  "Brusinkov",
  "Bruslask",
  "Bryksova",
  "Brzick",
  "Brzordovch",
  "Brzdimsk",
  "Brovsk",
  "Bubenesk",
  "Bubenesk",
  "Bubensk",
  "Bubensk Nb.",
  "Bubensk Nbe",
  "Bubenkova",
  "Bublavsk",
  "Bublkova",
  "Bubnova",
  "Bucharova",
  "Buchlovsk",
  "Buchovcova",
  "Budapesk",
  "Budesk",
  "Budilova",
  "Budilovsk",
  "Budovatelsk",
  "Budysk",
  "Budynsk",
  "Budnova",
  "Budick",
  "Budjovick",
  "Budjovick",
  "Bukolsk",
  "Bukoveck",
  "Bukovinsk",
  "Bukov",
  "Bulharsk",
  "Bulinkov",
  "Bulovka",
  "Burdova",
  "Bureova",
  "Burianova",
  "Butovick",
  "Butovick",
  "Buzuluck",
  "Buthradsk",
  "Bydhosk",
  "Bydovsk",
  "Bydovskho",
  "Bylansk",
  "Bystr",
  "Bystick",
  "Bystin",
  "Byick",
  "Bykovick",
  "Bzeneck",
  "Brtlova",
  "Bsk",
  "Bleneck Nm.",
  "Bleneck Nmst",
  "Blinsk",
  "Blkova",
  "Blkova",
  "Blovsk",
  "Bl",
  "Blick",
  "Bnova",
  "Btovsk",
  "Bhmova",
  "Bovsk",
  "Bchorsk",
  "Bchovick",
  "Bhounkova",
  "Blehradsk",
  "Blehradsk",
  "Blehradsk",
  "Blesk",
  "Blinskho",
  "Blocerkevsk",
  "Block",
  "Blohorsk",
  "Blohorsk",
  "Blomlnsk",
  "Blomlnsk",
  "Blovesk",
  "Blusk",
  "Bluick",
  "Blskov",
  "Blick",
  "Blick",
  "Beck",
  "Bn",
  "Beclavsk",
  "Behov",
  "Behov",
  "Betislavova",
  "Bevnovsk",
  "Bezanova",
  "Bezeck",
  "Bezensk",
  "Bezinova",
  "Bezinvesk",
  "Beznick",
  "Beznov",
  "Bezovick",
  "Bezovskho",
  "Bezov",
  "Beanov",
  "Beansk",
  "Beneck",
  "Bidlicov",
  "Bidlin",
  "Bzova",
  "Bansk",
  "Cafourkova",
  "Cedrov",
  "Celetn",
  "Celnin",
  "Celsiova",
  "Cementsk",
  "Ceplechova",
  "Cerhenick",
  "Cerhnsk",
  "Cetysk",
  "Chabaovick",
  "Chabersk",
  "Chabeick",
  "Chabsk",
  "Chalabalova",
  "Chaloupeckho",
  "Chaloupky",
  "Chaltick",
  "Chalupkova",
  "Chalupnick",
  "Chaplinovo Nm.",
  "Chaplinovo Nmst",
  "Charkovsk",
  "Charlese De Gaulla",
  "Charvtova",
  "Chatask",
  "Chatov",
  "Chebsk",
  "Chelickho",
  "Chemick",
  "Chilsk",
  "Chittussiho",
  "Chladrensk",
  "Chlebovick",
  "Chlumeck",
  "Chlumeck",
  "Chlumeck",
  "Chlumova",
  "Chlumnsk",
  "Chlumanskho",
  "Chlupova",
  "Chlupova",
  "Chldkova",
  "Chmelask",
  "Chmelick",
  "Chmelov",
  "Chmelova",
  "Choceradsk",
  "Chocesk",
  "Chocholoukova",
  "Chocholova",
  "Chodeck",
  "Chodoveck Nm.",
  "Chodoveck Nmst",
  "Chodovick",
  "Chodovsk",
  "Chodovsk",
  "Chodovsk",
  "Chodsk",
  "Cholupick",
  "Chomutovick",
  "Chomutovsk",
  "Chopinova",
  "Choratick",
  "Choroov",
  "Choruick",
  "Chorvatsk",
  "Chotesk",
  "Chotkova",
  "Chotouchovsk",
  "Chotousk",
  "Chotovick",
  "Chotutick",
  "Chotbuzsk",
  "Chotnovsk",
  "Chottovsk",
  "Chotovsk",
  "Chovatelsk",
  "Chrastavsk",
  "Chrobolsk",
  "Chrpov",
  "Chrudimsk",
  "Chrnn",
  "Chransk",
  "Chuchelsk",
  "Chudenick",
  "Chudomick",
  "Churnajevova",
  "Churovsk",
  "Chvaletick",
  "Chvaletick",
  "Chvalesk",
  "Chvalkovick",
  "Chvalova",
  "Chvalsk",
  "Chvalsk",
  "Chvalovick",
  "Chvatrubsk",
  "Chvojeneck",
  "Chyjick",
  "Chnick",
  "Chnovsk",
  "Chsk",
  "Chibsk",
  "Cibulka",
  "Cidlinsk",
  "Cignkova",
  "Ciheln",
  "Cihlova",
  "Cihlsk",
  "Cimburkova",
  "Ciolkovskho",
  "Cirkusov",
  "Cistercick",
  "Citolibsk",
  "Coriovch",
  "Ctiborova",
  "Ctinvesk",
  "Ctiradova",
  "Ctnick",
  "Cukern",
  "Cukrovarnick",
  "Cukrovarsk",
  "Cunova",
  "Cvikovsk",
  "Cviebn",
  "Cvrkova",
  "Cvrkova",
  "Cvrkova",
  "Cyprichova",
  "Cglerova",
  "Clkova",
  "Cnoveck",
  "Crkova",
  "Crkvick",
  "Crkvin",
  "Csask Louka",
  "Csask Ostrov",
  "Csask Ostrov",
  "Csask Ostrov",
  "Ctovsk",
  "Daimlerova",
  "Dalejsk",
  "Dalejsk",
  "Daleick",
  "Daliborova",
  "Dalimilova",
  "Dalovick",
  "Dandova",
  "Danielova",
  "Dany Medick",
  "Darwinova",
  "Dasnick",
  "Davelsk",
  "Davidoviova",
  "Davdkova",
  "Davdkova",
  "Daick",
  "Daickho",
  "Dakova",
  "Daick",
  "Dakova",
  "Dehtnsk",
  "Dejvick",
  "Dejvick",
  "Demlova",
  "Demolin",
  "Desensk",
  "Destinnov",
  "Destinov",
  "Devonsk",
  "Deylova",
  "Detn",
  "Deov",
  "Diabasov",
  "Diamantov",
  "Diblkova",
  "Diblkova",
  "Dienzenhoferovy Sady",
  "Dieselova",
  "Diskask",
  "Diskask",
  "Dismanova",
  "Dittrichova",
  "Divadeln",
  "Divadeln",
  "Diveck",
  "Diviznov",
  "Diviova",
  "Diviovsk",
  "Divok rka",
  "Divok rka",
  "Dlabaov",
  "Dlabaov",
  "Dlouh",
  "Dldn",
  "Do Blatin",
  "Do Borovin",
  "Do Chuchle",
  "Do Dolnic",
  "Do Dubin",
  "Do Dube",
  "Do Hlinek",
  "Do Klukovic",
  "Do Kopeka",
  "Do Kout",
  "Do Kout",
  "Do Lipan",
  "Do Lipin",
  "Do Lipin",
  "Do Luk",
  "Do Panenek",
  "Do Podkovy",
  "Do Pol",
  "Do Potok",
  "Do Povic",
  "Do Rokl",
  "Do Rybnk",
  "Do Svpravic",
  "Do Vozovny",
  "Do Vrchu",
  "Do Vrku",
  "Do Zahrdek I",
  "Do Zahrdek I",
  "Do Zahrdek I",
  "Do Zahrdek Ii",
  "Do Zahrdek Ii",
  "Do Zti",
  "Do dol",
  "Do jezda",
  "Do ertous",
  "Do tvrti",
  "Do an",
  "Dobevsk",
  "Dobnerova",
  "Dobratick",
  "Dobronick",
  "Dobronick",
  "Dobropolsk",
  "Dobrovick",
  "Dobrovolnho",
  "Dobrovolskho",
  "Dobrovskho",
  "Dobrovzsk",
  "Dobroovick",
  "Dobroovsk",
  "Dobrusk",
  "Dobansk",
  "Dobejovick",
  "Dobenick",
  "Dobichovsk",
  "Dobick",
  "Dobnsk",
  "Dohalick",
  "Doksansk",
  "Dolansk",
  "Dolejkova",
  "Dolealova",
  "Dolina",
  "Dolnobransk",
  "Dolnobeansk",
  "Dolnocholupick",
  "Dolnojiransk",
  "Dolnokrsk",
  "Dolnokeslick",
  "Dolnomlnsk",
  "Dolnomcholupsk",
  "Dolnomcholupsk",
  "Dolnopoernick",
  "Dolnoernoick",
  "Doln",
  "Doln",
  "Doln Chaloupky",
  "Dolomitov",
  "Dolsk",
  "Dolkova",
  "Dolneck",
  "Dolansk",
  "Domanovick",
  "Domansk",
  "Domalick",
  "Dominova",
  "Dominnsk",
  "Domkovsk",
  "Domksk",
  "Domousnick",
  "Donatellova",
  "Donovalsk",
  "Donsk",
  "Dontova",
  "Donnsk",
  "Dopplerova",
  "Dopravn",
  "Dopravk",
  "Dopravk",
  "Dostihov",
  "Dostojevskho",
  "Doubeck",
  "Doubick",
  "Doubravick",
  "Doubravsk",
  "Doubravnova",
  "Doubravick",
  "Doudlebsk",
  "Doudova",
  "Doupovsk",
  "Dr. Marodyho",
  "Dr. Zikmunda Wintra",
  "Dr.Zikmunda Wintra",
  "Dragounsk",
  "Drahansk",
  "Drahansk",
  "Drahelick",
  "Drahelick",
  "Drahobejlova",
  "Drahordova",
  "Drahotick",
  "Drahotnsk",
  "Drahovsk",
  "Drahovsk",
  "Drahoovskho",
  "Draenovsk",
  "Draenovsk",
  "Draetick",
  "Draick",
  "Draickho",
  "Draickho Nm.",
  "Draickho Nmst",
  "Drakovsk",
  "Dreyerova",
  "Drimlova",
  "Drnovsk",
  "Drobn",
  "Drtikolova",
  "Drtinova",
  "Druhanick",
  "Druhho Odboje",
  "Druicov",
  "Drunosti",
  "Drun",
  "Drustevn",
  "Drustevn Ochoz",
  "Drustevn Ochoz",
  "Drn",
  "Drbenick",
  "Drbesk",
  "Dubansk",
  "Dubeneck",
  "Dubesk",
  "Dubesk Horky",
  "Dubinsk",
  "Dubnick",
  "Dubnova",
  "Dubovick",
  "Dubov",
  "Dubrovnick",
  "Dubsk",
  "Duchcovsk",
  "Duchoslvka",
  "Dudkova",
  "Dudnsk",
  "Duhov",
  "Dukelsk",
  "Dukelskch Hrdin",
  "Dunajevskho",
  "Dunajsk",
  "Dunick",
  "Dunovskho",
  "Durychova",
  "Durychova",
  "Duskova",
  "Dukova",
  "Dukova",
  "Dun",
  "Dun",
  "Dvoreck",
  "Dvoreck Nm.",
  "Dvoreck Nmst",
  "Dvorn",
  "Dvorsk",
  "Dvoudln",
  "Dvouletky",
  "Dvouramenn",
  "Dvoeckho",
  "Dvoisk",
  "Dvokova",
  "Dvokovo Nb.",
  "Dvokovo Nbe",
  "Dygrnova",
  "Dyjsk",
  "Dykova",
  "Dsk",
  "Drerova",
  "Dinsk",
  "Dbolnsk",
  "Ddick",
  "Ddinova",
  "Ddinsk",
  "Dkansk",
  "Dkansk Vinice I",
  "Dkansk Vinice Ii",
  "Dlen",
  "Dlnick",
  "Dlosteleck",
  "Dtenick",
  "Dtsk",
  "Dtsk Ostrov",
  "Dvnsk",
  "Dnsk",
  "Dnsk",
  "Devask",
  "Devnick",
  "Devn",
  "Devick",
  "Dnovsk",
  "Dnov",
  "Dtensk",
  "Eberlova",
  "Ebrova",
  "Edisonova",
  "Edvardova",
  "Egyptsk",
  "Eichlerova",
  "Einsteinova",
  "Ejpovick",
  "Ekonomick",
  "Eledrova",
  "Elektrrensk",
  "Eliova",
  "Eliova",
  "Eliky Junkov",
  "Eliky Krsnohorsk",
  "Eliky Krsnohorsk",
  "Eliky Pekov",
  "Eliky Pemyslovny",
  "Ellnerov",
  "Elsnicovo Nmst",
  "Emilie Hyblerov",
  "Emlerova",
  "Engelmllerova",
  "Engelova",
  "Engelova",
  "Englerova",
  "Erbenova",
  "Erbenova",
  "Estonsk",
  "Etiopsk",
  "Euklidova",
  "Evropsk",
  "Evropsk",
  "Evropsk",
  "Evropsk",
  "Evropsk",
  "Evy Olmerov",
  "Exnrova",
  "F.V.Veselho",
  "Fabinova",
  "Fabinsk",
  "Fadjevova",
  "Fajmanov",
  "Fajtlova",
  "Falck",
  "Faltysova",
  "Famfulkova",
  "Fantova",
  "Faradayova",
  "Farkaova",
  "Farn",
  "Farsk",
  "Farskho",
  "Fastrova",
  "Federova",
  "Fejfarova",
  "Felberova",
  "Fenyklov",
  "Fetrovsk",
  "Fetekova",
  "Fialkov",
  "Fibichova",
  "Fikerova",
  "Filipova",
  "Filipovskho",
  "Filipny Welserov",
  "Fillova",
  "Filmask",
  "Filosofsk",
  "Fingerova",
  "Finkovsk",
  "Finsk",
  "Firkunho",
  "Fischlova",
  "Fierova",
  "Flemingovo Nm.",
  "Flemingovo Nmst",
  "Fljsk",
  "Flglova",
  "Foerstrova",
  "Folmavsk",
  "Formansk",
  "Formnkova",
  "Fotova",
  "Fragnerova",
  "Francouzsk",
  "Francouzsk",
  "Francouzsk",
  "Frantika Divie",
  "Frantika Jansy",
  "Frantika Kadlece",
  "Frantika Kka",
  "Frantika ernho",
  "Frantika ervenho",
  "Frantika imka",
  "Frantikova",
  "Franty Kocourka",
  "Frankova",
  "Freiwaldova",
  "Freyova",
  "Frimlova",
  "Friova",
  "Froncova",
  "Frostova",
  "Frokova",
  "Frydrychova",
  "Fryovick",
  "Frni rmka",
  "Frzask",
  "Frdeck",
  "Frdlantsk",
  "Fuchsova",
  "Fgnerovo Nm.",
  "Fgnerovo Nmst",
  "Gabinova",
  "Gabkova",
  "Gagarinova",
  "Galandova",
  "Galileova",
  "Gallaova",
  "Galvaniho",
  "Gaussova",
  "Gdask",
  "Generla Janouka",
  "Generla Mejstka",
  "Generla Pky",
  "Generla iky",
  "Generla iky",
  "Gensovsk",
  "Geologick",
  "Gercenova",
  "Gerstnerova",
  "Ginzova",
  "Glazunovova",
  "Glinkova",
  "Glowackho",
  "Goetheho",
  "Gogolova",
  "Golfov",
  "Gollova",
  "Golova",
  "Gonarenkova",
  "Gonarenkova",
  "Gorazdova",
  "Gotthardsk",
  "Goyova",
  "Gorova",
  "Grafick",
  "Grafitov",
  "Grammova",
  "Grantov",
  "Gregorova",
  "Grussova",
  "Gruznsk",
  "Gutfreundova",
  "Gutova",
  "Gymnasijn",
  "Gymnastick",
  "Habartick",
  "Habartick",
  "Habartovsk",
  "Haberfeldova",
  "Habrovsk",
  "Habrov",
  "Habick",
  "Habick",
  "Hackerova",
  "Hadovit",
  "Hadravsk",
  "Hajn",
  "Hakenova",
  "Halasova",
  "Halenkovsk",
  "Haltatsk",
  "Hamersk",
  "Hamplova",
  "Hamrov",
  "Hamskova",
  "Hankova",
  "Hanoukova",
  "Hanusova",
  "Hanuova",
  "Hanzelkova",
  "Hanzlkova",
  "Harantova",
  "Harcovsk",
  "Harlacherova",
  "Harmonick",
  "Harrachovsk",
  "Hartenbersk",
  "Hasisk",
  "Hasi",
  "Hasova",
  "Hastrmansk",
  "Haunerova",
  "Hauptova",
  "Hausmannova",
  "Havansk",
  "Havelsk",
  "Havelsk Ulika",
  "Havlovickho",
  "Havlovickho",
  "Havlovsk",
  "Havlnova",
  "Havlkova",
  "Havlkovo Nm.",
  "Havlkovo Nmst",
  "Havlkovy Sady",
  "Havljov",
  "Havljov",
  "Havranick",
  "Havran",
  "Havrnkova",
  "Havovsk",
  "Havsk",
  "Hakova",
  "Halerova",
  "Hatalsk",
  "Hatalsk Nm.",
  "Hatalsk Nmst",
  "Heckelova",
  "Heineho",
  "Heinemannova",
  "Hejnick",
  "Hejnick",
  "Hejplkova",
  "Hejtmansk",
  "Hejtmnkova",
  "Hekova",
  "Hekrova",
  "Heldova",
  "Heleny Malov",
  "Hellichova",
  "Helmova",
  "Helsinsk",
  "Helnsk",
  "Hennerova",
  "Heranova",
  "Herbenova",
  "Herdovsk",
  "Herlkovick",
  "Hermanick",
  "Hermelnsk",
  "Hermny Trlov",
  "Heroldovy Sady",
  "Herrmannova",
  "Herrova",
  "Hertzova",
  "Herleck I",
  "Herleck Ii",
  "Herleck Iii",
  "Herleck Iv",
  "Herkova",
  "Hevlnsk",
  "Heydukova",
  "Heyrovskho Nm.",
  "Heyrovskho Nm.",
  "Heyrovskho Nmst",
  "Heyrovskho Nmst",
  "Hekova",
  "Hemanova",
  "Hemnkov",
  "Hildy ihkov",
  "Hillebrantova",
  "Hilmarova",
  "Hirlova",
  "Hlavatho",
  "Hlaveneck",
  "Hlavn",
  "Hlavova",
  "Hlavkova",
  "Hlavova",
  "Hlaova",
  "Hledkov",
  "Hlinsk",
  "Hlivick",
  "Hlohov",
  "Hloubtnsk",
  "Hloubtnsk",
  "Hlubock",
  "Hlubok",
  "Hluboepsk",
  "Hluikova",
  "Hldkov",
  "Hldkov",
  "Hlvkova",
  "Hnvkovsk",
  "Hnvkovskho",
  "Hnzdensk",
  "Hoblsk",
  "Hodkovick",
  "Hodkovsk",
  "Hodonnsk",
  "Hodina",
  "Hodjovsk",
  "Hodjovsk",
  "Hodovick",
  "Hofbauerova",
  "Hoffmannova",
  "Hokejov",
  "Hokeovo Nm.",
  "Hokeovo Nmst",
  "Holandsk",
  "Holekova",
  "Holenick",
  "Holensk",
  "Holekova",
  "Holekova",
  "Holeovick Nbe",
  "Holeovick Pstav",
  "Holick",
  "Hollarovo Nm.",
  "Hollarovo Nmst",
  "Holohlavsk",
  "Holotnsk",
  "Holoubkova",
  "Holoubkovsk",
  "Holubick",
  "Holubinkov",
  "Holubkova",
  "Holubova",
  "Holub",
  "Holuick",
  "Holysk",
  "Holtova",
  "Holnsk",
  "Holovsk",
  "Holovick",
  "Holick",
  "Homolov",
  "Homrova",
  "Honzkova",
  "Hornick",
  "Hornocholupick",
  "Hornocholupick",
  "Hornofova",
  "Hornokrsk",
  "Hornokeslick",
  "Hornomlnsk",
  "Hornomcholupsk",
  "Hornomcholupsk",
  "Hornopoernick",
  "Horn",
  "Horn Chaloupky",
  "Horn Hrdloezsk",
  "Horn Stromky",
  "Hornkova",
  "Horolezeck",
  "Horomick",
  "Horomick",
  "Horouansk",
  "Horouansk",
  "Horovo Nm.",
  "Horovo Nmst",
  "Horsk",
  "Horusick",
  "Horymrovo Nm.",
  "Horymrovo Nmst",
  "Horkova",
  "Horkova",
  "Horikova",
  "Horteck",
  "Horovsk",
  "Horovsk",
  "Hospodsk",
  "Hostavick",
  "Hostavick",
  "Hostinskho",
  "Hostivask",
  "Hostivask Nm.",
  "Hostivask Nmst",
  "Hostivick",
  "Hostivtova",
  "Hostiovsk",
  "Hostousk",
  "Hostoova",
  "Hostnsk",
  "Hostnsk",
  "Houbask",
  "Houdova",
  "Hovorovick",
  "Hoansk",
  "Hoej Nb.",
  "Hoej Nbe",
  "Hoejho",
  "Hoelick",
  "Hoick",
  "Hoovskho",
  "Honeck",
  "Hokova",
  "Hotick",
  "Holkova",
  "Hrabaovsk",
  "Hrabkova",
  "Hrachovsk",
  "Hrad I. Ndvo",
  "Hrad Ii. Ndvo",
  "Hrad Iii. Ndvo",
  "Hradebn",
  "Hradeck",
  "Hradeckch",
  "Hradekova",
  "Hradensk",
  "Hradansk Nm.",
  "Hradansk Nmst",
  "Hranin",
  "Hrazansk",
  "Hrazansk",
  "Hrdinova",
  "Hrdlikova",
  "Hrdloezsk",
  "Hrdoovick",
  "Hroncova",
  "Hronovsk",
  "Hrontick",
  "Hrozenkovsk",
  "Hroznov",
  "Hroznho",
  "Hrubho",
  "Hrubnova",
  "Hrudikova",
  "Hrusick",
  "Hrukovsk",
  "Hrukovsk",
  "Hruovansk Nm.",
  "Hruovansk Nmst",
  "Hruovick",
  "Hruovsk",
  "Hrunskho",
  "Hruov",
  "Hruov",
  "Hrdkov",
  "Hrskho",
  "Huberova",
  "Hubikova",
  "Hubkova",
  "Hudcova",
  "Hudebn",
  "Hudekova",
  "Hudekova",
  "Hugo Haase",
  "Hulanova",
  "Hulick",
  "Humeneck",
  "Humpoleck",
  "Huntovsk",
  "Hurbanova",
  "Husask",
  "Husineck",
  "Husitsk",
  "Husitsk",
  "Husnkova",
  "Husova",
  "Husovo Nm.",
  "Husovo Nmst",
  "Hustopesk",
  "Hutnick",
  "Husk",
  "Hviezdoslavova",
  "Hviezdoslavova",
  "Hvozdeck",
  "Hvozdnick",
  "Hvozdkov",
  "Hvoansk",
  "Hvzdonick",
  "Hvzdova",
  "Hvzdsk",
  "Hyacintov",
  "Hybernsk",
  "Hybeova",
  "Hynaisova",
  "Hypmanova",
  "Hbova",
  "Hjeck",
  "Hjensk",
  "Hjkova",
  "Hjovna U Podjezdu",
  "Hjovna V rce",
  "Hjov",
  "Hjkova",
  "Hj",
  "Hkova",
  "Hlkova",
  "Hlova",
  "Hlv Statek",
  "Hgerova",
  "Hbnerov",
  "Hbitovn",
  "Hebenov",
  "Hebkova",
  "Hensk",
  "Hibojedsk",
  "Hibsk",
  "Hbkov",
  "Hdeleck",
  "Hlkova",
  "Hlkova",
  "Hrsk",
  "Ibsenova",
  "Imrychova",
  "Ingriova",
  "Internacionln",
  "Irkutsk",
  "Irsk",
  "Irvingova",
  "Italsk",
  "Italsk",
  "Italsk",
  "Ivanick",
  "Izraelsk",
  "Izraelsk",
  "Jabkenick",
  "Jabloneck",
  "Jabloneck",
  "Jablonskho",
  "Jabloov",
  "Jablunkovsk",
  "Jagellonsk",
  "Jagellonsk",
  "Jahodnick",
  "Jahodov",
  "Jakobiho",
  "Jakubovsk",
  "Jakubsk",
  "Jakutsk",
  "Jalodvorsk",
  "Jalovcov",
  "Jaltsk",
  "Jamborova",
  "Jamsk",
  "Jana Blka",
  "Jana Jindicha",
  "Jana Karafita",
  "Jana Kapara",
  "Jana Marka",
  "Jana Masaryka",
  "Jana Ouady",
  "Jana Pibka",
  "Jana Riky",
  "Jana Srba",
  "Jana Zajce",
  "Jana erstvho",
  "Jana elivskho",
  "Janderova",
  "Jandova",
  "Janekova",
  "Jankovcova",
  "Jankovsk",
  "Janouchova",
  "Janoukova",
  "Janovick",
  "Janovsk",
  "Janovskho",
  "Jansenova",
  "Janskho",
  "Jansova",
  "Jantarov",
  "Jankova",
  "Jankovo Nb.",
  "Jankovo Nb.",
  "Jankovo Nbe",
  "Jankovo Nbe",
  "Janrova",
  "Janova",
  "Jareova",
  "Jarkovsk",
  "Jarmily Novotn",
  "Jarn",
  "Jarnkova",
  "Jaromra Jindry",
  "Jaromra Vejvody",
  "Jaromrova",
  "Jaromsk",
  "Jaroslava Foglara",
  "Jaroslava vehly",
  "Jaroslavick",
  "Jasanov",
  "Jaselsk",
  "Jaselsk",
  "Jasenick",
  "Jasenn",
  "Jasmnov",
  "Jasn I",
  "Jasn Ii",
  "Jaspisov",
  "Jaten",
  "Jaurisova",
  "Jaurisova",
  "Javorensk",
  "Javornick",
  "Javorov",
  "Javorsk",
  "Javoick",
  "Jakova",
  "Jalovick",
  "Jedlov",
  "Jednostrann",
  "Jednostrann",
  "Jednotnho Zemdlskho Drustva",
  "Jednoad",
  "Jelenovsk",
  "Jelen",
  "Jelnkova",
  "Jemensk",
  "Jemnick",
  "Jenerlka",
  "Jenesk",
  "Jeniovsk",
  "Jensk",
  "Jenkovick",
  "Jentejnsk",
  "Jeremenkova",
  "Jeremenkova",
  "Jeremenkova",
  "Jeremiova",
  "Jeremiova",
  "Jerevansk",
  "Jeronmova",
  "Jeruzalmsk",
  "Jesenick",
  "Jeseniova",
  "Jestebick",
  "Jetelov",
  "Jetichovick",
  "Jevansk",
  "Jezdeck",
  "Jezdovick",
  "Jezern",
  "Jezersk",
  "Jezev",
  "Jen",
  "Jeabinov",
  "Jeabinov",
  "Jeick",
  "Jebkova",
  "Jebnick",
  "Jebov",
  "Jeetick",
  "Jetdsk",
  "Jedkova",
  "Jekova",
  "Jeovick",
  "Jeovick",
  "Jeovsk",
  "Jihlavsk",
  "Jihovchodn I",
  "Jihovchodn Ii",
  "Jihovchodn Iii",
  "Jihovchodn Iv",
  "Jihovchodn Ix",
  "Jihovchodn V",
  "Jihovchodn Vi",
  "Jihovchodn Vii",
  "Jihovchodn Viii",
  "Jihozpadn I",
  "Jihozpadn Ii",
  "Jihozpadn Iii",
  "Jihozpadn Iv",
  "Jihozpadn V",
  "Jihozpadn Vi",
  "Jihoesk",
  "Jilemnick",
  "Jilemnick",
  "Jilemnickho",
  "Jilmov",
  "Jilsk",
  "Jindrova",
  "Jindicha Jindicha",
  "Jindicha Plachty",
  "Jindichova",
  "Jindisk",
  "Jinolick",
  "Jinonick",
  "Jinonick",
  "Jinoansk",
  "Jirensk",
  "Jirekova",
  "Jirkovsk",
  "Jirskova",
  "Jirskova",
  "Jirnkova",
  "Jirskovo Nm.",
  "Jirskovo Nmst",
  "Jiransk",
  "Jiskrova",
  "Jistebnick",
  "Jitkovsk",
  "Jitravsk",
  "Jitravsk",
  "Jitrocelov",
  "Jitn",
  "Jivensk",
  "Jizersk",
  "Jinsk",
  "Jinsk",
  "Jiick",
  "Jiinkov",
  "Jiiny tpnikov",
  "Jisk",
  "Jiho Jandy",
  "Jiho Mana",
  "Jiho Ze Vtelna",
  "Jikova",
  "Jikov",
  "Jin I",
  "Jin Ii",
  "Jin Iii",
  "Jin Iv",
  "Jin Ix",
  "Jin Nm.",
  "Jin Nmst",
  "Jin Spojka",
  "Jin Spojka",
  "Jin Spojka",
  "Jin Spojka",
  "Jin V",
  "Jin Vi",
  "Jin Vii",
  "Jin Viii",
  "Jin Xi",
  "Jin Xii",
  "Jin Xiii",
  "Jin Xiv",
  "Jin Xv",
  "Jin Xvi",
  "Jin Xvii",
  "Johanitsk",
  "Jordana Jovkova",
  "Jordnsk",
  "Josefa Bbrdlka",
  "Josefa Houdka",
  "Josefa Houdka",
  "Josefa Koho",
  "Josefa Nmce",
  "Josefa Vaka",
  "Josefa imnka",
  "Josefsk",
  "Jos Martho",
  "Juarzova",
  "Jugoslvsk",
  "Jugoslvskch Partyzn",
  "Jugoslvskch Partyzn",
  "Jungmannova",
  "Jungmannova",
  "Jungmannovo Nmst",
  "Junck",
  "Jupiterova",
  "Jurkoviova",
  "Jurezova",
  "Jzd",
  "Jchymova",
  "Jchymova",
  "Jchymovsk",
  "Jnokova",
  "Jnsk",
  "Jnsk Vrek",
  "Jchova",
  "Jlkova",
  "Jlovick",
  "Jlovisk",
  "Jlovsk",
  "Jlovsk",
  "Jlov",
  "Jrova",
  "Jrovcovo Nm.",
  "Jrovcovo Nmst",
  "Jvansk",
  "Jvov",
  "K Austisu",
  "K Avii",
  "K Barrandovu",
  "K Baterim",
  "K Baantnici",
  "K Belvederu",
  "K Berance",
  "K Beranovu",
  "K Berounce",
  "K Bernku",
  "K Betonrn",
  "K Betni",
  "K Blatovu",
  "K Bohnicm",
  "K Borovku",
  "K Botii",
  "K Brance",
  "K Brnkm",
  "K Brusce",
  "K Brusce",
  "K Brdku",
  "K Blmu Vrchu",
  "K Bchovicm",
  "K Bezince",
  "K Bezinvsi",
  "K Bekm",
  "K Celinm",
  "K Cementrn",
  "K Chabm",
  "K Chabm",
  "K Chaloupce",
  "K Chaloupkm",
  "K Chatm",
  "K Chmelnici",
  "K Chumberku",
  "K Ciheln",
  "K Ciknce",
  "K Cli",
  "K Dalejm",
  "K Dobr Vod",
  "K Dobr Vod",
  "K Dolm",
  "K Drahani",
  "K Drahani",
  "K Drazdm",
  "K Drsnici",
  "K Dubinm",
  "K Dubovmu Mlnu",
  "K Dubu",
  "K Dubi",
  "K Dlnici",
  "K Dlnici",
  "K Dmai",
  "K Drm",
  "K Fantovu Mlnu",
  "K Farkm",
  "K Fialce",
  "K Fipance",
  "K Habrovce",
  "K Habru",
  "K Halti",
  "K Havlnu",
  "K Hlubok Cest",
  "K Hlsku",
  "K Holyni",
  "K Holmu Vrchu",
  "K Holmu Vrchu",
  "K Homolce",
  "K Horkm",
  "K Horkm",
  "K Horkm",
  "K Hornm Poernicm",
  "K Horomicm",
  "K Hoavce",
  "K Hraditi",
  "K Hrnm",
  "K Hruovu",
  "K Hruovu",
  "K Hrzi",
  "K Hutm",
  "K Hutm",
  "K Hutm",
  "K Hdku",
  "K Hjeku",
  "K Hji",
  "K Hji",
  "K Hjku",
  "K Hjovn",
  "K Hjovn",
  "K Hjovn",
  "K Hjm",
  "K Hrunce",
  "K Intern",
  "K Jalovce",
  "K Jasnkm",
  "K Jelenu",
  "K Jelenm",
  "K Jezeru",
  "K Jezeru",
  "K Jezu",
  "K Jezrku",
  "K Jihu",
  "K Jihu",
  "K Jinoanm",
  "K Jinoanm",
  "K Jinmu Mstu",
  "K Julin",
  "K Jzdrn",
  "K Labekm",
  "K Ladm",
  "K Lahovikm",
  "K Lahovsk",
  "K Laance",
  "K Lesoparku",
  "K Lesu",
  "K Lesu",
  "K Lesku",
  "K Letiti",
  "K Letanm",
  "K Libui",
  "K Lind",
  "K Lipanm",
  "K Lipinm",
  "K Lipm",
  "K Lochkovu",
  "K Lomu",
  "K Loui",
  "K Luhu",
  "K Lukm",
  "K Luinm",
  "K Luinm",
  "K Ldv",
  "K Ldv",
  "K Lnu",
  "K Lvce",
  "K Lznm",
  "K Lp",
  "K Markt",
  "K Matji",
  "K Mejtu",
  "K Metru",
  "K Metru",
  "K Milovu",
  "K Mlnku",
  "K Mlnu",
  "K Modanskmu Ndra",
  "K Mohyle",
  "K Moravin",
  "K Moravin",
  "K Mostku",
  "K Mostu",
  "K Motelu",
  "K Motolu",
  "K Mrm",
  "K Mcholupm",
  "K Mchurce",
  "K Nedvz",
  "K Netlukm",
  "K Noskovn",
  "K Nouzovu",
  "K Nov Vsi",
  "K Nov Vsi",
  "K Nov kole",
  "K Novmu Dvoru",
  "K Novmu Hradu",
  "K Novmu Sdliti",
  "K Novm Domkm",
  "K Ndra",
  "K Ndri",
  "K Nhonu",
  "K Nmst",
  "K Nplavce",
  "K Nplavce",
  "K Nvr",
  "K Nvr",
  "K Nvsi",
  "K Obci",
  "K Obecnm Hjovnm",
  "K Oboe",
  "K Obsinm",
  "K Ochozu",
  "K Ohrad",
  "K Okrouhlku",
  "K Olympiku",
  "K Opatilce",
  "K Opatilce",
  "K Oplocen",
  "K Orionce",
  "K Osmidomkm",
  "K Otoce",
  "K Ovnu",
  "K Ovnu",
  "K Padestnku",
  "K Paleku",
  "K Panenkm",
  "K Parku",
  "K Pastvinm",
  "K Pazderkm",
  "K Pekrn",
  "K Peluku",
  "K Petrov Komoe",
  "K Pitkovicm",
  "K Podchodu",
  "K Podjezdu",
  "K Podjezdu",
  "K Polm",
  "K Pomnku",
  "K Popelce",
  "K Popelce",
  "K Potoku",
  "K Pot",
  "K Pramenu",
  "K Preltm",
  "K Prdeln",
  "K Prhonicm",
  "K Prhonu",
  "K Prmstavu",
  "K Pyramidce",
  "K Provn",
  "K Pskovn",
  "K Psnici",
  "K Pehradm",
  "K Pejezdu",
  "K Pstaviti",
  "K Pvozu",
  "K Radhoti",
  "K Radonicm",
  "K Radotnu",
  "K Radotnu",
  "K Remzku",
  "K Rokli",
  "K Rokytce",
  "K Rotund",
  "K Rovinm",
  "K Rozkoi",
  "K Rozmez",
  "K Roztokm",
  "K Rozvodn",
  "K Rukavikrn",
  "K Rybnku",
  "K Rybnku",
  "K Rybnkm",
  "K Rybrn",
  "K Rynce",
  "K Rynce",
  "K Sadu",
  "K Safin",
  "K Samoobsluze",
  "K Samot",
  "K Sedliti",
  "K Sibin",
  "K Sokolovn",
  "K Sopce",
  "K Sopce",
  "K Starmu Bubeni",
  "K Starmu Lomu",
  "K Stavebninm",
  "K Sukovu",
  "K Sdkm",
  "K Sdkm",
  "K Sdliti",
  "K Sdliti",
  "K Teplrn",
  "K Topolm",
  "K Toprn",
  "K Transformtoru",
  "K Trati",
  "K Trninm",
  "K Trnkm",
  "K Trnku",
  "K Truhlce",
  "K Triti",
  "K Tuchomicm",
  "K Tboru",
  "K Tebonicm",
  "K Teovce",
  "K Tni",
  "K Ubytovnm",
  "K Uhnvsi",
  "K Uhnvsi",
  "K Uiliti",
  "K Valu",
  "K Vejvoku",
  "K Velk Ohrad",
  "K Velk Ohrad",
  "K Velkmu Dvoru",
  "K Vernerku",
  "K Viaduktu",
  "K Vidouli",
  "K Vilkm",
  "K Vinici",
  "K Vinicm",
  "K Vinoi",
  "K Vizerce",
  "K Viovce",
  "K Viovce",
  "K Viovmu Sadu",
  "K Vltav",
  "K Vlsence",
  "K Vodici",
  "K Vodojemu",
  "K Vodrn",
  "K Vod",
  "K Vrbikm",
  "K Vrb",
  "K Vrcholu",
  "K Vrtilce",
  "K Vrku",
  "K Vyhldce",
  "K Vysok Cest",
  "K Vystrkovu",
  "K Vclavce",
  "K Vpence",
  "K Vze",
  "K Vboru",
  "K Vtopn",
  "K Vzkumnm stavm",
  "K Vtrolamu",
  "K Zabrkm",
  "K Zadn Kopanin",
  "K Zadn Kopanin",
  "K Zahradnictv",
  "K Zahradm",
  "K Zahrdkm",
  "K Zastvce",
  "K Zatce",
  "K Zelen Louce",
  "K Zelenm Domkm",
  "K Zeleni",
  "K Zmku",
  "K Zti",
  "K Zvoditi",
  "K Zvorm",
  "K Zvrce",
  "K Zvtinm",
  "K dol",
  "K dol Hvzd",
  "K jezdu",
  "K stavu",
  "K vozu",
  "K ernoicm",
  "K ervenmu Dvoru",
  "K ervenmu Dvoru",
  "K ervenmu Dvoru",
  "K ervenmu Vrchu",
  "K estlicm",
  "K ihadlm",
  "K blicm",
  "K ece",
  "K eporyjm",
  "K eporyjm",
  "K anm",
  "K afrnce",
  "K afrnce",
  "K ancm",
  "K eberovu",
  "K eberku",
  "K edivce",
  "K ubrtce",
  "K eleznici",
  "K ikovu",
  "Kabelova",
  "Kabeova",
  "Kabtov",
  "Kadask",
  "Kadevkovsk",
  "Kafkova",
  "Kahovsk",
  "Kaizlovy Sady",
  "Kakosova",
  "Kakostov",
  "Kalabisova",
  "Kalaova",
  "Kalinov",
  "Kalinick",
  "Kalisk",
  "Kalsk",
  "Kalvodova",
  "Kamelova",
  "Kamencov",
  "Kamenick",
  "Kamenick",
  "Kamenit",
  "Kamenn",
  "Kamenk",
  "Kamerunsk",
  "Kampanova",
  "Kamzkov",
  "Kamck",
  "Kamck",
  "Kamck",
  "Kanadsk",
  "Kandertova",
  "Kanovnick",
  "Kapitulsk",
  "Kaplanova",
  "Kaplick",
  "Kapraov",
  "Kaprova",
  "Kaprova",
  "Kapucnsk",
  "Karafitov",
  "Karasova",
  "Karasovsk",
  "Kardausova",
  "Kardaovsk",
  "Kardaovsk",
  "Karenova",
  "Karfkova",
  "Karla Englie",
  "Karla Hlavka",
  "Karla Kryla",
  "Karla Kka",
  "Karla Michala",
  "Karla Rachnka",
  "Karla Tome",
  "Karla Zicha",
  "Karla ernho",
  "Karlick",
  "Karlova",
  "Karlovarsk",
  "Karlovarsk",
  "Karlovick",
  "Karlovo Nm.",
  "Karlovo Nm.",
  "Karlovo Nmst",
  "Karlovo Nmst",
  "Karlnsk Nm.",
  "Karlnsk Nmst",
  "Karltejnsk",
  "Karmelitsk",
  "Karolinsk",
  "Karoliny Svtl",
  "Karpatsk",
  "Kartoun",
  "Kartouzsk",
  "Kasalick",
  "Kateinsk",
  "Kateinsk Nm.",
  "Kateinsk Nmst",
  "Katovick",
  "Katusick",
  "Kavkazsk",
  "Kazask",
  "Kazask",
  "Kazimrova",
  "Kaznjovsk",
  "Kazn",
  "Kaznsk",
  "Kaerovsk",
  "Kansk",
  "Kakova",
  "Kakovskho",
  "Kaovsk",
  "Kaeho",
  "Kakova",
  "Kaovick",
  "Kaparovo Nm.",
  "Kaparovo Nmst",
  "Kapersk",
  "Katanov",
  "Kbelsk",
  "Kbelsk",
  "Kbelsk",
  "Kbelsk",
  "Kdoulov",
  "Ke Bezin",
  "Ke Bvm",
  "Ke Cviiti",
  "Ke Drakm",
  "Ke Drze",
  "Ke Dvoru",
  "Ke Dbnu",
  "Ke Garm",
  "Ke Golfu",
  "Ke Goniu",
  "Ke Hlsce",
  "Ke Hrdku",
  "Ke Hrzi",
  "Ke Hrzi",
  "Ke Hbitovu",
  "Ke Hiti",
  "Ke Kablu",
  "Ke Kablu",
  "Ke Kalvrii",
  "Ke Kamnce",
  "Ke Kamnce",
  "Ke Kamku",
  "Ke Kaplice",
  "Ke Kapslovn",
  "Ke Karlovu",
  "Ke Kateinkm",
  "Ke Kaznu",
  "Ke Kan",
  "Ke Kinu",
  "Ke Kladivm",
  "Ke Klimentce",
  "Ke Klubovn",
  "Ke Klnku",
  "Ke Klnku",
  "Ke Klovu",
  "Ke Koh-I-Nooru",
  "Ke Kolodjskmu Zmku",
  "Ke Kolodjm",
  "Ke Kolonii",
  "Ke Konstruktiv",
  "Ke Kopeku",
  "Ke Korunce",
  "Ke Kostelu",
  "Ke Kostelku",
  "Ke Kotlce",
  "Ke Koulce",
  "Ke Koupaliti",
  "Ke Kovrn",
  "Ke Kozm Hbetm",
  "Ke Krlovicm",
  "Ke Kri",
  "Ke Krsk Strni",
  "Ke Kulice",
  "Ke Kulturnmu Domu",
  "Ke Kurtm",
  "Ke Kyjovu",
  "Ke Klku",
  "Ke Kku",
  "Ke Kkm",
  "Ke Lhoteckmu Lesu",
  "Ke Mlnku",
  "Ke Mlnu",
  "Ke Mlnu",
  "Ke Schodm",
  "Ke Skalce",
  "Ke Skalkm",
  "Ke Skladm",
  "Ke Sklrn",
  "Ke Skle",
  "Ke Slatinm",
  "Ke Slivenci",
  "Ke Smrin",
  "Ke Smchovu",
  "Ke Smchovu",
  "Ke Splvku",
  "Ke Spof",
  "Ke Spoilovu",
  "Ke Splence",
  "Ke Srku",
  "Ke Stadionu",
  "Ke Stanici",
  "Ke Starmu Hiti",
  "Ke Starm Rybnkm",
  "Ke Stinkovskmu Rybnku",
  "Ke Stranick",
  "Ke Strouze",
  "Ke Strni",
  "Ke Stri",
  "Ke Studni",
  "Ke Studni",
  "Ke Studnce",
  "Ke Stupicm",
  "Ke Strn",
  "Ke Strce",
  "Ke Stelnici",
  "Ke Stelnici",
  "Ke Sv. Izidoru",
  "Ke Tem Mostm",
  "Ke Xaverovu",
  "Ke Zbraslavi",
  "Ke Zbrojnici",
  "Ke Zbuzanm",
  "Ke Zdibm",
  "Ke Zdravotnmu Stedisku",
  "Ke Zdi",
  "Ke Zlatmu Kopci",
  "Ke Zlinu",
  "Ke Znaku",
  "Ke Zvonici",
  "Ke Zvonice",
  "Ke kolce",
  "Ke kole",
  "Ke mejkalu",
  "Ke tvanici",
  "Ke ttu",
  "Ke tpcm",
  "Ke trkovn",
  "Ke vestkovce",
  "Kecova",
  "Kejhova",
  "Kejnick",
  "Kellnerova",
  "Keltsk",
  "Kelt",
  "Kelvinova",
  "Kemrova",
  "Keplerova",
  "Keplerova",
  "Keramick",
  "Kesnerka",
  "Kestansk",
  "Ketesk",
  "Kettnerova",
  "Keov",
  "Khodlova",
  "Kischova",
  "Kiinvsk",
  "Kladensk",
  "Kladensk",
  "Kladensk",
  "Kladinovsk",
  "Kladrubsk",
  "Kladsk",
  "Klamovka",
  "Klapkova",
  "Klaplkova",
  "Klatovsk",
  "Klausova",
  "Klecandova",
  "Klecansk",
  "Klenesk",
  "Klenovick",
  "Klenovsk",
  "Klenov",
  "Klekova",
  "Klekova",
  "Kleick",
  "Klicperova",
  "Klidn",
  "Klihask",
  "Klikat",
  "Klikat",
  "Klimentsk",
  "Klivarova",
  "Kloboukova",
  "Klobounick",
  "Kloknerova",
  "Klokotsk",
  "Klostermannova",
  "Klouzkov",
  "Kludskch",
  "Klukovick",
  "Klnova",
  "Klnova",
  "Klnova",
  "Klnovick",
  "Klnovick",
  "Klrov",
  "Kltereck",
  "Kltersk",
  "Klterskho",
  "Klmova",
  "Klmova",
  "Klneck",
  "Klnoveck",
  "Klnov",
  "Klrova",
  "Klansk",
  "Klova",
  "Klovsk",
  "Klovsk",
  "Kmochova",
  "Knnick",
  "Knevesk",
  "Knick",
  "Koberkova",
  "Kobrova",
  "Kobylisk",
  "Kobylisk Nm.",
  "Kobylisk Nmst",
  "Kobylkova",
  "Kochanova",
  "Kocianova",
  "Koclova",
  "Kocourova",
  "Kodask",
  "Kodicilova",
  "Kodymova",
  "Kohoutovsk",
  "Kohoutovch",
  "Kojetick",
  "Kojick",
  "Kokonsk",
  "Kolbenova",
  "Kolbenova",
  "Kolbenova",
  "Koldnova",
  "Kolejn",
  "Kolektivn",
  "Koleovsk",
  "Kollrova",
  "Kolmistrova",
  "Kolm",
  "Kolocova",
  "Kolodjsk",
  "Kolonie U Obecn Cihelny",
  "Kolonka",
  "Kolovesk",
  "Kolovratsk",
  "Kolov",
  "Koltorova",
  "Kolkova",
  "Kole Kaliny",
  "Kolova",
  "Kolnova",
  "Kolnsk",
  "Kolavka",
  "Komenskho Nm.",
  "Komenskho Nmst",
  "Komornick",
  "Komoansk",
  "Komoansk",
  "Komoansk",
  "Komunard",
  "Komrkova",
  "Komrovsk",
  "Koncov",
  "Konecchlumskho",
  "Konen",
  "Kongresov",
  "Konojedsk",
  "Konopisk",
  "Konopova",
  "Konopskova",
  "Konstantinova",
  "Konvalinkov",
  "Konviktsk",
  "Konzumn",
  "Konzumn",
  "Konkovo Nm.",
  "Konkovo Nmst",
  "Kontopsk",
  "Konvova",
  "Konelsk",
  "Konsk",
  "Kopalova",
  "Kopanina",
  "Kopansk",
  "Kopeckho",
  "Kopernkova",
  "Kopen",
  "Kopretinov",
  "Kopivnick",
  "Korandova",
  "Korandova",
  "Korunn",
  "Korunn",
  "Korunn",
  "Korunovan",
  "Korunovan",
  "Korybutova",
  "Korycansk",
  "Korytn",
  "Kosatcov",
  "Kosaova",
  "Kosmick",
  "Kosmonosk",
  "Kosova",
  "Kosoick",
  "Kososk",
  "Kosteleck",
  "Kosteleck",
  "Kosteln",
  "Kosteln Nmst",
  "Kosten",
  "Kostkov",
  "Kostlivho",
  "Kostnick Nm.",
  "Kostnick Nmst",
  "Kostomlatsk",
  "Kostrbova",
  "Kostnsk",
  "Kosrkovo Nb.",
  "Kosrkovo Nbe",
  "Kos",
  "Koterovsk",
  "Koterovsk",
  "Kotevn",
  "Kotlaska",
  "Kotlka",
  "Kotorsk",
  "Kotovka",
  "Kotrov",
  "Kotrlova",
  "Kotkova",
  "Kotrova",
  "Koubkova",
  "Koubkova",
  "Koubova",
  "Koukolov",
  "Koulka",
  "Koulova",
  "Kounick",
  "Kounovsk",
  "Koutsk",
  "Kouimsk",
  "Kovaneck",
  "Kovaovicova",
  "Kovriginova",
  "Kovk",
  "Kovrensk",
  "Kovova",
  "Kovsk",
  "Kovkova",
  "Kozinova",
  "Kozinovo Nmst",
  "Kozlova",
  "Kozlovsk",
  "Kozmkova",
  "Kozomnsk",
  "Kozck",
  "Kozkovsk",
  "Kozkov",
  "Koz",
  "Koova",
  "Koenskho",
  "Koaova",
  "Koick",
  "Kotova",
  "Koteck",
  "Koksk",
  "Kosk Nm.",
  "Kosk Nmst",
  "Kolkova",
  "Kotkova",
  "Koelusk",
  "Kolansk",
  "Kon",
  "Kokova",
  "Kpt. Nlepky",
  "Kpt. Strnskho",
  "Kraboick",
  "Krahul",
  "Krajansk",
  "Krajn",
  "Krajov",
  "Krajnkova",
  "Krakovsk",
  "Kralick",
  "Kralupsk",
  "Krameriova",
  "Kramlova",
  "Kramoln",
  "Kramolnsk",
  "Kramperova",
  "Kraslick",
  "Krasnick",
  "Krasnojarsk",
  "Kratochvlova",
  "Krausova",
  "Krbick",
  "Krchlebsk",
  "Krejnick",
  "Krejho",
  "Kremlikova",
  "Kremnick",
  "Kremnick",
  "Krhanick",
  "Krhanick",
  "Kristinova",
  "Krivsk",
  "Krkonosk",
  "Krnovsk",
  "Krnsk",
  "Krocnova",
  "Krocnovsk",
  "Kroftova",
  "Krohova",
  "Krokova",
  "Krolmusova",
  "Kropkova",
  "Krosensk",
  "Kroupova",
  "Kroupova",
  "Krouzova",
  "Krovova",
  "Krtesk",
  "Kruhov",
  "Krumlovsk",
  "Krupkovo Nm.",
  "Krupkovo Nmst",
  "Krupn",
  "Krupsk",
  "Kruovick",
  "Krubersk",
  "Kryloveck",
  "Kryloveck",
  "Krymsk",
  "Krynick",
  "Krystalov",
  "Krypnova",
  "Krytofova",
  "Krle Vclava Iv.",
  "Krlodvorsk",
  "Krlova",
  "Krlovick",
  "Krlovny ofie",
  "Krlovsk Obora",
  "Krlovsk Obora",
  "Krsnolipsk",
  "Krsnho",
  "Krsova",
  "Krtk",
  "Krtk",
  "Krtkho",
  "Krtk Ln",
  "Krmovsk",
  "Krsk",
  "Krnovo Nm.",
  "Krnovo Nmst",
  "Krnsk",
  "Krovick",
  "Krkova",
  "Kubatova",
  "Kubatova",
  "Kubelkova",
  "Kubiova",
  "Kubitova",
  "Kubova",
  "Kubnsk Nm.",
  "Kubnsk Nmst",
  "Kubkova",
  "Kubnova",
  "Kuchask",
  "Kudekov",
  "Kudrnova",
  "Kukelsk",
  "Kukelsk",
  "Kukulova",
  "Kukulova",
  "Kukunova",
  "Kulhavho",
  "Kulhnkovsk",
  "Kuncova",
  "Kundratka",
  "Kuneova",
  "Kunick",
  "Kunratick",
  "Kunratick Spojka",
  "Kunratick Spojka",
  "Kun",
  "Kun",
  "Kunnova",
  "Kunick",
  "Kuntick",
  "Kupeckho",
  "Kupkova",
  "Kurandov",
  "Kurkova",
  "Kurta Konrda",
  "Kurzova",
  "Kuratovova",
  "Kus",
  "Kusho",
  "Kutilova",
  "Kutnauerovo Nmst",
  "Kutnohorsk",
  "Kutnohorsk",
  "Kutrovick",
  "Kuttelwascherova",
  "Kutvirtova",
  "Kuerova",
  "Kuerov",
  "Kuatsk",
  "Kuelova",
  "Kvapilova",
  "Kvasinsk",
  "Kvestorsk",
  "Kvtinkov",
  "Kvtinsk",
  "Kvtnick",
  "Kvtnov",
  "Kvtnovho Povstn",
  "Kvtnovho Povstn",
  "Kvtnovho Vtzstv",
  "Kvtnovho Vtzstv",
  "Kvtn",
  "Kvtoslavova",
  "Kvtov",
  "Kyjevsk",
  "Kyjevsk",
  "Kyjovsk",
  "Kyjsk",
  "Kyjsk",
  "Kykalova",
  "Kymrova",
  "Kynick",
  "Kyselova",
  "Kyslkov",
  "Kysuck",
  "Kysck",
  "Kytlick",
  "Kytnsk",
  "Kcovsk",
  "Kdnerova",
  "Klikova",
  "Klmnova",
  "Kransk",
  "Kejpskho",
  "Kelovick",
  "Kemeln",
  "Kemencova",
  "Kemenn",
  "Kemenov",
  "Kemlkova",
  "Kenick",
  "Kenova",
  "Kepel",
  "Kepel",
  "Kesadlova",
  "Kesanovsk",
  "Keslick",
  "Kesomyslova",
  "Kensk",
  "Kimick",
  "Kimovsk",
  "Kivatcov",
  "Kivenick",
  "Kivokltsk",
  "Kiv",
  "Kikova",
  "Kianova",
  "Kilov",
  "Kiovnick",
  "Kiovnick Nm.",
  "Kiovnick Nmst",
  "Kikova",
  "Kikova",
  "Kovinovo Nm.",
  "Kovinovo Nmst",
  "Ktinsk",
  "Keneckho Nm.",
  "Keneckho Nmst",
  "Kkovskho",
  "Kov",
  "Kov",
  "Labsk",
  "Labtnsk",
  "Ladislava Coka",
  "Ladova",
  "Laglerov",
  "Lahovsk",
  "Lahovsk",
  "Lamaova",
  "Langweilova",
  "Lannova",
  "Lanov",
  "Lanhotsk",
  "Lanovsk",
  "Latnsk",
  "Laubova",
  "Laudonova",
  "Laudova",
  "Laurinova",
  "Lazarsk",
  "Lazarsk",
  "Lanovsk",
  "Laansk",
  "Laansk",
  "Laanskho",
  "Lebedvova",
  "Ledask",
  "Ledeck",
  "Ledesk",
  "Ledkovsk",
  "Lednick",
  "Lednov",
  "Ledvick",
  "Ledvinova",
  "Led",
  "Ledick",
  "Legerova",
  "Legerova",
  "Legerova",
  "Legerova",
  "Legion",
  "Lehrova",
  "Leitzova",
  "Leknnov",
  "Leopoldova",
  "Leskoveck",
  "Lesnick",
  "Lesnho",
  "Lesn",
  "Lessnerova",
  "Lesk",
  "Letc",
  "Leteck",
  "Letensk",
  "Letensk Nm.",
  "Letensk Nm.",
  "Letensk Nmst",
  "Letensk Nmst",
  "Letensk Sady",
  "Letn",
  "Letohradsk",
  "Letovsk",
  "Letansk",
  "Letansk",
  "Levandulov",
  "Levoben",
  "Levskho",
  "Lev",
  "Lexova",
  "Lekova",
  "Leansk",
  "Leensk",
  "Leetnsk",
  "Leovsk",
  "Letnsk",
  "Lhenick",
  "Lhoteck",
  "Lhoteck",
  "Lhotsk",
  "Lhotkova",
  "Libereck",
  "Liberijsk",
  "Libekova",
  "Libesk",
  "Libesk Ostrov",
  "Libesk Ostrov",
  "Libesk",
  "Libichovsk",
  "Libick",
  "Libiansk",
  "Libisk",
  "Libkovsk",
  "Liblick",
  "Liblick",
  "Libochovick",
  "Libock",
  "Liborova",
  "Libotovsk",
  "Libovick",
  "Liboansk",
  "Liboovsk",
  "Liboovick",
  "Libusk",
  "Libuina",
  "Libusk",
  "Libusk",
  "Libusk",
  "Libusk",
  "Libsk",
  "Libnsk",
  "Libansk",
  "Libick",
  "Libchovsk",
  "Libdick",
  "Libick",
  "Libick",
  "Lich",
  "Lidesk",
  "Lidick",
  "Lidickho",
  "Lihovarsk",
  "Liliov",
  "Lilkov",
  "Limuzsk",
  "Limuzsk",
  "Lindavsk",
  "Lindleyova",
  "Lindnerova",
  "Linhartova",
  "Linhartsk",
  "Lipansk",
  "Lipeck",
  "Lipeneck",
  "Lipensk",
  "Lipensk",
  "Lipensk Nm.",
  "Lipensk Nmst",
  "Lipnick",
  "Lipoltick",
  "Lipovick",
  "Lipovsk",
  "Lipov Alej",
  "Lipov Nmst",
  "Lipskho",
  "Lip",
  "Lisabonsk",
  "Lisabonsk",
  "Listopadov",
  "Lisztova",
  "Litavsk",
  "Litevsk",
  "Litick",
  "Litochlebsk",
  "Litomick",
  "Litomick",
  "Litovick",
  "Litoick",
  "Litoick",
  "Litonick",
  "Litvnovsk",
  "Litvnovsk",
  "Livornsk",
  "Liansk",
  "Liick",
  "Likova",
  "Liovick",
  "Li",
  "Li",
  "Lnsk",
  "Lobesk",
  "Lochenick",
  "Lochkovsk",
  "Lochotnsk",
  "Lodeck",
  "Lodn Mlny",
  "Lodnick",
  "Lodsk",
  "Lodsk",
  "Lohenick",
  "Lohniskho",
  "Lojovick",
  "Lojovick",
  "Lojovick",
  "Lolkova",
  "Lomask",
  "Lomeck",
  "Lomen",
  "Lomnick",
  "Lomnickho",
  "Lomov",
  "Londnsk",
  "Loosova",
  "Lopateck",
  "Lopateck",
  "Lopuchov",
  "Loretnsk",
  "Loretnsk Nm.",
  "Loretnsk Nmst",
  "Losinsk",
  "Lotysk",
  "Louck",
  "Loudova",
  "Lounsk",
  "Lounskch",
  "Loutksk",
  "Louansk",
  "Louimsk",
  "Loun",
  "Louovick",
  "Loveck",
  "Lovosick",
  "Lovosick",
  "Lovosick",
  "Lovensk",
  "Lovick",
  "Lozick",
  "Loetick",
  "Lokov",
  "Lstibosk",
  "Lubeneck",
  "Lublask",
  "Lublask",
  "Lublinsk",
  "Lubnick",
  "Lucembursk",
  "Lucembursk",
  "Lucinkov",
  "Ludmilina",
  "Ludvkova",
  "Luhovsk",
  "Lukaveck",
  "Lukavskho",
  "Lukeova",
  "Lukeova",
  "Lukovsk",
  "Lukova",
  "Lumir",
  "Lumrova",
  "Lumrova",
  "Lunkovsk",
  "Lupenick",
  "Lupova",
  "Lutnsk",
  "Lun",
  "Lutnick",
  "Luansk",
  "Lueck",
  "Luick",
  "Lunick",
  "Lun",
  "Lun",
  "Lusk",
  "Lvovsk",
  "Lysinsk",
  "Lysolajsk",
  "Lysolajsk dol",
  "Lykovo Nm.",
  "Lykovo Nmst",
  "Lyask",
  "Ldevsk",
  "Lnovsk",
  "Lnsk",
  "Lsenick",
  "Lskova",
  "Lzesk",
  "Lkask",
  "Lkoicov",
  "Lbalova",
  "Lbeznick",
  "Lpov",
  "Lskovick",
  "Lskov",
  "Lnick",
  "Lskova",
  "M. J. Lermontova",
  "Macekov",
  "Macharovo Nm.",
  "Macharovo Nmst",
  "Machatho",
  "Machkova",
  "Machnova",
  "Machovcova",
  "Machovick",
  "Machovsk",
  "Machuldova",
  "Machkova",
  "Madarova",
  "Madajanova",
  "Madridsk",
  "Magd. Rettigov",
  "Magdalny Rettigov",
  "Magistr",
  "Magnitogorsk",
  "Mahenova",
  "Mahlerovy Sady",
  "Mahulenina",
  "Maiselova",
  "Maiselova",
  "Majerov",
  "Majerskho",
  "Makedonsk",
  "Makovsk",
  "Makovskho",
  "Makov",
  "Malachitov",
  "Malebn",
  "Malenick",
  "Maleick",
  "Maleick",
  "Maleick",
  "Maleick Nm.",
  "Maleick Nmst",
  "Maleovsk",
  "Malinov",
  "Malik",
  "Malkovskho",
  "Malletova",
  "Malletova",
  "Malobevnovsk",
  "Malostransk Nb.",
  "Malostransk Nbe",
  "Malostransk Nmst",
  "Malotick",
  "Malovick",
  "Maltzsk Nm.",
  "Maltzsk Nmst",
  "Mal",
  "Mal Bylansk",
  "Mal Houdova",
  "Mal Kltern",
  "Mal Lada",
  "Mal Michnovka",
  "Mal Plynrn",
  "Mal Sklonn",
  "Mal Smidarsk",
  "Mal Tyrovka",
  "Mal Xaveriova",
  "Mal tupartsk",
  "Mal tpnsk",
  "Maltova",
  "Mal Nm.",
  "Mal Nmst",
  "Malho",
  "Malnsk",
  "Malsk",
  "Mal Dvr",
  "Mal Okrouhlk",
  "Malovick",
  "Malovsk Nm.",
  "Malovsk Nmst",
  "Mandloov",
  "Mandova",
  "Mansfeldova",
  "Mansk Zahrada",
  "Mantovsk",
  "Manel Dostlovch",
  "Manel Kotrbovch",
  "Manel Lykovch",
  "Marciho",
  "Mareova",
  "Marie Cibulkov",
  "Marie Podvalov",
  "Marinsk",
  "Marinsk",
  "Marinsk Hradby",
  "Marinsk Hradby",
  "Marinsk Nm.",
  "Marinsk Nmst",
  "Markova",
  "Markupova",
  "Markuova",
  "Markvartick",
  "Markyta",
  "Marktsk",
  "Maroldova",
  "Martinelliho",
  "Martinick",
  "Martinova",
  "Martinovsk",
  "Martinsk",
  "Marty Krsov",
  "Marvanova",
  "Marovsk",
  "Masarykovo Nb.",
  "Masarykovo Nb.",
  "Masarykovo Nbe",
  "Masarykovo Nbe",
  "Masn",
  "Matek",
  "Matensk",
  "Maternova",
  "Matesk",
  "Matedoukov",
  "Matjuchinova",
  "Matouova",
  "Mattioliho",
  "Matkova",
  "Matchova",
  "Matjkova",
  "Matjovskho",
  "Matjsk",
  "Maxovsk",
  "Mazancova",
  "Mazovsk",
  "Mazursk",
  "Maarsk",
  "Makova",
  "Maatkova",
  "Makova",
  "Makova",
  "Maatova",
  "Makova",
  "Maovick",
  "Matovskho",
  "Manova",
  "Mechovka",
  "Mechov",
  "Medinsk",
  "Medkova",
  "Medlovsk",
  "Medov",
  "Medukov",
  "Meinlinova",
  "Mejstkova",
  "Melantrichova",
  "Melioran",
  "Melodick",
  "Melounov",
  "Menclova",
  "Mendelova",
  "Mendk",
  "Menkova",
  "Menkovsk",
  "Merhoutova",
  "Merkurova",
  "Merukov",
  "Meskova",
  "Meteorologick",
  "Meteorologick",
  "Metodjova",
  "Metujsk",
  "Mexick",
  "Mezi Chatami",
  "Mezi Domky",
  "Mezi Domy",
  "Mezi Humny",
  "Mezi Lysinami",
  "Mezi Lny",
  "Mezi Poli",
  "Mezi Potoky",
  "Mezi Rolemi",
  "Mezi Rybnky",
  "Mezi Sklady",
  "Mezi Strnmi",
  "Mezi Vodami",
  "Mezi vozy",
  "Mezi kolami",
  "Mezibransk",
  "Mezihorsk",
  "Meziho",
  "Mezilehl",
  "Mezilesn",
  "Meziles",
  "Mezilu",
  "Mezipol",
  "Mezitraov",
  "Mezitraov",
  "Mezitraov",
  "Mezivr",
  "Mezikolsk",
  "Meislavova",
  "Meovsk",
  "Mekov",
  "Michalovicova",
  "Michalsk",
  "Michelangelova",
  "Michelsk",
  "Michelsk",
  "Michnova",
  "Michnovka",
  "Mickiewiczova",
  "Mikanova",
  "Mikova",
  "Mikovcova",
  "Mikovick",
  "Mikulandsk",
  "Mikuleckho",
  "Mikulova",
  "Mikulovick",
  "Mikule Z Husi",
  "Mikulsk",
  "Mikulick",
  "Mikovskho",
  "Milady Horkov",
  "Milady Horkov",
  "Milady Horkov",
  "Milady Horkov",
  "Milady Horkov",
  "Milana Kadlece",
  "Milenovsk",
  "Milerova",
  "Miletick",
  "Miletnsk",
  "Milevsk",
  "Milevsk",
  "Mileovsk",
  "Milotick",
  "Milovick",
  "Milovick",
  "Milnsk",
  "Milnsk",
  "Milova",
  "Milovsk",
  "Mimosk",
  "Minakova",
  "Minerln",
  "Minick",
  "Minsk",
  "Miranova",
  "Miroslava Hajna",
  "Miroslava Hamra",
  "Mirotick",
  "Mirotick",
  "Mirovick",
  "Miroovick",
  "Miroovsk",
  "Mistrovsk",
  "Mistnsk",
  "Mietick",
  "Mikovick",
  "Mladenovova",
  "Mladoboleslavsk",
  "Mladoboleslavsk",
  "Mladoboleslavsk",
  "Mladoboleslavsk",
  "Mladoboleslavsk",
  "Mladotick",
  "Mladotova",
  "Mladch",
  "Mladch Bchovic",
  "Mladina",
  "Mladjovsk",
  "Mlynsk",
  "Mldee",
  "Mldenick",
  "Mldkova",
  "Mld",
  "Mlzovick",
  "Mlkrensk",
  "Mlnsk",
  "Mlnsk",
  "Mnichovick",
  "Mochovsk",
  "Mochovsk",
  "Modensk",
  "Modlansk",
  "Modletick",
  "Modletnsk",
  "Modravsk",
  "Modr",
  "Modrho",
  "Modansk",
  "Modansk",
  "Modansk",
  "Modansk",
  "Modnov",
  "Mohelnick",
  "Mohylov",
  "Mojmrova",
  "Mokr",
  "Mokansk",
  "Moldavsk",
  "Molitorovsk",
  "Molkova",
  "Mongolsk",
  "Moravansk",
  "Moravan",
  "Moravsk",
  "Morseova",
  "Morstadtova",
  "Moruov",
  "Moruov",
  "Morvkova",
  "Moskevsk",
  "Mosteck",
  "Motolsk",
  "Moulkova",
  "Moysesova",
  "Mozambick",
  "Mozartova",
  "Monova",
  "Monho",
  "Mramorov",
  "Mratnsk",
  "Mranick",
  "Mrkosova",
  "Mrkvikova",
  "Mrkovsk",
  "Mrzkova",
  "Mrzovka",
  "Mrkova",
  "Mrtkova",
  "Mrtkova",
  "Muchomrkov",
  "Muchova",
  "Mukaovsk",
  "Mukaovskho",
  "Murgaova",
  "Murmansk",
  "Musilova",
  "Musorgskho",
  "Muslkova",
  "Mutnnsk",
  "Muzejn",
  "Muzikova",
  "Mukova",
  "Mydlka",
  "Myjavsk",
  "Mylnerovka",
  "Myslbekova",
  "Myslbekova",
  "Mysliveck",
  "Myslivekova",
  "Myslkova",
  "Myslkova",
  "Mylnsk",
  "Mchova",
  "Mchova",
  "Mdrova",
  "Mjovkov",
  "Mjov",
  "Mlkovsk",
  "Mnesova",
  "Mrova",
  "Mslova",
  "Mslovick",
  "Mtov",
  "Mlovsk",
  "Mlov",
  "Mrov",
  "Mrovho Hnut",
  "Mrovho Hnut",
  "Msteck",
  "Mova",
  "Mesk",
  "Movick",
  "Mnzbergerovch",
  "Mtn",
  "Mchenick",
  "Mcholupsk",
  "Mdneck",
  "Mlick",
  "Mlnick",
  "Mstsk",
  "Mskov",
  "Msn",
  "Mick",
  "Mnsk",
  "Meck",
  "Mensk",
  "N. A. Nkrasova",
  "Na Babch",
  "Na Bab",
  "Na Bahnech",
  "Na Balkn",
  "Na Balkn",
  "Na Bambouzku",
  "Na Banch",
  "Na Barikdch",
  "Na Bartoce",
  "Na Baterich",
  "Na Baterich",
  "Na Balkch",
  "Na Bat Sv. Ji",
  "Na Bat Sv. Ludmily",
  "Na Bat Sv. Tome",
  "Na Bendovce",
  "Na Bentkch",
  "Na Bernce",
  "Na Betonce",
  "Na Bevce",
  "Na Bitevn Plni",
  "Na Blanici",
  "Na Blanseku",
  "Na Blatech",
  "Na Bluku",
  "Na Bohdalci",
  "Na Bojiti",
  "Na Boleslavce",
  "Na Borovm",
  "Na Botii",
  "Na Bot",
  "Na Bokovn",
  "Na Brabenci",
  "Na Brzd",
  "Na Buance",
  "Na Blici",
  "Na Blidle",
  "Na Blohorsk Plni",
  "Na Behu",
  "Na Bevnovsk Plni",
  "Na Bezince",
  "Na Celn",
  "Na Cest",
  "Na Chmelnici",
  "Na Chobot",
  "Na Chodovci",
  "Na Chvalce",
  "Na Chvalsk Tvrzi",
  "Na Ciheln",
  "Na Cihlce",
  "Na Cikorce",
  "Na Ciknce",
  "Na Cimble",
  "Na Cpu",
  "Na Csace",
  "Na Dionysce",
  "Na Dlouh Mezi",
  "Na Dlouh Mezi",
  "Na Dlouh Mezi",
  "Na Dlouh Mezi",
  "Na Dlouhm Lnu",
  "Na Dldnce",
  "Na Dldnce",
  "Na Dldnce",
  "Na Dldnce",
  "Na Dobece",
  "Na Dobr Vod",
  "Na Dolinch",
  "Na Dolinch",
  "Na Dolnici",
  "Na Dolku",
  "Na Domovin",
  "Na Doubkov",
  "Na Drahch",
  "Na Drakch",
  "Na Drakch",
  "Na Drakch",
  "Na Dubin",
  "Na Dvorcch",
  "Na Dyrince",
  "Na Dlcch",
  "Na Dlech",
  "Na Ddince",
  "Na Ddinch",
  "Na Dkance",
  "Na Dkance",
  "Na Dlostlnch",
  "Na Dbnu",
  "Na Fabince",
  "Na Farkch",
  "Na Farkn I",
  "Na Farkn Ii",
  "Na Farkn Iii",
  "Na Farkn Iv",
  "Na Fialce I",
  "Na Fialce Ii",
  "Na Fidlovace",
  "Na Fierce",
  "Na Florenci",
  "Na Florenci",
  "Na Floe",
  "Na Folimance",
  "Na Formance",
  "Na Frantiku",
  "Na Groi",
  "Na Habrovce",
  "Na Habrov",
  "Na Hanspaulce",
  "Na Harf",
  "Na Havrnce",
  "Na Hlavn",
  "Na Hlinch",
  "Na Hloubtnsk Vinici",
  "Na Hldce",
  "Na Holm Vrchu",
  "Na Homolce",
  "Na Homoli",
  "Na Horce",
  "Na Horkch",
  "Na Hradnm Vodovodu",
  "Na Hranicch",
  "Na Hranicch",
  "Na Hrobci",
  "Na Hroud",
  "Na Hroud",
  "Na Hrdku",
  "Na Hrzi",
  "Na Hublce",
  "Na Humnech",
  "Na Hupech",
  "Na Hutmance",
  "Na Hutch",
  "Na Hutch",
  "Na Hvalce",
  "Na Hvzdrn",
  "Na Hdku",
  "Na Hjku",
  "Na Hebenech I",
  "Na Hebenech Ii",
  "Na Hebenech Ii",
  "Na Hebenkch",
  "Na Hrce",
  "Na Jabloce",
  "Na Jabloce",
  "Na Jahodch",
  "Na Jarov",
  "Na Jelench",
  "Na Jelench",
  "Na Jetelce",
  "Na Jetelce",
  "Na Jezerce",
  "Na Jezerch",
  "Na Jitence",
  "Na Jivinch",
  "Na Julisce",
  "Na Jlech",
  "Na Jlu",
  "Na Kameni",
  "Na Kamp",
  "Na Kaplice",
  "Na Karlovce",
  "Na Kavch Horch",
  "Na Kazance",
  "Na Kaence",
  "Na Kaerov",
  "Na Kindlovce",
  "Na Klaudince",
  "Na Klaudince",
  "Na Kleovce",
  "Na Klikovce",
  "Na Klimentce",
  "Na Klternm",
  "Na Klnech",
  "Na Klnech",
  "Na Klnku",
  "Na Knce",
  "Na Kocourkch",
  "Na Kocnce",
  "Na Kodymce",
  "Na Kolejnm Statku",
  "Na Komosku",
  "Na Komosku",
  "Na Konci",
  "Na Konen",
  "Na Konvce",
  "Na Kopanin",
  "Na Kopci",
  "Na Kopeku",
  "Na Kopytce",
  "Na Korunce",
  "Na Korb",
  "Na Korlov",
  "Na Kotlce",
  "Na Koupalit",
  "Na Kovrn",
  "Na Kozace",
  "Na Kozinci",
  "Na Koince",
  "Na Koku",
  "Na Kraji",
  "Na Krocnce",
  "Na Krutci",
  "Na Krlovce",
  "Na Krlovn",
  "Na Krsk Strni",
  "Na Kuthence",
  "Na Kvintusce",
  "Na Kvtnici",
  "Na Kyjov",
  "Na Kemnku",
  "Na Kenkov",
  "Na Keku",
  "Na Kivce",
  "Na Kivce",
  "Na Kivce",
  "Na Kivin",
  "Na Ktin",
  "Na Kdle",
  "Na Labuce",
  "Na Labuce I",
  "Na Labuce Ii",
  "Na Labuce Iii",
  "Na Labuce Iv",
  "Na Ladch",
  "Na Lahovsk",
  "Na Laurov",
  "Na Lepm",
  "Na Lhotech",
  "Na Lhotkch",
  "Na Libuince",
  "Na Losch",
  "Na Louce",
  "Na Loukoti",
  "Na Loui",
  "Na Louku",
  "Na Luka",
  "Na Lukch",
  "Na Luzch",
  "Na Luinch",
  "Na Luci",
  "Na Lysinch",
  "Na Lysin",
  "Na Ldv",
  "Na Lnech",
  "Na Lvce",
  "Na Lzece",
  "Na Le",
  "Na Malovance",
  "Na Mal rce",
  "Na Malm Klnu",
  "Na Maninch",
  "Na Manouce",
  "Na Markvartce",
  "Na Marn",
  "Na Mezi",
  "Na Mlejnku",
  "Na Moklin",
  "Na Mokin",
  "Na Morni",
  "Na Mole",
  "Na Mrzovce",
  "Na Musilech",
  "Na Mrch",
  "Na Mnce",
  "Na Mnkch",
  "Na Mt",
  "Na Mstku",
  "Na Neklance",
  "Na Nerce",
  "Na Nivch",
  "Na Novin",
  "Na Nov Silnici",
  "Na Nspu",
  "Na Nvrati",
  "Na Nvr",
  "Na Nvsi",
  "Na Obrtce",
  "Na Obrtce",
  "Na Odboce",
  "Na Ohrad",
  "Na Okraji",
  "Na Okraji",
  "Na Okrouhlku",
  "Na Okruhu",
  "Na Opyi",
  "Na Opyi",
  "Na Ostrohu",
  "Na Ostrov",
  "Na Ostrvku",
  "Na Ovesnku",
  "Na Ovinch",
  "Na Ovckm",
  "Na Ovn",
  "Na Oechovce",
  "Na Padestnku I",
  "Na Padestnku Ii",
  "Na Padestnku Iii",
  "Na Padestnku Iv",
  "Na Padestnku V",
  "Na Padestm",
  "Na Pahorku",
  "Na Pahoubce",
  "Na Palouku",
  "Na Palouku",
  "Na Pankrci",
  "Na Panorm",
  "Na Parcelch",
  "Na Parkn",
  "Na Parukce",
  "Na Pasece",
  "Na Pasece",
  "Na Pastvinch",
  "Na Pavm Vrchu",
  "Na Pazderce",
  "Na Pecch",
  "Na Pernikce",
  "Na Pertn",
  "Na Petynce",
  "Na Petynce",
  "Na Petinch",
  "Na Petinch",
  "Na Placch",
  "Na Planin",
  "Na Pluin",
  "Na Plzece",
  "Na Plcku",
  "Na Plni",
  "Na Plskav",
  "Na Podkovce",
  "Na Pokraji",
  "Na Pokraji",
  "Na Poli",
  "Na Polnku",
  "Na Pomez",
  "Na Pomez",
  "Na Popelce",
  "Na Popelce",
  "Na Potku",
  "Na Poustkch",
  "Na Pozorce",
  "Na Ponm Prvu",
  "Na Po",
  "Na Po",
  "Na Poru",
  "Na Poru",
  "Na Pramenech",
  "Na Pramenech",
  "Na Proseck Vyhldce",
  "Na Proseku",
  "Na Prostedn Cest",
  "Na Proutcch",
  "Na Provaznici",
  "Na Prhonu",
  "Na Prseku",
  "Na Pulce",
  "Na Pskovn",
  "Na Psku",
  "Na Pskch",
  "Na Pkn Vyhldce",
  "Na Pinch",
  "Na Pinch",
  "Na Pin",
  "Na Pedevsi",
  "Na Pesypu",
  "Na Pesypu",
  "Na Pdole",
  "Na Pkop",
  "Na Pkop",
  "Na Pvozch",
  "Na Pce",
  "Na Pn Mezi",
  "Na Radosti",
  "Na Radosti",
  "Na Rampch",
  "Na Rejditi",
  "Na Rohku",
  "Na Rokytce",
  "Na Rolch",
  "Na Rovinch",
  "Na Rovin",
  "Na Rovni",
  "Na Rovnosti",
  "Na Rovnm",
  "Na Rozcest",
  "Na Rozdlu",
  "Na Rozdlu",
  "Na Rozhledu",
  "Na Rozhran",
  "Na Rozhran",
  "Na Rozvod",
  "Na Rokov",
  "Na Rybnku",
  "Na Rybce",
  "Na Rybce",
  "Na Rymni",
  "Na Rynku",
  "Na Salabce",
  "Na Samot",
  "Na Schodech",
  "Na Schdkch",
  "Na Sedliti",
  "Na Sekyrce",
  "Na Selskm",
  "Na Senku",
  "Na Skalce",
  "Na Skalch",
  "Na Sklonku",
  "Na Skle",
  "Na Slatince",
  "Na Slatinch",
  "Na Slatinch",
  "Na Slatinch",
  "Na Slavkov",
  "Na Slovance",
  "Na Slupi",
  "Na Slupi",
  "Na Smetance",
  "Na Souvrati",
  "Na Souvrati",
  "Na Spojce",
  "Na Spdu",
  "Na Spleniti",
  "Na Srpeku",
  "Na Srzu",
  "Na Srku",
  "Na Star",
  "Na Star Cest",
  "Na Star Nvsi",
  "Na Star Silnici",
  "Na Star Vinici",
  "Na Stezce",
  "Na Stezce",
  "Na Struze",
  "Na Strni",
  "Na Strkch",
  "Na Stri",
  "Na Stri",
  "Na Stri",
  "Na Stri",
  "Na Stupnch",
  "Na Strce",
  "Na Strce",
  "Na Stelnici",
  "Na Svahu",
  "Na Svcence",
  "Na Sychrov",
  "Na Sychrov",
  "Na Sypkm",
  "Na Sypin",
  "Na Sdce",
  "Na Terase",
  "Na Topolce",
  "Na Topolce",
  "Na Truhlce",
  "Na Triti",
  "Na Tykace",
  "Na Tboe",
  "Na Teben",
  "Na Teben",
  "Na Universitnm Statku",
  "Na Usedlosti",
  "Na Vackov",
  "Na Valech",
  "Na Valentince",
  "Na Vart",
  "Na Vahov",
  "Na Vesel",
  "Na Vidouli",
  "Na Viktorce",
  "Na Vinici",
  "Na Vinice",
  "Na Vinikch",
  "Na Vininch Horch",
  "Na Vinobran",
  "Na Vinohradu",
  "Na Viovce",
  "Na Vlasace",
  "Na Vlastn Pd",
  "Na Vlastnm",
  "Na Vlku",
  "Na Vlovce",
  "Na Volnov",
  "Na Vrchmez",
  "Na Vrchmez",
  "Na Vrchmez",
  "Na Vrcholu",
  "Na Vrchu",
  "Na Vrchu",
  "Na Vrchch",
  "Na Vrchch",
  "Na Vrstevnici",
  "Na Vrstvch",
  "Na Vrku",
  "Na Vrkch",
  "Na Vrch",
  "Na Vrch",
  "Na Vydrholci",
  "Na Vyhldce",
  "Na Vypichu",
  "Na Vypichu",
  "Na Vysok I",
  "Na Vysok I",
  "Na Vysok Ii",
  "Na Vysoanskch Vinicch",
  "Na Vysoin",
  "Na Vclavce",
  "Na Vpence",
  "Na Vpennm",
  "Na Vtzn Plni",
  "Na Vbku",
  "Na Vhledech",
  "Na Vhonku",
  "Na Vrovn",
  "Na Vsledku I",
  "Na Vsledku Ii",
  "Na Vslun",
  "Na Vsp",
  "Na Vsp",
  "Na Vstupu",
  "Na Vtoni",
  "Na Vi",
  "Na Vince",
  "Na Vinch",
  "Na Vin",
  "Na Vneku",
  "Na Vtrnku",
  "Na Vtrnku",
  "Na Vtrov",
  "Na Vtru",
  "Na Zahrdkch",
  "Na Zatlance",
  "Na Zavadilce",
  "Na Zboenci",
  "Na Zderaze",
  "Na Zednkov",
  "Na Zelen Louce",
  "Na Zemance",
  "Na Zkratce",
  "Na Zlatnici",
  "Na Zlat",
  "Na Zlchov",
  "Na Zlchov",
  "Na Zmrzlku",
  "Na Znlci",
  "Na Zvonice",
  "Na Zbradl",
  "Na Zhonech",
  "Na Zjezdu",
  "Na Zmeck",
  "Na Zmkch",
  "Na Zmyli",
  "Na Zstelu",
  "Na Zstelu",
  "Na Ztorce",
  "Na Ztorch",
  "Na Zvji",
  "Na bo",
  "Na horu",
  "Na lehli",
  "Na seku",
  "Na spchu",
  "Na ern Hoe",
  "Na ern Strouze",
  "Na ernm Vrchu",
  "Na ervence",
  "Na eelice",
  "Na ihadle",
  "Na ist",
  "Na hku",
  "Na abatce",
  "Na acht",
  "Na afrnce",
  "Na ancch",
  "Na ediv",
  "Na ejdru",
  "Na ejdru",
  "Na mukce",
  "Na pejcharu",
  "Na pitlce",
  "Na pitlsku",
  "Na tamberku",
  "Na tpnici",
  "Na ub",
  "Na umav",
  "Na utce",
  "Na vihance",
  "Na hlavce",
  "Na ertvch",
  "Na vahov",
  "Naardensk",
  "Nad Akczem",
  "Nad Akty",
  "Nad Alej",
  "Nad Belvederem",
  "Nad Belri",
  "Nad Berounkou",
  "Nad Bertramkou",
  "Nad Botiem",
  "Nad Boislavkou",
  "Nad Boislavkou",
  "Nad Branickm Pivovarem",
  "Nad Brdkem",
  "Nad Brdkem",
  "Nad Bunkami I",
  "Nad Bunkami Ii",
  "Nad Bunkami Iii",
  "Nad Cementrnou",
  "Nad Chaloupkami",
  "Nad Chuchl",
  "Nad Cihelnou",
  "Nad Dalejskm dolm",
  "Nad Doly",
  "Nad Dolky",
  "Nad Drahou",
  "Nad Dubovm Mlnem",
  "Nad Dvorem",
  "Nad Dlnic",
  "Nad Elektrrnou",
  "Nad Elektrrnou",
  "Nad Flajnerkou",
  "Nad Habrovkou",
  "Nad Havlem",
  "Nad Helmrovkou",
  "Nad Hercovkou",
  "Nad Hercovkou",
  "Nad Hlinkem",
  "Nad Hlinkem",
  "Nad Horizontem",
  "Nad Hradnm Potokem",
  "Nad Hradnm Vodojemem",
  "Nad Husovmi Sady",
  "Nad Hutmi",
  "Nad Hutmi",
  "Nad Hjem",
  "Nad Hitm",
  "Nad Jenerlkou",
  "Nad Jetelkou",
  "Nad Jezem",
  "Nad Jezerkou",
  "Nad Jordnkem",
  "Nad Kajetnkou",
  "Nad Kamnkou",
  "Nad Kaplankou",
  "Nad Kaplikou",
  "Nad Kavalrkou",
  "Nad Kazankou",
  "Nad Kaznem",
  "Nad Kelerkou",
  "Nad Kesnerkou",
  "Nad Klamovkou",
  "Nad Klikovkou",
  "Nad Klovem",
  "Nad Koloni",
  "Nad Kolavkou",
  "Nad Komornickou",
  "Nad Konenou",
  "Nad Konvkou",
  "Nad Kostelem",
  "Nad Kotlaskou I",
  "Nad Kotlaskou Ii",
  "Nad Kotlaskou Iii",
  "Nad Kotlaskou Iv",
  "Nad Kotlaskou V",
  "Nad Koulkou",
  "Nad Koupadly",
  "Nad Koupalitm",
  "Nad Koinkou",
  "Nad Kokem",
  "Nad Krocnkou",
  "Nad Krocnkou",
  "Nad Krlovskou Oborou",
  "Nad Kulikou",
  "Nad Kundratkou",
  "Nad Kundratkou",
  "Nad Kundratkou",
  "Nad Kkem",
  "Nad Laurovou",
  "Nad Lesem",
  "Nad Lesnm Divadlem",
  "Nad Leskem",
  "Nad Libeskm Ndram",
  "Nad Libeskm Potokem",
  "Nad Libuskm Potokem",
  "Nad Lib",
  "Nad Lomem",
  "Nad Lomy",
  "Nad Lukami",
  "Nad Lvkou",
  "Nad Malm Mtem",
  "Nad Manovkou",
  "Nad Markytou",
  "Nad Mazankou",
  "Nad Meandry",
  "Nad Mlynkou",
  "Nad Mlnem",
  "Nad Mlnskm Potokem",
  "Nad Mohylou",
  "Nad Mokinou",
  "Nad Mostem",
  "Nad Motolskou Nemocnic",
  "Nad Motolskou Nemocnic",
  "Nad Mrzovkou",
  "Nad Mulovkou",
  "Nad Mulovkou",
  "Nad Novou Libn",
  "Nad Nuslemi",
  "Nad Ndram",
  "Nad Ndr",
  "Nad Nhonem",
  "Nad Nmstm",
  "Nad Nvs",
  "Nad Obc I",
  "Nad Obc Ii",
  "Nad Octrnou",
  "Nad Odbokou",
  "Nad Ohradou",
  "Nad Okrouhlkem",
  "Nad Olinami",
  "Nad Olinami",
  "Nad Ondejovem",
  "Nad Opatovem",
  "Nad Ostrovem",
  "Nad Pahorkem",
  "Nad Palatou",
  "Nad Panenskou",
  "Nad Parkem",
  "Nad Parknem",
  "Nad Paankou",
  "Nad Pentlovkou",
  "Nad Petruskou",
  "Nad Petynkou",
  "Nad Plynovodem",
  "Nad Podbabskou Sklou",
  "Nad Pomnkem",
  "Nad Popelkou",
  "Nad Popelkou",
  "Nad Potkem",
  "Nad Prahou",
  "Nad Pramenem",
  "Nad Primaskou",
  "Nad Primaskou",
  "Nad Propust",
  "Nad Pruhy",
  "Nad Pskovnou",
  "Nad Pehradou",
  "Nad Pvozem",
  "Nad Radotnem",
  "Nad Rohatci",
  "Nad Rokl",
  "Nad Rokoskou",
  "Nad Rokytkou",
  "Nad Rybnkem",
  "Nad Rybnkem",
  "Nad Rybnky",
  "Nad Rynkou",
  "Nad Rkem",
  "Nad Sadem",
  "Nad Sady",
  "Nad Santokou",
  "Nad Schody",
  "Nad Sklou",
  "Nad Slvi",
  "Nad Slvi",
  "Nad Smetankou",
  "Nad Sokolovnou",
  "Nad Soutokem",
  "Nad Soutokem",
  "Nad Splavem",
  "Nad Spdem",
  "Nad Splenm Mlnem",
  "Nad Stanic",
  "Nad Starou Pskovnou",
  "Nad Statkem",
  "Nad Strakovkou",
  "Nad Strouhou",
  "Nad Strn",
  "Nad Strn",
  "Nad Studnkou",
  "Nad Svahem",
  "Nad Spkou",
  "Nad Tejnkou",
  "Nad Teplrnou",
  "Nad Topoly",
  "Nad Trat",
  "Nad Trnkovem",
  "Nad Trojou",
  "Nad Turbovou",
  "Nad Tebenem I",
  "Nad Tebenem Ii",
  "Nad Tebenem Ii",
  "Nad Tebenem Iii",
  "Nad Tebenem Iii",
  "Nad Vavroukou",
  "Nad Vernerkem",
  "Nad Vinic",
  "Nad Vinnm Potokem",
  "Nad Vinnm Potokem",
  "Nad Vinnm Potokem",
  "Nad Vinohradem",
  "Nad Viovkou",
  "Nad Vltavou",
  "Nad Vodovodem",
  "Nad Vodovodem",
  "Nad Vojenskm Hbitovem",
  "Nad Vokolky",
  "Nad Volykou",
  "Nad Vrbami",
  "Nad Vrstvami",
  "Nad Vrovskou Horou",
  "Nad Vs",
  "Nad Vysoany",
  "Nad Vclavkou",
  "Nad Vpust",
  "Nad Vinkou",
  "Nad Zahradnictvm",
  "Nad Zatkou",
  "Nad Zavkou",
  "Nad Zbraslav",
  "Nad Zbrojnic",
  "Nad Zemankou",
  "Nad Zemankou",
  "Nad Zlatnic",
  "Nad Zlchovem",
  "Nad Zlonou",
  "Nad Zmekem",
  "Nad Zmenic",
  "Nad Ztim",
  "Nad Zvoditm",
  "Nad Zvrkou",
  "Nad dolm",
  "Nad dolm Hvzd",
  "Nad padem",
  "Nad vozem",
  "Nad labinou",
  "Nad labinou",
  "Nad afrnkou",
  "Nad ancemi",
  "Nad auerovmi Sady",
  "Nad eberkem",
  "Nad ejdrem",
  "Nad estikopy",
  "Nad etelkou",
  "Nad tolou",
  "Nad utkou",
  "Nad lkovnou",
  "Nad rkou",
  "Nad elivkou",
  "Nad lbkem",
  "Nademlejnsk",
  "Nadjovsk",
  "Narcisov",
  "Naskov",
  "Natanaelka",
  "Navarova",
  "Navigtor",
  "Navrtilova",
  "Naeradeck",
  "Naeick",
  "Neapolsk",
  "Nebeskho",
  "Nebovidsk",
  "Nebozzek-Sady",
  "Nebuick",
  "Nechanick",
  "Nechanskho",
  "Nechvalick",
  "Nechvlova",
  "Nechybova",
  "Nedaovsk",
  "Nedbalova",
  "Nedokonen",
  "Nedokonen",
  "Nedonsk",
  "Nedraick",
  "Nedvdick",
  "Nedvdovo Nm.",
  "Nedvdovo Nmst",
  "Nedvzsk",
  "Neffova",
  "Nefritov",
  "Neherovsk",
  "Nehvizdsk",
  "Nehvizdsk",
  "Nejdkova",
  "Neklanova",
  "Nekvasilova",
  "Nekzanka",
  "Nemocnin",
  "Nemoick",
  "Nepasick Nm.",
  "Nepasick Nmst",
  "Nepelova",
  "Nepilova",
  "Nepomuck",
  "Nepomuckch",
  "Nepovolen",
  "Nepravideln",
  "Neprjezdn",
  "Neplsk",
  "Neratovick",
  "Nerudova",
  "Nerudova",
  "Nesmick",
  "Nespeck",
  "Nesvadbova",
  "Netluck",
  "Netluky",
  "Netolick",
  "Netuilsk",
  "Netnsk",
  "Netebick",
  "Netebsk",
  "Neumannova",
  "Neustupnho",
  "Neuilova",
  "Nevanova",
  "Neveklovsk",
  "Newtonova",
  "Nezamyslova",
  "Nezdova",
  "Nezvalova",
  "Neova",
  "Neporova",
  "Nersk",
  "Nickerleho",
  "Niederleho",
  "Nikodmova",
  "Nikoly Tesly",
  "Nikoly Vapcarova",
  "Nisk",
  "Nitransk",
  "Nitransk",
  "Nivnick",
  "Nobelova",
  "Norbertov",
  "Norsk",
  "Nosick",
  "Nosticova",
  "Notesk",
  "Noutonick",
  "Nouzov",
  "Nouzovsk Nm.",
  "Nouzovsk Nmst",
  "Nouzov",
  "Novgorodsk",
  "Novobohdaleck",
  "Novoborsk",
  "Novoborsk",
  "Novochuchelsk",
  "Novodvorsk",
  "Novodvorsk",
  "Novodvorsk",
  "Novodvorsk",
  "Novohradsk",
  "Novohrdeck",
  "Novohrdeck",
  "Novolhotsk",
  "Novolipansk",
  "Novomeskho",
  "Novomeskho",
  "Novomlnsk",
  "Novopack",
  "Novopetrovick",
  "Novorossijsk",
  "Novosibinsk",
  "Novostranick",
  "Novosuchdolsk",
  "Novosvtsk",
  "Novotnho Lvka",
  "Novovesk",
  "Novovesk",
  "Novovysoansk",
  "Novovysoansk",
  "Novovysoansk",
  "Novozmeck",
  "Novozmeck",
  "Novokolsk",
  "Novotrboholsk",
  "Nov",
  "Nov Cesta",
  "Nov Kolonie",
  "Nov Ves",
  "Nov Ves",
  "Nov rka",
  "Novkovo Nm.",
  "Novkovo Nmst",
  "Novkovch",
  "Nov Domy",
  "Nov Dvory",
  "Nov Mlny",
  "Nov Nmst",
  "Novho",
  "Nov Lesk",
  "Nov Svt",
  "Nov Zlchov",
  "Nov Zlchov",
  "Nupack",
  "Nuselsk",
  "Nuselsk",
  "Nuick",
  "Nulova",
  "Nymbursk",
  "Nb. Edvarda Benee",
  "Nb. Edvarda Benee",
  "Nb. Edvarda Benee",
  "Nb. Kapitna Jaroe",
  "Nb. Kapitna Jaroe",
  "Nben",
  "Nbe Edvarda Benee",
  "Nbe Edvarda Benee",
  "Nbe Edvarda Benee",
  "Nbe Kapitna Jaroe",
  "Nbe Ludvka Svobody",
  "Nchodsk",
  "Ndran",
  "Ndran",
  "Ndvorn",
  "Nhorn",
  "Nkupn",
  "Nm. 14. jna",
  "Nm. 25. Bezna",
  "Nm. Antonna Pecka",
  "Nm. Barikd",
  "Nm. Boislavka",
  "Nm. Brat Synk",
  "Nm. Chuchelskch Bojovnk",
  "Nm. Chuchleskch Bojovnk",
  "Nm. Curieovch",
  "Nm. Dr. V. Holho",
  "Nm. Franze Kafky",
  "Nm. Generla Kutlvara",
  "Nm. Hrdin",
  "Nm. I. P. Pavlova",
  "Nm. Interbrigdy",
  "Nm. Jana Palacha",
  "Nm. Jana Palacha",
  "Nm. Jiho Berana",
  "Nm. Jiho Z Lobkovic",
  "Nm. Jiho Z Podbrad",
  "Nm. Jiho Z Podbrad",
  "Nm. Josefa Machka",
  "Nm. Kinskch",
  "Nm. Kinskch",
  "Nm. Mezi Zahrdkami",
  "Nm. Na Balabence",
  "Nm. Na Farkn",
  "Nm. Na Luinch",
  "Nm. Na Santince",
  "Nm. Na Stri",
  "Nm. Omladiny",
  "Nm. Osvoboditel",
  "Nm. Padlch",
  "Nm. Pod Katany",
  "Nm. Pod Lpou",
  "Nm. Prezidenta Masaryka",
  "Nm. Ped Bateriemi",
  "Nm. Republiky",
  "Nm. Smiickch",
  "Nm. Svatopluka echa",
  "Nm. Svobody",
  "Nm. U Lva",
  "Nm. U Lpy Svobody",
  "Nm. U Svatho Ji",
  "Nm. Winstona Churchilla",
  "Nm. eskho Povstn",
  "Nm.Organizace Spojench Nrod",
  "Nm.Plukovnka Vlka",
  "Nmst 14. jna",
  "Nmst 25. Bezna",
  "Nmst Antonna Pecka",
  "Nmst Barikd",
  "Nmst Boislavka",
  "Nmst Boislavka",
  "Nmst Brat Jandus",
  "Nmst Brat Synk",
  "Nmst Chuchelskch Bojovnk",
  "Nmst Curieovch",
  "Nmst Dr. Vclava Holho",
  "Nmst Generla Kutlvara",
  "Nmst Hrdin",
  "Nmst I. P. Pavlova",
  "Nmst Interbrigdy",
  "Nmst Jana Palacha",
  "Nmst Jana Palacha",
  "Nmst Jiho Berana",
  "Nmst Jiho Z Lobkovic",
  "Nmst Jiho Z Podbrad",
  "Nmst Jiho Z Podbrad",
  "Nmst Josefa Machka",
  "Nmst Junkovch",
  "Nmst Kinskch",
  "Nmst Kinskch",
  "Nmst Kosmonaut",
  "Nmst Mezi Zahrdkami",
  "Nmst Mru",
  "Nmst Na Balabence",
  "Nmst Na Farkn",
  "Nmst Na Luinch",
  "Nmst Na Santince",
  "Nmst Na Stri",
  "Nmst Omladiny",
  "Nmst Organizace Spojench Nrod",
  "Nmst Osvoboditel",
  "Nmst Padlch",
  "Nmst Plukovnka Vlka",
  "Nmst Pod Emauzy",
  "Nmst Pod Katany",
  "Nmst Pod Lpou",
  "Nmst Prezidenta Masaryka",
  "Nmst Protifaistickch Bojovnk",
  "Nmst Ped Bateriemi",
  "Nmst Ptelstv",
  "Nmst Republiky",
  "Nmst Republiky",
  "Nmst Smiickch",
  "Nmst Sv. Petra A Pavla",
  "Nmst Svatopluka echa",
  "Nmst Svobody",
  "Nmst U Lva",
  "Nmst U Lpy Svobody",
  "Nmst U Svatho Ji",
  "Nmst Winstona Churchilla",
  "Nmst Zdenky Braunerov",
  "Nmst eskho Povstn",
  "Nplavn",
  "Nprstkova",
  "Nrodn",
  "Nrodn",
  "Nrodn Obrany",
  "Nrodnch Hrdin",
  "Nron",
  "Nsirovo Nm.",
  "Nsirovo Nmst",
  "Nstrojsk",
  "Nvazn",
  "Nvrn",
  "Nvtrn",
  "Nvtrn",
  "Nzovsk",
  "Ndeck",
  "Nrsk",
  "Nansk",
  "Nmick",
  "Nvsk",
  "Obchodn",
  "Obchodn Nm.",
  "Obchodn Nmst",
  "Obiln",
  "Objzdn",
  "Obloukov",
  "Obora Hvzda",
  "Oborsk",
  "Obratask",
  "Obrovskho",
  "Obsiny",
  "Obslun",
  "Obvodov",
  "Obdovick",
  "Obt 6. Kvtna",
  "Obt 6.Kvtna",
  "Ocelkova",
  "Ocelsk",
  "Ocelsk",
  "Ocelkova",
  "Ochozsk",
  "Ochranovsk",
  "Od Rozcest",
  "Od Vysok",
  "Od koly",
  "Odboje",
  "Odbor",
  "Odbon",
  "Oddechov",
  "Oddlen",
  "Odersk",
  "Odlehl",
  "Ohmova",
  "Ohnivcova",
  "Ohniansk",
  "Ohradn",
  "Ohradn",
  "Ohradsk",
  "Ohradsk Nm.",
  "Ohradsk Nmst",
  "Ohrobeck",
  "Okensk",
  "Okosk",
  "Okrajn",
  "Okrajov",
  "Okrajov",
  "Okrasn",
  "Okrouhlick",
  "Okrouhlkova",
  "Okrov",
  "Okruhov",
  "Okrun",
  "Okrun",
  "Okneck",
  "Olbrachtova",
  "Olbramovick",
  "Oldichova",
  "Olenick",
  "Olesk",
  "Olgy Havlov",
  "Olivova",
  "Olomouck",
  "Olympijsk",
  "Olansk",
  "Olansk Nm.",
  "Olansk Nmst",
  "Olovick",
  "Olov",
  "Oltnsk",
  "Omladin",
  "Omsk",
  "Ondejovsk",
  "Ondkova",
  "Ondkova",
  "Onoveck",
  "Opata Konrda",
  "Opatovick",
  "Opatovsk",
  "Opatovsk",
  "Opatilka",
  "Opatilka",
  "Opaansk",
  "Oplansk",
  "Opletalova",
  "Opolsk",
  "Opoensk",
  "Oponsk",
  "Opravsk",
  "Opukov",
  "Oplkova",
  "Oplov",
  "Oravsk",
  "Ordovick",
  "Orebitsk",
  "Orelsk",
  "Orlick",
  "Ortenovo Nmst",
  "Osadn",
  "Osamocen",
  "Oseck",
  "Oset",
  "Osick",
  "Osikov",
  "Osinalick",
  "Oslunn",
  "Osmho Listopadu",
  "Osnick",
  "Osnick",
  "Osnick",
  "Ostravick",
  "Ostravsk",
  "Ostromesk",
  "Ostrov tvanice",
  "Ostrovn",
  "Ostrovskho",
  "Ostruensk",
  "Ostruinov",
  "Ostr",
  "Ostrilovo Nm.",
  "Ostrilovo Nmst",
  "Ostedeck",
  "Osticov",
  "Osvobozen",
  "Osvtov",
  "Otakara Vrby",
  "Otakarova",
  "Otavova",
  "Otavova",
  "Otavsk",
  "Oteven",
  "Otick",
  "Otlkovsk",
  "Otopask",
  "Otovick",
  "Otradovick",
  "Ottova",
  "Otvovick",
  "Oty Pavla",
  "Otnsk",
  "Otnsk",
  "Ouholick",
  "Ouhrabkova",
  "Oveneck",
  "Oveneck",
  "Ovesn",
  "Ovocn",
  "Ovocnsk",
  "Ovocn Trh",
  "Ovskov",
  "Ovlov",
  "Ovrsk",
  "Ov Hjek",
  "Oechov",
  "Oesk",
  "Pabnick",
  "Pabnick",
  "Pacajevova",
  "Paceick",
  "Pacholkova",
  "Pacovsk",
  "Paculova",
  "Padovsk",
  "Pajerova",
  "Pakomick",
  "Palackho",
  "Palackho Nm.",
  "Palackho Nmst",
  "Palmetov",
  "Palmovka",
  "Palskova",
  "Pampelikov",
  "Pancova",
  "Panelov",
  "Panenky",
  "Panensk",
  "Pankrck Nmst",
  "Pansk",
  "Pansk Zahrada",
  "Pansk Dvr",
  "Panukova",
  "Paprskov",
  "Paprensk",
  "Paprnkova",
  "Parautist",
  "Pardubick",
  "Park Ptelstv",
  "Parkov",
  "Parlova",
  "Parlova",
  "Parmsk",
  "Paroplavebn",
  "Partyznsk",
  "Paseck",
  "Pasteurova",
  "Pastevc",
  "Patokova",
  "Patokova",
  "Patokova",
  "Pavelkova",
  "Pavla Benee",
  "Pavla vandy Ze Semic",
  "Pavlick",
  "Pavliovsk",
  "Pavlovick",
  "Pavlovsk",
  "Pavlkova",
  "Pavrovskho",
  "Pakova",
  "Pazkova",
  "Pask",
  "Pask",
  "Pakova",
  "Paanka",
  "Peceradsk",
  "Pecharova",
  "Pechltova",
  "Pechltova",
  "Pechkova",
  "Peckova",
  "Pejevov",
  "Pekaova",
  "Pekaova",
  "Pekask",
  "Pekrensk",
  "Pekrkova",
  "Pelclova",
  "Pelechovsk",
  "Pelhimovsk",
  "Peliknova",
  "Pellova",
  "Pellova",
  "Pelnova",
  "Pelukov",
  "Pelykov",
  "Pelzova",
  "Penzovkov",
  "Perlitov",
  "Perlitov",
  "Perlov",
  "Pernerova",
  "Pernerova",
  "Peroutkova",
  "Peroutkova",
  "Peroutkova",
  "Peroutkova",
  "Perspektivn",
  "Pertoldova",
  "Peruck",
  "Perunova",
  "Pertejnsk",
  "Petra Bezrue",
  "Petra Rezka",
  "Petra Slezka",
  "Petrbokova",
  "Petrklov",
  "Petrohradsk",
  "Petrovick",
  "Petrovsk",
  "Petrsk",
  "Petrsk Nm.",
  "Petrsk Nmst",
  "Petrkova",
  "Petrlkova",
  "Petrlova",
  "Petrkova",
  "Petkova",
  "Petkovsk",
  "Petnsk",
  "Petnsk",
  "Petnsk Sady",
  "Petnsk Sady",
  "Pevnostn",
  "Perkov",
  "Peinova",
  "Pekova",
  "Pelova",
  "Peova",
  "Petukova",
  "Pekova",
  "Picassova",
  "Pickova",
  "Pihelsk",
  "Pikovick",
  "Pikrtova",
  "Pilask",
  "Pilnkovsk",
  "Pilot",
  "Pilovsk",
  "Pilovsk",
  "Pilsk",
  "Pirinsk",
  "Pirnerova",
  "Pitkovick",
  "Pitterova",
  "Pivcova",
  "Pivovarnick",
  "Pivovarsk",
  "Pivokov",
  "Pitkova",
  "Placina",
  "Placina",
  "Plajnerova",
  "Plamnkov",
  "Plask",
  "Platanov",
  "Platnsk",
  "Platnova",
  "Plaveck",
  "Plavnov",
  "Plaick",
  "Plaansk",
  "Plevensk",
  "Plenikova",
  "Plhovsk",
  "Plickova",
  "Plkovsk",
  "Plojharova",
  "Ploskovick",
  "Plounick",
  "Plovdivsk",
  "Plon",
  "Plotilova",
  "Plukovnka Mrze",
  "Plumlovsk",
  "Plutova",
  "Plynrn",
  "Plzesk",
  "Plzesk",
  "Plzesk",
  "Plzesk",
  "Plzesk",
  "Plnick",
  "Plnikova",
  "Poberova",
  "Pobon",
  "Pobosk",
  "Pobovick",
  "Poben",
  "Poben Cesta",
  "Pod Akty",
  "Pod Altnem",
  "Pod Altnem",
  "Pod Andlkou",
  "Pod Arelem",
  "Pod Aritmou",
  "Pod Ateliry",
  "Pod Bahnivkou",
  "Pod Balknem",
  "Pod Barvkou",
  "Pod Bateriemi",
  "Pod Batami",
  "Pod Belvederem",
  "Pod Belri",
  "Pod Bernkem",
  "Pod Bernkou",
  "Pod Betn",
  "Pod Bohdalcem I",
  "Pod Bohdalcem I",
  "Pod Bohdalcem Ii",
  "Pod Brentovou",
  "Pod Bruskou",
  "Pod Bunkou",
  "Pod Bn",
  "Pod Bezinou",
  "Pod Chaloupkami",
  "Pod Chodovem",
  "Pod Cihelnou",
  "Pod Cihelnou",
  "Pod Cukrkem",
  "Pod Csakou",
  "Pod Dldnkou",
  "Pod Domky",
  "Pod Drinopolem",
  "Pod Drhou",
  "Pod Duby",
  "Pod Dvorem",
  "Pod Dlnic",
  "Pod Dkankou",
  "Pod Dkankou",
  "Pod Dvnem",
  "Pod Farou",
  "Pod Fialkou",
  "Pod Formankou",
  "Pod Fotem",
  "Pod Garemi",
  "Pod Habrovkou",
  "Pod Habrovou",
  "Pod Haltem",
  "Pod Harfou",
  "Pod Havlnem",
  "Pod Havrnkou",
  "Pod Havrnkou",
  "Pod Hlinitm",
  "Pod Hloubtnskou Zastvkou",
  "Pod Hlskem",
  "Pod Homolkou",
  "Pod Hotelem",
  "Pod Hoavkou",
  "Pod Hrachovkou",
  "Pod Hradbami",
  "Pod Hradem",
  "Pod Hranic",
  "Pod Hrz",
  "Pod Hvzdou",
  "Pod Hvzdrnou",
  "Pod Hvzdrnou",
  "Pod Hybmankou",
  "Pod Hjem",
  "Pod Hjkem",
  "Pod Hjovnou",
  "Pod Hbitovem",
  "Pod Hitm",
  "Pod Jalovm Dvorem",
  "Pod Jankovem",
  "Pod Jarovem",
  "Pod Javory",
  "Pod Jirskovou tvrt",
  "Pod Juliskou",
  "Pod Kamnkou",
  "Pod Kaplikou",
  "Pod Kaplikou",
  "Pod Karlovarskou Silnic",
  "Pod Karlovem",
  "Pod Kavalrkou",
  "Pod Katany",
  "Pod Katany",
  "Pod Kesnerkou",
  "Pod Kladenskou Silnic",
  "Pod Klamovkou",
  "Pod Klapic",
  "Pod Klaudinkou",
  "Pod Klikovkou",
  "Pod Kopcem",
  "Pod Kostelem",
  "Pod Kotlaskou",
  "Pod Kotlkou",
  "Pod Kotlkou",
  "Pod Kotlkou",
  "Pod Krejcrkem",
  "Pod Krocnkou",
  "Pod Krlovkou",
  "Pod Krskm Lesem",
  "Pod Kulturnm Domem",
  "Pod Kynclovkou",
  "Pod Kem",
  "Pod Kkem",
  "Pod Labukou",
  "Pod Lahovskou",
  "Pod Lesem",
  "Pod Leskem",
  "Pod Letitm",
  "Pod Le",
  "Pod Lipami",
  "Pod Lipkami",
  "Pod Lisem",
  "Pod Lisem",
  "Pod Lochkovem",
  "Pod Lomem",
  "Pod Lysinami",
  "Pod Lzn",
  "Pod Marjnkou",
  "Pod Marktou",
  "Pod Martinem",
  "Pod Melikou",
  "Pod Mlnkem",
  "Pod Mohylou",
  "Pod Mostem",
  "Pod Naptm",
  "Pod Nouzovem",
  "Pod Novou kolou",
  "Pod Novm Lesem",
  "Pod Novm Lesem",
  "Pod Nuselskmi Schody",
  "Pod Nmstm",
  "Pod Nplavkou",
  "Pod Nplavkou",
  "Pod Nspem",
  "Pod Nvs",
  "Pod Oborou",
  "Pod Ovnem",
  "Pod Oechovkou",
  "Pod Palatou",
  "Pod Palrkou",
  "Pod Parukkou",
  "Pod Paankou",
  "Pod Paankou",
  "Pod Pekakou",
  "Pod Pekrnami",
  "Pod Petinami",
  "Pod Plynojemem",
  "Pod Plynojemem",
  "Pod Plynojemem",
  "Pod Plskavou",
  "Pod Potou",
  "Pod Pramenem",
  "Pod Prodejnou",
  "Pod Prsekem",
  "Pod Psenou",
  "Pod Pehradou",
  "Pod Pesypem",
  "Pod Radnic",
  "Pod Rapidem",
  "Pod Rapidem",
  "Pod Rapidem",
  "Pod Remzkem",
  "Pod Rovinou",
  "Pod Rozvodnou",
  "Pod Rybnkem",
  "Pod Rybnkem",
  "Pod Sady",
  "Pod Salabkou",
  "Pod Sirnou",
  "Pod Skalkou",
  "Pod Skalou",
  "Pod Sklenkou",
  "Pod Slovany",
  "Pod Smetankou",
  "Pod Sokolovnou",
  "Pod Soutratm",
  "Pod Spalovnou",
  "Pod Spiritkou",
  "Pod Spravedlnost",
  "Pod Srzem",
  "Pod Stadiony",
  "Pod Stanic",
  "Pod Starou kolou",
  "Pod Starkem",
  "Pod Statky",
  "Pod Stranickou Vinic",
  "Pod Strojrnami",
  "Pod Strn",
  "Pod Studnkou",
  "Pod Stupni",
  "Pod Strkou",
  "Pod Strkou",
  "Pod Strkou",
  "Pod Svahem",
  "Pod Sychrovem I",
  "Pod Sychrovem I",
  "Pod Sychrovem I",
  "Pod Sychrovem Ii",
  "Pod Sdlitm",
  "Pod Terasami",
  "Pod Terebkou",
  "Pod Topoly",
  "Pod Trat",
  "Pod Turnovskou Trat",
  "Pod Turnovskou Trat",
  "Pod Tborem",
  "Pod Tborem",
  "Pod Tebenem",
  "Pod Tenmi",
  "Pod Teovkou",
  "Pod Urnovm Hjem",
  "Pod Valem",
  "Pod Vartou",
  "Pod Vavincem",
  "Pod Velkm Hjem",
  "Pod Viaduktem",
  "Pod Vidoul",
  "Pod Viktorkou",
  "Pod Vilami",
  "Pod Vinicemi",
  "Pod Vinic",
  "Pod Vinohradem",
  "Pod Viovkou",
  "Pod Vlachovkou",
  "Pod Vlastnm Krovem",
  "Pod Vlkem",
  "Pod Vodojemem",
  "Pod Vodovodem",
  "Pod Vodrenskou V",
  "Pod Vrchem",
  "Pod Vrcholem",
  "Pod Vrstevnic",
  "Pod Vrkem",
  "Pod Vrkem",
  "Pod Vrovickou Vodrnou I",
  "Pod Vrovickou Vodrnou Ii",
  "Pod Vrovickou Vodrnou Iii",
  "Pod Vs",
  "Pod Vyhldkou",
  "Pod Vysokou",
  "Pod Vysokou Mez",
  "Pod Vyslakou",
  "Pod Vyehradem",
  "Pod Vclavem",
  "Pod Vtkovem",
  "Pod Vtopnou",
  "Pod Vinkou",
  "Pod Vtrolamem",
  "Pod Vtrovem",
  "Pod V",
  "Pod Zahradami",
  "Pod Zahrdkami",
  "Pod Zastvkou",
  "Pod Zatkou",
  "Pod Zbuzany",
  "Pod Zemankou",
  "Pod Zlinem",
  "Pod Zvonakou",
  "Pod Zvonikou",
  "Pod Zmekem",
  "Pod Zvrkou",
  "Pod tesy",
  "Pod ertovou Skalou",
  "Pod ihadlem",
  "Pod imickm Hjem",
  "Pod ancemi",
  "Pod kolou",
  "Pod mukkou",
  "Pod pejcharem",
  "Pod pitlem",
  "Pod tpem",
  "Pod vahovem",
  "Podbabsk",
  "Podbabsk",
  "Podblohorsk",
  "Podblov",
  "Podchsk",
  "Podedvorsk",
  "Podhajsk Pole",
  "Podhol",
  "Podhorsk",
  "Podhosk",
  "Podivnsk",
  "Podjavorinsk",
  "Podjezd",
  "Podkovsk",
  "Podkrkonosk",
  "Podkrkonoskch Tkalc",
  "Podle Kaerova",
  "Podle Lomu",
  "Podle Lomu",
  "Podle Nhonu",
  "Podle Nhonu",
  "Podle Sad",
  "Podle Trati",
  "Podlesek",
  "Podlesk",
  "Podlesn",
  "Podlensk",
  "Podlibsk",
  "Podlipnho",
  "Podliovsk",
  "Podluansk",
  "Podlkov",
  "Podnikatelsk",
  "Podndran",
  "Podohradsk",
  "Podolansk",
  "Podolsk",
  "Podolsk",
  "Podolsk Nb.",
  "Podolsk Nbe",
  "Podolsk Schody",
  "Podprova",
  "Podskalsk",
  "Podsychrovsk",
  "Podvinn Mln",
  "Podvinn Mln",
  "Podzmeck",
  "Podova",
  "Podbradova",
  "Podbradova",
  "Podbradsk",
  "Podbradsk",
  "Podbradsk",
  "Podl",
  "Pohledn",
  "Pohnertova",
  "Pohoelec",
  "Pohoelec",
  "Pokojn",
  "Pokornho",
  "Pokiven",
  "Polabsk",
  "Polabsk",
  "Polaneckho",
  "Poledn",
  "Poledn",
  "Polensk",
  "Polepsk",
  "Poleradsk",
  "Polesn",
  "Poleovick",
  "Politickch Vz",
  "Poliansk",
  "Poljanovova",
  "Poln",
  "Polovnick",
  "Polsk",
  "Polygrafick",
  "Polkova",
  "Polkova",
  "Polkensk",
  "Polvkova",
  "Pomezn",
  "Pomnnkov",
  "Pomoansk",
  "Ponrepova",
  "Poplun",
  "Popovick",
  "Popovova",
  "Posledn",
  "Pospchalova",
  "Pospilova",
  "Postlova",
  "Postrann",
  "Postupick",
  "Postekovsk",
  "Postinsk",
  "Postinsk",
  "Potock",
  "Poton",
  "Pouchova",
  "Pouptova",
  "Poustka",
  "Povltavsk",
  "Povltavsk",
  "Povltavsk",
  "Povodov",
  "Pozdesk",
  "Poznask",
  "Poeradsk",
  "Poernick",
  "Poernick",
  "Poteck",
  "Poteck",
  "Poansk",
  "Poansk",
  "Posk",
  "Poepnho Nm.",
  "Poepnho Nmst",
  "Potovsk",
  "Pornick",
  "Pplk. Novka",
  "Pplk. Sochora",
  "Prachatick",
  "Prachnerova",
  "Prachovick",
  "Prachovsk",
  "Pramenn",
  "Pramenn",
  "Pravohl",
  "Pravsk",
  "Prav",
  "Pran",
  "Prask",
  "Praskho",
  "Praskho Povstn",
  "Prask Okruh",
  "Prakovsk",
  "Preftova",
  "Preislerova",
  "Prelta",
  "Preltsk",
  "Preslova",
  "Primtorsk",
  "Probluzsk",
  "Probotsk",
  "Prochzkova",
  "Prodlouen",
  "Prokofjevova",
  "Prokopka",
  "Prokopova",
  "Prokopovo Nm.",
  "Prokopovo Nmst",
  "Prokopovch",
  "Prokopsk",
  "Prokopsk dol",
  "Prokopsk dol",
  "Prorektorsk",
  "Proseck",
  "Proseck",
  "Proseck",
  "Prosincov",
  "Proslunn",
  "Prosn",
  "Prostedn",
  "Proti Proudu",
  "Protilehl",
  "Protivnsk",
  "Proutn",
  "Prouzova",
  "Provaznick",
  "Provozn",
  "Prunovsk",
  "Prusick",
  "Pruskova",
  "Pruneck",
  "Prvnho Pluku",
  "Prvnho Pluku",
  "Prvomjov",
  "Prchesk",
  "Prsk",
  "Prbn",
  "Prchodn",
  "Prchova",
  "Prhledov",
  "Prhonek",
  "Prhonek",
  "Prhonick",
  "Prhonsk",
  "Prjezdn",
  "Prmyslov",
  "Prmyslov",
  "Prmyslov",
  "Prmyslov",
  "Prtan",
  "Preln",
  "Prkova",
  "Psohlavc",
  "Pstrun",
  "Psrsk",
  "Ptnick",
  "Puchmajerova",
  "Puchmajerova",
  "Pujmanov",
  "Pujmanov",
  "Pujmanov",
  "Purkrabsk",
  "Purkyova",
  "Putimsk",
  "Puova",
  "Pukinovo Nm.",
  "Pukinovo Nmst",
  "Pyelsk",
  "Plavsk",
  "Plkask",
  "Pmelnkov",
  "Pnkova",
  "Ptkova",
  "Pvovsk Nmst",
  "Pseck",
  "Pseckho",
  "Psen",
  "Pskask",
  "Pskovcov",
  "Pskovna",
  "Pskov",
  "Psnick",
  "Psnick",
  "Psnick Zahrady",
  "Psit",
  "Pkova",
  "Povick",
  "Pslova",
  "Pchovsk",
  "Pchovsk",
  "Pchavkov",
  "Prov",
  "Pnkav",
  "Pstitelsk",
  "Ptidom",
  "Ptipeskho",
  "P",
  "Pecechtlova",
  "Pechodn",
  "Ped Cibulkami",
  "Ped Drhou",
  "Ped Mosty",
  "Ped Ndram",
  "Ped Oborou",
  "Ped Rybnkem",
  "Ped Skalkami I",
  "Ped Skalkami Ii",
  "Ped Sklou",
  "Ped Sokolovnou",
  "Ped Trat",
  "Ped stavem",
  "Pedbosk",
  "Pedmick",
  "Pedn",
  "Pedpoln",
  "Pedposledn",
  "Pedvoje",
  "Pedvoje",
  "Pedkoln",
  "Peletov",
  "Pelousk",
  "Pemyslova",
  "Pemyslovsk",
  "Pemyslovsk",
  "Pemylensk",
  "Peruen",
  "Peslikov",
  "Pespoln",
  "Petluck",
  "Peuilova",
  "Pevoznick",
  "Pezletick",
  "Petick",
  "Petnsk",
  "Peat",
  "Pi Hranici",
  "Pi Hranici",
  "Pi Trati",
  "Pibyslavsk",
  "Pibkova",
  "Pistoupimsk",
  "Pdova",
  "Ptelstv",
  "Pborsk",
  "Pbramsk",
  "Pbnick",
  "Pchovick",
  "Pdolsk",
  "Pkr",
  "Plepsk",
  "Pmsk Nm.",
  "Pmsk Nmst",
  "Pm",
  "Pmtick",
  "Ppoton",
  "Ppen",
  "Prodn",
  "Pstavn",
  "Pvorsk",
  "Pvozn",
  "Pka",
  "Pn",
  "Penin",
  "Penkova",
  "Povansk",
  "Ptrossova",
  "Pdova",
  "Plkruhov",
  "Plnon",
  "Ptova",
  "R.A. Dvorskho",
  "Rabasova",
  "Rabysk",
  "Rackova",
  "Rackova Zahrada",
  "Radbuzsk",
  "Radechovsk",
  "Radeovsk",
  "Radhosk",
  "Radhosk",
  "Radimova",
  "Radimovick",
  "Radimsk",
  "Radiov",
  "Radiov",
  "Radist",
  "Radkovsk",
  "Radlick",
  "Radlick",
  "Radlick",
  "Radnick Schody",
  "Radomsk",
  "Radonick",
  "Radostavick",
  "Radostn",
  "Radotnsk",
  "Radotnsk",
  "Radouova",
  "Radouova",
  "Radouova",
  "Radova",
  "Radovsk",
  "Radoovick",
  "Radvanick",
  "Radzova",
  "Radina",
  "Radjovsk",
  "Raffaelova",
  "Raichlova",
  "Raisova",
  "Rajhradsk",
  "Rajmonova",
  "Rajsk",
  "Rakousova",
  "Rakovnick",
  "Rakovskho",
  "Randova",
  "Ransk",
  "Ratajova",
  "Ratajsk",
  "Ratbosk",
  "Ratiboick",
  "Ratibosk",
  "Ratibosk",
  "Ravennsk",
  "Raick",
  "Rainvesk",
  "Railovova",
  "Raova",
  "Raovick",
  "Raovsk",
  "Ranovo Nb.",
  "Ranovo Nb.",
  "Ranovo Nbe",
  "Ranovo Nbe",
  "Ransk",
  "Raick",
  "Reinerova",
  "Rejchova",
  "Rejskova",
  "Rekrean",
  "Rektorsk",
  "Rembrandtova",
  "Remzkov",
  "Renoirova",
  "Resslova",
  "Revoluce",
  "Revolun",
  "Revolun",
  "Rezedov",
  "Rezlerova",
  "Rekova",
  "Richtrova",
  "Riegrova",
  "Riegrovy Sady",
  "Rilsk",
  "Ringhofferova",
  "Ringhofferova",
  "Risk",
  "Roblnsk",
  "Rochovsk",
  "Rochovsk",
  "Rodopsk",
  "Rodovsk",
  "Rodvinovsk",
  "Roentgenova",
  "Rohanovsk",
  "Rohansk Nbe",
  "Rohansk Ostrov",
  "Rohateck",
  "Rohenick",
  "Rohlovsk",
  "Rohov",
  "Rohozeck",
  "Rohonick",
  "Rohova",
  "Roithova",
  "Rojick",
  "Roklova",
  "Rokycanova",
  "Rokycansk",
  "Rokytnick",
  "Rokytn",
  "Rolnick",
  "Roln",
  "Romaina Rollanda",
  "Romana Blahnka",
  "Ronalda Reagana",
  "Roneova",
  "Ronkova",
  "Ronovsk",
  "Rooseveltova",
  "Rorsov",
  "Rosesk",
  "Rosick",
  "Rostislavova",
  "Rostoklatsk",
  "Rostovsk",
  "Rotavsk",
  "Rotensk",
  "Roudnick",
  "Rousovick",
  "Rousnovsk",
  "Rovensk",
  "Rovnobn",
  "Rovn",
  "Rozdlen",
  "Rozdlovsk",
  "Rozhovick",
  "Rozkonho",
  "Rozkosk",
  "Rozmarnov",
  "Rozrazilov",
  "Roztock",
  "Roztylsk",
  "Roztylsk Nmst",
  "Roztylsk Sady",
  "Rozvadovsk",
  "Rozvodova",
  "Rozvojov",
  "Rozrina",
  "Roznova",
  "Rozen",
  "Roovsk",
  "Roickch",
  "Rokotova",
  "Roovick",
  "Rombersk",
  "Romitlsk",
  "Ronovsk",
  "Roalovick",
  "Rtysk",
  "Rubensova",
  "Rubeka",
  "Rubeova",
  "Rubliova",
  "Rubnov",
  "Rudesk",
  "Rudnkovsk",
  "Rudolfa Holeky",
  "Rudoltick",
  "Rudoltick",
  "Rujansk",
  "Rumbursk",
  "Rumunsk",
  "Rumunsk",
  "Ruprechtick",
  "Rusk",
  "Rusk",
  "Ruzysk",
  "Ruzysk",
  "Ruzysk Schody",
  "Ruinovsk",
  "Rybalkova",
  "Rybalkova",
  "Rybalkova",
  "Rybnin",
  "Rybn",
  "Rybova",
  "Rybsk",
  "Rybzov",
  "Rychnovsk",
  "Rychte Petka",
  "Rychte imona",
  "Rychtsk",
  "Rypkova",
  "Rytova",
  "Rytsk",
  "Ryzcov",
  "Ryzlinkov",
  "Rynkova",
  "Rjeck",
  "Rmov",
  "Rpoovsk",
  "Rova",
  "Rvov",
  "Rmaovsk",
  "Rnsk",
  "Rznerova",
  "Rennov",
  "Rennsk",
  "Rennsk",
  "Rov",
  "S. K. Neumanna",
  "Sabinova",
  "Sadask",
  "Sadov",
  "Sadsk",
  "Sadsk",
  "Sady Brat apk",
  "Safrov",
  "Salabova",
  "Salaova",
  "Salmovsk",
  "Salvtorsk",
  "Samcova",
  "Samohelova",
  "Samota U Podleskho Rybnka",
  "Sarajevsk",
  "Saratovsk",
  "Sartoriova",
  "Sasankov",
  "Sask",
  "Satalick",
  "Saturnova",
  "Saudkova",
  "Sauerova",
  "Saveljevova",
  "Savojsk",
  "Sazesk",
  "Sazesk",
  "Sazovick",
  "Sbhav I",
  "Sbhav Ii",
  "Schnirchova",
  "Schodiov",
  "Schodov",
  "Schoellerova",
  "Schoellerova",
  "Schulhoffova",
  "Schwaigerova",
  "Schwarzenbersk",
  "Schfflerova",
  "Sdruen",
  "Sechterova",
  "Sedleck",
  "Sedlovick",
  "Sedloovsk",
  "Sedlansk",
  "Sedmidomky",
  "Sedmidomky",
  "Sedmikrskov",
  "Sedmnctho Listopadu",
  "Seidlova",
  "Seifertova",
  "Sekaninova",
  "Sekeick",
  "Sekorova",
  "Selmick",
  "Selsk",
  "Selskch Bateri",
  "Semanskho",
  "Semick",
  "Semilsk",
  "Semilsk",
  "Seminrn",
  "Seminsk",
  "Seminsk Zahrada",
  "Semonick",
  "Semtnsk",
  "Semick",
  "Sendraick",
  "Senegalsk",
  "Senohrabsk",
  "Senovn",
  "Senovn Nm.",
  "Senovn Nmst",
  "Senoatsk",
  "Sestupn",
  "Sestupn",
  "Setbov",
  "Sevastopolsk",
  "Severn I",
  "Severn Ii",
  "Severn Iii",
  "Severn Iv",
  "Severn Ix",
  "Severn V",
  "Severn Vi",
  "Severn Vii",
  "Severn Viii",
  "Severn X",
  "Severn Xi",
  "Severovchodn I",
  "Severovchodn Ii",
  "Severovchodn Iii",
  "Severovchodn Iv",
  "Severovchodn V",
  "Severovchodn Vi",
  "Severozpadn I",
  "Severozpadn Ii",
  "Severozpadn Iii",
  "Severozpadn Iv",
  "Severozpadn V",
  "Severozpadn Vi",
  "Severnova",
  "Seven",
  "Seydlerova",
  "Sezemick",
  "Sezemnsk",
  "Sezimova",
  "Sesk",
  "Sibeliova",
  "Sibisk Nm.",
  "Sibisk Nmst",
  "Sicherova",
  "Sichrovskho",
  "Siemensova",
  "Silursk",
  "Sinkulova",
  "Sinkulova",
  "Sitteho",
  "Siwiecova",
  "Skaleck",
  "Skalnat",
  "Skalnick",
  "Skaln",
  "Skalsk",
  "Skalk",
  "Skandinvsk",
  "Skandinvsk",
  "Skautsk",
  "Sklensk",
  "Sklonn",
  "Sklsk",
  "Skokansk",
  "Skorkovsk",
  "Skorkovsk",
  "Skotsk",
  "Skoepka",
  "Skoicov",
  "Skryjsk",
  "Skupova",
  "Skuteckho",
  "Sklova",
  "Skivanova",
  "Skivansk",
  "Skivn",
  "Sladkovskho Nm.",
  "Sladkovskho Nmst",
  "Sladovnick",
  "Slancova",
  "Slan",
  "Slapsk",
  "Slatinov",
  "Slatinsk",
  "Slatiny",
  "Slatiansk",
  "Slavatova",
  "Slaviborsk Nm.",
  "Slaviborsk Nmst",
  "Slavick",
  "Slavi",
  "Slavinsk",
  "Slavnkova",
  "Slavojova",
  "Slavonick",
  "Slavkova",
  "Slavkova",
  "Slavkova",
  "Slavnskho",
  "Slavkova",
  "Slavtnsk",
  "Slep I",
  "Slep Ii",
  "Slezan",
  "Slezsk",
  "Slezsk",
  "Sliask",
  "Sliask",
  "Slibn",
  "Slinkov",
  "Sliveneck",
  "Slovansk Ostrov",
  "Slovakova",
  "Slovensk",
  "Slovensk",
  "Slovinsk",
  "Slunenicov",
  "Slunen",
  "Slunen",
  "Slunen Nm.",
  "Slunen Nmst",
  "Slunn",
  "Slutick",
  "Slueb",
  "Slueb",
  "Slusk",
  "Sldkova",
  "Sldkoviova",
  "Slmova",
  "Slnsk",
  "Slvy Hornka",
  "Slvask",
  "Slvask",
  "Slvask",
  "Sldov",
  "Slvov",
  "Smaragdov",
  "Smetanovo Nb.",
  "Smetanovo Nbe",
  "Smetkova",
  "Smidarsk",
  "Smikova",
  "Smiick",
  "Smiickho",
  "Smolensk",
  "Smolkova",
  "Smolkova",
  "Smotlachova",
  "Smotlachova",
  "Smrkov",
  "Smrinsk",
  "Smrovsk",
  "Smrov",
  "Smchovsk",
  "Smchovsk",
  "Smchovsk",
  "Smrn",
  "Snopkova",
  "Snmovn",
  "Snenkov",
  "Snn",
  "Sobolkova",
  "Soborsk",
  "Soboteck",
  "Sobnsk",
  "Sobslavova",
  "Sobslavsk",
  "Sobtick",
  "Sobtusk",
  "Sobnsk",
  "Sochask",
  "Sochova",
  "Sodomkova",
  "Sofijsk Nm.",
  "Sofijsk Nmst",
  "Sojkovsk",
  "Sojovick",
  "Soj",
  "Soj",
  "Sokolovsk",
  "Sokolovsk",
  "Sokolovsk",
  "Sokolovsk",
  "Sokolsk",
  "Sokratova",
  "Solidarity",
  "Solnick",
  "Soln",
  "Sopotsk",
  "Sosnoveck",
  "Soubn I",
  "Soubn Ii",
  "Soubn Iii",
  "Soubn Iv",
  "Soudn",
  "Soukalova",
  "Soukenick",
  "Soumarsk",
  "Sousedn",
  "Sousedn",
  "Sousedsk",
  "Sousedkova",
  "Soustrunick",
  "Soustrunick",
  "Souvratn",
  "Soukova",
  "Sovenick",
  "Sovova",
  "Sovkova",
  "Sov Vrek",
  "Spinozova",
  "Spiritka",
  "Splavn",
  "Spodn",
  "Spoja",
  "Spojenc",
  "Spojen",
  "Spojn",
  "Spojovac",
  "Spojovac",
  "Spojovac",
  "Spojovac",
  "Spojov",
  "Spolen",
  "Spolsk",
  "Spoluprce",
  "Sportovc",
  "Sportovc",
  "Sportovn",
  "Spotebitelsk",
  "Spoick",
  "Spoilovsk",
  "Spytihnvova",
  "Spdn",
  "Spdov",
  "Splen",
  "Splen",
  "Splen Mln",
  "Srbova",
  "Srbsk",
  "Srbnsk",
  "Srnekova",
  "Srn",
  "Srn",
  "Srpnov",
  "Srzn",
  "Stachova",
  "Stadick",
  "Stadionov",
  "Stadinov",
  "Stallichova",
  "Stamicova",
  "Stanin",
  "Starobyl",
  "Starochodovsk",
  "Starochuchelsk",
  "Starodejvick",
  "Starodubesk",
  "Starodvorsk",
  "Staroklnovick",
  "Starokolnsk",
  "Starokosk",
  "Starolzesk",
  "Staromlnsk",
  "Staromodansk",
  "Staromstsk Nm.",
  "Staromstsk Nmst",
  "Staropack",
  "Staropramenn",
  "Starostranick",
  "Starosteovick",
  "Starosuchdolsk",
  "Starojezdsk",
  "Staroesk",
  "Star Cesta",
  "Star Nves",
  "Star Obec",
  "Star Spojovac",
  "Star Stodleck",
  "Star Nm.",
  "Star Nmst",
  "Star Zmeck Schody",
  "Star Zmeck Schody",
  "Starho",
  "Star Lis",
  "Statenick",
  "Statkov",
  "Stavba",
  "Stavebn",
  "Stavitelsk",
  "Stavovsk",
  "Stakova",
  "Stakovka",
  "Stakovsk",
  "Stehlkova",
  "Steinerova",
  "Stejskalova",
  "Stiessova",
  "Stinkovsk",
  "Stochovsk",
  "Stodleck",
  "Stojick",
  "Stolikova",
  "Stolisk",
  "Stoupajc",
  "Stoupajc",
  "Stradonick",
  "Strahovsk",
  "Strahovsk Ndvo",
  "Strakatho",
  "Strakonick",
  "Strakonick",
  "Strakonick",
  "Strakonick",
  "Strakonick",
  "Strakonick",
  "Strakoov",
  "Stranick",
  "Stratovsk",
  "Stranick",
  "Stranick",
  "Straovsk",
  "Stransk",
  "Strm",
  "Strm Vrch",
  "Strnadova",
  "Strnady",
  "Strojick",
  "Strojnick",
  "Strojrensk",
  "Stromovka",
  "Stromovka",
  "Stropnick",
  "Stropnick",
  "Stropnick",
  "Strossmayerovo Nm.",
  "Strossmayerovo Nmst",
  "Strouhalova",
  "Stroupenickho",
  "Struhaovsk",
  "Strunkovsk",
  "Struky",
  "Strun",
  "Strkovick",
  "Strnick",
  "Strn",
  "Strovsk",
  "Strn",
  "Studeneck",
  "Studentsk",
  "Studen",
  "Studnick",
  "Studnikova",
  "Studnin",
  "Studnkov",
  "Stulkov",
  "Stupick",
  "Stupkova",
  "Stupsk",
  "Stupov",
  "Stdleck",
  "Strkova",
  "Stblova",
  "Stedn",
  "Stedohorsk",
  "Stedov",
  "Stekovsk",
  "Steleck Ostrov",
  "Stelesk",
  "Stelnin",
  "Stelnin",
  "Stemchov",
  "Steovick",
  "Steovick",
  "Stimelick",
  "Stbrn",
  "Stbrskho",
  "Stbrskho",
  "Stkovsk",
  "Stkovsk",
  "Stkovsk",
  "Suchardova",
  "Suchdolsk",
  "Suchdolsk",
  "Suchdolsk",
  "Suchdolsk Nm.",
  "Suchdolsk Nmst",
  "Such Vrek",
  "Sudkova",
  "Sudomsk",
  "Sudjovick",
  "Sukova",
  "Sulanskho",
  "Sulick",
  "Sulick",
  "Sulova",
  "Sulovick",
  "Sumova",
  "Suppho",
  "Suttnerov",
  "Suick",
  "Suilova",
  "Svahov",
  "Svatavina",
  "Svatojnsk",
  "Svatoplukova",
  "Svatoslavova",
  "Svatovtsk",
  "Svatovtsk",
  "Svatoovick",
  "Svait",
  "Svijansk",
  "Svitavsk",
  "Svitkova",
  "Svobodova",
  "Svobodova",
  "Svojetick",
  "Svojskova",
  "Svojick",
  "Svojovick",
  "Svornosti",
  "Svrateck",
  "Svrovsk",
  "Svtkova",
  "Svn",
  "Svpomoci",
  "Svpomocn",
  "Svpravick",
  "Svpravick",
  "Svdnick",
  "Svcenho",
  "Svtick",
  "Svtova",
  "Svtsk",
  "Sychrovsk",
  "Symfonick",
  "Synkovick",
  "Synkovsk",
  "Syrsk",
  "Sdky",
  "Sdovsk",
  "Smova",
  "Srsk",
  "Srsk",
  "Srsk",
  "Szavsk",
  "Skask",
  "Sdlitn",
  "Sdlitn",
  "Sdlit",
  "Sdnsk",
  "Skor",
  "Skoveck",
  "Tachlovick",
  "Tachovsk",
  "Tachovsk Nm.",
  "Tachovsk Nmst",
  "Tadrova",
  "Tajovskho",
  "Talafsova",
  "Talichova",
  "Talmbersk",
  "Tanvaldsk",
  "Tasovsk",
  "Tatarkova",
  "Tatransk",
  "Tauerova",
  "Tauferova",
  "Taussigova",
  "Tavolnkov",
  "Taicov",
  "Takentsk",
  "Technick",
  "Technologick",
  "Tehovsk",
  "Tejnick",
  "Tejnka",
  "Telsk",
  "Templov",
  "Tenisov",
  "Teplick",
  "Teplrensk",
  "Teplrensk",
  "Terasovit",
  "Tererova",
  "Tereznsk",
  "Terronsk",
  "Tesakova",
  "Tetnsk",
  "Theinova",
  "Thomayerova",
  "Thunovsk",
  "Thurnova",
  "Thkurova",
  "Thmova",
  "Tibetsk",
  "Tichnova",
  "Tichnova",
  "Tichonick",
  "Tich",
  "Tichho",
  "Tigridova",
  "Tikovsk",
  "Tilleho Nm.",
  "Tilleho Nmst",
  "Tilschov",
  "Tiskask",
  "Tismick",
  "Tiick",
  "Tlumaovsk",
  "Tlustho",
  "Tobruck",
  "Tolstho",
  "Tomanova",
  "Tomick",
  "Tomkova",
  "Tomsova",
  "Tomkova",
  "Tomsk",
  "Tomkova",
  "Topasov",
  "Topolov",
  "Torusk",
  "Toulovsk",
  "Touesk",
  "Touick",
  "Touimsk",
  "Touimsk",
  "Tovarova",
  "Tovaovskho",
  "Tovrn",
  "Toensk",
  "Toit",
  "Trabantsk",
  "Trachtova",
  "Trampotova",
  "Travnat",
  "Travn",
  "Travn",
  "Trennsk",
  "Trhanovsk Nmst",
  "Trmick",
  "Trnavsk",
  "Trnavsk",
  "Trnit",
  "Trnkovo Nm.",
  "Trnkovo Nmst",
  "Trnkov",
  "Trnovansk",
  "Trn",
  "Trocnovsk",
  "Troilova",
  "Trojanova",
  "Trojanv Mln",
  "Trojdln",
  "Trojick",
  "Trojmezn",
  "Trojmezn",
  "Trojsk",
  "Trojsk",
  "Trojsk",
  "Trojsk",
  "Troskovick",
  "Trousilova",
  "Truhlka",
  "Truhlova",
  "Truhlsk",
  "Trutnovsk",
  "Tryskovick",
  "Tryskovick",
  "Trytova",
  "Trvnick",
  "Trvnkova",
  "Trglova",
  "Trit",
  "Tuchomick",
  "Tuchorazsk",
  "Tuchotick",
  "Tuhsk",
  "Tuklatsk",
  "Tuleick",
  "Tulipnov",
  "Tulkova",
  "Tulsk",
  "Tunel",
  "Tunisk",
  "Tupolevova",
  "Turgenvova",
  "Turistick",
  "Turkmensk",
  "Turkovick",
  "Turkovsk",
  "Turnovsk",
  "Turnovskho",
  "Tursk",
  "Turnsk",
  "Tusarova",
  "Tuick",
  "Tuimick",
  "Tuebnkov",
  "Tvrdonick",
  "Tvrdho",
  "Tychonova",
  "Tyliovsk",
  "Tylovick",
  "Tylovo Nm.",
  "Tylovo Nmst",
  "Tyminov",
  "Tyrkysov",
  "Tyrova",
  "Tboritsk",
  "Tborsk",
  "Tdick",
  "Thl",
  "Tlnsk",
  "Trkova",
  "Tmlova",
  "Tmlova",
  "Tn",
  "Tneck",
  "Tnsk",
  "Tnsk Ulika",
  "Tovick",
  "Tlovchovn",
  "Tnov",
  "Tovick",
  "Tkova",
  "Tnsk",
  "Tanovskho",
  "Tebanick",
  "Tebechovick",
  "Tebenick",
  "Tebeovsk",
  "Tebihosk",
  "Tebohostick",
  "Tebonick",
  "Teboradick",
  "Tebotovsk",
  "Tebosk",
  "Tebzskho",
  "Tebjick",
  "Tebtnsk",
  "Teov",
  "Teov",
  "Teov",
  "Tineck",
  "Ttinov",
  "Tdom",
  "Tstolin",
  "Tmova",
  "U Akademie",
  "U Akt",
  "U Albrechtova Vrchu",
  "U Andlky",
  "U Arborky",
  "U Bakale",
  "U Balabenky",
  "U Baznu",
  "U Baantnice",
  "U Berounky",
  "U Bernky",
  "U Besedy",
  "U Blaenky",
  "U Boroviek",
  "U Botie",
  "U Botie",
  "U Boch Bojovnk",
  "U Branek",
  "U Bruskch Kasren",
  "U Brusnice",
  "U Brusnice",
  "U Bubce",
  "U Bulhara",
  "U Bulhara",
  "U Blho Mlnku",
  "U Behu",
  "U Chaloupek",
  "U Chmelnice",
  "U Chodovskho Hbitova",
  "U Cibulky",
  "U Cihelny",
  "U Ciknky",
  "U Cukrovaru",
  "U Csask Cesty",
  "U Dejvickho Rybnku",
  "U Demartinky",
  "U Divadla",
  "U Divadla",
  "U Dobeky",
  "U Dobrk",
  "U Dobrk",
  "U Dobenskch",
  "U Domu Slueb",
  "U Drahan",
  "U Druh Baterie",
  "U Druh Baterie",
  "U Drupolu",
  "U Drustev",
  "U Drustva Idel",
  "U Drustva Klid",
  "U Drustva Prce",
  "U Drustva Prce",
  "U Drustva Repo",
  "U Drustva Tempo",
  "U Drustva ivot",
  "U Drhy",
  "U Drhy",
  "U Drky",
  "U Drberny",
  "U Dubesk Tvrze",
  "U Dubu",
  "U Dvojdom",
  "U Dvora",
  "U Dvou Srp",
  "U Dlnice",
  "U Dvch Hrad",
  "U Dvch Hrad",
  "U Dkanky",
  "U Dlnickho Cviit",
  "U Dtskho Domova",
  "U Dtskho Hit",
  "U Elektry",
  "U Elektry",
  "U Elektrrny",
  "U Florina",
  "U Fota",
  "U Gabrielky",
  "U Gar",
  "U Golfu",
  "U Gymnzia",
  "U Habee",
  "U Habrovky",
  "U Hadovky",
  "U Harfy",
  "U Hasisk Zbrojnice",
  "U Hasisk Zbrojnice",
  "U Havlkovch Sad",
  "U Hellady",
  "U Hercovky",
  "U Hlinku",
  "U Hodin",
  "U Homolky",
  "U Hostavickho Potoka",
  "U Hostivaskho Ndra",
  "U Hostivaskho Ndra",
  "U Hotelu",
  "U Hranic",
  "U Hrnskho Rybnka",
  "U Hrocha",
  "U Hruky",
  "U Hrze",
  "U Hudebn koly",
  "U Hvozdu",
  "U Hvzdy",
  "U Hvzdy",
  "U Hje",
  "U Hjku",
  "U Hjovny",
  "U Hz",
  "U Hbitov",
  "U Hit",
  "U Invalidovny",
  "U Jamsk",
  "U Jankovky",
  "U Javoru",
  "U Jedlikova stavu",
  "U Jednoty",
  "U Jesl",
  "U Jezera",
  "U Jezerky",
  "U Jezu",
  "U Jezrka",
  "U Jinonickho Rybnka",
  "U Jirkovsk",
  "U Jizby",
  "U Jrku",
  "U Jzdrny",
  "U Kabelovny",
  "U Kabelovny",
  "U Kamnky",
  "U Kamku",
  "U Kanlky",
  "U Kapliek",
  "U Kapliky",
  "U Karlova Stnku",
  "U Kasren",
  "U Kavalrky",
  "U Kazna",
  "U Kany",
  "U Katanu",
  "U Kempinku",
  "U Kina",
  "U Klavrky",
  "U Klikovky",
  "U Klimentky",
  "U Kloubovch Dom",
  "U Klubovny",
  "U Klubu",
  "U Knsk Louky",
  "U Kola",
  "U Kolej",
  "U Kolej",
  "U Kolodj",
  "U Kolonie",
  "U Kolonilu",
  "U Kombintu",
  "U Konen",
  "U Kon",
  "U Kosin",
  "U Kostela",
  "U Kostrounku",
  "U Kotlky",
  "U Koupadel",
  "U Koku",
  "U Krbu",
  "U Krbu",
  "U Krelovy Studnky",
  "U Kruhovky",
  "U Krlovsk Louky",
  "U Krsk Vodrny",
  "U Krskho Ndra",
  "U Kublova",
  "U Kunratickho Lesa",
  "U Kiovatky",
  "U Ke",
  "U Ke",
  "U Kku",
  "U Laboratoe",
  "U Ladronky",
  "U Lanov Drhy",
  "U Ledren",
  "U Lesa",
  "U Lesa",
  "U Leska",
  "U Letenskho Sadu",
  "U Letit",
  "U Letohrdku Krlovny Anny",
  "U Libeskho Pivovaru",
  "U Libeskho Zmku",
  "U Libuinch Lzn",
  "U Libusk Sokolovny",
  "U Lidovho Domu",
  "U Lip",
  "U Lipov Aleje",
  "U Lisu",
  "U Lodnice",
  "U Lomu",
  "U Loskot",
  "U Louky",
  "U Luickho Semine",
  "U Lzeky",
  "U Lzn",
  "U Lkrny",
  "U Lhn",
  "U Lpy",
  "U Malvazinky",
  "U Mal eky",
  "U Markty",
  "U Matesk koly",
  "U Matje",
  "U Ma Magdaleny",
  "U Meteoru",
  "U Meznku",
  "U Michelsk koly",
  "U Michelskho Lesa",
  "U Michelskho Lesa",
  "U Michelskho Mlna",
  "U Milosrdnch",
  "U Mlna",
  "U Mlna",
  "U Mlnskho Rybnka",
  "U Modr koly",
  "U Modansk koly",
  "U Molu",
  "U Mrzovky",
  "U Mydlrny",
  "U Myslivny",
  "U Mstskch Dom",
  "U Manskho Pivovaru",
  "U Manskch kol",
  "U Nadmae",
  "U Nemocensk Pojiovny",
  "U Nemocnice",
  "U Nesypky",
  "U Nikolajky",
  "U Nov Dlnice",
  "U Nov Louky",
  "U Nov koly",
  "U Novho Dvora",
  "U Novho Suchdola",
  "U Novho Suchdola",
  "U Novch Dom I",
  "U Novch Dom Ii",
  "U Novch Dom Iii",
  "U Novch Vil",
  "U Ndran Lvky",
  "U Ndra",
  "U Ndre",
  "U Nhonu",
  "U Nhonu",
  "U Nkladovho Ndra",
  "U Nkladovho Ndra",
  "U Nrodn Galerie",
  "U Ns",
  "U Obce",
  "U Obecnho Domu",
  "U Obecnho Dvora",
  "U Obory",
  "U Okrouhlku",
  "U Oliek",
  "U Opatrovny",
  "U Ovna",
  "U Palaty",
  "U Palirky",
  "U Palouku",
  "U Pamtnku",
  "U Pansk Zahrady",
  "U Paprny",
  "U Parku",
  "U Parknu",
  "U Parnho Mlna",
  "U Pastouky",
  "U Pavilnu",
  "U Pazderek",
  "U Pejrny",
  "U Pekaky",
  "U Pekren",
  "U Pentlovky",
  "U Pergamenky",
  "U Pernikky",
  "U Perntejnskch",
  "U Petin",
  "U Pily",
  "U Plovrny",
  "U Plynrny",
  "U Plynrny",
  "U Pltenice",
  "U Podchodu",
  "U Podjezdu",
  "U Podolskho Hbitova",
  "U Podolskho Sanatoria",
  "U Pohdky",
  "U Polikliniky",
  "U Pomnku",
  "U Potoka",
  "U Poustek",
  "U Potovky",
  "U Poty",
  "U Pramene",
  "U Pran Brny",
  "U Pranho Mostu",
  "U Pranho Mostu",
  "U Praskch Lom",
  "U Prefy",
  "U Prioru",
  "U Prknovky",
  "U Prodejny",
  "U Propusti",
  "U Proseck koly",
  "U Proseckho Kostela",
  "U Prvn Baterie",
  "U Prvn Baterie",
  "U Prdelny",
  "U Prhonu",
  "U Prseku",
  "U Pumpy",
  "U Prnk",
  "U Pt Baterie",
  "U Pt Baterie",
  "U Pseck Brny",
  "U Pskovny",
  "U Pechodu",
  "U Pehrady",
  "U Pejezdu",
  "U Pjovny",
  "U Radily",
  "U Radnice",
  "U Rajsk Zahrady",
  "U Rakovky",
  "U Rohovch Kasren",
  "U Rokytky",
  "U Rokytky",
  "U Rokytky",
  "U Rozkoe",
  "U Roztockho Hje",
  "U Rybnka",
  "U Rybnka",
  "U Rybstv",
  "U Rychty",
  "U Rychty",
  "U Rynky",
  "U Rynky",
  "U Sadu",
  "U Sanatoria",
  "U Sanopzu",
  "U Santoky",
  "U Schod",
  "U Sedleck koly",
  "U Seadit",
  "U Sila",
  "U Silnice",
  "U Silnice",
  "U Skalky",
  "U Skladu",
  "U Skldky",
  "U Skopc",
  "U Skly",
  "U Sladovny",
  "U Slavie",
  "U Sloupu",
  "U Slovanky",
  "U Slovansk Pojiovny",
  "U Sluncov",
  "U Slvrny",
  "U Smaltovny",
  "U Smetanky",
  "U Smolnic",
  "U Smchovskho Hbitova",
  "U Sokolovny",
  "U Soutoku",
  "U Sovovch Mln",
  "U Sparty",
  "U Splavu",
  "U Spojky",
  "U Spoj",
  "U Spoleensk Zahrady",
  "U Sportovit",
  "U Spoitelny",
  "U Stanice",
  "U Star Cihelny",
  "U Star Plynrny",
  "U Star Poty",
  "U Star Skldky",
  "U Star Sokolovny",
  "U Star Studnky",
  "U Star Tvrze",
  "U Star koly",
  "U Star koly",
  "U Starho Hbitova",
  "U Starho Hit",
  "U Starho Mlna",
  "U Starho Ndra",
  "U Starho Splavu",
  "U Starho Stadionu",
  "U Starho Stadinu",
  "U Starho idovskho Hbitova",
  "U Starho idovskho Hbitova",
  "U Statku",
  "U Stavoservisu",
  "U Stojanu",
  "U Strouhy",
  "U Stre",
  "U Studny",
  "U Studnky",
  "U Studnky",
  "U Strovny",
  "U Sttn Drhy",
  "U Sttn Drhy",
  "U Strky",
  "U Stediska",
  "U Steovickch Hi",
  "U Suiky",
  "U Svahu",
  "U Svatho Ducha",
  "U Svobodrny",
  "U Svodnice",
  "U Svornosti",
  "U Svpomoci",
  "U Svtliky",
  "U Synagogy",
  "U Sdek",
  "U Sdlit",
  "U Tabulky",
  "U Technoplynu",
  "U Tenisu",
  "U Teplrny",
  "U Topren",
  "U Tovren",
  "U Transforman Stanice",
  "U Transformtoru",
  "U Trati",
  "U Trativodu",
  "U Trezorky",
  "U Trojice",
  "U Trojskho Zmku",
  "U Trpce",
  "U Trnice",
  "U Tvrze",
  "U Tyre",
  "U Tyrovky",
  "U Tyrovy koly",
  "U Tet Baterie",
  "U Teovky",
  "U Teovho Sadu",
  "U Tn",
  "U Uhnvesk Obory",
  "U Uranie",
  "U Uilit",
  "U Valu",
  "U Velk Skly",
  "U Vesny",
  "U Viktorky",
  "U Vinice",
  "U Viniek",
  "U Vinn Rvy",
  "U Vinnch Sklep",
  "U Vinohradsk Nemocnice",
  "U Vinohradskho Hbitova",
  "U Vinohradskho Hbitova",
  "U Vizerky",
  "U Viovky",
  "U Viovky",
  "U Vlachovky",
  "U Vlasaky",
  "U Vleky",
  "U Vleky",
  "U Vltavy",
  "U Vobornk",
  "U Vodice",
  "U Vodojemu",
  "U Vodojemu",
  "U Vodotoku",
  "U Vody",
  "U Vodrny",
  "U Vojanky",
  "U Vojensk Nemocnice",
  "U Vojtky",
  "U Vokovick koly",
  "U Vorlk",
  "U Vozovny",
  "U Vrbiek",
  "U Vrby",
  "U Vrtilky",
  "U Vrovickho Hbitova",
  "U Vrovickho Hbitova",
  "U Vrovickho Ndra",
  "U Vysoanskho Cukrovaru",
  "U Vysoanskho Pivovaru",
  "U Vclava",
  "U Vhy",
  "U Vpenice",
  "U Vpenky",
  "U Vpenn Skly",
  "U Vkupnho Stediska",
  "U Vstavby",
  "U Vstavit",
  "U Vstavit",
  "U Vzkumu",
  "U Vely",
  "U Vtrnku",
  "U Vtrolamu",
  "U Vtrolamu",
  "U Ve",
  "U Waltrovky",
  "U Zahradnictv",
  "U Zahradnho Msta",
  "U Zahrady",
  "U Zahrdek",
  "U Zahrdksk Kolonie",
  "U Zastvky",
  "U Zbrojnice",
  "U Zdravotnho stavu",
  "U Zelenho Ptka",
  "U Zemnku",
  "U Zempisnho stavu",
  "U Zlat Studn",
  "U Zlina",
  "U Zlina",
  "U Zlinskho Hit",
  "U Zvonaky",
  "U Zvoniky",
  "U Zbhlickho Zmku",
  "U Zjezdku",
  "U Zkrutu",
  "U Zmeckho Parku",
  "U Zmeku",
  "U Zmenice",
  "U Zsobn Zahrady",
  "U Zti",
  "U Zvodit",
  "U Zvor",
  "U l",
  "U ekrny",
  "U ern Rokle",
  "U ervenho Mlnku",
  "U ervenho Mlnku",
  "U eskch Lodnic",
  "U ihadel",
  "U istiky",
  "U okoldoven",
  "U tvrt Baterie",
  "U ty Dom",
  "U empa",
  "U anky",
  "U alamounky",
  "U alamounky",
  "U est Baterie",
  "U est Baterie",
  "U koliky",
  "U kolky",
  "U kolnho Pole",
  "U kolsk Zahrady",
  "U koly",
  "U tpu",
  "U umavy",
  "U umavnky",
  "U lkovny",
  "U ch",
  "U pk",
  "U eleznice",
  "U elezninho Mostu",
  "U elezn Lvky",
  "U elivky",
  "U idovskho Hbitova",
  "U lbku",
  "U upanskch",
  "Uheln Trh",
  "Uhersk",
  "Uhnvesk",
  "Ukonen",
  "Ukrajinsk",
  "Uljanovsk",
  "Ulrychova",
  "Ulova",
  "Umleck",
  "Ungarova",
  "Unhosk",
  "Univerzitn",
  "Upolnov",
  "Upraven",
  "Uralsk",
  "Urbanick",
  "Urbanova",
  "Urbnkova",
  "Ureova",
  "Uruguaysk",
  "Urxova",
  "Utilova",
  "Uzaven",
  "Uzbeck",
  "Uzouk",
  "Uitelsk",
  "Uovsk",
  "Uock",
  "V Aleji",
  "V Alejch",
  "V Americe",
  "V Babyku",
  "V Bambouskch",
  "V Bainch",
  "V Bentkch",
  "V Bezpe",
  "V Bokch I",
  "V Bokch Ii",
  "V Bokch Iii",
  "V Borovikch",
  "V Botanice",
  "V Brance",
  "V Brdku",
  "V Brdku",
  "V Bytovkch",
  "V Blce",
  "V Bezinkch",
  "V Bezin",
  "V Bez",
  "V Bzkch",
  "V Celnici",
  "V Cestikch",
  "V Cestkch",
  "V Chaloupkch",
  "V Chaloupkch",
  "V Chatch",
  "V Chotejn",
  "V Cibulkch",
  "V Ciheln",
  "V Cpu",
  "V Dolinch",
  "V Dolin",
  "V Dolin",
  "V Dolch",
  "V Domcch",
  "V Domov",
  "V Doubcch",
  "V Dlcch",
  "V Edenu",
  "V Halti",
  "V Hliniti",
  "V Hlubok",
  "V Hodkovikch",
  "V Holeovikch",
  "V Honu",
  "V Horkch",
  "V Horn Stromce",
  "V Hrobech",
  "V Humenci",
  "V Humenci",
  "V Humnech",
  "V Hji",
  "V Hjkch",
  "V Hjch",
  "V Hrkch",
  "V Jahodch",
  "V Javorech",
  "V Javoku",
  "V Jehliin",
  "V Jehli",
  "V Jezerch",
  "V Jezevinch",
  "V Jezrkch",
  "V Jirchch",
  "V Jm",
  "V Kaliti",
  "V Kaliti",
  "V Kapslovn",
  "V Klukovicch",
  "V Kole",
  "V Kolkovn",
  "V Korytech",
  "V Korytech",
  "V Kotcch",
  "V Koutku",
  "V Kout",
  "V Kratinch",
  "V Kruhu",
  "V Kuatech",
  "V Klku",
  "V Kepelkch",
  "V Kovinch",
  "V Kkch",
  "V Ladech",
  "V Lesku",
  "V Lipinch",
  "V Lipinch",
  "V Lipkch",
  "V Lipch",
  "V Listnch",
  "V Lomech",
  "V Louce",
  "V Luhu",
  "V Lukch",
  "V Luinch",
  "V Luch",
  "V Lnech",
  "V Lznch",
  "V Lskch",
  "V Malch Domech I",
  "V Malch Domech Ii",
  "V Malch Domech Iii",
  "V Meziho",
  "V Mili",
  "V Mokinch",
  "V Mydlinkch",
  "V Nov Hostivai",
  "V Nov Vsi",
  "V Nov Vsi",
  "V Nov tvrti",
  "V Novm Hloubtn",
  "V Novm Hloubtn",
  "V Novch Bohnicch",
  "V Novch Domcch",
  "V Novch Vokovicch",
  "V Nklch",
  "V Nsypu",
  "V Ninch",
  "V Oblouku",
  "V Obanskm Domov",
  "V Obrkch",
  "V Ochozu",
  "V Ohrad",
  "V Ohybu",
  "V Okru",
  "V Oklech",
  "V Olinch",
  "V Olinch",
  "V Olin",
  "V Ondejov",
  "V Opatov",
  "V Osikch",
  "V Ostruin",
  "V Oudolku",
  "V Oe",
  "V Pachmance",
  "V Padolin",
  "V Parcelch",
  "V Parku",
  "V Parnku",
  "V Patkch",
  "V Paezinch",
  "V Pevnosti",
  "V Pevnosti",
  "V Pitkovikch",
  "V Planinch",
  "V Platzu",
  "V Plni",
  "V Podbab",
  "V Podho",
  "V Podhj",
  "V Podhj",
  "V Podlu",
  "V Podskal",
  "V Podvr",
  "V Podzm",
  "V Poli",
  "V Polch",
  "V Potokch",
  "V Potoinch",
  "V Potokch",
  "V Prutinch",
  "V Prhledu",
  "V Prel",
  "V Ptm",
  "V Pskovn",
  "V Pinkch",
  "V Pednm Hloubtn",
  "V Pednm Veleslavn",
  "V Pedpol",
  "V Pedpol",
  "V Pelomu",
  "V Pstavu",
  "V Remzku",
  "V Rohonku",
  "V Rohu",
  "V Rohch",
  "V Rokli",
  "V Roklch",
  "V Rovinch",
  "V Rovinch",
  "V Rybnkch",
  "V Rybnkch",
  "V Rji",
  "V Rji",
  "V Rkos",
  "V Sadech",
  "V Sedlci",
  "V Sedlci",
  "V Slavtn",
  "V Soudnm",
  "V Strni",
  "V Stedu",
  "V Sudech",
  "V Sdliti",
  "V Tehovikch",
  "V Tiin",
  "V Trninch",
  "V Teovce",
  "V Tnch",
  "V Ulice",
  "V Ulikch",
  "V Zahradn tvrti",
  "V Zahradch",
  "V Zahrdkch",
  "V Zatce",
  "V Zeleni",
  "V Zelenm dol",
  "V Zhorskm",
  "V Zhybu",
  "V Zkopech",
  "V Zkout",
  "V Zles",
  "V Zlomu",
  "V Zmcch",
  "V Zpol",
  "V Zti",
  "V Ztoce",
  "V Zvitu",
  "V Zvt",
  "V Zezu",
  "V dol",
  "V dol Hvzd",
  "V hlu",
  "V horu",
  "V valu",
  "V voze",
  "V zk",
  "V labin",
  "V labin",
  "V eku",
  "V thlch",
  "V reckm dol",
  "V abokiku",
  "V ku",
  "V. P. kalova",
  "V. P. kalova",
  "Vachkova",
  "Vackova",
  "Vacovsk",
  "Vacnova",
  "Vacnovsk",
  "Vajdova",
  "Vajgarsk",
  "Valcsk",
  "Valdick",
  "Valdovsk",
  "Valdtejnsk",
  "Valdtejnsk Nm.",
  "Valdtejnsk Nmst",
  "Valentinsk",
  "Valentinsk",
  "Valentova",
  "Valeovsk",
  "Valsk",
  "Valtick",
  "Valtnovsk",
  "Valkova",
  "Valovsk",
  "Vambersk",
  "Vanick",
  "Vankova",
  "Vankova",
  "Varhulkov",
  "Varnsdorfsk",
  "Varavsk",
  "Vavkova",
  "Vavenova",
  "Vavineck",
  "Vazovova",
  "Vakova",
  "Vakova",
  "Vakova",
  "Vatkova",
  "Ve Dvoe",
  "Ve Lhotce",
  "Ve Lhotce",
  "Ve Skalkch",
  "Ve Skalch",
  "Ve Skle",
  "Ve Slatinch",
  "Ve Smekch",
  "Ve Smrin",
  "Ve Stromoad",
  "Ve Struhch",
  "Ve Struhch",
  "Ve Strni",
  "Ve Studenm",
  "Ve Stnu",
  "Ve Steovikch",
  "Ve Steovikch",
  "Ve Svahu",
  "Ve Vilkch",
  "Ve Vilch",
  "Ve Viovce",
  "Ve Vratech",
  "Ve Vrbch",
  "Ve Vrchu",
  "Ve Vrch",
  "Ve Vhledu",
  "Ve Vhledu",
  "Ve Vrech",
  "Ve Zlii",
  "Ve tpnici",
  "Ve lbku",
  "Vedlej",
  "Vehlovick",
  "Vejrakova",
  "Vejvanovskho",
  "Vejvodova",
  "Velebnho",
  "Velehradsk",
  "Velemnsk",
  "Velemnsk",
  "Velenick",
  "Velenovskho",
  "Veleslavnova",
  "Veleslavnsk",
  "Veleslavnsk",
  "Veletovsk",
  "Veletrn",
  "Veletrn",
  "Velesk",
  "Velensk",
  "Velflovic",
  "Velflkova",
  "Velhartick",
  "Velichovsk",
  "Velimsk",
  "Velkoborsk",
  "Velkooseck",
  "Velkopevorsk Nm.",
  "Velkopevorsk Nmst",
  "Velk Lada",
  "Velk Lada",
  "Velk Skla",
  "Velk Kunratick",
  "Veltrusk",
  "Veltsk",
  "Velvarsk",
  "Velnsk",
  "Venuina",
  "Verdiho",
  "Verdunsk",
  "Verneick",
  "Verneick",
  "Vernovsk",
  "Veronsk Nm.",
  "Veselsk",
  "Vesk",
  "Veslask Ostrov",
  "Vestavn",
  "Vesteck",
  "Veverkova",
  "Veern",
  "Vidimova",
  "Vidimsk",
  "Vidlicov",
  "Vidlk",
  "Vidonick",
  "Vidoulsk",
  "Vidovick",
  "Vietnamsk",
  "Viklefova",
  "Vikova",
  "Viktora Huga",
  "Viktorinova",
  "Viktorina",
  "Viksk",
  "Vilov",
  "Vilmkova",
  "Vilmovsk",
  "Vimpersk Nmst",
  "Vinaickho",
  "Vinask",
  "Vinin",
  "Vinohradsk",
  "Vinohradsk",
  "Vinohradsk",
  "Vinohradsk",
  "Vinohradsk",
  "Vinohradsk",
  "Vinohradsk",
  "Vinohrady",
  "Vinopalnick",
  "Vinosk",
  "Vinosk Nm.",
  "Vinosk Nmst",
  "Vinova",
  "Violkov",
  "Vitosk",
  "Vitkova",
  "Vitjovsk",
  "Vizovick",
  "Viovka",
  "Viovka",
  "Viov",
  "Vlachova",
  "Vladimrova",
  "Vladislava Vanury",
  "Vladislavova",
  "Vladivostock",
  "Vladyck",
  "Vlastibosk",
  "Vlastina",
  "Vlastina",
  "Vlastislavova",
  "Vlasty Buriana",
  "Vlasty Hilsk",
  "Vlasty Prchov",
  "Vlaskova",
  "Vlaimsk",
  "Vlask",
  "Vlask",
  "Vlatov",
  "Vlkanovsk",
  "Vlkova",
  "Vlkovick",
  "Vlnit",
  "Vltavan",
  "Vltavan",
  "Vltavan",
  "Vltavick",
  "Vltavsk",
  "Vltavnov",
  "Vlrsk",
  "Vlsenick",
  "Vlick",
  "Vlkova",
  "Vlnovsk",
  "Vnislavova",
  "Vnitn",
  "Vnoukova",
  "Vnj",
  "Voborskho",
  "Vobrubova",
  "Vocelova",
  "Voctova",
  "Voctova",
  "Vodick",
  "Vodikova",
  "Vodikova",
  "Vodnick",
  "Vodn",
  "Vodochodsk",
  "Vodojemsk",
  "Vodck",
  "Vodrensk",
  "Vodradsk",
  "Vodansk",
  "Vodanskho",
  "Vojenova",
  "Vojetick",
  "Vojick",
  "Vojkovick",
  "Vojslavick",
  "Vojtova",
  "Vojtkova",
  "Vojtsk",
  "Vojkova",
  "Vokovick",
  "Vokovick",
  "Vokrojova",
  "Vokova",
  "Voknsk",
  "Volarsk",
  "Volavkova",
  "Volenkova",
  "Volkova",
  "Volkovova",
  "Voltova",
  "Volutov",
  "Volysk",
  "Volovsk",
  "Volovsk",
  "Vondrouova",
  "Vorask",
  "Voronsk",
  "Voronsk",
  "Vorovsk",
  "Vorilsk",
  "Voskova",
  "Voskovcova",
  "Vosmkovch",
  "Vostrovsk",
  "Vostrho",
  "Vostkova",
  "Votavova",
  "Votick",
  "Votokova",
  "Votrubova",
  "Votuzsk",
  "Vozov",
  "Vozov",
  "Vokova",
  "Vokova",
  "Voahlkova",
  "Voick",
  "Vrab",
  "Vranick",
  "Vranovsk",
  "Vransk",
  "Vratimovsk",
  "Vratislavova",
  "Vratislavsk",
  "Vratiov",
  "Vraansk",
  "Vrbenskho",
  "Vrbick",
  "Vrbkov",
  "Vrbova",
  "Vrbansk",
  "Vrchlabsk",
  "Vrchlickho",
  "Vrchlickho Sady",
  "Vrchovinsk",
  "Vrtensk",
  "Vrtkovsk",
  "Vrzova",
  "Vrsk",
  "Vrteck",
  "Vrn",
  "Vrovick",
  "Vrovick Nm.",
  "Vrovick Nmst",
  "Vrovka",
  "Vsetnsk",
  "Vstavaov",
  "Vstupn",
  "Vybralova",
  "Vycplkova",
  "Vydersk",
  "Vydrova",
  "Vyhldkova",
  "Vykoukovch",
  "Vyksk",
  "Vyskoilova",
  "Vysokovsk",
  "Vysokokolsk",
  "Vysok Cesta",
  "Vysoansk",
  "Vysoansk",
  "Vysoansk",
  "Vysoansk Nm.",
  "Vysoansk Nmst",
  "Vyven",
  "Vyebrodsk",
  "Vyehradsk",
  "Vy",
  "Vylovsk",
  "Vzdun",
  "Vzdlen",
  "Vzestupn",
  "Vzpoury",
  "Vchalova",
  "Vclava Balho",
  "Vclava Kovaka",
  "Vclava Rady",
  "Vclava Trojana",
  "Vclava paka",
  "Vclavick",
  "Vclavkova",
  "Vclavsk",
  "Vclavsk Nm.",
  "Vclavsk Nmst",
  "Vgnerova",
  "Vnkov",
  "Vpencov",
  "Vpenn",
  "Vpenkova",
  "Vova",
  "Vsk",
  "Vdesk",
  "Vdesk",
  "Vdesk",
  "Vrsk",
  "Vta Nejedlho",
  "Vtkova",
  "Vtkovick",
  "Vtovcova",
  "Vtovcova",
  "Vtzn",
  "Vtzn",
  "Vtzn Nm.",
  "Vtzn Nm.",
  "Vtzn Nmst",
  "Vtzn Nmst",
  "Vchodn",
  "Vchodn Nm.",
  "Vchodn Nmst",
  "Vchoz",
  "Vhledov",
  "Vhledsk Nm.",
  "Vhledsk Nmst",
  "Vjezdn",
  "Vjezdov",
  "Vletn",
  "Vletn",
  "Vmarova",
  "Vmolova",
  "Vpadov",
  "Vpadov",
  "Vravsk",
  "Vrobn",
  "Vstavit",
  "Vstavn",
  "Vstupn",
  "Vtosk",
  "Vtvarnick",
  "Vtvarn",
  "Vzkumnk",
  "Velask",
  "Velnin",
  "Vkova",
  "Vstonick",
  "Vtrn",
  "Vtrovcova",
  "Vtrov",
  "Vtruick",
  "Vzesk",
  "Vzesk",
  "Vtnsk",
  "Vnova",
  "Vick",
  "Vesovick",
  "Vesov",
  "Vehrdova",
  "Vejansk",
  "Velipsk",
  "Verubsk",
  "Vestarsk",
  "Vetatsk",
  "Vesk",
  "Wagnerova",
  "Waldesova",
  "Washingtonova",
  "Wassermannova",
  "Wattova",
  "Weberova",
  "Weberova",
  "Weilova",
  "Weissova",
  "Wenzigova",
  "Wenzigova",
  "Werichova",
  "Wichterlova",
  "Wiedermannova",
  "Wiesenthalova",
  "Wilsonova",
  "Wilsonova",
  "Winklerova",
  "Wolfova",
  "Wolkerova",
  "Wuchterlova",
  "Xaveriova",
  "Xaverovsk",
  "Za Archivem",
  "Za Arielem",
  "Za Avi",
  "Za Baantnic",
  "Za Botiem",
  "Za Brankou",
  "Za Brumlovkou",
  "Za Brdkem",
  "Za Bzami",
  "Za Chalupami",
  "Za Cukrovarem",
  "Za Csaskm Mlnem",
  "Za Dolejkem",
  "Za Drahou",
  "Za Dvorem",
  "Za Dlnic",
  "Za Dlnic",
  "Za Elektrrnou",
  "Za Elektrrnou",
  "Za Farou",
  "Za Fotem",
  "Za Hanspaulkou",
  "Za Hatalem",
  "Za Hldkovem",
  "Za Horou",
  "Za Horou",
  "Za Hospodou",
  "Za Hrz",
  "Za Humny",
  "Za Hjem",
  "Za Hjem",
  "Za Hjovnou",
  "Za Hbitovem",
  "Za Invalidovnou",
  "Za Jalovm Dvorem",
  "Za Jednotou",
  "Za Kajetnkou",
  "Za Kaplikou",
  "Za Karlnskm Pstavem",
  "Za Kaabkou",
  "Za Klovem",
  "Za Knotkem",
  "Za Knotkem",
  "Za Kostelem",
  "Za Kovrnou",
  "Za Kovskm Rybnkem",
  "Za Kem",
  "Za Kkem",
  "Za Leskem",
  "Za Lidovm Domem",
  "Za Luhem",
  "Za Luinami",
  "Za Lny",
  "Za Lzekou",
  "Za Mlnem",
  "Za Mosty",
  "Za Mosty",
  "Za Mototechnou",
  "Za Mstkem",
  "Za Nadmaem",
  "Za Novkovou Zahradou",
  "Za Nvs",
  "Za Obecnm adem",
  "Za Oborou",
  "Za Opravnou",
  "Za Opusem",
  "Za Ovnem",
  "Za Paprnou",
  "Za Parkem",
  "Za Pavilnem",
  "Za Pekakou",
  "Za Pekrnou",
  "Za Pivovarem",
  "Za Ploty",
  "Za Podjezdem",
  "Za Pohoelcem",
  "Za Pohdkou",
  "Za Potokem",
  "Za Poskou Branou",
  "Za Poskou Brnou",
  "Za Potou",
  "Za Potovskou Zahradou",
  "Za Potovskou Zahradou",
  "Za Prodejnou",
  "Za Pruhy",
  "Za Prsekem",
  "Za Pskovnou",
  "Za Radost",
  "Za Rokytkou",
  "Za Rybnkem",
  "Za Rybnky",
  "Za Rybstvm",
  "Za Rjem",
  "Za Sadem",
  "Za Sedmidomky",
  "Za Skalkou",
  "Za Skalkou",
  "Za Slatinami",
  "Za Slovankou",
  "Za Sokolovnou",
  "Za Stadionem",
  "Za Statkem",
  "Za Statky",
  "Za Stodolami",
  "Za Stodolou",
  "Za Strahovem",
  "Za Stranickou Vozovnou",
  "Za Stranickou Vozovnou",
  "Za Strojrnami",
  "Za Studnkou",
  "Za Stelnic",
  "Za Sdlitm",
  "Za Teplrnou",
  "Za Trat",
  "Za Trat",
  "Za Tebenem",
  "Za Vackovem",
  "Za Valem",
  "Za Viaduktem",
  "Za Vinic",
  "Za Vlasakou",
  "Za Vodrnou",
  "Za Vokovickou Vozovnou",
  "Za Vokovickou Vozovnou",
  "Za Vtrem",
  "Za Zahradami",
  "Za Zahradou",
  "Za Zastvkou",
  "Za Zelenou Likou",
  "Za Zmekem",
  "Za ernm Mostem",
  "Za ernm Mostem",
  "Za ernm Mostem",
  "Za kolkou",
  "Za kolou",
  "Za matlkem",
  "Za eleznic",
  "Za enskmi Domovy",
  "Za ikovskou Vozovnou",
  "Zacharsk",
  "Zachova",
  "Zadn",
  "Zahrada Na Bat",
  "Zahradnick",
  "Zahradn",
  "Zahradnkova",
  "Zahradnkova",
  "Zahrdeck",
  "Zahrdeck",
  "Zahrdksk",
  "Zahrdk",
  "Zajeick",
  "Zaje",
  "Zaje",
  "Zakouilova",
  "Zakryt",
  "Zaknsk",
  "Zaleansk",
  "Zalinsk",
  "Zamask",
  "Zamenhofova",
  "Zapadl",
  "Zapomenut",
  "Zapova",
  "Zapskch",
  "Zastavn",
  "Zastren",
  "Zavadilova",
  "Zavt",
  "Zaansk",
  "Zbeensk",
  "Zborovsk",
  "Zborovsk",
  "Zbraslavsk",
  "Zbraslavsk",
  "Zbraslavsk Nm.",
  "Zbraslavsk Nmst",
  "Zbrojnick",
  "Zbudovsk",
  "Zbuzansk",
  "Zbuzkova",
  "Zbynick",
  "Zbyslavsk",
  "Zbytinsk",
  "Zbovsk",
  "Zdaru",
  "Zdail",
  "Zderazsk",
  "Zdeky Nyplov",
  "Zdibsk",
  "Zdick",
  "Zdimick",
  "Zdislavick",
  "Zdobnick",
  "Zdoovsk",
  "Zdkovsk",
  "Zelenesk",
  "Zelenesk",
  "Zelenkova",
  "Zelenky-Hajskho",
  "Zelenohorsk",
  "Zelen",
  "Zelen",
  "Zelen Louka",
  "Zelen Pruh",
  "Zelen Pruh",
  "Zelen Pruh",
  "Zelinsk",
  "Zemanka",
  "Zemsk Prvo",
  "Zemdlsk",
  "Zengrova",
  "Zenklova",
  "Zenklova",
  "Zeyerova Alej",
  "Zhoeleck",
  "Zikova",
  "Zimova",
  "Zimkova",
  "Zkrcen",
  "Zlatnice",
  "Zlatnick",
  "Zlatokorunsk",
  "Zlat",
  "Zlat Ulika U Daliborky",
  "Zlenick",
  "Zleick",
  "Zlivsk",
  "Zlinsk",
  "Zlinsk",
  "Zlonick",
  "Zlonnsk",
  "Zlonick",
  "Zlchovsk",
  "Znojemsk",
  "Zoubkova",
  "Zrzavho",
  "Ztracen",
  "Zubatho",
  "Zubrnick",
  "Zvolensk",
  "Zvolsk",
  "Zvolsk",
  "Zvonaova",
  "Zvonaovsk",
  "Zvonask",
  "Zvoncovit",
  "Zvonick",
  "Zvonkov",
  "Zvonkova",
  "Zvnovick",
  "Zvkovsk",
  "Zblatsk",
  "Zblatsk",
  "Zbransk",
  "Zbrod",
  "Zbhlick",
  "Zdraansk",
  "Zhornick",
  "Zhorskho",
  "Zhoansk",
  "Zhoanskho",
  "Zhebsk",
  "Zjezdn",
  "Zkolansk",
  "Zkosteln",
  "Zkupsk",
  "Zles",
  "Zles",
  "Zles",
  "Zlusk",
  "Zluanskho",
  "Zluick",
  "Zlusk",
  "Zlusk",
  "Zmeck",
  "Zmeck Schody",
  "Zmez",
  "Zmiova",
  "Zmlsk",
  "Zpadn",
  "Zpasnick",
  "Zpolsk",
  "Zpoton",
  "Zpsk",
  "Zrubova",
  "Zrybnick",
  "Zrybnin",
  "Zrybsk",
  "Zsadsk",
  "Zsmuck",
  "Ztisk",
  "Zti",
  "Ztopkova",
  "Ztosk",
  "Zvadova",
  "Zvesk",
  "Zvist",
  "Zviova",
  "Zviova",
  "Zvodn",
  "Zvrchy",
  "Zvrka",
  "Zzvorkova",
  "Zijov",
  "Ztkova",
  "Zvrova",
  "Zen",
  "dlick",
  "doln",
  "doln",
  "dol Hvzd",
  "hlavsk",
  "hlov",
  "jezd",
  "jezd",
  "jezdsk",
  "libick",
  "norov",
  "ntick",
  "ntick",
  "pick",
  "prkova",
  "psk",
  "slavsk",
  "stavn",
  "steck",
  "steck",
  "stedn",
  "tuln",
  "tuln",
  "valsk",
  "voz",
  "voz",
  "vozov",
  "zk",
  "ajkovskho",
  "akovick",
  "akovick",
  "ankovsk",
  "apkova",
  "astavina",
  "astonick",
  "echova",
  "echtick",
  "echurova",
  "ediov",
  "ejetick",
  "ejkovick",
  "ekankov",
  "ekankov",
  "ekanovsk",
  "elakovskho Sady",
  "elakovskho Sady",
  "eljabinsk",
  "elkovick",
  "eln",
  "elkovick",
  "enkovsk",
  "enovick",
  "entick",
  "entick",
  "epersk",
  "eradick",
  "erchovsk",
  "ermkova",
  "ernick",
  "ernilovsk",
  "ernin",
  "ernochova",
  "ernockho",
  "ernohorskho",
  "ernokosteleck",
  "ernokosteleck",
  "ernokosteleck",
  "ernomosk",
  "ernotnsk",
  "ernovick",
  "ernoick",
  "ern",
  "ernho",
  "ernnova",
  "ernnsk",
  "erpadlov",
  "ertousk",
  "ertousk",
  "ertv Vrek",
  "ervencov",
  "ervenkova",
  "erven",
  "erven B",
  "erven Mln",
  "erveanskho",
  "ervnov",
  "eransk",
  "eskobratrsk",
  "eskobrodsk",
  "eskobrodsk",
  "eskobrodsk",
  "eskobrodsk",
  "eskobrodsk",
  "eskobrodsk",
  "eskobrodsk",
  "eskobrodsk",
  "eskodubsk",
  "eskolipsk",
  "eskolipsk",
  "eskomalnsk",
  "eskomoravsk",
  "eskomoravsk",
  "eskoslovenskho Exilu",
  "eskoslovenskho Exilu",
  "esk",
  "esk Druiny",
  "eskho ervenho Ke",
  "estlick",
  "estmrova",
  "eskova",
  "eelick",
  "ekova",
  "eovsk",
  "ibuzsk",
  "ihkova",
  "iklova",
  "iklova",
  "imelick",
  "imick",
  "imick",
  "imick",
  "imick",
  "irvkov",
  "istovick",
  "melick",
  "s. Armdy",
  "s. Tankist",
  "tydln",
  "tykolsk",
  "umpelkova",
  "uprova",
  "beleck",
  "pova",
  "slavsk",
  "lova",
  "lova",
  "nsk",
  "nsk",
  "ovsk",
  "blick",
  "blick",
  "blick",
  "adov",
  "ehoova",
  "epesk",
  "epn",
  "eporyjsk",
  "eporyjsk",
  "eporyjsk",
  "eporyjsk Nmst",
  "epov",
  "epsk",
  "epkov",
  "epnsk",
  "epick",
  "epick",
  "etzokov",
  "etzov",
  "evnick",
  "evnick",
  "eznick",
  "ezovo Nm.",
  "ezovo Nmst",
  "eickho",
  "eetovsk",
  "eovsk",
  "ipsk",
  "ipsk",
  "snovka",
  "jnov",
  "movsk",
  "movsk",
  "msk",
  "anova",
  "ansk",
  "n",
  "achovsk",
  "afakova",
  "afrneck",
  "afrnkova",
  "afrnov",
  "afova",
  "akvick",
  "aldova",
  "alounova",
  "alvjov",
  "anovsk",
  "antrochova",
  "atrova",
  "atrova",
  "ebelova",
  "eberovsk",
  "ebestinsk",
  "ebkova",
  "edivho",
  "edova",
  "ejbalov",
  "emberova",
  "enovsk",
  "ermsk",
  "ermsk",
  "estajovick",
  "estajovick",
  "estidom",
  "etelkova",
  "evce Matoue",
  "evenkova",
  "evkova",
  "ekov",
  "ekov",
  "ibinsk",
  "ikm",
  "imanovsk",
  "imkova",
  "imonova",
  "imkova",
  "imnkova",
  "ircova",
  "irok",
  "irok",
  "ikova",
  "koln",
  "kolsk",
  "kroupovo Nm.",
  "kroupovo Nmst",
  "krtova",
  "kvoreck",
  "kbova",
  "lechtitelsk",
  "lejnick",
  "likova",
  "litrova",
  "luknovsk",
  "meralova",
  "milovskho",
  "molkova",
  "olnova",
  "ostakoviovo Nm.",
  "ostakoviovo Nmst",
  "panielova",
  "panlsk",
  "pakova",
  "pecinova",
  "perlova",
  "pirkova",
  "pitlsk",
  "plechnerova",
  "porkova",
  "potzova",
  "plova",
  "robrova",
  "robrova",
  "romova",
  "tamberk",
  "tefkova",
  "tefnikova",
  "temberova",
  "ternberkova",
  "ternova",
  "ternovsk",
  "tichova",
  "tiplova",
  "tikova",
  "tinsk",
  "tochlova",
  "tolbova",
  "tolcova",
  "tolmsk",
  "tolmsk",
  "torchova",
  "torknova",
  "trambersk",
  "tulcova",
  "tupartsk",
  "tursova",
  "tverkova",
  "tychova",
  "tychova",
  "tbrova",
  "thlick",
  "ttnho",
  "ttov",
  "trova",
  "trova",
  "tchovick",
  "tpanick",
  "tpask",
  "tpnin",
  "tpnkova",
  "tpnovsk",
  "tpnsk",
  "tpnsk",
  "trboholsk",
  "trkov",
  "ttkova",
  "ttnsk",
  "ubertova",
  "ulcova",
  "ultysova",
  "umavsk",
  "umavskho",
  "umberova",
  "umensk",
  "umick",
  "umpersk",
  "ustova",
  "vabinskho",
  "vecova",
  "vehlova",
  "vehlova",
  "vejcarovo Nmst",
  "vestkov",
  "vestkov",
  "vestkov",
  "vihovsk",
  "vbky",
  "vbova",
  "vdsk",
  "reck",
  "rovo Kolo",
  "rina",
  "talsk",
  "fask",
  "mova",
  "pkov",
  "tkova",
  "astnho",
  "rova",
  "abovesk",
  "aclsk",
  "alanskho",
  "almanova",
  "alovsk",
  "ambersk",
  "ampask",
  "ampinov",
  "andovsk",
  "ateck",
  "ateck",
  "ateckch",
  "drnick",
  "ehusk",
  "ehuick",
  "eletavsk",
  "eleznin",
  "elezni",
  "eleznobrodsk",
  "elezn",
  "eliveck",
  "elivka",
  "elivsk",
  "elkovick",
  "elnavsk",
  "enkova",
  "eretick",
  "ermanick",
  "ernoseck",
  "ernovsk",
  "erotnova",
  "hersk",
  "ichlnsk",
  "idlickho",
  "ilinsk",
  "ilovsk",
  "inkovsk",
  "irovnick",
  "itavsk",
  "itavskho",
  "itn",
  "itn",
  "itomrsk",
  "ivanick",
  "ivcov",
  "ivcovch",
  "ivonnsk",
  "ielick",
  "ikova",
  "ikovo Nm.",
  "ikovo Nmst",
  "lebsk",
  "luskov",
  "ofie Podlipsk",
  "ufanova",
  "ukovskho",
  "ukovskho",
  "ulov",
  "upanovick",
  "vahovsk",
  "bova",
  "kovsk",
  "rovick",
  "ovsk",
  "rsk",
];

},{}],324:[function(require,module,exports){
module["exports"] = [
  "#{street_name} #{building_number}"
];

},{}],325:[function(require,module,exports){
module["exports"] = [
  "#{street}"
];

},{}],326:[function(require,module,exports){
module["exports"] = [
  "Pacific/Midway",
  "Pacific/Pago_Pago",
  "Pacific/Honolulu",
  "America/Juneau",
  "America/Los_Angeles",
  "America/Tijuana",
  "America/Denver",
  "America/Phoenix",
  "America/Chihuahua",
  "America/Mazatlan",
  "America/Chicago",
  "America/Regina",
  "America/Mexico_City",
  "America/Mexico_City",
  "America/Monterrey",
  "America/Guatemala",
  "America/New_York",
  "America/Indiana/Indianapolis",
  "America/Bogota",
  "America/Lima",
  "America/Lima",
  "America/Halifax",
  "America/Caracas",
  "America/La_Paz",
  "America/Santiago",
  "America/St_Johns",
  "America/Sao_Paulo",
  "America/Argentina/Buenos_Aires",
  "America/Guyana",
  "America/Godthab",
  "Atlantic/South_Georgia",
  "Atlantic/Azores",
  "Atlantic/Cape_Verde",
  "Europe/Dublin",
  "Europe/London",
  "Europe/Lisbon",
  "Europe/London",
  "Africa/Casablanca",
  "Africa/Monrovia",
  "Etc/UTC",
  "Europe/Belgrade",
  "Europe/Bratislava",
  "Europe/Budapest",
  "Europe/Ljubljana",
  "Europe/Prague",
  "Europe/Sarajevo",
  "Europe/Skopje",
  "Europe/Warsaw",
  "Europe/Zagreb",
  "Europe/Brussels",
  "Europe/Copenhagen",
  "Europe/Madrid",
  "Europe/Paris",
  "Europe/Amsterdam",
  "Europe/Berlin",
  "Europe/Berlin",
  "Europe/Rome",
  "Europe/Stockholm",
  "Europe/Vienna",
  "Africa/Algiers",
  "Europe/Bucharest",
  "Africa/Cairo",
  "Europe/Helsinki",
  "Europe/Kiev",
  "Europe/Riga",
  "Europe/Sofia",
  "Europe/Tallinn",
  "Europe/Vilnius",
  "Europe/Athens",
  "Europe/Istanbul",
  "Europe/Minsk",
  "Asia/Jerusalem",
  "Africa/Harare",
  "Africa/Johannesburg",
  "Europe/Moscow",
  "Europe/Moscow",
  "Europe/Moscow",
  "Asia/Kuwait",
  "Asia/Riyadh",
  "Africa/Nairobi",
  "Asia/Baghdad",
  "Asia/Tehran",
  "Asia/Muscat",
  "Asia/Muscat",
  "Asia/Baku",
  "Asia/Tbilisi",
  "Asia/Yerevan",
  "Asia/Kabul",
  "Asia/Yekaterinburg",
  "Asia/Karachi",
  "Asia/Karachi",
  "Asia/Tashkent",
  "Asia/Kolkata",
  "Asia/Kolkata",
  "Asia/Kolkata",
  "Asia/Kolkata",
  "Asia/Kathmandu",
  "Asia/Dhaka",
  "Asia/Dhaka",
  "Asia/Colombo",
  "Asia/Almaty",
  "Asia/Novosibirsk",
  "Asia/Rangoon",
  "Asia/Bangkok",
  "Asia/Bangkok",
  "Asia/Jakarta",
  "Asia/Krasnoyarsk",
  "Asia/Shanghai",
  "Asia/Chongqing",
  "Asia/Hong_Kong",
  "Asia/Urumqi",
  "Asia/Kuala_Lumpur",
  "Asia/Singapore",
  "Asia/Taipei",
  "Australia/Perth",
  "Asia/Irkutsk",
  "Asia/Ulaanbaatar",
  "Asia/Seoul",
  "Asia/Tokyo",
  "Asia/Tokyo",
  "Asia/Tokyo",
  "Asia/Yakutsk",
  "Australia/Darwin",
  "Australia/Adelaide",
  "Australia/Melbourne",
  "Australia/Melbourne",
  "Australia/Sydney",
  "Australia/Brisbane",
  "Australia/Hobart",
  "Asia/Vladivostok",
  "Pacific/Guam",
  "Pacific/Port_Moresby",
  "Asia/Magadan",
  "Asia/Magadan",
  "Pacific/Noumea",
  "Pacific/Fiji",
  "Asia/Kamchatka",
  "Pacific/Majuro",
  "Pacific/Auckland",
  "Pacific/Auckland",
  "Pacific/Tongatapu",
  "Pacific/Fakaofo",
  "Pacific/Apia"
];

},{}],327:[function(require,module,exports){
module["exports"] = [
  "Adaptive",
  "Advanced",
  "Ameliorated",
  "Assimilated",
  "Automated",
  "Balanced",
  "Business-focused",
  "Centralized",
  "Cloned",
  "Compatible",
  "Configurable",
  "Cross-group",
  "Cross-platform",
  "Customer-focused",
  "Customizable",
  "Decentralized",
  "De-engineered",
  "Devolved",
  "Digitized",
  "Distributed",
  "Diverse",
  "Down-sized",
  "Enhanced",
  "Enterprise-wide",
  "Ergonomic",
  "Exclusive",
  "Expanded",
  "Extended",
  "Face to face",
  "Focused",
  "Front-line",
  "Fully-configurable",
  "Function-based",
  "Fundamental",
  "Future-proofed",
  "Grass-roots",
  "Horizontal",
  "Implemented",
  "Innovative",
  "Integrated",
  "Intuitive",
  "Inverse",
  "Managed",
  "Mandatory",
  "Monitored",
  "Multi-channelled",
  "Multi-lateral",
  "Multi-layered",
  "Multi-tiered",
  "Networked",
  "Object-based",
  "Open-architected",
  "Open-source",
  "Operative",
  "Optimized",
  "Optional",
  "Organic",
  "Organized",
  "Persevering",
  "Persistent",
  "Phased",
  "Polarised",
  "Pre-emptive",
  "Proactive",
  "Profit-focused",
  "Profound",
  "Programmable",
  "Progressive",
  "Public-key",
  "Quality-focused",
  "Reactive",
  "Realigned",
  "Re-contextualized",
  "Re-engineered",
  "Reduced",
  "Reverse-engineered",
  "Right-sized",
  "Robust",
  "Seamless",
  "Secured",
  "Self-enabling",
  "Sharable",
  "Stand-alone",
  "Streamlined",
  "Switchable",
  "Synchronised",
  "Synergistic",
  "Synergized",
  "Team-oriented",
  "Total",
  "Triple-buffered",
  "Universal",
  "Up-sized",
  "Upgradable",
  "User-centric",
  "User-friendly",
  "Versatile",
  "Virtual",
  "Visionary",
  "Vision-oriented"
];

},{}],328:[function(require,module,exports){
module["exports"] = [
  "clicks-and-mortar",
  "value-added",
  "vertical",
  "proactive",
  "robust",
  "revolutionary",
  "scalable",
  "leading-edge",
  "innovative",
  "intuitive",
  "strategic",
  "e-business",
  "mission-critical",
  "sticky",
  "one-to-one",
  "24/7",
  "end-to-end",
  "global",
  "B2B",
  "B2C",
  "granular",
  "frictionless",
  "virtual",
  "viral",
  "dynamic",
  "24/365",
  "best-of-breed",
  "killer",
  "magnetic",
  "bleeding-edge",
  "web-enabled",
  "interactive",
  "dot-com",
  "sexy",
  "back-end",
  "real-time",
  "efficient",
  "front-end",
  "distributed",
  "seamless",
  "extensible",
  "turn-key",
  "world-class",
  "open-source",
  "cross-platform",
  "cross-media",
  "synergistic",
  "bricks-and-clicks",
  "out-of-the-box",
  "enterprise",
  "integrated",
  "impactful",
  "wireless",
  "transparent",
  "next-generation",
  "cutting-edge",
  "user-centric",
  "visionary",
  "customized",
  "ubiquitous",
  "plug-and-play",
  "collaborative",
  "compelling",
  "holistic",
  "rich",
  "synergies",
  "web-readiness",
  "paradigms",
  "markets",
  "partnerships",
  "infrastructures",
  "platforms",
  "initiatives",
  "channels",
  "eyeballs",
  "communities",
  "ROI",
  "solutions",
  "e-tailers",
  "e-services",
  "action-items",
  "portals",
  "niches",
  "technologies",
  "content",
  "vortals",
  "supply-chains",
  "convergence",
  "relationships",
  "architectures",
  "interfaces",
  "e-markets",
  "e-commerce",
  "systems",
  "bandwidth",
  "infomediaries",
  "models",
  "mindshare",
  "deliverables",
  "users",
  "schemas",
  "networks",
  "applications",
  "metrics",
  "e-business",
  "functionalities",
  "experiences",
  "web services",
  "methodologies"
];

},{}],329:[function(require,module,exports){
module["exports"] = [
  "implement",
  "utilize",
  "integrate",
  "streamline",
  "optimize",
  "evolve",
  "transform",
  "embrace",
  "enable",
  "orchestrate",
  "leverage",
  "reinvent",
  "aggregate",
  "architect",
  "enhance",
  "incentivize",
  "morph",
  "empower",
  "envisioneer",
  "monetize",
  "harness",
  "facilitate",
  "seize",
  "disintermediate",
  "synergize",
  "strategize",
  "deploy",
  "brand",
  "grow",
  "target",
  "syndicate",
  "synthesize",
  "deliver",
  "mesh",
  "incubate",
  "engage",
  "maximize",
  "benchmark",
  "expedite",
  "reintermediate",
  "whiteboard",
  "visualize",
  "repurpose",
  "innovate",
  "scale",
  "unleash",
  "drive",
  "extend",
  "engineer",
  "revolutionize",
  "generate",
  "exploit",
  "transition",
  "e-enable",
  "iterate",
  "cultivate",
  "matrix",
  "productize",
  "redefine",
  "recontextualize"
];

},{}],330:[function(require,module,exports){
module["exports"] = [
  "24 hour",
  "24/7",
  "3rd generation",
  "4th generation",
  "5th generation",
  "6th generation",
  "actuating",
  "analyzing",
  "asymmetric",
  "asynchronous",
  "attitude-oriented",
  "background",
  "bandwidth-monitored",
  "bi-directional",
  "bifurcated",
  "bottom-line",
  "clear-thinking",
  "client-driven",
  "client-server",
  "coherent",
  "cohesive",
  "composite",
  "context-sensitive",
  "contextually-based",
  "content-based",
  "dedicated",
  "demand-driven",
  "didactic",
  "directional",
  "discrete",
  "disintermediate",
  "dynamic",
  "eco-centric",
  "empowering",
  "encompassing",
  "even-keeled",
  "executive",
  "explicit",
  "exuding",
  "fault-tolerant",
  "foreground",
  "fresh-thinking",
  "full-range",
  "global",
  "grid-enabled",
  "heuristic",
  "high-level",
  "holistic",
  "homogeneous",
  "human-resource",
  "hybrid",
  "impactful",
  "incremental",
  "intangible",
  "interactive",
  "intermediate",
  "leading edge",
  "local",
  "logistical",
  "maximized",
  "methodical",
  "mission-critical",
  "mobile",
  "modular",
  "motivating",
  "multimedia",
  "multi-state",
  "multi-tasking",
  "national",
  "needs-based",
  "neutral",
  "next generation",
  "non-volatile",
  "object-oriented",
  "optimal",
  "optimizing",
  "radical",
  "real-time",
  "reciprocal",
  "regional",
  "responsive",
  "scalable",
  "secondary",
  "solution-oriented",
  "stable",
  "static",
  "systematic",
  "systemic",
  "system-worthy",
  "tangible",
  "tertiary",
  "transitional",
  "uniform",
  "upward-trending",
  "user-facing",
  "value-added",
  "web-enabled",
  "well-modulated",
  "zero administration",
  "zero defect",
  "zero tolerance"
];

},{}],331:[function(require,module,exports){
var company = {};
module['exports'] = company;
company.suffix = require("./suffix");
company.adjective = require("./adjective");
company.descriptor = require("./descriptor");
company.noun = require("./noun");
company.bs_verb = require("./bs_verb");
company.bs_noun = require("./bs_noun");
company.name = require("./name");

},{"./adjective":327,"./bs_noun":328,"./bs_verb":329,"./descriptor":330,"./name":332,"./noun":333,"./suffix":334}],332:[function(require,module,exports){
module["exports"] = [
  "#{Name.last_name} #{suffix}",
  "#{Name.last_name} #{suffix}",
  "#{Name.man_last_name} a #{Name.man_last_name} #{suffix}"
];

},{}],333:[function(require,module,exports){
module["exports"] = [
  "ability",
  "access",
  "adapter",
  "algorithm",
  "alliance",
  "analyzer",
  "application",
  "approach",
  "architecture",
  "archive",
  "artificial intelligence",
  "array",
  "attitude",
  "benchmark",
  "budgetary management",
  "capability",
  "capacity",
  "challenge",
  "circuit",
  "collaboration",
  "complexity",
  "concept",
  "conglomeration",
  "contingency",
  "core",
  "customer loyalty",
  "database",
  "data-warehouse",
  "definition",
  "emulation",
  "encoding",
  "encryption",
  "extranet",
  "firmware",
  "flexibility",
  "focus group",
  "forecast",
  "frame",
  "framework",
  "function",
  "functionalities",
  "Graphic Interface",
  "groupware",
  "Graphical User Interface",
  "hardware",
  "help-desk",
  "hierarchy",
  "hub",
  "implementation",
  "info-mediaries",
  "infrastructure",
  "initiative",
  "installation",
  "instruction set",
  "interface",
  "internet solution",
  "intranet",
  "knowledge user",
  "knowledge base",
  "local area network",
  "leverage",
  "matrices",
  "matrix",
  "methodology",
  "middleware",
  "migration",
  "model",
  "moderator",
  "monitoring",
  "moratorium",
  "neural-net",
  "open architecture",
  "open system",
  "orchestration",
  "paradigm",
  "parallelism",
  "policy",
  "portal",
  "pricing structure",
  "process improvement",
  "product",
  "productivity",
  "project",
  "projection",
  "protocol",
  "secured line",
  "service-desk",
  "software",
  "solution",
  "standardization",
  "strategy",
  "structure",
  "success",
  "superstructure",
  "support",
  "synergy",
  "system engine",
  "task-force",
  "throughput",
  "time-frame",
  "toolset",
  "utilisation",
  "website",
  "workforce"
];

},{}],334:[function(require,module,exports){
module["exports"] = [
  "s.r.o.",
  "a.s.",
  "v.o.s."
];

},{}],335:[function(require,module,exports){
arguments[4][296][0].apply(exports,arguments)
},{"./month":336,"./weekday":337,"dup":296}],336:[function(require,module,exports){
// Source: http://unicode.org/cldr/trac/browser/tags/release-27/common/main/en.xml#L1799
module["exports"] = {
  wide: [
    "Leden",
    "nor",
    "Bezen",
    "Duben",
    "Kvten",
    "erven",
    "ervenec",
    "Srpen",
    "Z",
    "jen",
    "Listopad",
    "Prosinec"
  ],
  // Property "wide_context" is optional, if not set then "wide" will be used instead
  // It is used to specify a word in context, which may differ from a stand-alone word
  wide_context: [
    "Leden",
    "nor",
    "Bezen",
    "Duben",
    "Kvten",
    "erven",
    "ervenec",
    "Srpen",
    "Z",
    "jen",
    "Listopad",
    "Prosinec"
  ],
  abbr: [
    "Led",
    "no",
    "Be",
    "Dub",
    "Kv",
    "er",
    "rc",
    "Srp",
    "Z",
    "j",
    "Lis",
    "Pro"
  ],
  // Property "abbr_context" is optional, if not set then "abbr" will be used instead
  // It is used to specify a word in context, which may differ from a stand-alone word
  abbr_context: [
    "Led",
    "no",
    "Be",
    "Dub",
    "Kv",
    "er",
    "rc",
    "Srp",
    "Z",
    "j",
    "Lis",
    "Pro"
  ]
};

},{}],337:[function(require,module,exports){
// Source: http://unicode.org/cldr/trac/browser/tags/release-27/common/main/en.xml#L1847
module["exports"] = {
  wide: [
    "Pondl",
    "ter",
    "Steda",
    "tvrtek",
    "Ptek",
    "Sobota",
    "Nedle"
  ],
  // Property "wide_context" is optional, if not set then "wide" will be used instead
  // It is used to specify a word in context, which may differ from a stand-alone word
  wide_context: [
    "Pondl",
    "ter",
    "Steda",
    "tvrtek",
    "Ptek",
    "Sobota",
    "Nedle"
  ],
  abbr: [
    "Po",
    "t",
    "St",
    "t",
    "P",
    "So",
    "Ne"
  ],
  // Property "abbr_context" is optional, if not set then "abbr" will be used instead
  // It is used to specify a word in context, which may differ from a stand-alone word
  abbr_context: [
    "Po",
    "t",
    "St",
    "t",
    "P",
    "So",
    "Ne"
  ]
};

},{}],338:[function(require,module,exports){
var cz = {};
module['exports'] = cz;
cz.title = "Czech";
cz.address = require("./address");
cz.company = require("./company");
cz.internet = require("./internet");
cz.lorem = require("./lorem");
cz.name = require("./name");
cz.phone_number = require("./phone_number");
cz.date = require("./date");

},{"./address":318,"./company":331,"./date":335,"./internet":341,"./lorem":342,"./name":347,"./phone_number":355}],339:[function(require,module,exports){
module["exports"] = [
  "cz",
  "com",
  "net",
  "eu",
  "org"
];

},{}],340:[function(require,module,exports){
module["exports"] = [
  "gmail.com",
  "seznam.cz",
  "centrum.cz",
  "volny.cz",
  "atlas.cz"
];

},{}],341:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":339,"./free_email":340,"dup":302}],342:[function(require,module,exports){
var lorem = {};
module['exports'] = lorem;
lorem.words = require("./words");
lorem.supplemental = require("./supplemental");

},{"./supplemental":343,"./words":344}],343:[function(require,module,exports){
module["exports"] = [
  "abbas",
  "abduco",
  "abeo",
  "abscido",
  "absconditus",
  "absens",
  "absorbeo",
  "absque",
  "abstergo",
  "absum",
  "abundans",
  "abutor",
  "accedo",
  "accendo",
  "acceptus",
  "accipio",
  "accommodo",
  "accusator",
  "acer",
  "acerbitas",
  "acervus",
  "acidus",
  "acies",
  "acquiro",
  "acsi",
  "adamo",
  "adaugeo",
  "addo",
  "adduco",
  "ademptio",
  "adeo",
  "adeptio",
  "adfectus",
  "adfero",
  "adficio",
  "adflicto",
  "adhaero",
  "adhuc",
  "adicio",
  "adimpleo",
  "adinventitias",
  "adipiscor",
  "adiuvo",
  "administratio",
  "admiratio",
  "admitto",
  "admoneo",
  "admoveo",
  "adnuo",
  "adopto",
  "adsidue",
  "adstringo",
  "adsuesco",
  "adsum",
  "adulatio",
  "adulescens",
  "adultus",
  "aduro",
  "advenio",
  "adversus",
  "advoco",
  "aedificium",
  "aeger",
  "aegre",
  "aegrotatio",
  "aegrus",
  "aeneus",
  "aequitas",
  "aequus",
  "aer",
  "aestas",
  "aestivus",
  "aestus",
  "aetas",
  "aeternus",
  "ager",
  "aggero",
  "aggredior",
  "agnitio",
  "agnosco",
  "ago",
  "ait",
  "aiunt",
  "alienus",
  "alii",
  "alioqui",
  "aliqua",
  "alius",
  "allatus",
  "alo",
  "alter",
  "altus",
  "alveus",
  "amaritudo",
  "ambitus",
  "ambulo",
  "amicitia",
  "amiculum",
  "amissio",
  "amita",
  "amitto",
  "amo",
  "amor",
  "amoveo",
  "amplexus",
  "amplitudo",
  "amplus",
  "ancilla",
  "angelus",
  "angulus",
  "angustus",
  "animadverto",
  "animi",
  "animus",
  "annus",
  "anser",
  "ante",
  "antea",
  "antepono",
  "antiquus",
  "aperio",
  "aperte",
  "apostolus",
  "apparatus",
  "appello",
  "appono",
  "appositus",
  "approbo",
  "apto",
  "aptus",
  "apud",
  "aqua",
  "ara",
  "aranea",
  "arbitro",
  "arbor",
  "arbustum",
  "arca",
  "arceo",
  "arcesso",
  "arcus",
  "argentum",
  "argumentum",
  "arguo",
  "arma",
  "armarium",
  "armo",
  "aro",
  "ars",
  "articulus",
  "artificiose",
  "arto",
  "arx",
  "ascisco",
  "ascit",
  "asper",
  "aspicio",
  "asporto",
  "assentator",
  "astrum",
  "atavus",
  "ater",
  "atqui",
  "atrocitas",
  "atrox",
  "attero",
  "attollo",
  "attonbitus",
  "auctor",
  "auctus",
  "audacia",
  "audax",
  "audentia",
  "audeo",
  "audio",
  "auditor",
  "aufero",
  "aureus",
  "auris",
  "aurum",
  "aut",
  "autem",
  "autus",
  "auxilium",
  "avaritia",
  "avarus",
  "aveho",
  "averto",
  "avoco",
  "baiulus",
  "balbus",
  "barba",
  "bardus",
  "basium",
  "beatus",
  "bellicus",
  "bellum",
  "bene",
  "beneficium",
  "benevolentia",
  "benigne",
  "bestia",
  "bibo",
  "bis",
  "blandior",
  "bonus",
  "bos",
  "brevis",
  "cado",
  "caecus",
  "caelestis",
  "caelum",
  "calamitas",
  "calcar",
  "calco",
  "calculus",
  "callide",
  "campana",
  "candidus",
  "canis",
  "canonicus",
  "canto",
  "capillus",
  "capio",
  "capitulus",
  "capto",
  "caput",
  "carbo",
  "carcer",
  "careo",
  "caries",
  "cariosus",
  "caritas",
  "carmen",
  "carpo",
  "carus",
  "casso",
  "caste",
  "casus",
  "catena",
  "caterva",
  "cattus",
  "cauda",
  "causa",
  "caute",
  "caveo",
  "cavus",
  "cedo",
  "celebrer",
  "celer",
  "celo",
  "cena",
  "cenaculum",
  "ceno",
  "censura",
  "centum",
  "cerno",
  "cernuus",
  "certe",
  "certo",
  "certus",
  "cervus",
  "cetera",
  "charisma",
  "chirographum",
  "cibo",
  "cibus",
  "cicuta",
  "cilicium",
  "cimentarius",
  "ciminatio",
  "cinis",
  "circumvenio",
  "cito",
  "civis",
  "civitas",
  "clam",
  "clamo",
  "claro",
  "clarus",
  "claudeo",
  "claustrum",
  "clementia",
  "clibanus",
  "coadunatio",
  "coaegresco",
  "coepi",
  "coerceo",
  "cogito",
  "cognatus",
  "cognomen",
  "cogo",
  "cohaero",
  "cohibeo",
  "cohors",
  "colligo",
  "colloco",
  "collum",
  "colo",
  "color",
  "coma",
  "combibo",
  "comburo",
  "comedo",
  "comes",
  "cometes",
  "comis",
  "comitatus",
  "commemoro",
  "comminor",
  "commodo",
  "communis",
  "comparo",
  "compello",
  "complectus",
  "compono",
  "comprehendo",
  "comptus",
  "conatus",
  "concedo",
  "concido",
  "conculco",
  "condico",
  "conduco",
  "confero",
  "confido",
  "conforto",
  "confugo",
  "congregatio",
  "conicio",
  "coniecto",
  "conitor",
  "coniuratio",
  "conor",
  "conqueror",
  "conscendo",
  "conservo",
  "considero",
  "conspergo",
  "constans",
  "consuasor",
  "contabesco",
  "contego",
  "contigo",
  "contra",
  "conturbo",
  "conventus",
  "convoco",
  "copia",
  "copiose",
  "cornu",
  "corona",
  "corpus",
  "correptius",
  "corrigo",
  "corroboro",
  "corrumpo",
  "coruscus",
  "cotidie",
  "crapula",
  "cras",
  "crastinus",
  "creator",
  "creber",
  "crebro",
  "credo",
  "creo",
  "creptio",
  "crepusculum",
  "cresco",
  "creta",
  "cribro",
  "crinis",
  "cruciamentum",
  "crudelis",
  "cruentus",
  "crur",
  "crustulum",
  "crux",
  "cubicularis",
  "cubitum",
  "cubo",
  "cui",
  "cuius",
  "culpa",
  "culpo",
  "cultellus",
  "cultura",
  "cum",
  "cunabula",
  "cunae",
  "cunctatio",
  "cupiditas",
  "cupio",
  "cuppedia",
  "cupressus",
  "cur",
  "cura",
  "curatio",
  "curia",
  "curiositas",
  "curis",
  "curo",
  "curriculum",
  "currus",
  "cursim",
  "curso",
  "cursus",
  "curto",
  "curtus",
  "curvo",
  "curvus",
  "custodia",
  "damnatio",
  "damno",
  "dapifer",
  "debeo",
  "debilito",
  "decens",
  "decerno",
  "decet",
  "decimus",
  "decipio",
  "decor",
  "decretum",
  "decumbo",
  "dedecor",
  "dedico",
  "deduco",
  "defaeco",
  "defendo",
  "defero",
  "defessus",
  "defetiscor",
  "deficio",
  "defigo",
  "defleo",
  "defluo",
  "defungo",
  "degenero",
  "degero",
  "degusto",
  "deinde",
  "delectatio",
  "delego",
  "deleo",
  "delibero",
  "delicate",
  "delinquo",
  "deludo",
  "demens",
  "demergo",
  "demitto",
  "demo",
  "demonstro",
  "demoror",
  "demulceo",
  "demum",
  "denego",
  "denique",
  "dens",
  "denuncio",
  "denuo",
  "deorsum",
  "depereo",
  "depono",
  "depopulo",
  "deporto",
  "depraedor",
  "deprecator",
  "deprimo",
  "depromo",
  "depulso",
  "deputo",
  "derelinquo",
  "derideo",
  "deripio",
  "desidero",
  "desino",
  "desipio",
  "desolo",
  "desparatus",
  "despecto",
  "despirmatio",
  "infit",
  "inflammatio",
  "paens",
  "patior",
  "patria",
  "patrocinor",
  "patruus",
  "pauci",
  "paulatim",
  "pauper",
  "pax",
  "peccatus",
  "pecco",
  "pecto",
  "pectus",
  "pecunia",
  "pecus",
  "peior",
  "pel",
  "ocer",
  "socius",
  "sodalitas",
  "sol",
  "soleo",
  "solio",
  "solitudo",
  "solium",
  "sollers",
  "sollicito",
  "solum",
  "solus",
  "solutio",
  "solvo",
  "somniculosus",
  "somnus",
  "sonitus",
  "sono",
  "sophismata",
  "sopor",
  "sordeo",
  "sortitus",
  "spargo",
  "speciosus",
  "spectaculum",
  "speculum",
  "sperno",
  "spero",
  "spes",
  "spiculum",
  "spiritus",
  "spoliatio",
  "sponte",
  "stabilis",
  "statim",
  "statua",
  "stella",
  "stillicidium",
  "stipes",
  "stips",
  "sto",
  "strenuus",
  "strues",
  "studio",
  "stultus",
  "suadeo",
  "suasoria",
  "sub",
  "subito",
  "subiungo",
  "sublime",
  "subnecto",
  "subseco",
  "substantia",
  "subvenio",
  "succedo",
  "succurro",
  "sufficio",
  "suffoco",
  "suffragium",
  "suggero",
  "sui",
  "sulum",
  "sum",
  "summa",
  "summisse",
  "summopere",
  "sumo",
  "sumptus",
  "supellex",
  "super",
  "suppellex",
  "supplanto",
  "suppono",
  "supra",
  "surculus",
  "surgo",
  "sursum",
  "suscipio",
  "suspendo",
  "sustineo",
  "suus",
  "synagoga",
  "tabella",
  "tabernus",
  "tabesco",
  "tabgo",
  "tabula",
  "taceo",
  "tactus",
  "taedium",
  "talio",
  "talis",
  "talus",
  "tam",
  "tamdiu",
  "tamen",
  "tametsi",
  "tamisium",
  "tamquam",
  "tandem",
  "tantillus",
  "tantum",
  "tardus",
  "tego",
  "temeritas",
  "temperantia",
  "templum",
  "temptatio",
  "tempus",
  "tenax",
  "tendo",
  "teneo",
  "tener",
  "tenuis",
  "tenus",
  "tepesco",
  "tepidus",
  "ter",
  "terebro",
  "teres",
  "terga",
  "tergeo",
  "tergiversatio",
  "tergo",
  "tergum",
  "termes",
  "terminatio",
  "tero",
  "terra",
  "terreo",
  "territo",
  "terror",
  "tersus",
  "tertius",
  "testimonium",
  "texo",
  "textilis",
  "textor",
  "textus",
  "thalassinus",
  "theatrum",
  "theca",
  "thema",
  "theologus",
  "thermae",
  "thesaurus",
  "thesis",
  "thorax",
  "thymbra",
  "thymum",
  "tibi",
  "timidus",
  "timor",
  "titulus",
  "tolero",
  "tollo",
  "tondeo",
  "tonsor",
  "torqueo",
  "torrens",
  "tot",
  "totidem",
  "toties",
  "totus",
  "tracto",
  "trado",
  "traho",
  "trans",
  "tredecim",
  "tremo",
  "trepide",
  "tres",
  "tribuo",
  "tricesimus",
  "triduana",
  "triginta",
  "tripudio",
  "tristis",
  "triumphus",
  "trucido",
  "truculenter",
  "tubineus",
  "tui",
  "tum",
  "tumultus",
  "tunc",
  "turba",
  "turbo",
  "turpe",
  "turpis",
  "tutamen",
  "tutis",
  "tyrannus",
  "uberrime",
  "ubi",
  "ulciscor",
  "ullus",
  "ulterius",
  "ultio",
  "ultra",
  "umbra",
  "umerus",
  "umquam",
  "una",
  "unde",
  "undique",
  "universe",
  "unus",
  "urbanus",
  "urbs",
  "uredo",
  "usitas",
  "usque",
  "ustilo",
  "ustulo",
  "usus",
  "uter",
  "uterque",
  "utilis",
  "utique",
  "utor",
  "utpote",
  "utrimque",
  "utroque",
  "utrum",
  "uxor",
  "vaco",
  "vacuus",
  "vado",
  "vae",
  "valde",
  "valens",
  "valeo",
  "valetudo",
  "validus",
  "vallum",
  "vapulus",
  "varietas",
  "varius",
  "vehemens",
  "vel",
  "velociter",
  "velum",
  "velut",
  "venia",
  "venio",
  "ventito",
  "ventosus",
  "ventus",
  "venustas",
  "ver",
  "verbera",
  "verbum",
  "vere",
  "verecundia",
  "vereor",
  "vergo",
  "veritas",
  "vero",
  "versus",
  "verto",
  "verumtamen",
  "verus",
  "vesco",
  "vesica",
  "vesper",
  "vespillo",
  "vester",
  "vestigium",
  "vestrum",
  "vetus",
  "via",
  "vicinus",
  "vicissitudo",
  "victoria",
  "victus",
  "videlicet",
  "video",
  "viduata",
  "viduo",
  "vigilo",
  "vigor",
  "vilicus",
  "vilis",
  "vilitas",
  "villa",
  "vinco",
  "vinculum",
  "vindico",
  "vinitor",
  "vinum",
  "vir",
  "virga",
  "virgo",
  "viridis",
  "viriliter",
  "virtus",
  "vis",
  "viscus",
  "vita",
  "vitiosus",
  "vitium",
  "vito",
  "vivo",
  "vix",
  "vobis",
  "vociferor",
  "voco",
  "volaticus",
  "volo",
  "volubilis",
  "voluntarius",
  "volup",
  "volutabrum",
  "volva",
  "vomer",
  "vomica",
  "vomito",
  "vorago",
  "vorax",
  "voro",
  "vos",
  "votum",
  "voveo",
  "vox",
  "vulariter",
  "vulgaris",
  "vulgivagus",
  "vulgo",
  "vulgus",
  "vulnero",
  "vulnus",
  "vulpes",
  "vulticulus",
  "vultuosus",
  "xiphias"
];

},{}],344:[function(require,module,exports){
module["exports"] = [
  "alias",
  "consequatur",
  "aut",
  "perferendis",
  "sit",
  "voluptatem",
  "accusantium",
  "doloremque",
  "aperiam",
  "eaque",
  "ipsa",
  "quae",
  "ab",
  "illo",
  "inventore",
  "veritatis",
  "et",
  "quasi",
  "architecto",
  "beatae",
  "vitae",
  "dicta",
  "sunt",
  "explicabo",
  "aspernatur",
  "aut",
  "odit",
  "aut",
  "fugit",
  "sed",
  "quia",
  "consequuntur",
  "magni",
  "dolores",
  "eos",
  "qui",
  "ratione",
  "voluptatem",
  "sequi",
  "nesciunt",
  "neque",
  "dolorem",
  "ipsum",
  "quia",
  "dolor",
  "sit",
  "amet",
  "consectetur",
  "adipisci",
  "velit",
  "sed",
  "quia",
  "non",
  "numquam",
  "eius",
  "modi",
  "tempora",
  "incidunt",
  "ut",
  "labore",
  "et",
  "dolore",
  "magnam",
  "aliquam",
  "quaerat",
  "voluptatem",
  "ut",
  "enim",
  "ad",
  "minima",
  "veniam",
  "quis",
  "nostrum",
  "exercitationem",
  "ullam",
  "corporis",
  "nemo",
  "enim",
  "ipsam",
  "voluptatem",
  "quia",
  "voluptas",
  "sit",
  "suscipit",
  "laboriosam",
  "nisi",
  "ut",
  "aliquid",
  "ex",
  "ea",
  "commodi",
  "consequatur",
  "quis",
  "autem",
  "vel",
  "eum",
  "iure",
  "reprehenderit",
  "qui",
  "in",
  "ea",
  "voluptate",
  "velit",
  "esse",
  "quam",
  "nihil",
  "molestiae",
  "et",
  "iusto",
  "odio",
  "dignissimos",
  "ducimus",
  "qui",
  "blanditiis",
  "praesentium",
  "laudantium",
  "totam",
  "rem",
  "voluptatum",
  "deleniti",
  "atque",
  "corrupti",
  "quos",
  "dolores",
  "et",
  "quas",
  "molestias",
  "excepturi",
  "sint",
  "occaecati",
  "cupiditate",
  "non",
  "provident",
  "sed",
  "ut",
  "perspiciatis",
  "unde",
  "omnis",
  "iste",
  "natus",
  "error",
  "similique",
  "sunt",
  "in",
  "culpa",
  "qui",
  "officia",
  "deserunt",
  "mollitia",
  "animi",
  "id",
  "est",
  "laborum",
  "et",
  "dolorum",
  "fuga",
  "et",
  "harum",
  "quidem",
  "rerum",
  "facilis",
  "est",
  "et",
  "expedita",
  "distinctio",
  "nam",
  "libero",
  "tempore",
  "cum",
  "soluta",
  "nobis",
  "est",
  "eligendi",
  "optio",
  "cumque",
  "nihil",
  "impedit",
  "quo",
  "porro",
  "quisquam",
  "est",
  "qui",
  "minus",
  "id",
  "quod",
  "maxime",
  "placeat",
  "facere",
  "possimus",
  "omnis",
  "voluptas",
  "assumenda",
  "est",
  "omnis",
  "dolor",
  "repellendus",
  "temporibus",
  "autem",
  "quibusdam",
  "et",
  "aut",
  "consequatur",
  "vel",
  "illum",
  "qui",
  "dolorem",
  "eum",
  "fugiat",
  "quo",
  "voluptas",
  "nulla",
  "pariatur",
  "at",
  "vero",
  "eos",
  "et",
  "accusamus",
  "officiis",
  "debitis",
  "aut",
  "rerum",
  "necessitatibus",
  "saepe",
  "eveniet",
  "ut",
  "et",
  "voluptates",
  "repudiandae",
  "sint",
  "et",
  "molestiae",
  "non",
  "recusandae",
  "itaque",
  "earum",
  "rerum",
  "hic",
  "tenetur",
  "a",
  "sapiente",
  "delectus",
  "ut",
  "aut",
  "reiciendis",
  "voluptatibus",
  "maiores",
  "doloribus",
  "asperiores",
  "repellat"
];

},{}],345:[function(require,module,exports){
module["exports"] = [
  "Abigail",
  "Ada",
  "Adalberta",
  "Adla",
  "Adelaida",
  "Adina",
  "Adolfa",
  "Adolfna",
  "Adriana",
  "Adrina",
  "Adriena",
  "Afra",
  "Agta",
  "Aglaja",
  "Aida",
  "Alana",
  "Albena",
  "Alberta",
  "Albertina",
  "Albertna",
  "Albna",
  "Alena",
  "Aleka",
  "Alexandra",
  "Alfrda",
  "Alice",
  "Alida",
  "Alina",
  "Alma",
  "Aloisie",
  "Alojzije",
  "Albta",
  "Amlie",
  "Amanda",
  "Amta",
  "Amlie",
  "Anabela",
  "Anastzie",
  "Anatzie",
  "Anatolie",
  "Anatlie",
  "Andla",
  "Andlna",
  "Andrea",
  "Aneta",
  "Aneka",
  "Angela",
  "Angelika",
  "Anita",
  "Anna",
  "Anselma",
  "Antonie",
  "Apolena",
  "Arabela",
  "Aranka",
  "Areta",
  "Ariadna",
  "Ariana",
  "Ariela",
  "Arleta",
  "Armida",
  "Arna",
  "Arnolda",
  "Arnotka",
  "Astrid",
  "Astrida",
  "Atanzie",
  "Augusta",
  "Augustina",
  "Augustna",
  "Aura",
  "Aurlie",
  "Aurora",
  "Babeta",
  "Barbara",
  "Barbora",
  "Beta",
  "Beatrice",
  "Bedika",
  "Bela",
  "Bla",
  "Belinda",
  "Benedikta",
  "Berenika",
  "Berit",
  "Bernarda",
  "Berta",
  "Bertolda",
  "Bianka",
  "Bibiana",
  "Birgit",
  "Birgita",
  "Blahomila",
  "Blahomra",
  "Blahoslava",
  "Blanka",
  "Blaena",
  "Bohdana",
  "Bohumila",
  "Bohumra",
  "Bohuna",
  "Bohuslava",
  "Bohue",
  "Bojana",
  "Bojislava",
  "Boleslava",
  "Borislava",
  "Boislava",
  "Boena",
  "Boetcha",
  "Boidara",
  "Branimra",
  "Branislava",
  "Bratislava",
  "Brenda",
  "Brigita",
  "Brita",
  "Bronislava",
  "Bruna",
  "Brunhilda",
  "Betislava",
  "Cecilie",
  "Ceclie",
  "Celestina",
  "Celestna",
  "Celie",
  "Celina",
  "Ctibora",
  "Ctirada",
  "Ctislava",
  "Cyntie",
  "Cyrila",
  "eka",
  "estmra",
  "istoslava",
  "Dagmar",
  "Dagmara",
  "Dalibora",
  "Dalida",
  "Dalie",
  "Dalila",
  "Dalimila",
  "Dalimra",
  "Damaris",
  "Damiana",
  "Damina",
  "Dana",
  "Danica",
  "Daniela",
  "Danue",
  "Danuta",
  "Daria",
  "Darie",
  "Darina",
  "Darja",
  "Davida",
  "Debora",
  "Delie",
  "Denisa",
  "Diana",
  "Dina",
  "Dita",
  "Divika",
  "Dobrava",
  "Dobromila",
  "Dobromra",
  "Dobroslava",
  "Dominika",
  "Donalda",
  "Donta",
  "Dora",
  "Doris",
  "Dorota",
  "Doubrava",
  "Doubravka",
  "Drahomila",
  "Drahomra",
  "Drahoslava",
  "Drahotna",
  "Drahue",
  "Dulcinea",
  "Duana",
  "Edita",
  "Eduarda",
  "Edvarda",
  "Egona",
  "Ela",
  "Elektra",
  "Elena",
  "Eleonora",
  "Elfrda",
  "Elika",
  "Elsa",
  "Elvra",
  "Elza",
  "Ema",
  "Emanuela",
  "Emilie",
  "Emlie",
  "Erika",
  "Erna",
  "Ervna",
  "Estela",
  "Ester",
  "Estera",
  "Etela",
  "Eufrozina",
  "Eufrozna",
  "Eugenie",
  "Eullie",
  "Eunika",
  "Eusebie",
  "Eva",
  "Evelina",
  "Evelna",
  "Evenie",
  "Fabina",
  "Fabie",
  "Fatima",
  "Faustina",
  "Faustna",
  "Fba",
  "Fedora",
  "Felicie",
  "Felcie",
  "Felicita",
  "Ferdinanda",
  "Fidelie",
  "Filipa",
  "Filomna",
  "Flavie",
  "Flora",
  "Flra",
  "Florentina",
  "Florentna",
  "Frantika",
  "Frda",
  "Gabriela",
  "Gaja",
  "Gajana",
  "Galina",
  "Garika",
  "Gema",
  "Geralda",
  "Geraldina",
  "Gerarda",
  "Gerardina",
  "Gerda",
  "Gerharda",
  "Gertruda",
  "Gilberta",
  "Gina",
  "Gisela",
  "Gita",
  "Gizela",
  "Glorie",
  "Gordana",
  "Gracina",
  "Gracie",
  "Grcie",
  "Graina",
  "Grta",
  "Griselda",
  "Grizelda",
  "Gudrun",
  "Gustava",
  "Gvendolina",
  "Gvendolna",
  "Halina",
  "Hana",
  "Hta",
  "Havla",
  "Heda",
  "Hedvika",
  "Heidrun",
  "Helena",
  "Helga",
  "Herberta",
  "Hermna",
  "Herta",
  "Hilda",
  "Hortensie",
  "Hortenzie",
  "Horymra",
  "Hostimila",
  "Hostimra",
  "Hostislava",
  "Hvzdoslava",
  "Hyacinta",
  "Chranislava",
  "Iboja",
  "Ida",
  "Igncie",
  "Ignta",
  "Ildika",
  "Iljana",
  "Ilona",
  "Ilsa",
  "Ilza",
  "Ines",
  "Inesa",
  "Inz",
  "Ingeborg",
  "Ingeborga",
  "Ingrid",
  "Ingrida",
  "Inka",
  "Irena",
  "Iris",
  "Irma",
  "Isabela",
  "Isidora",
  "Isolda",
  "Iva",
  "Ivana",
  "Iveta",
  "Ivona",
  "Izabela",
  "Izidora",
  "Izolda",
  "Jadrana",
  "Jadranka",
  "Jakuba",
  "Jakubka",
  "Jana",
  "Jarmila",
  "Jarolma",
  "Jaromra",
  "Jaroslava",
  "Jasmna",
  "Jasna",
  "Jasnna",
  "Jelena",
  "Jenovfa",
  "Jesika",
  "Jindra",
  "Jindika",
  "Jiina",
  "Jitka",
  "Johana",
  "Jolana",
  "Jolanta",
  "Jordana",
  "Jorga",
  "Josefa",
  "Josefna",
  "Jovana",
  "Jozefa",
  "Jozefna",
  "Judita",
  "Juliana",
  "Julina",
  "Julie",
  "Justina",
  "Justna",
  "Juta",
  "Kamila",
  "Karin",
  "Karina",
  "Karla",
  "Karmela",
  "Karmen",
  "Karolina",
  "Karolna",
  "Kateina",
  "Katrin",
  "Katrina",
  "Kazi",
  "Kazimra",
  "Kira",
  "Klra",
  "Klaudie",
  "Klementina",
  "Klementna",
  "Kleopatra",
  "Klotylda",
  "Koleta",
  "Kolombna",
  "Kolumbna",
  "Konstance",
  "Konstancie",
  "Konsuela",
  "Konzuela",
  "Kora",
  "Kordula",
  "Korina",
  "Kornlie",
  "Krasava",
  "Krasomila",
  "Kristina",
  "Kristna",
  "Kunhuta",
  "Kvta",
  "Kvtoslava",
  "Kvtue",
  "Lada",
  "Ladislava",
  "Larisa",
  "Laura",
  "Laurencie",
  "Lea",
  "Lda",
  "Leila",
  "Lejla",
  "Lena",
  "Lenka",
  "Leokdie",
  "Leona",
  "Leonora",
  "Leontina",
  "Leontna",
  "Leopolda",
  "Leopoldina",
  "Leopoldna",
  "Leticie",
  "Lia",
  "Liana",
  "Libna",
  "Libora",
  "Liboslava",
  "Libue",
  "Lidmila",
  "Liliana",
  "Lina",
  "Linda",
  "Livie",
  "Ljuba",
  "Lola",
  "Loreta",
  "Lorna",
  "Lota",
  "Lubomra",
  "Luboslava",
  "Lucina",
  "Lucie",
  "Ludie",
  "Luka",
  "Ludmila",
  "Ludomra",
  "Ludoslava",
  "Ludvika",
  "Ludvka",
  "Luisa",
  "Lujza",
  "Lukrcie",
  "Lumra",
  "Lydie",
  "Ldie",
  "Mabel",
  "Mabela",
  "Magda",
  "Magdalena",
  "Magdalna",
  "Mahulena",
  "Maja",
  "Mja",
  "Malvna",
  "Manon",
  "Manona",
  "Manuela",
  "Marcela",
  "Marcelna",
  "Margit",
  "Margita",
  "Mariana",
  "Marie",
  "Marieta",
  "Marika",
  "Marilyn",
  "Marina",
  "Mariola",
  "Marion",
  "Marisa",
  "Marita",
  "Markta",
  "Marlena",
  "Marta",
  "Martina",
  "Matylda",
  "Maud",
  "Maxima",
  "Meislava",
  "Medea",
  "Mdea",
  "Melnie",
  "Melinda",
  "Melisa",
  "Melita",
  "Mercedes",
  "Michaela",
  "Michala",
  "Milada",
  "Milana",
  "Milena",
  "Miloslava",
  "Milred",
  "Milue",
  "Mna",
  "Mira",
  "Mirabela",
  "Miranda",
  "Mirela",
  "Miriam",
  "Mirjam",
  "Mirka",
  "Miromila",
  "Miroslava",
  "Mnislava",
  "Mona",
  "Monika",
  "Muriel",
  "Muriela",
  "Myrna",
  "Naa",
  "Nadda",
  "Naneta",
  "Narcisa",
  "Natalie",
  "Natlie",
  "Nataa",
  "Neda",
  "Nela",
  "Nevena",
  "Nika",
  "Nik",
  "Nikodma",
  "Nikol",
  "Nikola",
  "Nila",
  "Nina",
  "Noema",
  "Noemi",
  "Nona",
  "Nora",
  "Norberta",
  "Norma",
  "Odeta",
  "Oflie",
  "Oktavie",
  "Oktvie",
  "Oldika",
  "Olga",
  "Oliva",
  "Olivie",
  "Olympie",
  "Ondejka",
  "Otakara",
  "Otilie",
  "Otlie",
  "Oxana",
  "Palmira",
  "Pamela",
  "Paskala",
  "Patricie",
  "Pavla",
  "Pavlna",
  "Pelagie",
  "Penelopa",
  "Perla",
  "Persida",
  "Perzida",
  "Petra",
  "Petrana",
  "Petronela",
  "Petronila",
  "Petrue",
  "Petula",
  "Pilar",
  "Polyxena",
  "Pravdomila",
  "Pravomila",
  "Pravoslav",
  "Pravoslava",
  "Priscila",
  "Priska",
  "Prokopa",
  "Pibyslava",
  "Radana",
  "Radimra",
  "Radislava",
  "Radka",
  "Radmila",
  "Radomila",
  "Radomra",
  "Radoslava",
  "Radovana",
  "Radslava",
  "Rafaela",
  "Rchel",
  "Raisa",
  "Rajsa",
  "Ramona",
  "Rastislava",
  "Rebeka",
  "Regina",
  "Regna",
  "Renata",
  "Renta",
  "Ren",
  "Ria",
  "Riana",
  "Richarda",
  "Rina",
  "Rita",
  "Roberta",
  "Robina",
  "Romana",
  "Rosa",
  "Rosalinda",
  "Rosamunda",
  "Rosana",
  "Rostislava",
  "Rovena",
  "Roxana",
  "Rza",
  "Rozlie",
  "Rozalinda",
  "Rozamunda",
  "Rozana",
  "Rozina",
  "Rozita",
  "Rozvita",
  "Rudolfa",
  "Rudolfina",
  "Rudolfna",
  "Rut",
  "Rt",
  "Rena",
  "ehoka",
  "Sabina",
  "Sabrina",
  "Salomea",
  "Salomena",
  "Samuela",
  "Sandra",
  "Sra",
  "Saskia",
  "Saskie",
  "Saxona",
  "Selena",
  "Selma",
  "Senta",
  "Serafna",
  "Serena",
  "Scholastika",
  "Sibyla",
  "Sidonie",
  "Silvna",
  "Silvie",
  "Simeona",
  "Simona",
  "Skarlet",
  "Skarleta",
  "Slavna",
  "Slvka",
  "Slavomila",
  "Slavomra",
  "Sobslava",
  "Sofie",
  "Sofronie",
  "Solveig",
  "Solveiga",
  "Soa",
  "Sotira",
  "Stanislava",
  "Stza",
  "Stela",
  "Svatava",
  "Svatoslava",
  "Svtla",
  "Svtlana",
  "Svtlue",
  "Sylva",
  "Sylvie",
  "Sylvie",
  "rka",
  "arlota",
  "imona",
  "tpna",
  "tpnka",
  "Tamara",
  "Ta",
  "Tana",
  "Tea",
  "Tekla",
  "Teodora",
  "Teodozie",
  "Teofila",
  "Tereza",
  "Terezie",
  "Thea",
  "Theodora",
  "Theodosie",
  "Theofila",
  "Tomka",
  "Toska",
  "Ulrika",
  "Una",
  "Urula",
  "Vclava",
  "Valburga",
  "Valdemara",
  "Valentina",
  "Valentna",
  "Valerie",
  "Valrie",
  "Vanda",
  "Vanesa",
  "Vduna",
  "Veleslava",
  "Velislava",
  "Vnceslava",
  "Vendelna",
  "Vendula",
  "Vendulka",
  "Vnka",
  "Venue",
  "Vra",
  "Verona",
  "Veronika",
  "Vroslava",
  "Vslava",
  "Vesna",
  "Viktorie",
  "Vilma",
  "Vilemna",
  "Vilma",
  "Vincencie",
  "Viola",
  "Violeta",
  "Virginie",
  "Virgnie",
  "Vta",
  "Vtzslava",
  "Viviana",
  "Vladana",
  "Vladna",
  "Vladimra",
  "Vladislava",
  "Vlasta",
  "Vlastimila",
  "Vlastimra",
  "Vlastislava",
  "Vojmra",
  "Vojslava",
  "Vojtka",
  "Vorila",
  "Vratislava",
  "Xaverie",
  "Xenie",
  "Zaida",
  "Zaira",
  "Zbyhnva",
  "Zbyka",
  "Zbyslava",
  "Zbyka",
  "Zdena",
  "Zdenka",
  "Zdeka",
  "Zdeslava",
  "Zdislava",
  "Zenobie",
  "Zina",
  "Zinaida",
  "Zita",
  "Zlata",
  "Zlatomra",
  "Zlatue",
  "Zoe",
  "Zoja",
  "Zora",
  "Zoroslava",
  "Zuzana",
  "Zvonimra",
  "akelina",
  "akelna",
  "aneta",
  "dana",
  "elimra",
  "elislava",
  "elmra",
  "itomra",
  "itoslava",
  "iva",
  "ivana",
  "ofie",
];

},{}],346:[function(require,module,exports){
module["exports"] = [
  "Adamov",
  "Adamcov",
  "Admkov",
  "Albrechtov",
  "Ambroov",
  "Andlov",
  "Andrleov",
  "Antoov",
  "Bajrov",
  "Balov",
  "Balcarov",
  "Balogov",
  "Balounov",
  "Barkov",
  "Baranov",
  "Bareov",
  "Brtov",
  "Bartkov",
  "Bartoov",
  "Bartoov",
  "Bartokov",
  "Bartnkov",
  "Batov",
  "Baurov",
  "Bayrov",
  "Baantov",
  "Bekov",
  "Bevov",
  "Bednov",
  "Bednakov",
  "Blohlvkov",
  "Bendov",
  "Beneov",
  "Beranov",
  "Bernkov",
  "Bergrov",
  "Berkov",
  "Berkyov",
  "Bernardov",
  "Bezdkov",
  "Blkov",
  "Blov",
  "Bnov",
  "Bittnrov",
  "Blahov",
  "Blhov",
  "Blakov",
  "Blechov",
  "Bobkov",
  "Bokov",
  "Bohov",
  "Bohkov",
  "Bhmov",
  "Borovikov",
  "Boukov",
  "Boudov",
  "Boukov",
  "Brabcov",
  "Brabencov",
  "Bradov",
  "Bradov",
  "Braunov",
  "Brzdov",
  "Brzdilov",
  "Brejchov",
  "Bezinov",
  "Bzov",
  "Broov",
  "Brokov",
  "Brychtov",
  "Bubenkov",
  "Bukov",
  "Buchtov",
  "Burdov",
  "Bureov",
  "Burianov",
  "Burinkov",
  "Byrtusov",
  "adov",
  "Cahov",
  "pov",
  "apkov",
  "echov",
  "ejkov",
  "ermkov",
  "ernkov",
  "ernochov",
  "ernohorskov",
  "ernov",
  "ervekov",
  "ervenkov",
  "ervenov",
  "ervinkov",
  "Chaloupkov",
  "Chalupov",
  "Charvtov",
  "Chldkov",
  "Chlupov",
  "Chmelaov",
  "Chmelkov",
  "Chovancov",
  "Chromov",
  "Chudobov",
  "Chvtalov",
  "Chvojkov",
  "Chytilov",
  "Cibulkov",
  "ihkov",
  "Cihlov",
  "Csaov",
  "kov",
  "onkov",
  "Coufalov",
  "urdov",
  "Dankov",
  "Danilov",
  "Daniov",
  "Davidov",
  "Ddkov",
  "Demetrov",
  "Dittrichov",
  "Diviov",
  "Dlouhov",
  "Dobeov",
  "Dobiov",
  "Dobrovolnov",
  "Doekalov",
  "Dokalov",
  "Dohnalov",
  "Dokoupilov",
  "Dolekov",
  "Dolejov",
  "Dolejov",
  "Dolealov",
  "Dolelov",
  "Doskoilov",
  "Dostlov",
  "Doubkov",
  "Doubravov",
  "Douov",
  "Drbkov",
  "Drozdov",
  "Dubskov",
  "Duchoov",
  "Dudov",
  "Dudkov",
  "Dufkov",
  "Dunkov",
  "Dukov",
  "Dvokov",
  "Dvokov",
  "Dvorskov",
  "Eliov",
  "Erbnov",
  "Fabinov",
  "Fantov",
  "Farkaov",
  "Fejfarov",
  "Fenclov",
  "Ferencov",
  "Ferkoov",
  "Fialov",
  "Fiedlrov",
  "Filipov",
  "Fischrov",
  "Firov",
  "Florinov",
  "Fojtkov",
  "Foltnov",
  "Formanov",
  "Formnkov",
  "Fotov",
  "Fouskov",
  "Francov",
  "Frankov",
  "Frankov",
  "Fridrichov",
  "Frydrychov",
  "Fuchsov",
  "Fukov",
  "Fuksov",
  "Gborov",
  "Gabrilov",
  "Gajdoov",
  "Gaiov",
  "Gottwaldov",
  "Gregorov",
  "Grubrov",
  "Grundzov",
  "Grygarov",
  "Hjkov",
  "Hajnov",
  "Hlov",
  "Hamplov",
  "Hnov",
  "Hankov",
  "Hankov",
  "Hanouskov",
  "Hanusov",
  "Hanuov",
  "Hanzalov",
  "Hanzlov",
  "Hanzlkov",
  "Hartmanov",
  "Hakov",
  "Havlov",
  "Havelkov",
  "Havlkov",
  "Havlkov",
  "Havrnkov",
  "Heczkoov",
  "Hegrov",
  "Hejdov",
  "Hejdukov",
  "Hejlov",
  "Hejnov",
  "Hendrychov",
  "Hermanov",
  "Hemanov",
  "Hemnkov",
  "Hladkov",
  "Hladkov",
  "Hlavov",
  "Hlavkov",
  "Hlavatov",
  "Hlvkov",
  "Hloukov",
  "Hoffmannov",
  "Hofmanov",
  "Holanov",
  "Holasov",
  "Holcov",
  "Holekov",
  "Holkov",
  "Holoubkov",
  "Holubov",
  "Holov",
  "Homolov",
  "Homolkov",
  "Horov",
  "Horkov",
  "Horkov",
  "Hoejov",
  "Horkov",
  "Horkov",
  "Hornkov",
  "Hornkov",
  "Horskov",
  "Horvtov",
  "Horvthov",
  "Hokov",
  "Houdkov",
  "Houkov",
  "Hovorkov",
  "Hrabalov",
  "Hrabovskov",
  "Hradeckov",
  "Hradilov",
  "Hrbkov",
  "Hrbkov",
  "Hrdinov",
  "Hrdlikov",
  "Hrdov",
  "Hrnov",
  "Hrochov",
  "Hromdkov",
  "Hronov",
  "Hrubeov",
  "Hrubov",
  "Hrukov",
  "Hrzov",
  "Hubkov",
  "Hudcov",
  "Hudekov",
  "Hlkov",
  "Humlov",
  "Huskov",
  "Hukov",
  "Hblov",
  "Hynkov",
  "Jahodov",
  "Jakeov",
  "Jaklov",
  "Jakoubkov",
  "Jakubcov",
  "Jankov",
  "Jankov",
  "Janatov",
  "Janov",
  "Jankov",
  "Jandov",
  "Janekov",
  "Janekov",
  "Jankov",
  "Jankov",
  "Jankov",
  "Janotov",
  "Janoukov",
  "Janovskov",
  "Jansov",
  "Jnskov",
  "Janov",
  "Jareov",
  "Jaroov",
  "Jakov",
  "Javrkov",
  "Jechov",
  "Jedlikov",
  "Jelnov",
  "Jelnkov",
  "Jenkov",
  "Jebkov",
  "Jeov",
  "Jekov",
  "Jlkov",
  "Jindrov",
  "Jrov",
  "Jirkov",
  "Jirnkov",
  "Jirskov",
  "Jikov",
  "Jirkov",
  "Jirkov",
  "Jiroukov",
  "Jirsov",
  "Johnov",
  "Jonov",
  "Junkov",
  "Jurkov",
  "Jurekov",
  "Juicov",
  "Jukov",
  "Kabtov",
  "Karkov",
  "Kadebkov",
  "Kadlcov",
  "Kafkov",
  "Kaisrov",
  "Kalov",
  "Kalbov",
  "Kalaov",
  "Kalinov",
  "Kalivodov",
  "Kalousov",
  "Kalouskov",
  "Kamenkov",
  "Kaov",
  "Kov",
  "Kakov",
  "Kantorov",
  "Kaplanov",
  "Karasov",
  "Karskov",
  "Karbanov",
  "Karlov",
  "Karlkov",
  "Kasalov",
  "Kakov",
  "Kaparov",
  "Kaprkov",
  "Kavkov",
  "Kazdov",
  "Kindlov",
  "Klekov",
  "Kleinov",
  "Klementov",
  "Klmov",
  "Klimentov",
  "Klimeov",
  "Kloukov",
  "Kloudov",
  "Knapov",
  "Knotkov",
  "Kochov",
  "Koov",
  "Kocinov",
  "Kocmanov",
  "Kocourkov",
  "Kohoutov",
  "Kohoutkov",
  "Kolkov",
  "Kolov",
  "Kolakov",
  "Kolkov",
  "Kolmanov",
  "Komrkov",
  "Komnkov",
  "Konenov",
  "Konkov",
  "Kopalov",
  "Kopekov",
  "Kopeckov",
  "Kopenov",
  "Kopivov",
  "Korblov",
  "Konkov",
  "Kosov",
  "Koskov",
  "Kosinov",
  "Kolov",
  "Kostkov",
  "Kotasov",
  "Kotkov",
  "Kotlrov",
  "Kotrbov",
  "Koubov",
  "Koubkov",
  "Koudelov",
  "Koudelkov",
  "Koukalov",
  "Kouilov",
  "Koutnov",
  "Kovov",
  "Kovov",
  "Kovakov",
  "Kovkov",
  "Kozkov",
  "Kozlov",
  "Krajkov",
  "Krlov",
  "Krlkov",
  "Krlkov",
  "Krtkov",
  "Kratochvlov",
  "Krausov",
  "Krmov",
  "Kekov",
  "Krejov",
  "Krejkov",
  "Krejov",
  "Kenkov",
  "Kritofov",
  "Kivnkov",
  "Kov",
  "Kkov",
  "Kropkov",
  "Kroupov",
  "Krupov",
  "Krupikov",
  "Krupkov",
  "Kubov",
  "Kubnkov",
  "Kubtov",
  "Kubcov",
  "Kubelkov",
  "Kubeov",
  "Kubicov",
  "Kubkov",
  "Kubkov",
  "Kubnov",
  "Kubiov",
  "Kuov",
  "Kuerov",
  "Kuchaov",
  "Kuchtov",
  "Kudlkov",
  "Kudrnov",
  "Kuklov",
  "Kulhnkov",
  "Kulhavov",
  "Kuncov",
  "Kuneov",
  "Kupcov",
  "Kupkov",
  "Kurkov",
  "Kulov",
  "Kvapilov",
  "Kvasnikov",
  "Kynclov",
  "Kyselov",
  "Lacinov",
  "Lackoov",
  "Lakatoov",
  "Landov",
  "Langov",
  "Langrov",
  "Langrov",
  "Ltalov",
  "Lavikov",
  "Leov",
  "Lebedov",
  "Levov",
  "Lbalov",
  "Linhartov",
  "Likov",
  "Lorencov",
  "Loudov",
  "Ludvkov",
  "Lukov",
  "Lukov",
  "Lukkov",
  "Lukeov",
  "Mackov",
  "Mackov",
  "Machov",
  "Mchov",
  "Machaov",
  "Machov",
  "Machkov",
  "Machalov",
  "Machlkov",
  "Macurov",
  "Majrov",
  "Malekov",
  "Mlkov",
  "Malkov",
  "Malinov",
  "Malov",
  "Makov",
  "Marekov",
  "Markov",
  "Mareov",
  "Makov",
  "Marlkov",
  "Markov",
  "Martincov",
  "Martinkov",
  "Martnkov",
  "Makov",
  "Masopustov",
  "Matjkov",
  "Matjkov",
  "Matouov",
  "Matoukov",
  "Matulov",
  "Matukov",
  "Matyov",
  "Matysov",
  "Maxov",
  "Mayrov",
  "Maznkov",
  "Medkov",
  "Melicharov",
  "Menclov",
  "Menkov",
  "Mertov",
  "Michalov",
  "Michalcov",
  "Michlkov",
  "Michalkov",
  "Michnov",
  "Mikov",
  "Mikov",
  "Mkov",
  "Mikeov",
  "Mikoov",
  "Mikulov",
  "Mikulkov",
  "Minov",
  "Minakov",
  "Mirgov",
  "Mldkov",
  "Mlochov",
  "Mlejnkov",
  "Mojov",
  "Mokrov",
  "Molnrov",
  "Moravcov",
  "Morvkov",
  "Motlov",
  "Motykov",
  "Moukov",
  "Moudrov",
  "Mrkov",
  "Mrzov",
  "Mrzkov",
  "Mrkvikov",
  "Muchov",
  "Mllrov",
  "Mllrov",
  "Musilov",
  "Mukov",
  "Mykov",
  "Nagyov",
  "Najmanov",
  "Navrtilov",
  "Neasov",
  "Nedbalov",
  "Nedomov",
  "Nedvdov",
  "Nejedlov",
  "Nmcov",
  "Nmekov",
  "Neporov",
  "Nesvadbov",
  "Neubaurov",
  "Neumanov",
  "Neumannov",
  "Nguynov",
  "Nguyen vanov",
  "Noskov",
  "Novkov",
  "Novkov",
  "Novosadov",
  "Novotnov",
  "Novov",
  "Odehnalov",
  "Olhov",
  "Olivov",
  "Ondrov",
  "Ondrkov",
  "Orsgov",
  "Othalov",
  "Palekov",
  "Pnkov",
  "Papeov",
  "Pazkov",
  "Pakov",
  "Ptkov",
  "Patokov",
  "Paulov",
  "Pavlov",
  "Pavelkov",
  "Pavelkov",
  "Pavlasov",
  "Pavlicov",
  "Pavlkov",
  "Pavlkov",
  "Pavlov",
  "Pazderov",
  "Pechov",
  "Pechov",
  "Pechkov",
  "Peckov",
  "Pekaov",
  "Pekrkov",
  "Pelcov",
  "Peliknov",
  "Peinov",
  "Pernicov",
  "Peroutkov",
  "Pekov",
  "Pekov",
  "Petov",
  "Peterkov",
  "Petrov",
  "Petrkov",
  "Petrov",
  "Petkov",
  "Petkov",
  "Petrov",
  "Phamov",
  "Pchov",
  "Pilaov",
  "Piltov",
  "Pov",
  "Pivokov",
  "Plakov",
  "Plachov",
  "Plkov",
  "Pluhaov",
  "Podzimkov",
  "Pohlov",
  "Pokornov",
  "Polkov",
  "Polchov",
  "Polkov",
  "Polanskov",
  "Polkov",
  "Polvkov",
  "Popelkov",
  "Pospchalov",
  "Pospilov",
  "Potkov",
  "Pourov",
  "Prachaov",
  "Prkov",
  "Prakov",
  "Prchalov",
  "Pibylov",
  "Phodov",
  "Pikrylov",
  "Prochzkov",
  "Prokeov",
  "Prokopov",
  "Prokov",
  "Provaznkov",
  "Prchov",
  "Prov",
  "Penikov",
  "Ptkov",
  "Rcov",
  "Radov",
  "Rakov",
  "Rambouskov",
  "Rakov",
  "Ratajov",
  "ehkov",
  "ehkov",
  "ehoov",
  "Remeov",
  "ezov",
  "Rezkov",
  "eznkov",
  "Richtrov",
  "Richtrov",
  "hov",
  "Roubalov",
  "Rousov",
  "Rozsypalov",
  "Rudolfov",
  "Rkov",
  "Rikov",
  "Rybov",
  "Rybov",
  "Rdlov",
  "Ryavov",
  "Sadlkov",
  "afov",
  "afakov",
  "afrnkov",
  "lkov",
  "Samkov",
  "andov",
  "akov",
  "Schejbalov",
  "Schmidtov",
  "Schneidrov",
  "Schwarzov",
  "ebkov",
  "ebelov",
  "ebestov",
  "edov",
  "edivov",
  "Sedlkov",
  "Sedlkov",
  "Sedlov",
  "Sehnalov",
  "Seidlov",
  "Seifertov",
  "Sekaninov",
  "Semerdov",
  "enkov",
  "estkov",
  "evkov",
  "Severov",
  "Sikorov",
  "ilhavov",
  "mov",
  "imkov",
  "imkov",
  "imnkov",
  "imkov",
  "imekov",
  "imkov",
  "imonov",
  "imnkov",
  "indelov",
  "indlrov",
  "pov",
  "pkov",
  "rov",
  "irokov",
  "ikov",
  "Sivkov",
  "Skclov",
  "Skalov",
  "Sklov",
  "Skalickov",
  "Sklenov",
  "kodov",
  "Skopalov",
  "Skoepov",
  "krabalov",
  "Skivnkov",
  "Slabov",
  "Sldkov",
  "Sladkov",
  "Slmov",
  "Slaninov",
  "Slavkov",
  "Slavkov",
  "lechtov",
  "Slezkov",
  "Slovkov",
  "Slovkov",
  "Slukov",
  "Smejkalov",
  "mejkalov",
  "Smkalov",
  "merdov",
  "Smetanov",
  "mdov",
  "Smolov",
  "Smolkov",
  "Smolkov",
  "Smrkov",
  "Smrov",
  "Smutnov",
  "najdrov",
  "Sobkov",
  "Sobotkov",
  "Sochorov",
  "Sojkov",
  "Sokolov",
  "olcov",
  "Sommrov",
  "Soukov",
  "Soukupov",
  "Sovov",
  "pakov",
  "Spilov",
  "pikov",
  "plchalov",
  "Spurnov",
  "rmkov",
  "Srbov",
  "Stankov",
  "Strkov",
  "Starov",
  "astnov",
  "tefanov",
  "tefkov",
  "teflov",
  "Stehlkov",
  "Steinrov",
  "Stejskalov",
  "tpnov",
  "tpnkov",
  "trbov",
  "Stiborov",
  "Stoklasov",
  "Strakov",
  "Strnskov",
  "Strejkov",
  "Strnadov",
  "Strouhalov",
  "Stuchlkov",
  "Studenov",
  "Studnikov",
  "Stupkov",
  "ubrtov",
  "Suchnkov",
  "Suchomlov",
  "Suchov",
  "Sukov",
  "ulcov",
  "ustrov",
  "vbov",
  "Svainov",
  "vandov",
  "varcov",
  "Svatoov",
  "Svatoov",
  "vcov",
  "vehlov",
  "vejdov",
  "vestkov",
  "Svtlkov",
  "Svitkov",
  "Svobodov",
  "Svozilov",
  "Skorov",
  "Synkov",
  "Syrovov",
  "Tborskov",
  "Tancoov",
  "Teplov",
  "Tesaov",
  "Tichov",
  "Tomanov",
  "Tomnkov",
  "Tomov",
  "Tomkov",
  "Tomekov",
  "Tomkov",
  "Tomeov",
  "Tthov",
  "Tranov",
  "Trvnkov",
  "Trkov",
  "Tskov",
  "Trnkov",
  "Trojanov",
  "Truhlov",
  "Tukov",
  "Tmov",
  "Turekov",
  "Turkov",
  "Tvrdkov",
  "Tvrdov",
  "Uhrov",
  "Uhlov",
  "Ulrichov",
  "Urbanov",
  "Urbancov",
  "Urbnkov",
  "Vackov",
  "Vchov",
  "Vclavkov",
  "Vclavkov",
  "Vaculkov",
  "Vgnrov",
  "Valov",
  "Valkov",
  "Vlkov",
  "Valentov",
  "Valeov",
  "Vov",
  "Vanurov",
  "Vankov",
  "Vankov",
  "Vankov",
  "Vargov",
  "Vakov",
  "Vakov",
  "Vakov",
  "Vvrov",
  "Vavkov",
  "Veeov",
  "Vejvodov",
  "Vernrov",
  "Veselov",
  "Veverkov",
  "Vchov",
  "Vilmkov",
  "Vinov",
  "Vkov",
  "Vtov",
  "Vitskov",
  "Vtkov",
  "Vlachov",
  "Vlaskov",
  "Vlkov",
  "Vlkov",
  "Voboilov",
  "Vodkov",
  "Vodikov",
  "Vodrkov",
  "Vojkov",
  "Vojtov",
  "Vojtchov",
  "Vojtkov",
  "Vojtkov",
  "Vokounov",
  "Volkov",
  "Volfov",
  "Volnov",
  "Vondrov",
  "Vondrkov",
  "Vondrkov",
  "Vorkov",
  "Vorlov",
  "Vokov",
  "Vorlkov",
  "Votavov",
  "Votrubov",
  "Vrabcov",
  "Vrnov",
  "Vrbov",
  "Vrzalov",
  "Vybralov",
  "Vydrov",
  "Vymazalov",
  "Vyskoilov",
  "Vyslouilov",
  "Wagnrov",
  "Waltrov",
  "Webrov",
  "Weissov",
  "Winklrov",
  "Wolfov",
  "Zbranskov",
  "kov",
  "Zachov",
  "Zahrdkov",
  "Zahradnkov",
  "Zajcov",
  "Zajkov",
  "kov",
  "Zlekov",
  "Zmenkov",
  "Zapletalov",
  "Zrubov",
  "Zatloukalov",
  "Zavadilov",
  "Zavlov",
  "Zboilov",
  "rskov",
  "Zdrailov",
  "Zednkov",
  "Zelenkov",
  "Zelenov",
  "Zelinkov",
  "Zemanov",
  "Zemnkov",
  "emlikov",
  "Zezulov",
  "dkov",
  "igov",
  "Zkov",
  "Zikmundov",
  "Zimov",
  "ikov",
  "Zlmalov",
  "Zoubkov",
  "Zouharov",
  "rkov",
  "Zvinov",
];

},{}],347:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.male_first_name = require("./male_first_name");
name.female_first_name = require("./female_first_name");
name.male_last_name = require("./male_last_name");
name.female_last_name = require("./female_last_name");
name.prefix = require("./prefix");
name.suffix = require("./suffix");
name.title = require("./title");
name.name = require("./name");

},{"./female_first_name":345,"./female_last_name":346,"./male_first_name":348,"./male_last_name":349,"./name":350,"./prefix":351,"./suffix":352,"./title":353}],348:[function(require,module,exports){
module["exports"] = [
  "Abadon",
  "Abdon",
  "bel",
  "Abelard",
  "Abraham",
  "Abrahm",
  "Absolon",
  "Absoln",
  "Adalbert",
  "Adam",
  "Adin",
  "Adolf",
  "Adrian",
  "Adrin",
  "Agaton",
  "Achil",
  "Achiles",
  "Alan",
  "Alban",
  "Albert",
  "Albn",
  "Albrecht",
  "Aldo",
  "Alen",
  "Ale",
  "Alexandr",
  "Alexej",
  "Alfons",
  "Alfrd",
  "Alois",
  "Alojz",
  "Alva",
  "Alvar",
  "Alvin",
  "Amadeus",
  "Amand",
  "Amt",
  "Ambro",
  "Amos",
  "mos",
  "Anastz",
  "Anatol",
  "Andl",
  "Andln",
  "Andrej",
  "Anselm",
  "Antal",
  "Antonn",
  "Aram",
  "Ariel",
  "Aristid",
  "Arkd",
  "Armand",
  "Armin",
  "Arne",
  "Arnold",
  "Arnot",
  "ron",
  "rn",
  "Arpd",
  "Arsen",
  "Artur",
  "Artu",
  "Arzen",
  "Atanas",
  "Atan",
  "Atila",
  "August",
  "Augustin",
  "Augustn",
  "Aurel",
  "Aurelin",
  "Axel",
  "Baltazar",
  "Barnab",
  "Bartolomj",
  "Basil",
  "Bazil",
  "Beatus",
  "Bedich",
  "Benedikt",
  "Benjamin",
  "Benjamn",
  "Bernard",
  "Bertold",
  "Bertram",
  "Bivoj",
  "Blahomil",
  "Blahomr",
  "Blahoslav",
  "Blaej",
  "Bohdan",
  "Bohuchval",
  "Bohumil",
  "Bohumr",
  "Bohun",
  "Bohuslav",
  "Bohu",
  "Bojan",
  "Bolemr",
  "Boleslav",
  "Bonifc",
  "Borek",
  "Boris",
  "Borislav",
  "Boek",
  "Boislav",
  "Boivoj",
  "Boetch",
  "Boidar",
  "Boislav",
  "Branimr",
  "Branislav",
  "Bratislav",
  "Bret",
  "Brian",
  "Brit",
  "Bronislav",
  "Bruno",
  "Betislav",
  "Budimr",
  "Budislav",
  "Budivoj",
  "Cecil",
  "Cedrik",
  "Celestin",
  "Celestn",
  "Csar",
  "Czar",
  "Ctibor",
  "Ctirad",
  "Ctislav",
  "Cyprin",
  "Cyril",
  "enk",
  "estmr",
  "istoslav",
  "Dag",
  "Dalibor",
  "Dalimil",
  "Dalimr",
  "Damin",
  "Dan",
  "Daniel",
  "Darek",
  "Darius",
  "David",
  "Denis",
  "Dpold",
  "Dtmar",
  "Dtich",
  "Dezider",
  "Dimitrij",
  "Dino",
  "Dionz",
  "Dionzos",
  "Divi",
  "Dluho",
  "Dobromil",
  "Dobromr",
  "Dobroslav",
  "Dominik",
  "Donald",
  "Dont",
  "Dorian",
  "Dorin",
  "Drahomil",
  "Drahomr",
  "Draho",
  "Drahoslav",
  "Draho",
  "Drahotn",
  "Drahutin",
  "Duan",
  "Edgar",
  "Edmond",
  "Edmund",
  "Eduard",
  "Edvard",
  "Edvin",
  "Edvn",
  "Egmont",
  "Egon",
  "Eli",
  "Elizej",
  "Elizeus",
  "Elmar",
  "Elvis",
  "Emanuel",
  "Emanuel",
  "Emerich",
  "Emil",
  "Emilin",
  "Engelbert",
  "Erazim",
  "Erazmus",
  "Erhard",
  "Erich",
  "Erik",
  "Ernest",
  "Ernst",
  "Ervn",
  "Eugen",
  "Eusebius",
  "Evald",
  "Evan",
  "Evarist",
  "Even",
  "Ezechiel",
  "Ezra",
  "Fabin",
  "Faust",
  "Faustin",
  "Faustn",
  "Fedor",
  "Felicin",
  "Felix",
  "Ferdinand",
  "Fidel",
  "Fidelius",
  "Filemon",
  "Filibert",
  "Filip",
  "Filomen",
  "Flavin",
  "Flavius",
  "Florentin",
  "Florentn",
  "Florin",
  "Fortunt",
  "Fra",
  "Franc",
  "Frantiek",
  "Fridoln",
  "Gabin",
  "Gabriel",
  "Gl",
  "Garik",
  "Gaston",
  "Gedeon",
  "Gejza",
  "Genadij",
  "Gerald",
  "Gerard",
  "Gerazim",
  "Gerhard",
  "Gza",
  "Gilbert",
  "Gleb",
  "Glen",
  "Gorazd",
  "Gordon",
  "Gothard",
  "Gracin",
  "Grant",
  "Gunter",
  "Gnter",
  "Gustav",
  "Hanu",
  "Harald",
  "Harold",
  "Hatal",
  "Havel",
  "Helmut",
  "Herbert",
  "Herman",
  "Heman",
  "Hilar",
  "Hilarius",
  "Hjalmar",
  "Homr",
  "Honor",
  "Honorius",
  "Horc",
  "Horst",
  "Horymr",
  "Hostimil",
  "Hostimr",
  "Hostislav",
  "Hostivt",
  "Hovard",
  "Hubert",
  "Hugo",
  "Hvzdoslav",
  "Hyacint",
  "Hynek",
  "Hypolit",
  "Chrabro",
  "Chraniboj",
  "Chranibor",
  "Chranislav",
  "Chrudo",
  "Chval",
  "Ignc",
  "Ignt",
  "Igor",
  "Ilja",
  "Inocenc",
  "Irenej",
  "Ireneus",
  "Irvin",
  "Isidor",
  "Ivan",
  "Ivar",
  "Ivo",
  "Ivor",
  "Izai",
  "Izk",
  "Izidor",
  "Izmael",
  "Jacek",
  "Jchym",
  "Jakub",
  "Jan",
  "Jarmil",
  "Jarolm",
  "Jaromil",
  "Jaromr",
  "Jaroslav",
  "Jason",
  "Jaso",
  "Jeremi",
  "Jeronm",
  "Jilj",
  "Jimram",
  "Jindich",
  "Ji",
  "Job",
  "Joel",
  "Jon",
  "Jonatan",
  "Jonathan",
  "Jordan",
  "Josef",
  "Jot",
  "Jozef",
  "Jozue",
  "Juda",
  "Julin",
  "Julius",
  "Justin",
  "Justn",
  "Kajetn",
  "Kamil",
  "Karel",
  "Kasin",
  "Kastor",
  "Kapar",
  "Kazimr",
  "Kilin",
  "Kim",
  "Klaudin",
  "Klaudius",
  "Klement",
  "Kliment",
  "Knut",
  "Koloman",
  "Kolombn",
  "Kolumbn",
  "Kolumbn",
  "Konrd",
  "Konstantin",
  "Konstantn",
  "Kornel",
  "Kornelius",
  "Kosma",
  "Kosmas",
  "Krasomil",
  "Krasoslav",
  "Kristin",
  "Krypn",
  "Krytof",
  "Kesomysl",
  "Kian",
  "Kurt",
  "Kvto",
  "Kvtoslav",
  "Kvto",
  "Kvido",
  "Ladislav",
  "Lambert",
  "Lars",
  "Laurenc",
  "Lazar",
  "Leander",
  "Leandr",
  "Leo",
  "Leodegar",
  "Leon",
  "Leonard",
  "Leonid",
  "Leontn",
  "Leopold",
  "Leo",
  "Leek",
  "Lev",
  "Libor",
  "Liboslav",
  "Lionel",
  "Livius",
  "Lorenc",
  "Lotar",
  "Lothar",
  "Lubomr",
  "Lubor",
  "Luboslav",
  "Lubo",
  "Lucin",
  "Lucius",
  "Ludk",
  "Ludivoj",
  "Ludomr",
  "Ludoslav",
  "Ludvk",
  "Luk",
  "Lukrecius",
  "Lumr",
  "Lutibor",
  "Lutobor",
  "Magnus",
  "Makar",
  "Manfred",
  "Manfrd",
  "Mansvet",
  "Manuel",
  "Marcel",
  "Marek",
  "Marian",
  "Marin",
  "Marin",
  "Mario",
  "Marius",
  "Martin",
  "Matj",
  "Matou",
  "Maty",
  "Max",
  "Maxim",
  "Maximilin",
  "Maxmilin",
  "Meislav",
  "Medard",
  "Melichar",
  "Merlin",
  "Mervin",
  "Metod",
  "Metodj",
  "Michael",
  "Michal",
  "Mikol",
  "Mikul",
  "Milan",
  "Mil",
  "Milk",
  "Milivoj",
  "Milo",
  "Milorad",
  "Miloslav",
  "Milo",
  "Milota",
  "Milou",
  "Milovan",
  "Milovn",
  "Milutn",
  "Mirek",
  "Mirko",
  "Miromil",
  "Miron",
  "Miroslav",
  "Mirtil",
  "Mlad",
  "Mladen",
  "Mnata",
  "Mnislav",
  "Modest",
  "Mojmr",
  "Moj",
  "Morgan",
  "Moric",
  "Moris",
  "Moic",
  "Mstislav",
  "Myron",
  "Myrtil",
  "Napoleon",
  "Narcis",
  "Natan",
  "Natanael",
  "Nathan",
  "Nathanael",
  "Nhoslav",
  "Neklan",
  "Nepomuk",
  "Nezamysl",
  "Nikita",
  "Nikodm",
  "Nikola",
  "Nikolas",
  "Norbert",
  "Norman",
  "Odolen",
  "Odon",
  "Oktavin",
  "Oktavius",
  "Olaf",
  "Olbram",
  "Oldich",
  "Oleg",
  "Oliver",
  "Omar",
  "Ondej",
  "Orest",
  "Oskar",
  "Osvald",
  "Ota",
  "Otakar",
  "Otmar",
  "Oto",
  "Otokar",
  "Otomar",
  "Ovidius",
  "Palmiro",
  "Pankrc",
  "Pantaleon",
  "Paris",
  "Parsival",
  "Paskal",
  "Patrik",
  "Pavel",
  "Pavln",
  "Pelhim",
  "Perikles",
  "Petr",
  "Petronius",
  "Pius",
  "Platon",
  "Platn",
  "Polykarp",
  "Pravdomil",
  "Pravomil",
  "Prokop",
  "Prosper",
  "Pemysl",
  "Pibyslav",
  "Radan",
  "Radegast",
  "Radek",
  "Radhost",
  "Radim",
  "Radimr",
  "Radislav",
  "Radivoj",
  "Radko",
  "Radmil",
  "Radomil",
  "Radomr",
  "Radoslav",
  "Rado",
  "Radovan",
  "Radz",
  "Radvan",
  "Rafael",
  "Raimund",
  "Rainald",
  "Rainer",
  "Rainhard",
  "Rainold",
  "Rajko",
  "Ralf",
  "Ramon",
  "Randolf",
  "Ranek",
  "Ranko",
  "Rastislav",
  "Ratibor",
  "Ratmr",
  "Redmond",
  "Reginald",
  "Remig",
  "Remus",
  "Rent",
  "Ren",
  "Richard",
  "Robert",
  "Robin",
  "Robinson",
  "Rodan",
  "Roderik",
  "Rodrigo",
  "Roger",
  "Roch",
  "Roland",
  "Rolf",
  "Roman",
  "Romeo",
  "Romuald",
  "Romul",
  "Romulus",
  "Ronald",
  "Rostislav",
  "Ruben",
  "Rudolf",
  "Rufus",
  "Rupert",
  "Ruprecht",
  "Ruslan",
  "eho",
  "Sba",
  "Smo",
  "Samson",
  "Samuel",
  "Saturnin",
  "Saul",
  "Sva",
  "Sebastian",
  "Sebastin",
  "Sebestian",
  "Sedrik",
  "Serafn",
  "Serenus",
  "Sergej",
  "Servc",
  "Severn",
  "Sidon",
  "Sigfrd",
  "Silvan",
  "Silvn",
  "Silvestr",
  "Silvius",
  "Simeon",
  "Simon",
  "Sinkler",
  "Sixt",
  "Sixtus",
  "Slvek",
  "Slaviboj",
  "Slavibor",
  "Slavoboj",
  "Slavoj",
  "Slavomil",
  "Slavomr",
  "Smil",
  "Sobslav",
  "Sokrat",
  "Soter",
  "Spytihnv",
  "Stanimr",
  "Stanislav",
  "Stojan",
  "Stojmr",
  "Svatoboj",
  "Svatobor",
  "Svatomr",
  "Svatopluk",
  "Svatoslav",
  "Sven",
  "Svetozar",
  "alamoun",
  "alomoun",
  "avel",
  "ebastin",
  "imon",
  "asta",
  "tefan",
  "tpn",
  "Tade",
  "Tankred",
  "Taras",
  "Teobald",
  "Teodor",
  "Teodorik",
  "Teodoz",
  "Teofan",
  "Teofil",
  "Terenc",
  "Terencius",
  "Theobald",
  "Theodor",
  "Theodorik",
  "Theofan",
  "Theofil",
  "Tiber",
  "Tiberius",
  "Tibor",
  "Tiburcius",
  "Tichomil",
  "Tichomr",
  "Tichon",
  "Timon",
  "Timotej",
  "Timoteus",
  "Timur",
  "Titus",
  "Tobi",
  "Tom",
  "Tomislav",
  "Tor",
  "Torkvt",
  "Torsten",
  "Tristan",
  "Udo",
  "Ulrich",
  "Upton",
  "Urban",
  "Uve",
  "Vclav",
  "Vadim",
  "Valdemar",
  "Valentin",
  "Valentn",
  "Valerin",
  "Valter",
  "Valtr",
  "Vasil",
  "Vavinec",
  "Veleslav",
  "Velimr",
  "Velislav",
  "Vnceslav",
  "Vendeln",
  "Vnek",
  "Verner",
  "Vroslav",
  "Vidor",
  "Viktor",
  "Viktorin",
  "Viktorn",
  "Vilm",
  "Vilibald",
  "Vilmar",
  "Vincenc",
  "Virgil",
  "Virgin",
  "Vt",
  "Vtzslav",
  "Vitold",
  "Vtoslav",
  "Vivian",
  "Vladan",
  "Vladimr",
  "Vladislav",
  "Vladivoj",
  "Vlastimil",
  "Vlastimr",
  "Vlastislav",
  "Vlk",
  "Vojen",
  "Vojmil",
  "Vojmr",
  "Vojslav",
  "Vojtch",
  "Vok",
  "Volfgang",
  "Vratislav",
  "Vsevolod",
  "Veboj",
  "Vebor",
  "Verad",
  "Veslav",
  "Xaver",
  "Xaverius",
  "Zboj",
  "Zachar",
  "Zachari",
  "Zvi",
  "Zbislav",
  "Zbyhnv",
  "Zbynk",
  "Zbyslav",
  "Zbyek",
  "Zdenk",
  "Zderad",
  "Zdeslav",
  "Zdk",
  "Zdirad",
  "Zdislav",
  "Zeno",
  "Zenon",
  "Zikmund",
  "Zlatan",
  "Zlatko",
  "Zlatomr",
  "Zoltn",
  "Zoran",
  "Zoroslav",
  "Zosim",
  "Zvonimr",
  "arko",
  "dan",
  "elibor",
  "elimr",
  "elislav",
  "elmr",
  "itomr",
  "itoslav",
  "ivan",
];

},{}],349:[function(require,module,exports){
module["exports"] = [
  "Adam",
  "Adamec",
  "Admek",
  "Albrecht",
  "Ambro",
  "Andl",
  "Andrle",
  "Anto",
  "Bajer",
  "Bal",
  "Balcar",
  "Balog",
  "Baloun",
  "Bark",
  "Baran",
  "Bare",
  "Brta",
  "Bartk",
  "Barto",
  "Barto",
  "Bartoek",
  "Bartnk",
  "Bata",
  "Bauer",
  "Bayer",
  "Baant",
  "Beka",
  "Bev",
  "Bedn",
  "Bednak",
  "Blohlvek",
  "Benda",
  "Bene",
  "Beran",
  "Bernek",
  "Berger",
  "Berka",
  "Berky",
  "Bernard",
  "Bezdk",
  "Blek",
  "Bl",
  "Bna",
  "Bittner",
  "Blaha",
  "Blha",
  "Blaek",
  "Blecha",
  "Bobek",
  "Boek",
  "Boh",
  "Bohek",
  "Bhm",
  "Borovika",
  "Bouek",
  "Bouda",
  "Bouka",
  "Brabec",
  "Brabenec",
  "Brada",
  "Brad",
  "Braun",
  "Brzda",
  "Brzdil",
  "Brejcha",
  "Bezina",
  "Bza",
  "Bro",
  "Broek",
  "Brychta",
  "Bubenk",
  "Buek",
  "Buchta",
  "Burda",
  "Bure",
  "Burian",
  "Burinek",
  "Byrtus",
  "ada",
  "Caha",
  "p",
  "apek",
  "ech",
  "ejka",
  "ermk",
  "ernk",
  "ernoch",
  "ernohorsk",
  "ern",
  "ervek",
  "ervenka",
  "erven",
  "ervinka",
  "Chaloupka",
  "Chalupa",
  "Charvt",
  "Chldek",
  "Chlup",
  "Chmela",
  "Chmelk",
  "Chovanec",
  "Chrom",
  "Chudoba",
  "Chvtal",
  "Chvojka",
  "Chytil",
  "Cibulka",
  "ihk",
  "Cihl",
  "Csa",
  "ek",
  "onka",
  "Coufal",
  "urda",
  "Dank",
  "Daniel",
  "Dani",
  "David",
  "Ddek",
  "Demeter",
  "Dittrich",
  "Divi",
  "Dlouh",
  "Dobe",
  "Dobi",
  "Dobrovoln",
  "Doekal",
  "Dokal",
  "Dohnal",
  "Dokoupil",
  "Doleek",
  "Dolej",
  "Dolej",
  "Doleal",
  "Doleel",
  "Doskoil",
  "Dostl",
  "Doubek",
  "Doubrava",
  "Doua",
  "Drbek",
  "Drozd",
  "Dubsk",
  "Ducho",
  "Duda",
  "Dudek",
  "Dufek",
  "Dunka",
  "Duek",
  "Dvoek",
  "Dvok",
  "Dvorsk",
  "Eli",
  "Erben",
  "Fabin",
  "Fanta",
  "Farka",
  "Fejfar",
  "Fencl",
  "Ferenc",
  "Ferko",
  "Fiala",
  "Fiedler",
  "Filip",
  "Fischer",
  "Fier",
  "Florin",
  "Fojtk",
  "Foltn",
  "Forman",
  "Formnek",
  "Fot",
  "Fousek",
  "Franc",
  "Frank",
  "Frank",
  "Fridrich",
  "Frydrych",
  "Fuchs",
  "Fuk",
  "Fuksa",
  "Gbor",
  "Gabriel",
  "Gajdo",
  "Gai",
  "Gottwald",
  "Gregor",
  "Gruber",
  "Grundza",
  "Grygar",
  "Hjek",
  "Hajn",
  "Hla",
  "Hampl",
  "Hna",
  "Hanek",
  "Hank",
  "Hanousek",
  "Hanus",
  "Hanu",
  "Hanzal",
  "Hanzl",
  "Hanzlk",
  "Hartman",
  "Haek",
  "Havel",
  "Havelka",
  "Havlek",
  "Havlk",
  "Havrnek",
  "Heczko",
  "Heger",
  "Hejda",
  "Hejduk",
  "Hejl",
  "Hejna",
  "Hendrych",
  "Herman",
  "Heman",
  "Hemnek",
  "Hladk",
  "Hladk",
  "Hlav",
  "Hlavek",
  "Hlavat",
  "Hlvka",
  "Hlouek",
  "Hoffmann",
  "Hofman",
  "Holan",
  "Holas",
  "Holec",
  "Holeek",
  "Holk",
  "Holoubek",
  "Holub",
  "Hol",
  "Homola",
  "Homolka",
  "Hora",
  "Horek",
  "Hork",
  "Hoej",
  "Hork",
  "Hork",
  "Hornek",
  "Hornk",
  "Horsk",
  "Horvt",
  "Horvth",
  "Hoek",
  "Houdek",
  "Houka",
  "Hovorka",
  "Hrabal",
  "Hrabovsk",
  "Hradeck",
  "Hradil",
  "Hrbek",
  "Hrbek",
  "Hrdina",
  "Hrdlika",
  "Hrd",
  "Hrn",
  "Hroch",
  "Hromdka",
  "Hron",
  "Hrube",
  "Hrub",
  "Hruka",
  "Hrza",
  "Hubek",
  "Hudec",
  "Hudeek",
  "Hlka",
  "Huml",
  "Husk",
  "Huek",
  "Hbl",
  "Hynek",
  "Jahoda",
  "Jake",
  "Jakl",
  "Jakoubek",
  "Jakubec",
  "Janek",
  "Jank",
  "Janata",
  "Jana",
  "Jank",
  "Janda",
  "Janeek",
  "Janeka",
  "Janek",
  "Jank",
  "Jank",
  "Janota",
  "Janouek",
  "Janovsk",
  "Jansa",
  "Jnsk",
  "Jan",
  "Jare",
  "Jaro",
  "Jaek",
  "Javrek",
  "Jech",
  "Jedlika",
  "Jelen",
  "Jelnek",
  "Jenek",
  "Jebek",
  "Je",
  "Jeek",
  "Jlek",
  "Jindra",
  "Jra",
  "Jirk",
  "Jirnek",
  "Jirsek",
  "Jik",
  "Jirka",
  "Jirk",
  "Jirouek",
  "Jirsa",
  "John",
  "Jon",
  "Junek",
  "Jurk",
  "Jureka",
  "Juica",
  "Juk",
  "Kabt",
  "Karek",
  "Kadebek",
  "Kadlec",
  "Kafka",
  "Kaiser",
  "Kala",
  "Kalb",
  "Kala",
  "Kalina",
  "Kalivoda",
  "Kalous",
  "Kalousek",
  "Kamenk",
  "Kaa",
  "Ka",
  "Kaka",
  "Kantor",
  "Kaplan",
  "Karas",
  "Karsek",
  "Karban",
  "Karel",
  "Karlk",
  "Kasal",
  "Kak",
  "Kapar",
  "Kaprek",
  "Kavka",
  "Kazda",
  "Kindl",
  "Kleka",
  "Klein",
  "Klement",
  "Klma",
  "Kliment",
  "Klime",
  "Klouek",
  "Klouda",
  "Knap",
  "Knotek",
  "Koch",
  "Ko",
  "Kocin",
  "Kocman",
  "Kocourek",
  "Kohout",
  "Kohoutek",
  "Kolek",
  "Kol",
  "Kolak",
  "Kolek",
  "Kolman",
  "Komrek",
  "Komnek",
  "Konen",
  "Konek",
  "Kopal",
  "Kopeek",
  "Kopeck",
  "Kopen",
  "Kopiva",
  "Korbel",
  "Konek",
  "Kos",
  "Kosk",
  "Kosina",
  "Kol",
  "Kostka",
  "Kotas",
  "Kotek",
  "Kotlr",
  "Kotrba",
  "Kouba",
  "Koubek",
  "Koudela",
  "Koudelka",
  "Koukal",
  "Kouil",
  "Koutn",
  "Kov",
  "Kov",
  "Kovak",
  "Kovk",
  "Kozk",
  "Kozel",
  "Krajek",
  "Krl",
  "Krlek",
  "Krlk",
  "Krtk",
  "Kratochvl",
  "Kraus",
  "Krm",
  "Keek",
  "Krej",
  "Krejk",
  "Krej",
  "Kenek",
  "Kritof",
  "Kivnek",
  "K",
  "Kek",
  "Kropek",
  "Kroupa",
  "Krupa",
  "Krupika",
  "Krupka",
  "Kuba",
  "Kubnek",
  "Kubt",
  "Kubec",
  "Kubelka",
  "Kube",
  "Kubica",
  "Kubek",
  "Kubk",
  "Kubn",
  "Kubi",
  "Kua",
  "Kuera",
  "Kucha",
  "Kuchta",
  "Kudlek",
  "Kudrna",
  "Kukla",
  "Kulhnek",
  "Kulhav",
  "Kunc",
  "Kune",
  "Kupec",
  "Kupka",
  "Kurka",
  "Kuel",
  "Kvapil",
  "Kvasnika",
  "Kyncl",
  "Kysela",
  "Lacina",
  "Lacko",
  "Lakato",
  "Landa",
  "Lang",
  "Langer",
  "Langr",
  "Ltal",
  "Lavika",
  "Le",
  "Lebeda",
  "Lev",
  "Lbal",
  "Linhart",
  "Lika",
  "Lorenc",
  "Louda",
  "Ludvk",
  "Luk",
  "Luk",
  "Lukek",
  "Luke",
  "Mack",
  "Macek",
  "Mach",
  "Mcha",
  "Macha",
  "Mach",
  "Machek",
  "Machala",
  "Machlek",
  "Macura",
  "Majer",
  "Maleek",
  "Mlek",
  "Malk",
  "Malina",
  "Mal",
  "Mak",
  "Mareek",
  "Marek",
  "Mare",
  "Mak",
  "Marlek",
  "Mark",
  "Martinec",
  "Martinek",
  "Martnek",
  "Maek",
  "Masopust",
  "Matjek",
  "Matjka",
  "Matou",
  "Matouek",
  "Matula",
  "Matuka",
  "Maty",
  "Matys",
  "Maxa",
  "Mayer",
  "Maznek",
  "Medek",
  "Melichar",
  "Mencl",
  "Menk",
  "Merta",
  "Michal",
  "Michalec",
  "Michlek",
  "Michalk",
  "Michna",
  "Mika",
  "Mika",
  "Mka",
  "Mike",
  "Miko",
  "Mikula",
  "Mikulek",
  "Min",
  "Minak",
  "Mirga",
  "Mldek",
  "Mloch",
  "Mlejnek",
  "Moj",
  "Mokr",
  "Molnr",
  "Moravec",
  "Morvek",
  "Motl",
  "Motyka",
  "Mouka",
  "Moudr",
  "Mrek",
  "Mrz",
  "Mrzek",
  "Mrkvika",
  "Mucha",
  "Mller",
  "Mller",
  "Musil",
  "Muk",
  "Myka",
  "Nagy",
  "Najman",
  "Navrtil",
  "Neas",
  "Nedbal",
  "Nedoma",
  "Nedvd",
  "Nejedl",
  "Nmec",
  "Nmeek",
  "Nepor",
  "Nesvadba",
  "Neubauer",
  "Neuman",
  "Neumann",
  "Nguyen",
  "Nguyen van",
  "Nosek",
  "Novek",
  "Novk",
  "Novosad",
  "Novotn",
  "Nov",
  "Odehnal",
  "Olh",
  "Oliva",
  "Ondra",
  "Ondrek",
  "Orsg",
  "Othal",
  "Paleek",
  "Pnek",
  "Pape",
  "Pazek",
  "Paek",
  "Ptek",
  "Patoka",
  "Paul",
  "Pavel",
  "Pavelek",
  "Pavelka",
  "Pavlas",
  "Pavlica",
  "Pavlek",
  "Pavlk",
  "Pavl",
  "Pazdera",
  "Pech",
  "Pecha",
  "Pechek",
  "Pecka",
  "Peka",
  "Pekrek",
  "Pelc",
  "Pelikn",
  "Peina",
  "Pernica",
  "Peroutka",
  "Peek",
  "Peka",
  "Peta",
  "Peterka",
  "Petr",
  "Petrk",
  "Petr",
  "Petek",
  "Petk",
  "Petr",
  "Pham",
  "Pcha",
  "Pila",
  "Pilt",
  "Pa",
  "Pivoka",
  "Plaek",
  "Plach",
  "Plek",
  "Pluha",
  "Podzimek",
  "Pohl",
  "Pokorn",
  "Polek",
  "Polch",
  "Polk",
  "Polansk",
  "Polek",
  "Polvka",
  "Popelka",
  "Pospchal",
  "Pospil",
  "Potek",
  "Pour",
  "Pracha",
  "Prek",
  "Prak",
  "Prchal",
  "Pibyl",
  "Phoda",
  "Pikryl",
  "Prochzka",
  "Proke",
  "Prokop",
  "Proek",
  "Provaznk",
  "Prcha",
  "Pra",
  "Penika",
  "Ptek",
  "Rc",
  "Rada",
  "Rak",
  "Rambousek",
  "Raka",
  "Rataj",
  "ehek",
  "ehk",
  "eho",
  "Reme",
  "ez",
  "Rezek",
  "eznek",
  "Richter",
  "Richtr",
  "ha",
  "Roubal",
  "Rous",
  "Rozsypal",
  "Rudolf",
  "Rek",
  "Rika",
  "Ryba",
  "Ryb",
  "Rdl",
  "Ryav",
  "Sadlek",
  "af",
  "afak",
  "afrnek",
  "lek",
  "Samek",
  "anda",
  "aek",
  "Schejbal",
  "Schmidt",
  "Schneider",
  "Schwarz",
  "ebek",
  "ebela",
  "ebesta",
  "eda",
  "ediv",
  "Sedlek",
  "Sedlk",
  "Sedl",
  "Sehnal",
  "Seidl",
  "Seifert",
  "Sekanina",
  "Semerd",
  "enk",
  "estk",
  "evk",
  "Severa",
  "Sikora",
  "ilhav",
  "ma",
  "imek",
  "imk",
  "imnek",
  "imk",
  "imeek",
  "imek",
  "imon",
  "imnek",
  "indel",
  "indler",
  "p",
  "pek",
  "r",
  "irok",
  "ika",
  "Sivk",
  "Skcel",
  "Skala",
  "Skla",
  "Skalick",
  "Sklen",
  "koda",
  "Skopal",
  "Skoepa",
  "krabal",
  "Skivnek",
  "Slab",
  "Sldek",
  "Sladk",
  "Slma",
  "Slanina",
  "Slavek",
  "Slavk",
  "lechta",
  "Slezk",
  "Slovek",
  "Slovk",
  "Sluka",
  "Smejkal",
  "mejkal",
  "Smkal",
  "merda",
  "Smetana",
  "md",
  "Smola",
  "Smolk",
  "Smolka",
  "Smrka",
  "Smr",
  "Smutn",
  "najdr",
  "Sobek",
  "Sobotka",
  "Sochor",
  "Sojka",
  "Sokol",
  "olc",
  "Sommer",
  "Souek",
  "Soukup",
  "Sova",
  "paek",
  "Spil",
  "pika",
  "plchal",
  "Spurn",
  "rmek",
  "Srb",
  "Stank",
  "Strek",
  "Star",
  "astn",
  "tefan",
  "tefek",
  "tefl",
  "Stehlk",
  "Steiner",
  "Stejskal",
  "tpn",
  "tpnek",
  "trba",
  "Stibor",
  "Stoklasa",
  "Straka",
  "Strnsk",
  "Strejek",
  "Strnad",
  "Strouhal",
  "Stuchlk",
  "Studen",
  "Studnika",
  "Stupka",
  "ubrt",
  "Suchnek",
  "Suchomel",
  "Such",
  "Suk",
  "ulc",
  "ustr",
  "vb",
  "Svaina",
  "vanda",
  "varc",
  "Svato",
  "Svato",
  "vec",
  "vehla",
  "vejda",
  "vestka",
  "Svtlk",
  "Svitk",
  "Svoboda",
  "Svozil",
  "Skora",
  "Synek",
  "Syrov",
  "Tborsk",
  "Tanco",
  "Tepl",
  "Tesa",
  "Tich",
  "Toman",
  "Tomnek",
  "Tom",
  "Tomek",
  "Tomeek",
  "Tomek",
  "Tome",
  "Tth",
  "Tran",
  "Trvnek",
  "Trka",
  "Tska",
  "Trnka",
  "Trojan",
  "Truhl",
  "Tuek",
  "Tma",
  "Tureek",
  "Turek",
  "Tvrdk",
  "Tvrd",
  "Uher",
  "Uhl",
  "Ulrich",
  "Urban",
  "Urbanec",
  "Urbnek",
  "Vacek",
  "Vcha",
  "Vclavek",
  "Vclavk",
  "Vaculk",
  "Vgner",
  "Vala",
  "Valek",
  "Vlek",
  "Valenta",
  "Vale",
  "Va",
  "Vanura",
  "Vanek",
  "Vank",
  "Vanek",
  "Varga",
  "Vak",
  "Vaek",
  "Vaek",
  "Vvra",
  "Vavk",
  "Veea",
  "Vejvoda",
  "Verner",
  "Vesel",
  "Veverka",
  "Vcha",
  "Vilmek",
  "Vin",
  "Vek",
  "Vt",
  "Vitsek",
  "Vtek",
  "Vlach",
  "Vlask",
  "Vlek",
  "Vlk",
  "Voboil",
  "Vodk",
  "Vodika",
  "Vodrka",
  "Vojek",
  "Vojta",
  "Vojtch",
  "Vojtek",
  "Vojtek",
  "Vokoun",
  "Volek",
  "Volf",
  "Voln",
  "Vondra",
  "Vondrek",
  "Vondrk",
  "Vorek",
  "Vorel",
  "Voek",
  "Vorlek",
  "Votava",
  "Votruba",
  "Vrabec",
  "Vrna",
  "Vrba",
  "Vrzal",
  "Vybral",
  "Vydra",
  "Vymazal",
  "Vyskoil",
  "Vyslouil",
  "Wagner",
  "Walter",
  "Weber",
  "Weiss",
  "Winkler",
  "Wolf",
  "Zbransk",
  "ek",
  "Zach",
  "Zahrdka",
  "Zahradnk",
  "Zajc",
  "Zajek",
  "k",
  "Zlek",
  "Zmenk",
  "Zapletal",
  "Zruba",
  "Zatloukal",
  "Zavadil",
  "Zavel",
  "Zboil",
  "rsk",
  "Zdrail",
  "Zednk",
  "Zelenka",
  "Zelen",
  "Zelinka",
  "Zeman",
  "Zemnek",
  "emlika",
  "Zezula",
  "dek",
  "iga",
  "Zka",
  "Zikmund",
  "Zima",
  "ika",
  "Zlmal",
  "Zoubek",
  "Zouhar",
  "rek",
  "Zvina",
];

},{}],350:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{man_first_name} #{man_last_name}",
  "#{prefix} #{woman_first_name} #{woman_last_name}",
  "#{man_first_name} #{man_last_name} #{suffix}",
  "#{woman_first_name} #{woman_last_name} #{suffix}",
  "#{man_first_name} #{man_last_name}",
  "#{man_first_name} #{man_last_name}",
  "#{man_first_name} #{man_last_name}",
  "#{woman_first_name} #{woman_last_name}",
  "#{woman_first_name} #{woman_last_name}",
  "#{woman_first_name} #{woman_last_name}"
];

},{}],351:[function(require,module,exports){
module["exports"] = [
  "Ing.",
  "Mgr.",
  "JUDr.",
  "MUDr."
];

},{}],352:[function(require,module,exports){
module["exports"] = [
  "Phd."
];

},{}],353:[function(require,module,exports){
module["exports"] = {
  "descriptor": [
    "Lead",
    "Senior",
    "Direct",
    "Corporate",
    "Dynamic",
    "Future",
    "Product",
    "National",
    "Regional",
    "District",
    "Central",
    "Global",
    "Customer",
    "Investor",
    "Dynamic",
    "International",
    "Legacy",
    "Forward",
    "Internal",
    "Human",
    "Chief",
    "Principal"
  ],
  "level": [
    "Solutions",
    "Program",
    "Brand",
    "Security",
    "Research",
    "Marketing",
    "Directives",
    "Implementation",
    "Integration",
    "Functionality",
    "Response",
    "Paradigm",
    "Tactics",
    "Identity",
    "Markets",
    "Group",
    "Division",
    "Applications",
    "Optimization",
    "Operations",
    "Infrastructure",
    "Intranet",
    "Communications",
    "Web",
    "Branding",
    "Quality",
    "Assurance",
    "Mobility",
    "Accounts",
    "Data",
    "Creative",
    "Configuration",
    "Accountability",
    "Interactions",
    "Factors",
    "Usability",
    "Metrics"
  ],
  "job": [
    "Supervisor",
    "Associate",
    "Executive",
    "Liason",
    "Officer",
    "Manager",
    "Engineer",
    "Specialist",
    "Director",
    "Coordinator",
    "Administrator",
    "Architect",
    "Analyst",
    "Designer",
    "Planner",
    "Orchestrator",
    "Technician",
    "Developer",
    "Producer",
    "Consultant",
    "Assistant",
    "Facilitator",
    "Agent",
    "Representative",
    "Strategist"
  ]
};

},{}],354:[function(require,module,exports){
module["exports"] = [
  "601 ### ###",
  "737 ### ###",
  "736 ### ###",
  "### ### ###",
  "+420 ### ### ###",
  "00420 ### ### ###"
];

},{}],355:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":354,"dup":312}],356:[function(require,module,exports){
module["exports"] = [
  "###",
  "##",
  "#",
  "##a",
  "##b",
  "##c"
];

},{}],357:[function(require,module,exports){
module["exports"] = [
  "#{city_prefix} #{Name.first_name}#{city_suffix}",
  "#{city_prefix} #{Name.first_name}",
  "#{Name.first_name}#{city_suffix}",
  "#{Name.last_name}#{city_suffix}"
];

},{}],358:[function(require,module,exports){
module["exports"] = [
  "Nord",
  "Ost",
  "West",
  "Sd",
  "Neu",
  "Alt",
  "Bad"
];

},{}],359:[function(require,module,exports){
module["exports"] = [
  "stadt",
  "dorf",
  "land",
  "scheid",
  "burg"
];

},{}],360:[function(require,module,exports){
module["exports"] = [
  "gypten",
  "quatorialguinea",
  "thiopien",
  "sterreich",
  "Afghanistan",
  "Albanien",
  "Algerien",
  "Amerikanisch-Samoa",
  "Amerikanische Jungferninseln",
  "Andorra",
  "Angola",
  "Anguilla",
  "Antarktis",
  "Antigua und Barbuda",
  "Argentinien",
  "Armenien",
  "Aruba",
  "Aserbaidschan",
  "Australien",
  "Bahamas",
  "Bahrain",
  "Bangladesch",
  "Barbados",
  "Belarus",
  "Belgien",
  "Belize",
  "Benin",
  "die Bermudas",
  "Bhutan",
  "Bolivien",
  "Bosnien und Herzegowina",
  "Botsuana",
  "Bouvetinsel",
  "Brasilien",
  "Britische Jungferninseln",
  "Britisches Territorium im Indischen Ozean",
  "Brunei Darussalam",
  "Bulgarien",
  "Burkina Faso",
  "Burundi",
  "Chile",
  "China",
  "Cookinseln",
  "Costa Rica",
  "Dnemark",
  "Demokratische Republik Kongo",
  "Demokratische Volksrepublik Korea",
  "Deutschland",
  "Dominica",
  "Dominikanische Republik",
  "Dschibuti",
  "Ecuador",
  "El Salvador",
  "Eritrea",
  "Estland",
  "Frer",
  "Falklandinseln",
  "Fidschi",
  "Finnland",
  "Frankreich",
  "Franzsisch-Guayana",
  "Franzsisch-Polynesien",
  "Franzsische Gebiete im sdlichen Indischen Ozean",
  "Gabun",
  "Gambia",
  "Georgien",
  "Ghana",
  "Gibraltar",
  "Grnland",
  "Grenada",
  "Griechenland",
  "Guadeloupe",
  "Guam",
  "Guatemala",
  "Guinea",
  "Guinea-Bissau",
  "Guyana",
  "Haiti",
  "Heard und McDonaldinseln",
  "Honduras",
  "Hongkong",
  "Indien",
  "Indonesien",
  "Irak",
  "Iran",
  "Irland",
  "Island",
  "Israel",
  "Italien",
  "Jamaika",
  "Japan",
  "Jemen",
  "Jordanien",
  "Jugoslawien",
  "Kaimaninseln",
  "Kambodscha",
  "Kamerun",
  "Kanada",
  "Kap Verde",
  "Kasachstan",
  "Katar",
  "Kenia",
  "Kirgisistan",
  "Kiribati",
  "Kleinere amerikanische berseeinseln",
  "Kokosinseln",
  "Kolumbien",
  "Komoren",
  "Kongo",
  "Kroatien",
  "Kuba",
  "Kuwait",
  "Laos",
  "Lesotho",
  "Lettland",
  "Libanon",
  "Liberia",
  "Libyen",
  "Liechtenstein",
  "Litauen",
  "Luxemburg",
  "Macau",
  "Madagaskar",
  "Malawi",
  "Malaysia",
  "Malediven",
  "Mali",
  "Malta",
  "ehemalige jugoslawische Republik Mazedonien",
  "Marokko",
  "Marshallinseln",
  "Martinique",
  "Mauretanien",
  "Mauritius",
  "Mayotte",
  "Mexiko",
  "Mikronesien",
  "Monaco",
  "Mongolei",
  "Montserrat",
  "Mosambik",
  "Myanmar",
  "Nrdliche Marianen",
  "Namibia",
  "Nauru",
  "Nepal",
  "Neukaledonien",
  "Neuseeland",
  "Nicaragua",
  "Niederlndische Antillen",
  "Niederlande",
  "Niger",
  "Nigeria",
  "Niue",
  "Norfolkinsel",
  "Norwegen",
  "Oman",
  "Osttimor",
  "Pakistan",
  "Palau",
  "Panama",
  "Papua-Neuguinea",
  "Paraguay",
  "Peru",
  "Philippinen",
  "Pitcairninseln",
  "Polen",
  "Portugal",
  "Puerto Rico",
  "Runion",
  "Republik Korea",
  "Republik Moldau",
  "Ruanda",
  "Rumnien",
  "Russische Fderation",
  "So Tom und Prncipe",
  "Sdafrika",
  "Sdgeorgien und Sdliche Sandwichinseln",
  "Salomonen",
  "Sambia",
  "Samoa",
  "San Marino",
  "Saudi-Arabien",
  "Schweden",
  "Schweiz",
  "Senegal",
  "Seychellen",
  "Sierra Leone",
  "Simbabwe",
  "Singapur",
  "Slowakei",
  "Slowenien",
  "Somalien",
  "Spanien",
  "Sri Lanka",
  "St. Helena",
  "St. Kitts und Nevis",
  "St. Lucia",
  "St. Pierre und Miquelon",
  "St. Vincent und die Grenadinen",
  "Sudan",
  "Surinam",
  "Svalbard und Jan Mayen",
  "Swasiland",
  "Syrien",
  "Trkei",
  "Tadschikistan",
  "Taiwan",
  "Tansania",
  "Thailand",
  "Togo",
  "Tokelau",
  "Tonga",
  "Trinidad und Tobago",
  "Tschad",
  "Tschechische Republik",
  "Tunesien",
  "Turkmenistan",
  "Turks- und Caicosinseln",
  "Tuvalu",
  "Uganda",
  "Ukraine",
  "Ungarn",
  "Uruguay",
  "Usbekistan",
  "Vanuatu",
  "Vatikanstadt",
  "Venezuela",
  "Vereinigte Arabische Emirate",
  "Vereinigte Staaten",
  "Vereinigtes Knigreich",
  "Vietnam",
  "Wallis und Futuna",
  "Weihnachtsinsel",
  "Westsahara",
  "Zentralafrikanische Republik",
  "Zypern"
];

},{}],361:[function(require,module,exports){
module["exports"] = [
  "Deutschland"
];

},{}],362:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.country = require("./country");
address.street_root = require("./street_root");
address.building_number = require("./building_number");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.city = require("./city");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":356,"./city":357,"./city_prefix":358,"./city_suffix":359,"./country":360,"./default_country":361,"./postcode":363,"./secondary_address":364,"./state":365,"./state_abbr":366,"./street_address":367,"./street_name":368,"./street_root":369}],363:[function(require,module,exports){
module["exports"] = [
  "#####",
  "#####"
];

},{}],364:[function(require,module,exports){
module["exports"] = [
  "Apt. ###",
  "Zimmer ###",
  "# OG"
];

},{}],365:[function(require,module,exports){
module["exports"] = [
  "Baden-Wrttemberg",
  "Bayern",
  "Berlin",
  "Brandenburg",
  "Bremen",
  "Hamburg",
  "Hessen",
  "Mecklenburg-Vorpommern",
  "Niedersachsen",
  "Nordrhein-Westfalen",
  "Rheinland-Pfalz",
  "Saarland",
  "Sachsen",
  "Sachsen-Anhalt",
  "Schleswig-Holstein",
  "Thringen"
];

},{}],366:[function(require,module,exports){
module["exports"] = [
  "BW",
  "BY",
  "BE",
  "BB",
  "HB",
  "HH",
  "HE",
  "MV",
  "NI",
  "NW",
  "RP",
  "SL",
  "SN",
  "ST",
  "SH",
  "TH"
];

},{}],367:[function(require,module,exports){
arguments[4][324][0].apply(exports,arguments)
},{"dup":324}],368:[function(require,module,exports){
module["exports"] = [
  "#{street_root}"
];

},{}],369:[function(require,module,exports){
module["exports"] = [
  "Ackerweg",
  "Adalbert-Stifter-Str.",
  "Adalbertstr.",
  "Adolf-Baeyer-Str.",
  "Adolf-Kaschny-Str.",
  "Adolf-Reichwein-Str.",
  "Adolfsstr.",
  "Ahornweg",
  "Ahrstr.",
  "Akazienweg",
  "Albert-Einstein-Str.",
  "Albert-Schweitzer-Str.",
  "Albertus-Magnus-Str.",
  "Albert-Zarthe-Weg",
  "Albin-Edelmann-Str.",
  "Albrecht-Haushofer-Str.",
  "Aldegundisstr.",
  "Alexanderstr.",
  "Alfred-Delp-Str.",
  "Alfred-Kubin-Str.",
  "Alfred-Stock-Str.",
  "Alkenrather Str.",
  "Allensteiner Str.",
  "Alsenstr.",
  "Alt Steinbcheler Weg",
  "Alte Garten",
  "Alte Heide",
  "Alte Landstr.",
  "Alte Ziegelei",
  "Altenberger Str.",
  "Altenhof",
  "Alter Grenzweg",
  "Altstadtstr.",
  "Am Alten Gaswerk",
  "Am Alten Schafstall",
  "Am Arenzberg",
  "Am Benthal",
  "Am Birkenberg",
  "Am Blauen Berg",
  "Am Borsberg",
  "Am Brungen",
  "Am Bchelter Hof",
  "Am Buttermarkt",
  "Am Ehrenfriedhof",
  "Am Eselsdamm",
  "Am Falkenberg",
  "Am Frankenberg",
  "Am Gesundheitspark",
  "Am Gierlichshof",
  "Am Graben",
  "Am Hagelkreuz",
  "Am Hang",
  "Am Heidkamp",
  "Am Hemmelrather Hof",
  "Am Hofacker",
  "Am Hohen Ufer",
  "Am Hllers Eck",
  "Am Hhnerberg",
  "Am Jgerhof",
  "Am Junkernkamp",
  "Am Kemperstiegel",
  "Am Kettnersbusch",
  "Am Kiesberg",
  "Am Klsterchen",
  "Am Knechtsgraben",
  "Am Kllerweg",
  "Am Kttersbach",
  "Am Kreispark",
  "Am Kronefeld",
  "Am Kchenhof",
  "Am Khnsbusch",
  "Am Lindenfeld",
  "Am Mrchen",
  "Am Mittelberg",
  "Am Mnchshof",
  "Am Mhlenbach",
  "Am Neuenhof",
  "Am Nonnenbruch",
  "Am Plattenbusch",
  "Am Quettinger Feld",
  "Am Rosenhgel",
  "Am Sandberg",
  "Am Scherfenbrand",
  "Am Schokker",
  "Am Silbersee",
  "Am Sonnenhang",
  "Am Sportplatz",
  "Am Stadtpark",
  "Am Steinberg",
  "Am Telegraf",
  "Am Thelenhof",
  "Am Vogelkreuz",
  "Am Vogelsang",
  "Am Vogelsfeldchen",
  "Am Wambacher Hof",
  "Am Wasserturm",
  "Am Weidenbusch",
  "Am Weiher",
  "Am Weingarten",
  "Am Werth",
  "Amselweg",
  "An den Irlen",
  "An den Rheinauen",
  "An der Bergerweide",
  "An der Dingbank",
  "An der Evangelischen Kirche",
  "An der Evgl. Kirche",
  "An der Feldgasse",
  "An der Fettehenne",
  "An der Kante",
  "An der Laach",
  "An der Lehmkuhle",
  "An der Lichtenburg",
  "An der Luisenburg",
  "An der Robertsburg",
  "An der Schmitten",
  "An der Schusterinsel",
  "An der Steinrtsch",
  "An St. Andreas",
  "An St. Remigius",
  "Andreasstr.",
  "Ankerweg",
  "Annette-Kolb-Str.",
  "Apenrader Str.",
  "Arnold-Ohletz-Str.",
  "Atzlenbacher Str.",
  "Auerweg",
  "Auestr.",
  "Auf dem Acker",
  "Auf dem Blahnenhof",
  "Auf dem Bohnbchel",
  "Auf dem Bruch",
  "Auf dem End",
  "Auf dem Forst",
  "Auf dem Herberg",
  "Auf dem Lehn",
  "Auf dem Stein",
  "Auf dem Weierberg",
  "Auf dem Weiherhahn",
  "Auf den Reien",
  "Auf der Donnen",
  "Auf der Griee",
  "Auf der Ohmer",
  "Auf der Weide",
  "Auf'm Berg",
  "Auf'm Kamp",
  "Augustastr.",
  "August-Kekul-Str.",
  "A.-W.-v.-Hofmann-Str.",
  "Bahnallee",
  "Bahnhofstr.",
  "Baltrumstr.",
  "Bamberger Str.",
  "Baumberger Str.",
  "Bebelstr.",
  "Beckers Kmpchen",
  "Beerenstr.",
  "Beethovenstr.",
  "Behringstr.",
  "Bendenweg",
  "Bensberger Str.",
  "Benzstr.",
  "Bergische Landstr.",
  "Bergstr.",
  "Berliner Platz",
  "Berliner Str.",
  "Bernhard-Letterhaus-Str.",
  "Bernhard-Lichtenberg-Str.",
  "Bernhard-Ridder-Str.",
  "Bernsteinstr.",
  "Bertha-Middelhauve-Str.",
  "Bertha-von-Suttner-Str.",
  "Bertolt-Brecht-Str.",
  "Berzeliusstr.",
  "Bielertstr.",
  "Biesenbach",
  "Billrothstr.",
  "Birkenbergstr.",
  "Birkengartenstr.",
  "Birkenweg",
  "Bismarckstr.",
  "Bitterfelder Str.",
  "Blankenburg",
  "Blaukehlchenweg",
  "Bltenstr.",
  "Boberstr.",
  "Bcklerstr.",
  "Bodelschwinghstr.",
  "Bodestr.",
  "Bogenstr.",
  "Bohnenkampsweg",
  "Bohofsweg",
  "Bonifatiusstr.",
  "Bonner Str.",
  "Borkumstr.",
  "Bornheimer Str.",
  "Borsigstr.",
  "Borussiastr.",
  "Bracknellstr.",
  "Brahmsweg",
  "Brandenburger Str.",
  "Breidenbachstr.",
  "Breslauer Str.",
  "Bruchhauser Str.",
  "Brckenstr.",
  "Brucknerstr.",
  "Brder-Bonhoeffer-Str.",
  "Buchenweg",
  "Brgerbuschweg",
  "Burgloch",
  "Burgplatz",
  "Burgstr.",
  "Burgweg",
  "Brriger Weg",
  "Burscheider Str.",
  "Buschkmpchen",
  "Butterheider Str.",
  "Carl-Duisberg-Platz",
  "Carl-Duisberg-Str.",
  "Carl-Leverkus-Str.",
  "Carl-Maria-von-Weber-Platz",
  "Carl-Maria-von-Weber-Str.",
  "Carlo-Mierendorff-Str.",
  "Carl-Rumpff-Str.",
  "Carl-von-Ossietzky-Str.",
  "Charlottenburger Str.",
  "Christian-He-Str.",
  "Claasbruch",
  "Clemens-Winkler-Str.",
  "Concordiastr.",
  "Cranachstr.",
  "Dahlemer Str.",
  "Daimlerstr.",
  "Damaschkestr.",
  "Danziger Str.",
  "Debengasse",
  "Dechant-Fein-Str.",
  "Dechant-Krey-Str.",
  "Deichtorstr.",
  "Dhnnberg",
  "Dhnnstr.",
  "Dianastr.",
  "Diedenhofener Str.",
  "Diepental",
  "Diepenthaler Str.",
  "Dieselstr.",
  "Dillinger Str.",
  "Distelkamp",
  "Dohrgasse",
  "Domblick",
  "Dnhoffstr.",
  "Dornierstr.",
  "Drachenfelsstr.",
  "Dr.-August-Blank-Str.",
  "Dresdener Str.",
  "Driescher Hecke",
  "Drosselweg",
  "Dudweilerstr.",
  "Dnenweg",
  "Dnfelder Str.",
  "Dnnwalder Grenzweg",
  "Dppeler Str.",
  "Drerstr.",
  "Drscheider Weg",
  "Dsseldorfer Str.",
  "Edelrather Weg",
  "Edmund-Husserl-Str.",
  "Eduard-Spranger-Str.",
  "Ehrlichstr.",
  "Eichenkamp",
  "Eichenweg",
  "Eidechsenweg",
  "Eifelstr.",
  "Eifgenstr.",
  "Eintrachtstr.",
  "Elbestr.",
  "Elisabeth-Langgsser-Str.",
  "Elisabethstr.",
  "Elisabeth-von-Thadden-Str.",
  "Elisenstr.",
  "Elsa-Brndstrm-Str.",
  "Elsbachstr.",
  "Else-Lasker-Schler-Str.",
  "Elsterstr.",
  "Emil-Fischer-Str.",
  "Emil-Nolde-Str.",
  "Engelbertstr.",
  "Engstenberger Weg",
  "Entenpfuhl",
  "Erbelegasse",
  "Erftstr.",
  "Erfurter Str.",
  "Erich-Heckel-Str.",
  "Erich-Klausener-Str.",
  "Erich-Ollenhauer-Str.",
  "Erlenweg",
  "Ernst-Bloch-Str.",
  "Ernst-Ludwig-Kirchner-Str.",
  "Erzbergerstr.",
  "Eschenallee",
  "Eschenweg",
  "Esmarchstr.",
  "Espenweg",
  "Euckenstr.",
  "Eulengasse",
  "Eulenkamp",
  "Ewald-Flamme-Str.",
  "Ewald-Rll-Str.",
  "Fhrstr.",
  "Farnweg",
  "Fasanenweg",
  "Fabacher Hof",
  "Felderstr.",
  "Feldkampstr.",
  "Feldsiefer Weg",
  "Feldsiefer Wiesen",
  "Feldstr.",
  "Feldtorstr.",
  "Felix-von-Roll-Str.",
  "Ferdinand-Lassalle-Str.",
  "Fester Weg",
  "Feuerbachstr.",
  "Feuerdornweg",
  "Fichtenweg",
  "Fichtestr.",
  "Finkelsteinstr.",
  "Finkenweg",
  "Fixheider Str.",
  "Flabbenhuschen",
  "Flensburger Str.",
  "Fliederweg",
  "Florastr.",
  "Florianweg",
  "Flotowstr.",
  "Flurstr.",
  "Fhrenweg",
  "Fontanestr.",
  "Forellental",
  "Fortunastr.",
  "Franz-Esser-Str.",
  "Franz-Hitze-Str.",
  "Franz-Kail-Str.",
  "Franz-Marc-Str.",
  "Freiburger Str.",
  "Freiheitstr.",
  "Freiherr-vom-Stein-Str.",
  "Freudenthal",
  "Freudenthaler Weg",
  "Fridtjof-Nansen-Str.",
  "Friedenberger Str.",
  "Friedensstr.",
  "Friedhofstr.",
  "Friedlandstr.",
  "Friedlieb-Ferdinand-Runge-Str.",
  "Friedrich-Bayer-Str.",
  "Friedrich-Bergius-Platz",
  "Friedrich-Ebert-Platz",
  "Friedrich-Ebert-Str.",
  "Friedrich-Engels-Str.",
  "Friedrich-List-Str.",
  "Friedrich-Naumann-Str.",
  "Friedrich-Sertrner-Str.",
  "Friedrichstr.",
  "Friedrich-Weskott-Str.",
  "Friesenweg",
  "Frischenberg",
  "Fritz-Erler-Str.",
  "Fritz-Henseler-Str.",
  "Frbelstr.",
  "Frstenbergplatz",
  "Frstenbergstr.",
  "Gabriele-Mnter-Str.",
  "Gartenstr.",
  "Gebhardstr.",
  "Geibelstr.",
  "Gellertstr.",
  "Georg-von-Vollmar-Str.",
  "Gerhard-Domagk-Str.",
  "Gerhart-Hauptmann-Str.",
  "Gerichtsstr.",
  "Geschwister-Scholl-Str.",
  "Gezelinallee",
  "Gierener Weg",
  "Ginsterweg",
  "Gisbert-Cremer-Str.",
  "Glcksburger Str.",
  "Gluckstr.",
  "Gneisenaustr.",
  "Goetheplatz",
  "Goethestr.",
  "Golo-Mann-Str.",
  "Grlitzer Str.",
  "Grresstr.",
  "Graebestr.",
  "Graf-Galen-Platz",
  "Gregor-Mendel-Str.",
  "Greifswalder Str.",
  "Grillenweg",
  "Gronenborner Weg",
  "Groe Kirchstr.",
  "Grunder Wiesen",
  "Grundermhle",
  "Grundermhlenhof",
  "Grundermhlenweg",
  "Grner Weg",
  "Grunewaldstr.",
  "Grnstr.",
  "Gnther-Weisenborn-Str.",
  "Gustav-Freytag-Str.",
  "Gustav-Heinemann-Str.",
  "Gustav-Radbruch-Str.",
  "Gut Reuschenberg",
  "Gutenbergstr.",
  "Haberstr.",
  "Habichtgasse",
  "Hafenstr.",
  "Hagenauer Str.",
  "Hahnenblecher",
  "Halenseestr.",
  "Halfenleimbach",
  "Hallesche Str.",
  "Halligstr.",
  "Hamberger Str.",
  "Hammerweg",
  "Hndelstr.",
  "Hannah-Hch-Str.",
  "Hans-Arp-Str.",
  "Hans-Gerhard-Str.",
  "Hans-Sachs-Str.",
  "Hans-Schlehahn-Str.",
  "Hans-von-Dohnanyi-Str.",
  "Hardenbergstr.",
  "Haselweg",
  "Hauptstr.",
  "Haus-Vorster-Str.",
  "Hauweg",
  "Havelstr.",
  "Havensteinstr.",
  "Haydnstr.",
  "Hebbelstr.",
  "Heckenweg",
  "Heerweg",
  "Hegelstr.",
  "Heidberg",
  "Heidehhe",
  "Heidestr.",
  "Heimstttenweg",
  "Heinrich-Bll-Str.",
  "Heinrich-Brning-Str.",
  "Heinrich-Claes-Str.",
  "Heinrich-Heine-Str.",
  "Heinrich-Hrlein-Str.",
  "Heinrich-Lbke-Str.",
  "Heinrich-Ltzenkirchen-Weg",
  "Heinrichstr.",
  "Heinrich-Strerath-Str.",
  "Heinrich-von-Kleist-Str.",
  "Heinrich-von-Stephan-Str.",
  "Heisterbachstr.",
  "Helenenstr.",
  "Helmestr.",
  "Hemmelrather Weg",
  "Henry-T.-v.-Bttinger-Str.",
  "Herderstr.",
  "Heribertstr.",
  "Hermann-Ehlers-Str.",
  "Hermann-Hesse-Str.",
  "Hermann-Knig-Str.",
  "Hermann-Lns-Str.",
  "Hermann-Milde-Str.",
  "Hermann-Nrrenberg-Str.",
  "Hermann-von-Helmholtz-Str.",
  "Hermann-Waibel-Str.",
  "Herzogstr.",
  "Heymannstr.",
  "Hindenburgstr.",
  "Hirzenberg",
  "Hitdorfer Kirchweg",
  "Hitdorfer Str.",
  "Hfer Mhle",
  "Hfer Weg",
  "Hohe Str.",
  "Hhenstr.",
  "Hltgestal",
  "Holunderweg",
  "Holzer Weg",
  "Holzer Wiesen",
  "Hornpottweg",
  "Hubertusweg",
  "Hufelandstr.",
  "Hufer Weg",
  "Humboldtstr.",
  "Hummelsheim",
  "Hummelweg",
  "Humperdinckstr.",
  "Hscheider Grten",
  "Hscheider Str.",
  "Htte",
  "Ilmstr.",
  "Im Bergischen Heim",
  "Im Bruch",
  "Im Buchenhain",
  "Im Bhl",
  "Im Burgfeld",
  "Im Dorf",
  "Im Eisholz",
  "Im Friedenstal",
  "Im Frohental",
  "Im Grunde",
  "Im Hederichsfeld",
  "Im Jcherfeld",
  "Im Kalkfeld",
  "Im Kirberg",
  "Im Kirchfeld",
  "Im Kreuzbruch",
  "Im Mhlenfeld",
  "Im Nesselrader Kamp",
  "Im Oberdorf",
  "Im Oberfeld",
  "Im Rosengarten",
  "Im Rottland",
  "Im Scheffengarten",
  "Im Staderfeld",
  "Im Steinfeld",
  "Im Weidenblech",
  "Im Winkel",
  "Im Ziegelfeld",
  "Imbach",
  "Imbacher Weg",
  "Immenweg",
  "In den Blechenhfen",
  "In den Dehlen",
  "In der Birkenau",
  "In der Dasladen",
  "In der Felderhtten",
  "In der Hartmannswiese",
  "In der Hhle",
  "In der Schaafsdellen",
  "In der Wasserkuhl",
  "In der Wste",
  "In Holzhausen",
  "Insterstr.",
  "Jacob-Frhlen-Str.",
  "Jgerstr.",
  "Jahnstr.",
  "Jakob-Eulenberg-Weg",
  "Jakobistr.",
  "Jakob-Kaiser-Str.",
  "Jenaer Str.",
  "Johannes-Baptist-Str.",
  "Johannes-Dott-Str.",
  "Johannes-Popitz-Str.",
  "Johannes-Wislicenus-Str.",
  "Johannisburger Str.",
  "Johann-Janssen-Str.",
  "Johann-Wirtz-Weg",
  "Josefstr.",
  "Jch",
  "Julius-Doms-Str.",
  "Julius-Leber-Str.",
  "Kaiserplatz",
  "Kaiserstr.",
  "Kaiser-Wilhelm-Allee",
  "Kalkstr.",
  "Kmpchenstr.",
  "Kmpenwiese",
  "Kmper Weg",
  "Kamptalweg",
  "Kanalstr.",
  "Kandinskystr.",
  "Kantstr.",
  "Kapellenstr.",
  "Karl-Arnold-Str.",
  "Karl-Bosch-Str.",
  "Karl-Bckart-Str.",
  "Karl-Carstens-Ring",
  "Karl-Friedrich-Goerdeler-Str.",
  "Karl-Jaspers-Str.",
  "Karl-Knig-Str.",
  "Karl-Krekeler-Str.",
  "Karl-Marx-Str.",
  "Karlstr.",
  "Karl-Ulitzka-Str.",
  "Karl-Wichmann-Str.",
  "Karl-Wingchen-Str.",
  "Ksenbrod",
  "Kthe-Kollwitz-Str.",
  "Katzbachstr.",
  "Kerschensteinerstr.",
  "Kiefernweg",
  "Kieler Str.",
  "Kieselstr.",
  "Kiesweg",
  "Kinderhausen",
  "Kleiberweg",
  "Kleine Kirchstr.",
  "Kleingansweg",
  "Kleinheider Weg",
  "Klief",
  "Kneippstr.",
  "Knochenbergsweg",
  "Kochergarten",
  "Kocherstr.",
  "Kockelsberg",
  "Kolberger Str.",
  "Kolmarer Str.",
  "Klner Gasse",
  "Klner Str.",
  "Kolpingstr.",
  "Knigsberger Platz",
  "Konrad-Adenauer-Platz",
  "Kpenicker Str.",
  "Kopernikusstr.",
  "Krnerstr.",
  "Kschenberg",
  "Kttershof",
  "Kreuzbroicher Str.",
  "Kreuzkamp",
  "Krummer Weg",
  "Kruppstr.",
  "Kuhlmannweg",
  "Kump",
  "Kumper Weg",
  "Kunstfeldstr.",
  "Kppersteger Str.",
  "Kursiefen",
  "Kursiefer Weg",
  "Kurtekottenweg",
  "Kurt-Schumacher-Ring",
  "Kyllstr.",
  "Langenfelder Str.",
  "Lngsleimbach",
  "Lrchenweg",
  "Legienstr.",
  "Lehner Mhle",
  "Leichlinger Str.",
  "Leimbacher Hof",
  "Leinestr.",
  "Leineweberstr.",
  "Leipziger Str.",
  "Lerchengasse",
  "Lessingstr.",
  "Libellenweg",
  "Lichstr.",
  "Liebigstr.",
  "Lindenstr.",
  "Lingenfeld",
  "Linienstr.",
  "Lippe",
  "Lchergraben",
  "Lfflerstr.",
  "Loheweg",
  "Lohrbergstr.",
  "Lohrstr.",
  "Lhstr.",
  "Lortzingstr.",
  "Ltzener Str.",
  "Lwenburgstr.",
  "Lucasstr.",
  "Ludwig-Erhard-Platz",
  "Ludwig-Girtler-Str.",
  "Ludwig-Knorr-Str.",
  "Luisenstr.",
  "Lupinenweg",
  "Lurchenweg",
  "Ltzenkirchener Str.",
  "Lycker Str.",
  "Maashofstr.",
  "Manforter Str.",
  "Marc-Chagall-Str.",
  "Maria-Dresen-Str.",
  "Maria-Terwiel-Str.",
  "Marie-Curie-Str.",
  "Marienburger Str.",
  "Mariendorfer Str.",
  "Marienwerderstr.",
  "Marie-Schlei-Str.",
  "Marktplatz",
  "Markusweg",
  "Martin-Buber-Str.",
  "Martin-Heidegger-Str.",
  "Martin-Luther-Str.",
  "Masurenstr.",
  "Mathildenweg",
  "Maurinusstr.",
  "Mauspfad",
  "Max-Beckmann-Str.",
  "Max-Delbrck-Str.",
  "Max-Ernst-Str.",
  "Max-Holthausen-Platz",
  "Max-Horkheimer-Str.",
  "Max-Liebermann-Str.",
  "Max-Pechstein-Str.",
  "Max-Planck-Str.",
  "Max-Scheler-Str.",
  "Max-Schnenberg-Str.",
  "Maybachstr.",
  "Meckhofer Feld",
  "Meisenweg",
  "Memelstr.",
  "Menchendahler Str.",
  "Mendelssohnstr.",
  "Merziger Str.",
  "Mettlacher Str.",
  "Metzer Str.",
  "Michaelsweg",
  "Miselohestr.",
  "Mittelstr.",
  "Mohlenstr.",
  "Moltkestr.",
  "Monheimer Str.",
  "Montanusstr.",
  "Montessoriweg",
  "Moosweg",
  "Morsbroicher Str.",
  "Moselstr.",
  "Moskauer Str.",
  "Mozartstr.",
  "Mhlenweg",
  "Muhrgasse",
  "Muldestr.",
  "Mlhausener Str.",
  "Mlheimer Str.",
  "Mnsters Gchen",
  "Mnzstr.",
  "Mritzstr.",
  "Myliusstr.",
  "Nachtigallenweg",
  "Nauener Str.",
  "Neiestr.",
  "Nelly-Sachs-Str.",
  "Netzestr.",
  "Neuendriesch",
  "Neuenhausgasse",
  "Neuenkamp",
  "Neujudenhof",
  "Neukronenberger Str.",
  "Neustadtstr.",
  "Nicolai-Hartmann-Str.",
  "Niederblecher",
  "Niederfeldstr.",
  "Nietzschestr.",
  "Nikolaus-Gro-Str.",
  "Nobelstr.",
  "Norderneystr.",
  "Nordstr.",
  "Ober dem Hof",
  "Obere Lindenstr.",
  "Obere Str.",
  "Oberlbach",
  "Odenthaler Str.",
  "Oderstr.",
  "Okerstr.",
  "Olof-Palme-Str.",
  "Ophovener Str.",
  "Opladener Platz",
  "Opladener Str.",
  "Ortelsburger Str.",
  "Oskar-Moll-Str.",
  "Oskar-Schlemmer-Str.",
  "Oststr.",
  "Oswald-Spengler-Str.",
  "Otto-Dix-Str.",
  "Otto-Grimm-Str.",
  "Otto-Hahn-Str.",
  "Otto-Mller-Str.",
  "Otto-Stange-Str.",
  "Ottostr.",
  "Otto-Varnhagen-Str.",
  "Otto-Wels-Str.",
  "Ottweilerstr.",
  "Oulustr.",
  "Overfeldweg",
  "Pappelweg",
  "Paracelsusstr.",
  "Parkstr.",
  "Pastor-Louis-Str.",
  "Pastor-Scheibler-Str.",
  "Pastorskamp",
  "Paul-Klee-Str.",
  "Paul-Lbe-Str.",
  "Paulstr.",
  "Peenestr.",
  "Pescher Busch",
  "Peschstr.",
  "Pestalozzistr.",
  "Peter-Grie-Str.",
  "Peter-Joseph-Lenn-Str.",
  "Peter-Neuenheuser-Str.",
  "Petersbergstr.",
  "Peterstr.",
  "Pfarrer-Jekel-Str.",
  "Pfarrer-Klein-Str.",
  "Pfarrer-Rhr-Str.",
  "Pfeilshofstr.",
  "Philipp-Ott-Str.",
  "Piet-Mondrian-Str.",
  "Platanenweg",
  "Pommernstr.",
  "Porschestr.",
  "Poststr.",
  "Potsdamer Str.",
  "Pregelstr.",
  "Prienitzstr.",
  "Ptzdelle",
  "Quarzstr.",
  "Quettinger Str.",
  "Rat-Deycks-Str.",
  "Rathenaustr.",
  "Ratherkmp",
  "Ratiborer Str.",
  "Raushofstr.",
  "Regensburger Str.",
  "Reinickendorfer Str.",
  "Renkgasse",
  "Rennbaumplatz",
  "Rennbaumstr.",
  "Reuschenberger Str.",
  "Reusrather Str.",
  "Reuterstr.",
  "Rheinallee",
  "Rheindorfer Str.",
  "Rheinstr.",
  "Rhein-Wupper-Platz",
  "Richard-Wagner-Str.",
  "Rilkestr.",
  "Ringstr.",
  "Robert-Blum-Str.",
  "Robert-Koch-Str.",
  "Robert-Medenwald-Str.",
  "Rolandstr.",
  "Romberg",
  "Rntgenstr.",
  "Roonstr.",
  "Ropenstall",
  "Ropenstaller Weg",
  "Rosenthal",
  "Rostocker Str.",
  "Rotdornweg",
  "Rttgerweg",
  "Rckertstr.",
  "Rudolf-Breitscheid-Str.",
  "Rudolf-Mann-Platz",
  "Rudolf-Stracke-Str.",
  "Ruhlachplatz",
  "Ruhlachstr.",
  "Rttersweg",
  "Saalestr.",
  "Saarbrcker Str.",
  "Saarlauterner Str.",
  "Saarstr.",
  "Salamanderweg",
  "Samlandstr.",
  "Sanddornstr.",
  "Sandstr.",
  "Sauerbruchstr.",
  "Schfershtte",
  "Scharnhorststr.",
  "Scheffershof",
  "Scheidemannstr.",
  "Schellingstr.",
  "Schenkendorfstr.",
  "Schiebergstr.",
  "Schillerstr.",
  "Schlangenhecke",
  "Schlebuscher Heide",
  "Schlebuscher Str.",
  "Schlebuschrath",
  "Schlehdornstr.",
  "Schleiermacherstr.",
  "Schlostr.",
  "Schmalenbruch",
  "Schnepfenflucht",
  "Schffenweg",
  "Schllerstr.",
  "Schne Aussicht",
  "Schneberger Str.",
  "Schopenhauerstr.",
  "Schubertplatz",
  "Schubertstr.",
  "Schulberg",
  "Schulstr.",
  "Schumannstr.",
  "Schwalbenweg",
  "Schwarzastr.",
  "Sebastianusweg",
  "Semmelweisstr.",
  "Siebelplatz",
  "Siemensstr.",
  "Solinger Str.",
  "Sonderburger Str.",
  "Spandauer Str.",
  "Speestr.",
  "Sperberweg",
  "Sperlingsweg",
  "Spitzwegstr.",
  "Sporrenberger Mhle",
  "Spreestr.",
  "St. Ingberter Str.",
  "Starenweg",
  "Stauffenbergstr.",
  "Stefan-Zweig-Str.",
  "Stegerwaldstr.",
  "Steglitzer Str.",
  "Steinbcheler Feld",
  "Steinbcheler Str.",
  "Steinstr.",
  "Steinweg",
  "Stephan-Lochner-Str.",
  "Stephanusstr.",
  "Stettiner Str.",
  "Stixchesstr.",
  "Stckenstr.",
  "Stralsunder Str.",
  "Straburger Str.",
  "Stresemannplatz",
  "Strombergstr.",
  "Stromstr.",
  "Stttekofener Str.",
  "Sudestr.",
  "Srderstr.",
  "Syltstr.",
  "Talstr.",
  "Tannenbergstr.",
  "Tannenweg",
  "Taubenweg",
  "Teitscheider Weg",
  "Telegrafenstr.",
  "Teltower Str.",
  "Tempelhofer Str.",
  "Theodor-Adorno-Str.",
  "Theodor-Fliedner-Str.",
  "Theodor-Gierath-Str.",
  "Theodor-Haubach-Str.",
  "Theodor-Heuss-Ring",
  "Theodor-Storm-Str.",
  "Theodorstr.",
  "Thomas-Dehler-Str.",
  "Thomas-Morus-Str.",
  "Thomas-von-Aquin-Str.",
  "Tnges Feld",
  "Torstr.",
  "Treptower Str.",
  "Treuburger Str.",
  "Uhlandstr.",
  "Ulmenweg",
  "Ulmer Str.",
  "Ulrichstr.",
  "Ulrich-von-Hassell-Str.",
  "Umlag",
  "Unstrutstr.",
  "Unter dem Schildchen",
  "Unterlbach",
  "Unterstr.",
  "Uppersberg",
  "Van\\'t-Hoff-Str.",
  "Veit-Sto-Str.",
  "Vereinsstr.",
  "Viktor-Meyer-Str.",
  "Vincent-van-Gogh-Str.",
  "Virchowstr.",
  "Voigtslach",
  "Volhardstr.",
  "Vlklinger Str.",
  "Von-Brentano-Str.",
  "Von-Diergardt-Str.",
  "Von-Eichendorff-Str.",
  "Von-Ketteler-Str.",
  "Von-Knoeringen-Str.",
  "Von-Pettenkofer-Str.",
  "Von-Siebold-Str.",
  "Wacholderweg",
  "Waldstr.",
  "Walter-Flex-Str.",
  "Walter-Hempel-Str.",
  "Walter-Hochapfel-Str.",
  "Walter-Nernst-Str.",
  "Wannseestr.",
  "Warnowstr.",
  "Warthestr.",
  "Weddigenstr.",
  "Weichselstr.",
  "Weidenstr.",
  "Weidfeldstr.",
  "Weiherfeld",
  "Weiherstr.",
  "Weinhuser Str.",
  "Weidornweg",
  "Weienseestr.",
  "Weizkamp",
  "Werftstr.",
  "Werkstttenstr.",
  "Werner-Heisenberg-Str.",
  "Werrastr.",
  "Weyerweg",
  "Widdauener Str.",
  "Wiebertshof",
  "Wiehbachtal",
  "Wiembachallee",
  "Wiesdorfer Platz",
  "Wiesenstr.",
  "Wilhelm-Busch-Str.",
  "Wilhelm-Hastrich-Str.",
  "Wilhelm-Leuschner-Str.",
  "Wilhelm-Liebknecht-Str.",
  "Wilhelmsgasse",
  "Wilhelmstr.",
  "Willi-Baumeister-Str.",
  "Willy-Brandt-Ring",
  "Winand-Rossi-Str.",
  "Windthorststr.",
  "Winkelweg",
  "Winterberg",
  "Wittenbergstr.",
  "Wolf-Vostell-Str.",
  "Wolkenburgstr.",
  "Wupperstr.",
  "Wuppertalstr.",
  "Wstenhof",
  "Yitzhak-Rabin-Str.",
  "Zauberkuhle",
  "Zedernweg",
  "Zehlendorfer Str.",
  "Zehntenweg",
  "Zeisigweg",
  "Zeppelinstr.",
  "Zschopaustr.",
  "Zum Claashuschen",
  "Zndhtchenweg",
  "Zur Alten Brauerei",
  "Zur alten Fabrik"
];

},{}],370:[function(require,module,exports){
module["exports"] = [
  "+49-1##-#######",
  "+49-1###-########"
];

},{}],371:[function(require,module,exports){
var cell_phone = {};
module['exports'] = cell_phone;
cell_phone.formats = require("./formats");

},{"./formats":370}],372:[function(require,module,exports){
var company = {};
module['exports'] = company;
company.suffix = require("./suffix");
company.legal_form = require("./legal_form");
company.name = require("./name");

},{"./legal_form":373,"./name":374,"./suffix":375}],373:[function(require,module,exports){
module["exports"] = [
  "GmbH",
  "AG",
  "Gruppe",
  "KG",
  "GmbH & Co. KG",
  "UG",
  "OHG"
];

},{}],374:[function(require,module,exports){
module["exports"] = [
  "#{Name.last_name} #{suffix}",
  "#{Name.last_name}-#{Name.last_name}",
  "#{Name.last_name}, #{Name.last_name} und #{Name.last_name}"
];

},{}],375:[function(require,module,exports){
arguments[4][373][0].apply(exports,arguments)
},{"dup":373}],376:[function(require,module,exports){
var de = {};
module['exports'] = de;
de.title = "German";
de.address = require("./address");
de.company = require("./company");
de.internet = require("./internet");
de.lorem = require("./lorem");
de.name = require("./name");
de.phone_number = require("./phone_number");
de.cell_phone = require("./cell_phone");
},{"./address":362,"./cell_phone":371,"./company":372,"./internet":379,"./lorem":380,"./name":383,"./phone_number":389}],377:[function(require,module,exports){
module["exports"] = [
  "com",
  "info",
  "name",
  "net",
  "org",
  "de",
  "ch"
];

},{}],378:[function(require,module,exports){
module["exports"] = [
  "gmail.com",
  "yahoo.com",
  "hotmail.com"
];

},{}],379:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":377,"./free_email":378,"dup":302}],380:[function(require,module,exports){
var lorem = {};
module['exports'] = lorem;
lorem.words = require("./words");

},{"./words":381}],381:[function(require,module,exports){
arguments[4][344][0].apply(exports,arguments)
},{"dup":344}],382:[function(require,module,exports){
module["exports"] = [
  "Aaron",
  "Abdul",
  "Abdullah",
  "Adam",
  "Adrian",
  "Adriano",
  "Ahmad",
  "Ahmed",
  "Ahmet",
  "Alan",
  "Albert",
  "Alessandro",
  "Alessio",
  "Alex",
  "Alexander",
  "Alfred",
  "Ali",
  "Amar",
  "Amir",
  "Amon",
  "Andre",
  "Andreas",
  "Andrew",
  "Angelo",
  "Ansgar",
  "Anthony",
  "Anton",
  "Antonio",
  "Arda",
  "Arian",
  "Armin",
  "Arne",
  "Arno",
  "Arthur",
  "Artur",
  "Arved",
  "Arvid",
  "Ayman",
  "Baran",
  "Baris",
  "Bastian",
  "Batuhan",
  "Bela",
  "Ben",
  "Benedikt",
  "Benjamin",
  "Bennet",
  "Bennett",
  "Benno",
  "Bent",
  "Berat",
  "Berkay",
  "Bernd",
  "Bilal",
  "Bjarne",
  "Bjrn",
  "Bo",
  "Boris",
  "Brandon",
  "Brian",
  "Bruno",
  "Bryan",
  "Burak",
  "Calvin",
  "Can",
  "Carl",
  "Carlo",
  "Carlos",
  "Caspar",
  "Cedric",
  "Cedrik",
  "Cem",
  "Charlie",
  "Chris",
  "Christian",
  "Christiano",
  "Christoph",
  "Christopher",
  "Claas",
  "Clemens",
  "Colin",
  "Collin",
  "Conner",
  "Connor",
  "Constantin",
  "Corvin",
  "Curt",
  "Damian",
  "Damien",
  "Daniel",
  "Danilo",
  "Danny",
  "Darian",
  "Dario",
  "Darius",
  "Darren",
  "David",
  "Davide",
  "Davin",
  "Dean",
  "Deniz",
  "Dennis",
  "Denny",
  "Devin",
  "Diego",
  "Dion",
  "Domenic",
  "Domenik",
  "Dominic",
  "Dominik",
  "Dorian",
  "Dustin",
  "Dylan",
  "Ecrin",
  "Eddi",
  "Eddy",
  "Edgar",
  "Edwin",
  "Efe",
  "Ege",
  "Elia",
  "Eliah",
  "Elias",
  "Elijah",
  "Emanuel",
  "Emil",
  "Emilian",
  "Emilio",
  "Emir",
  "Emirhan",
  "Emre",
  "Enes",
  "Enno",
  "Enrico",
  "Eren",
  "Eric",
  "Erik",
  "Etienne",
  "Fabian",
  "Fabien",
  "Fabio",
  "Fabrice",
  "Falk",
  "Felix",
  "Ferdinand",
  "Fiete",
  "Filip",
  "Finlay",
  "Finley",
  "Finn",
  "Finnley",
  "Florian",
  "Francesco",
  "Franz",
  "Frederic",
  "Frederick",
  "Frederik",
  "Friedrich",
  "Fritz",
  "Furkan",
  "Fynn",
  "Gabriel",
  "Georg",
  "Gerrit",
  "Gian",
  "Gianluca",
  "Gino",
  "Giuliano",
  "Giuseppe",
  "Gregor",
  "Gustav",
  "Hagen",
  "Hamza",
  "Hannes",
  "Hanno",
  "Hans",
  "Hasan",
  "Hassan",
  "Hauke",
  "Hendrik",
  "Hennes",
  "Henning",
  "Henri",
  "Henrick",
  "Henrik",
  "Henry",
  "Hugo",
  "Hussein",
  "Ian",
  "Ibrahim",
  "Ilias",
  "Ilja",
  "Ilyas",
  "Immanuel",
  "Ismael",
  "Ismail",
  "Ivan",
  "Iven",
  "Jack",
  "Jacob",
  "Jaden",
  "Jakob",
  "Jamal",
  "James",
  "Jamie",
  "Jan",
  "Janek",
  "Janis",
  "Janne",
  "Jannek",
  "Jannes",
  "Jannik",
  "Jannis",
  "Jano",
  "Janosch",
  "Jared",
  "Jari",
  "Jarne",
  "Jarno",
  "Jaron",
  "Jason",
  "Jasper",
  "Jay",
  "Jayden",
  "Jayson",
  "Jean",
  "Jens",
  "Jeremias",
  "Jeremie",
  "Jeremy",
  "Jermaine",
  "Jerome",
  "Jesper",
  "Jesse",
  "Jim",
  "Jimmy",
  "Joe",
  "Joel",
  "Joey",
  "Johann",
  "Johannes",
  "John",
  "Johnny",
  "Jon",
  "Jona",
  "Jonah",
  "Jonas",
  "Jonathan",
  "Jonte",
  "Joost",
  "Jordan",
  "Joris",
  "Joscha",
  "Joschua",
  "Josef",
  "Joseph",
  "Josh",
  "Joshua",
  "Josua",
  "Juan",
  "Julian",
  "Julien",
  "Julius",
  "Juri",
  "Justin",
  "Justus",
  "Kaan",
  "Kai",
  "Kalle",
  "Karim",
  "Karl",
  "Karlo",
  "Kay",
  "Keanu",
  "Kenan",
  "Kenny",
  "Keno",
  "Kerem",
  "Kerim",
  "Kevin",
  "Kian",
  "Kilian",
  "Kim",
  "Kimi",
  "Kjell",
  "Klaas",
  "Klemens",
  "Konrad",
  "Konstantin",
  "Koray",
  "Korbinian",
  "Kurt",
  "Lars",
  "Lasse",
  "Laurence",
  "Laurens",
  "Laurenz",
  "Laurin",
  "Lean",
  "Leander",
  "Leandro",
  "Leif",
  "Len",
  "Lenn",
  "Lennard",
  "Lennart",
  "Lennert",
  "Lennie",
  "Lennox",
  "Lenny",
  "Leo",
  "Leon",
  "Leonard",
  "Leonardo",
  "Leonhard",
  "Leonidas",
  "Leopold",
  "Leroy",
  "Levent",
  "Levi",
  "Levin",
  "Lewin",
  "Lewis",
  "Liam",
  "Lian",
  "Lias",
  "Lino",
  "Linus",
  "Lio",
  "Lion",
  "Lionel",
  "Logan",
  "Lorenz",
  "Lorenzo",
  "Loris",
  "Louis",
  "Luan",
  "Luc",
  "Luca",
  "Lucas",
  "Lucian",
  "Lucien",
  "Ludwig",
  "Luis",
  "Luiz",
  "Luk",
  "Luka",
  "Lukas",
  "Luke",
  "Lutz",
  "Maddox",
  "Mads",
  "Magnus",
  "Maik",
  "Maksim",
  "Malik",
  "Malte",
  "Manuel",
  "Marc",
  "Marcel",
  "Marco",
  "Marcus",
  "Marek",
  "Marian",
  "Mario",
  "Marius",
  "Mark",
  "Marko",
  "Markus",
  "Marlo",
  "Marlon",
  "Marten",
  "Martin",
  "Marvin",
  "Marwin",
  "Mateo",
  "Mathis",
  "Matis",
  "Mats",
  "Matteo",
  "Mattes",
  "Matthias",
  "Matthis",
  "Matti",
  "Mattis",
  "Maurice",
  "Max",
  "Maxim",
  "Maximilian",
  "Mehmet",
  "Meik",
  "Melvin",
  "Merlin",
  "Mert",
  "Michael",
  "Michel",
  "Mick",
  "Miguel",
  "Mika",
  "Mikail",
  "Mike",
  "Milan",
  "Milo",
  "Mio",
  "Mirac",
  "Mirco",
  "Mirko",
  "Mohamed",
  "Mohammad",
  "Mohammed",
  "Moritz",
  "Morten",
  "Muhammed",
  "Murat",
  "Mustafa",
  "Nathan",
  "Nathanael",
  "Nelson",
  "Neo",
  "Nevio",
  "Nick",
  "Niclas",
  "Nico",
  "Nicolai",
  "Nicolas",
  "Niels",
  "Nikita",
  "Niklas",
  "Niko",
  "Nikolai",
  "Nikolas",
  "Nils",
  "Nino",
  "Noah",
  "Noel",
  "Norman",
  "Odin",
  "Oke",
  "Ole",
  "Oliver",
  "Omar",
  "Onur",
  "Oscar",
  "Oskar",
  "Pascal",
  "Patrice",
  "Patrick",
  "Paul",
  "Peer",
  "Pepe",
  "Peter",
  "Phil",
  "Philip",
  "Philipp",
  "Pierre",
  "Piet",
  "Pit",
  "Pius",
  "Quentin",
  "Quirin",
  "Rafael",
  "Raik",
  "Ramon",
  "Raphael",
  "Rasmus",
  "Raul",
  "Rayan",
  "Ren",
  "Ricardo",
  "Riccardo",
  "Richard",
  "Rick",
  "Rico",
  "Robert",
  "Robin",
  "Rocco",
  "Roman",
  "Romeo",
  "Ron",
  "Ruben",
  "Ryan",
  "Said",
  "Salih",
  "Sam",
  "Sami",
  "Sammy",
  "Samuel",
  "Sandro",
  "Santino",
  "Sascha",
  "Sean",
  "Sebastian",
  "Selim",
  "Semih",
  "Shawn",
  "Silas",
  "Simeon",
  "Simon",
  "Sinan",
  "Sky",
  "Stefan",
  "Steffen",
  "Stephan",
  "Steve",
  "Steven",
  "Sven",
  "Snke",
  "Sren",
  "Taha",
  "Tamino",
  "Tammo",
  "Tarik",
  "Tayler",
  "Taylor",
  "Teo",
  "Theo",
  "Theodor",
  "Thies",
  "Thilo",
  "Thomas",
  "Thorben",
  "Thore",
  "Thorge",
  "Tiago",
  "Til",
  "Till",
  "Tillmann",
  "Tim",
  "Timm",
  "Timo",
  "Timon",
  "Timothy",
  "Tino",
  "Titus",
  "Tizian",
  "Tjark",
  "Tobias",
  "Tom",
  "Tommy",
  "Toni",
  "Tony",
  "Torben",
  "Tore",
  "Tristan",
  "Tyler",
  "Tyron",
  "Umut",
  "Valentin",
  "Valentino",
  "Veit",
  "Victor",
  "Viktor",
  "Vin",
  "Vincent",
  "Vito",
  "Vitus",
  "Wilhelm",
  "Willi",
  "William",
  "Willy",
  "Xaver",
  "Yannic",
  "Yannick",
  "Yannik",
  "Yannis",
  "Yasin",
  "Youssef",
  "Yunus",
  "Yusuf",
  "Yven",
  "Yves",
  "mer",
  "Aaliyah",
  "Abby",
  "Abigail",
  "Ada",
  "Adelina",
  "Adriana",
  "Aileen",
  "Aimee",
  "Alana",
  "Alea",
  "Alena",
  "Alessa",
  "Alessia",
  "Alexa",
  "Alexandra",
  "Alexia",
  "Alexis",
  "Aleyna",
  "Alia",
  "Alica",
  "Alice",
  "Alicia",
  "Alina",
  "Alisa",
  "Alisha",
  "Alissa",
  "Aliya",
  "Aliyah",
  "Allegra",
  "Alma",
  "Alyssa",
  "Amalia",
  "Amanda",
  "Amelia",
  "Amelie",
  "Amina",
  "Amira",
  "Amy",
  "Ana",
  "Anabel",
  "Anastasia",
  "Andrea",
  "Angela",
  "Angelina",
  "Angelique",
  "Anja",
  "Ann",
  "Anna",
  "Annabel",
  "Annabell",
  "Annabelle",
  "Annalena",
  "Anne",
  "Anneke",
  "Annelie",
  "Annemarie",
  "Anni",
  "Annie",
  "Annika",
  "Anny",
  "Anouk",
  "Antonia",
  "Arda",
  "Ariana",
  "Ariane",
  "Arwen",
  "Ashley",
  "Asya",
  "Aurelia",
  "Aurora",
  "Ava",
  "Ayleen",
  "Aylin",
  "Ayse",
  "Azra",
  "Betty",
  "Bianca",
  "Bianka",
  "Caitlin",
  "Cara",
  "Carina",
  "Carla",
  "Carlotta",
  "Carmen",
  "Carolin",
  "Carolina",
  "Caroline",
  "Cassandra",
  "Catharina",
  "Catrin",
  "Cecile",
  "Cecilia",
  "Celia",
  "Celina",
  "Celine",
  "Ceyda",
  "Ceylin",
  "Chantal",
  "Charleen",
  "Charlotta",
  "Charlotte",
  "Chayenne",
  "Cheyenne",
  "Chiara",
  "Christin",
  "Christina",
  "Cindy",
  "Claire",
  "Clara",
  "Clarissa",
  "Colleen",
  "Collien",
  "Cora",
  "Corinna",
  "Cosima",
  "Dana",
  "Daniela",
  "Daria",
  "Darleen",
  "Defne",
  "Delia",
  "Denise",
  "Diana",
  "Dilara",
  "Dina",
  "Dorothea",
  "Ecrin",
  "Eda",
  "Eileen",
  "Ela",
  "Elaine",
  "Elanur",
  "Elea",
  "Elena",
  "Eleni",
  "Eleonora",
  "Eliana",
  "Elif",
  "Elina",
  "Elisa",
  "Elisabeth",
  "Ella",
  "Ellen",
  "Elli",
  "Elly",
  "Elsa",
  "Emelie",
  "Emely",
  "Emilia",
  "Emilie",
  "Emily",
  "Emma",
  "Emmely",
  "Emmi",
  "Emmy",
  "Enie",
  "Enna",
  "Enya",
  "Esma",
  "Estelle",
  "Esther",
  "Eva",
  "Evelin",
  "Evelina",
  "Eveline",
  "Evelyn",
  "Fabienne",
  "Fatima",
  "Fatma",
  "Felicia",
  "Felicitas",
  "Felina",
  "Femke",
  "Fenja",
  "Fine",
  "Finia",
  "Finja",
  "Finnja",
  "Fiona",
  "Flora",
  "Florentine",
  "Francesca",
  "Franka",
  "Franziska",
  "Frederike",
  "Freya",
  "Frida",
  "Frieda",
  "Friederike",
  "Giada",
  "Gina",
  "Giulia",
  "Giuliana",
  "Greta",
  "Hailey",
  "Hana",
  "Hanna",
  "Hannah",
  "Heidi",
  "Helen",
  "Helena",
  "Helene",
  "Helin",
  "Henriette",
  "Henrike",
  "Hermine",
  "Ida",
  "Ilayda",
  "Imke",
  "Ina",
  "Ines",
  "Inga",
  "Inka",
  "Irem",
  "Isa",
  "Isabel",
  "Isabell",
  "Isabella",
  "Isabelle",
  "Ivonne",
  "Jacqueline",
  "Jamie",
  "Jamila",
  "Jana",
  "Jane",
  "Janin",
  "Janina",
  "Janine",
  "Janna",
  "Janne",
  "Jara",
  "Jasmin",
  "Jasmina",
  "Jasmine",
  "Jella",
  "Jenna",
  "Jennifer",
  "Jenny",
  "Jessica",
  "Jessy",
  "Jette",
  "Jil",
  "Jill",
  "Joana",
  "Joanna",
  "Joelina",
  "Joeline",
  "Joelle",
  "Johanna",
  "Joleen",
  "Jolie",
  "Jolien",
  "Jolin",
  "Jolina",
  "Joline",
  "Jona",
  "Jonah",
  "Jonna",
  "Josefin",
  "Josefine",
  "Josephin",
  "Josephine",
  "Josie",
  "Josy",
  "Joy",
  "Joyce",
  "Judith",
  "Judy",
  "Jule",
  "Julia",
  "Juliana",
  "Juliane",
  "Julie",
  "Julienne",
  "Julika",
  "Julina",
  "Juna",
  "Justine",
  "Kaja",
  "Karina",
  "Karla",
  "Karlotta",
  "Karolina",
  "Karoline",
  "Kassandra",
  "Katarina",
  "Katharina",
  "Kathrin",
  "Katja",
  "Katrin",
  "Kaya",
  "Kayra",
  "Kiana",
  "Kiara",
  "Kim",
  "Kimberley",
  "Kimberly",
  "Kira",
  "Klara",
  "Korinna",
  "Kristin",
  "Kyra",
  "Laila",
  "Lana",
  "Lara",
  "Larissa",
  "Laura",
  "Laureen",
  "Lavinia",
  "Lea",
  "Leah",
  "Leana",
  "Leandra",
  "Leann",
  "Lee",
  "Leila",
  "Lena",
  "Lene",
  "Leni",
  "Lenia",
  "Lenja",
  "Lenya",
  "Leona",
  "Leoni",
  "Leonie",
  "Leonora",
  "Leticia",
  "Letizia",
  "Levke",
  "Leyla",
  "Lia",
  "Liah",
  "Liana",
  "Lili",
  "Lilia",
  "Lilian",
  "Liliana",
  "Lilith",
  "Lilli",
  "Lillian",
  "Lilly",
  "Lily",
  "Lina",
  "Linda",
  "Lindsay",
  "Line",
  "Linn",
  "Linnea",
  "Lisa",
  "Lisann",
  "Lisanne",
  "Liv",
  "Livia",
  "Liz",
  "Lola",
  "Loreen",
  "Lorena",
  "Lotta",
  "Lotte",
  "Louisa",
  "Louise",
  "Luana",
  "Luca",
  "Lucia",
  "Lucie",
  "Lucienne",
  "Lucy",
  "Luisa",
  "Luise",
  "Luka",
  "Luna",
  "Luzie",
  "Lya",
  "Lydia",
  "Lyn",
  "Lynn",
  "Madeleine",
  "Madita",
  "Madleen",
  "Madlen",
  "Magdalena",
  "Maike",
  "Mailin",
  "Maira",
  "Maja",
  "Malena",
  "Malia",
  "Malin",
  "Malina",
  "Mandy",
  "Mara",
  "Marah",
  "Mareike",
  "Maren",
  "Maria",
  "Mariam",
  "Marie",
  "Marieke",
  "Mariella",
  "Marika",
  "Marina",
  "Marisa",
  "Marissa",
  "Marit",
  "Marla",
  "Marleen",
  "Marlen",
  "Marlena",
  "Marlene",
  "Marta",
  "Martha",
  "Mary",
  "Maryam",
  "Mathilda",
  "Mathilde",
  "Matilda",
  "Maxi",
  "Maxima",
  "Maxine",
  "Maya",
  "Mayra",
  "Medina",
  "Medine",
  "Meike",
  "Melanie",
  "Melek",
  "Melike",
  "Melina",
  "Melinda",
  "Melis",
  "Melisa",
  "Melissa",
  "Merle",
  "Merve",
  "Meryem",
  "Mette",
  "Mia",
  "Michaela",
  "Michelle",
  "Mieke",
  "Mila",
  "Milana",
  "Milena",
  "Milla",
  "Mina",
  "Mira",
  "Miray",
  "Miriam",
  "Mirja",
  "Mona",
  "Monique",
  "Nadine",
  "Nadja",
  "Naemi",
  "Nancy",
  "Naomi",
  "Natalia",
  "Natalie",
  "Nathalie",
  "Neele",
  "Nela",
  "Nele",
  "Nelli",
  "Nelly",
  "Nia",
  "Nicole",
  "Nika",
  "Nike",
  "Nikita",
  "Nila",
  "Nina",
  "Nisa",
  "Noemi",
  "Nora",
  "Olivia",
  "Patricia",
  "Patrizia",
  "Paula",
  "Paulina",
  "Pauline",
  "Penelope",
  "Philine",
  "Phoebe",
  "Pia",
  "Rahel",
  "Rania",
  "Rebecca",
  "Rebekka",
  "Riana",
  "Rieke",
  "Rike",
  "Romina",
  "Romy",
  "Ronja",
  "Rosa",
  "Rosalie",
  "Ruby",
  "Sabrina",
  "Sahra",
  "Sally",
  "Salome",
  "Samantha",
  "Samia",
  "Samira",
  "Sandra",
  "Sandy",
  "Sanja",
  "Saphira",
  "Sara",
  "Sarah",
  "Saskia",
  "Selin",
  "Selina",
  "Selma",
  "Sena",
  "Sidney",
  "Sienna",
  "Silja",
  "Sina",
  "Sinja",
  "Smilla",
  "Sofia",
  "Sofie",
  "Sonja",
  "Sophia",
  "Sophie",
  "Soraya",
  "Stefanie",
  "Stella",
  "Stephanie",
  "Stina",
  "Sude",
  "Summer",
  "Susanne",
  "Svea",
  "Svenja",
  "Sydney",
  "Tabea",
  "Talea",
  "Talia",
  "Tamara",
  "Tamia",
  "Tamina",
  "Tanja",
  "Tara",
  "Tarja",
  "Teresa",
  "Tessa",
  "Thalea",
  "Thalia",
  "Thea",
  "Theresa",
  "Tia",
  "Tina",
  "Tomke",
  "Tuana",
  "Valentina",
  "Valeria",
  "Valerie",
  "Vanessa",
  "Vera",
  "Veronika",
  "Victoria",
  "Viktoria",
  "Viola",
  "Vivian",
  "Vivien",
  "Vivienne",
  "Wibke",
  "Wiebke",
  "Xenia",
  "Yara",
  "Yaren",
  "Yasmin",
  "Ylvi",
  "Ylvie",
  "Yvonne",
  "Zara",
  "Zehra",
  "Zeynep",
  "Zoe",
  "Zoey",
  "Zo"
];

},{}],383:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.last_name = require("./last_name");
name.prefix = require("./prefix");
name.nobility_title_prefix = require("./nobility_title_prefix");
name.name = require("./name");

},{"./first_name":382,"./last_name":384,"./name":385,"./nobility_title_prefix":386,"./prefix":387}],384:[function(require,module,exports){
module["exports"] = [
  "Abel",
  "Abicht",
  "Abraham",
  "Abramovic",
  "Abt",
  "Achilles",
  "Achkinadze",
  "Ackermann",
  "Adam",
  "Adams",
  "Ade",
  "Agostini",
  "Ahlke",
  "Ahrenberg",
  "Ahrens",
  "Aigner",
  "Albert",
  "Albrecht",
  "Alexa",
  "Alexander",
  "Alizadeh",
  "Allgeyer",
  "Amann",
  "Amberg",
  "Anding",
  "Anggreny",
  "Apitz",
  "Arendt",
  "Arens",
  "Arndt",
  "Aryee",
  "Aschenbroich",
  "Assmus",
  "Astafei",
  "Auer",
  "Axmann",
  "Baarck",
  "Bachmann",
  "Badane",
  "Bader",
  "Baganz",
  "Bahl",
  "Bak",
  "Balcer",
  "Balck",
  "Balkow",
  "Balnuweit",
  "Balzer",
  "Banse",
  "Barr",
  "Bartels",
  "Barth",
  "Barylla",
  "Baseda",
  "Battke",
  "Bauer",
  "Bauermeister",
  "Baumann",
  "Baumeister",
  "Bauschinger",
  "Bauschke",
  "Bayer",
  "Beavogui",
  "Beck",
  "Beckel",
  "Becker",
  "Beckmann",
  "Bedewitz",
  "Beele",
  "Beer",
  "Beggerow",
  "Beh",
  "Behr",
  "Behrenbruch",
  "Belz",
  "Bender",
  "Benecke",
  "Benner",
  "Benninger",
  "Benzing",
  "Berends",
  "Berger",
  "Berner",
  "Berning",
  "Bertenbreiter",
  "Best",
  "Bethke",
  "Betz",
  "Beushausen",
  "Beutelspacher",
  "Beyer",
  "Biba",
  "Bichler",
  "Bickel",
  "Biedermann",
  "Bieler",
  "Bielert",
  "Bienasch",
  "Bienias",
  "Biesenbach",
  "Bigdeli",
  "Birkemeyer",
  "Bittner",
  "Blank",
  "Blaschek",
  "Blassneck",
  "Bloch",
  "Blochwitz",
  "Blockhaus",
  "Blum",
  "Blume",
  "Bock",
  "Bode",
  "Bogdashin",
  "Bogenrieder",
  "Bohge",
  "Bolm",
  "Borgschulze",
  "Bork",
  "Bormann",
  "Bornscheuer",
  "Borrmann",
  "Borsch",
  "Boruschewski",
  "Bos",
  "Bosler",
  "Bourrouag",
  "Bouschen",
  "Boxhammer",
  "Boyde",
  "Bozsik",
  "Brand",
  "Brandenburg",
  "Brandis",
  "Brandt",
  "Brauer",
  "Braun",
  "Brehmer",
  "Breitenstein",
  "Bremer",
  "Bremser",
  "Brenner",
  "Brettschneider",
  "Breu",
  "Breuer",
  "Briesenick",
  "Bringmann",
  "Brinkmann",
  "Brix",
  "Broening",
  "Brosch",
  "Bruckmann",
  "Bruder",
  "Bruhns",
  "Brunner",
  "Bruns",
  "Brutigam",
  "Brmme",
  "Brggmann",
  "Buchholz",
  "Buchrucker",
  "Buder",
  "Bultmann",
  "Bunjes",
  "Burger",
  "Burghagen",
  "Burkhard",
  "Burkhardt",
  "Burmeister",
  "Busch",
  "Buschbaum",
  "Busemann",
  "Buss",
  "Busse",
  "Bussmann",
  "Byrd",
  "Bcker",
  "Bhm",
  "Bnisch",
  "Brgeling",
  "Brner",
  "Bttner",
  "Bchele",
  "Bhler",
  "Bker",
  "Bngener",
  "Brger",
  "Brklein",
  "Bscher",
  "Bttner",
  "Camara",
  "Carlowitz",
  "Carlsohn",
  "Caspari",
  "Caspers",
  "Chapron",
  "Christ",
  "Cierpinski",
  "Clarius",
  "Cleem",
  "Cleve",
  "Co",
  "Conrad",
  "Cordes",
  "Cornelsen",
  "Cors",
  "Cotthardt",
  "Crews",
  "Cronjger",
  "Crosskofp",
  "Da",
  "Dahm",
  "Dahmen",
  "Daimer",
  "Damaske",
  "Danneberg",
  "Danner",
  "Daub",
  "Daubner",
  "Daudrich",
  "Dauer",
  "Daum",
  "Dauth",
  "Dautzenberg",
  "De",
  "Decker",
  "Deckert",
  "Deerberg",
  "Dehmel",
  "Deja",
  "Delonge",
  "Demut",
  "Dengler",
  "Denner",
  "Denzinger",
  "Derr",
  "Dertmann",
  "Dethloff",
  "Deuschle",
  "Dieckmann",
  "Diedrich",
  "Diekmann",
  "Dienel",
  "Dies",
  "Dietrich",
  "Dietz",
  "Dietzsch",
  "Diezel",
  "Dilla",
  "Dingelstedt",
  "Dippl",
  "Dittmann",
  "Dittmar",
  "Dittmer",
  "Dix",
  "Dobbrunz",
  "Dobler",
  "Dohring",
  "Dolch",
  "Dold",
  "Dombrowski",
  "Donie",
  "Doskoczynski",
  "Dragu",
  "Drechsler",
  "Drees",
  "Dreher",
  "Dreier",
  "Dreissigacker",
  "Dressler",
  "Drews",
  "Duma",
  "Dutkiewicz",
  "Dyett",
  "Dylus",
  "Dchert",
  "Dbel",
  "Dring",
  "Drner",
  "Drre",
  "Dck",
  "Eberhard",
  "Eberhardt",
  "Ecker",
  "Eckhardt",
  "Edorh",
  "Effler",
  "Eggenmueller",
  "Ehm",
  "Ehmann",
  "Ehrig",
  "Eich",
  "Eichmann",
  "Eifert",
  "Einert",
  "Eisenlauer",
  "Ekpo",
  "Elbe",
  "Eleyth",
  "Elss",
  "Emert",
  "Emmelmann",
  "Ender",
  "Engel",
  "Engelen",
  "Engelmann",
  "Eplinius",
  "Erdmann",
  "Erhardt",
  "Erlei",
  "Erm",
  "Ernst",
  "Ertl",
  "Erwes",
  "Esenwein",
  "Esser",
  "Evers",
  "Everts",
  "Ewald",
  "Fahner",
  "Faller",
  "Falter",
  "Farber",
  "Fassbender",
  "Faulhaber",
  "Fehrig",
  "Feld",
  "Felke",
  "Feller",
  "Fenner",
  "Fenske",
  "Feuerbach",
  "Fietz",
  "Figl",
  "Figura",
  "Filipowski",
  "Filsinger",
  "Fincke",
  "Fink",
  "Finke",
  "Fischer",
  "Fitschen",
  "Fleischer",
  "Fleischmann",
  "Floder",
  "Florczak",
  "Flore",
  "Flottmann",
  "Forkel",
  "Forst",
  "Frahmeke",
  "Frank",
  "Franke",
  "Franta",
  "Frantz",
  "Franz",
  "Franzis",
  "Franzmann",
  "Frauen",
  "Frauendorf",
  "Freigang",
  "Freimann",
  "Freimuth",
  "Freisen",
  "Frenzel",
  "Frey",
  "Fricke",
  "Fried",
  "Friedek",
  "Friedenberg",
  "Friedmann",
  "Friedrich",
  "Friess",
  "Frisch",
  "Frohn",
  "Frosch",
  "Fuchs",
  "Fuhlbrgge",
  "Fusenig",
  "Fust",
  "Frster",
  "Gaba",
  "Gabius",
  "Gabler",
  "Gadschiew",
  "Gakstdter",
  "Galander",
  "Gamlin",
  "Gamper",
  "Gangnus",
  "Ganzmann",
  "Garatva",
  "Gast",
  "Gastel",
  "Gatzka",
  "Gauder",
  "Gebhardt",
  "Geese",
  "Gehre",
  "Gehrig",
  "Gehring",
  "Gehrke",
  "Geiger",
  "Geisler",
  "Geissler",
  "Gelling",
  "Gens",
  "Gerbennow",
  "Gerdel",
  "Gerhardt",
  "Gerschler",
  "Gerson",
  "Gesell",
  "Geyer",
  "Ghirmai",
  "Ghosh",
  "Giehl",
  "Gierisch",
  "Giesa",
  "Giesche",
  "Gilde",
  "Glatting",
  "Goebel",
  "Goedicke",
  "Goldbeck",
  "Goldfuss",
  "Goldkamp",
  "Goldkhle",
  "Goller",
  "Golling",
  "Gollnow",
  "Golomski",
  "Gombert",
  "Gotthardt",
  "Gottschalk",
  "Gotz",
  "Goy",
  "Gradzki",
  "Graf",
  "Grams",
  "Grasse",
  "Gratzky",
  "Grau",
  "Greb",
  "Green",
  "Greger",
  "Greithanner",
  "Greschner",
  "Griem",
  "Griese",
  "Grimm",
  "Gromisch",
  "Gross",
  "Grosser",
  "Grossheim",
  "Grosskopf",
  "Grothaus",
  "Grothkopp",
  "Grotke",
  "Grube",
  "Gruber",
  "Grundmann",
  "Gruning",
  "Gruszecki",
  "Grss",
  "Grtzinger",
  "Grn",
  "Grner",
  "Gummelt",
  "Gunkel",
  "Gunther",
  "Gutjahr",
  "Gutowicz",
  "Gutschank",
  "Gbel",
  "Gckeritz",
  "Ghler",
  "Grlich",
  "Grmer",
  "Gtz",
  "Gtzelmann",
  "Gldemeister",
  "Gnther",
  "Gnz",
  "Grbig",
  "Haack",
  "Haaf",
  "Habel",
  "Hache",
  "Hackbusch",
  "Hackelbusch",
  "Hadfield",
  "Hadwich",
  "Haferkamp",
  "Hahn",
  "Hajek",
  "Hallmann",
  "Hamann",
  "Hanenberger",
  "Hannecker",
  "Hanniske",
  "Hansen",
  "Hardy",
  "Hargasser",
  "Harms",
  "Harnapp",
  "Harter",
  "Harting",
  "Hartlieb",
  "Hartmann",
  "Hartwig",
  "Hartz",
  "Haschke",
  "Hasler",
  "Hasse",
  "Hassfeld",
  "Haug",
  "Hauke",
  "Haupt",
  "Haverney",
  "Heberstreit",
  "Hechler",
  "Hecht",
  "Heck",
  "Hedermann",
  "Hehl",
  "Heidelmann",
  "Heidler",
  "Heinemann",
  "Heinig",
  "Heinke",
  "Heinrich",
  "Heinze",
  "Heiser",
  "Heist",
  "Hellmann",
  "Helm",
  "Helmke",
  "Helpling",
  "Hengmith",
  "Henkel",
  "Hennes",
  "Henry",
  "Hense",
  "Hensel",
  "Hentel",
  "Hentschel",
  "Hentschke",
  "Hepperle",
  "Herberger",
  "Herbrand",
  "Hering",
  "Hermann",
  "Hermecke",
  "Herms",
  "Herold",
  "Herrmann",
  "Herschmann",
  "Hertel",
  "Herweg",
  "Herwig",
  "Herzenberg",
  "Hess",
  "Hesse",
  "Hessek",
  "Hessler",
  "Hetzler",
  "Heuck",
  "Heydemller",
  "Hiebl",
  "Hildebrand",
  "Hildenbrand",
  "Hilgendorf",
  "Hillard",
  "Hiller",
  "Hingsen",
  "Hingst",
  "Hinrichs",
  "Hirsch",
  "Hirschberg",
  "Hirt",
  "Hodea",
  "Hoffman",
  "Hoffmann",
  "Hofmann",
  "Hohenberger",
  "Hohl",
  "Hohn",
  "Hohnheiser",
  "Hold",
  "Holdt",
  "Holinski",
  "Holl",
  "Holtfreter",
  "Holz",
  "Holzdeppe",
  "Holzner",
  "Hommel",
  "Honz",
  "Hooss",
  "Hoppe",
  "Horak",
  "Horn",
  "Horna",
  "Hornung",
  "Hort",
  "Howard",
  "Huber",
  "Huckestein",
  "Hudak",
  "Huebel",
  "Hugo",
  "Huhn",
  "Hujo",
  "Huke",
  "Huls",
  "Humbert",
  "Huneke",
  "Huth",
  "Hber",
  "Hfner",
  "Hcke",
  "Hft",
  "Hhne",
  "Hnig",
  "Hrdt",
  "Hbenbecker",
  "Hbl",
  "Hbner",
  "Hgel",
  "Httcher",
  "Htter",
  "Ibe",
  "Ihly",
  "Illing",
  "Isak",
  "Isekenmeier",
  "Itt",
  "Jacob",
  "Jacobs",
  "Jagusch",
  "Jahn",
  "Jahnke",
  "Jakobs",
  "Jakubczyk",
  "Jambor",
  "Jamrozy",
  "Jander",
  "Janich",
  "Janke",
  "Jansen",
  "Jarets",
  "Jaros",
  "Jasinski",
  "Jasper",
  "Jegorov",
  "Jellinghaus",
  "Jeorga",
  "Jerschabek",
  "Jess",
  "John",
  "Jonas",
  "Jossa",
  "Jucken",
  "Jung",
  "Jungbluth",
  "Jungton",
  "Just",
  "Jrgens",
  "Kaczmarek",
  "Kaesmacher",
  "Kahl",
  "Kahlert",
  "Kahles",
  "Kahlmeyer",
  "Kaiser",
  "Kalinowski",
  "Kallabis",
  "Kallensee",
  "Kampf",
  "Kampschulte",
  "Kappe",
  "Kappler",
  "Karhoff",
  "Karrass",
  "Karst",
  "Karsten",
  "Karus",
  "Kass",
  "Kasten",
  "Kastner",
  "Katzinski",
  "Kaufmann",
  "Kaul",
  "Kausemann",
  "Kawohl",
  "Kazmarek",
  "Kedzierski",
  "Keil",
  "Keiner",
  "Keller",
  "Kelm",
  "Kempe",
  "Kemper",
  "Kempter",
  "Kerl",
  "Kern",
  "Kesselring",
  "Kesselschlger",
  "Kette",
  "Kettenis",
  "Keutel",
  "Kick",
  "Kiessling",
  "Kinadeter",
  "Kinzel",
  "Kinzy",
  "Kirch",
  "Kirst",
  "Kisabaka",
  "Klaas",
  "Klabuhn",
  "Klapper",
  "Klauder",
  "Klaus",
  "Kleeberg",
  "Kleiber",
  "Klein",
  "Kleinert",
  "Kleininger",
  "Kleinmann",
  "Kleinsteuber",
  "Kleiss",
  "Klemme",
  "Klimczak",
  "Klinger",
  "Klink",
  "Klopsch",
  "Klose",
  "Kloss",
  "Kluge",
  "Kluwe",
  "Knabe",
  "Kneifel",
  "Knetsch",
  "Knies",
  "Knippel",
  "Knobel",
  "Knoblich",
  "Knoll",
  "Knorr",
  "Knorscheidt",
  "Knut",
  "Kobs",
  "Koch",
  "Kochan",
  "Kock",
  "Koczulla",
  "Koderisch",
  "Koehl",
  "Koehler",
  "Koenig",
  "Koester",
  "Kofferschlager",
  "Koha",
  "Kohle",
  "Kohlmann",
  "Kohnle",
  "Kohrt",
  "Koj",
  "Kolb",
  "Koleiski",
  "Kolokas",
  "Komoll",
  "Konieczny",
  "Konig",
  "Konow",
  "Konya",
  "Koob",
  "Kopf",
  "Kosenkow",
  "Koster",
  "Koszewski",
  "Koubaa",
  "Kovacs",
  "Kowalick",
  "Kowalinski",
  "Kozakiewicz",
  "Krabbe",
  "Kraft",
  "Kral",
  "Kramer",
  "Krauel",
  "Kraus",
  "Krause",
  "Krauspe",
  "Kreb",
  "Krebs",
  "Kreissig",
  "Kresse",
  "Kreutz",
  "Krieger",
  "Krippner",
  "Krodinger",
  "Krohn",
  "Krol",
  "Kron",
  "Krueger",
  "Krug",
  "Kruger",
  "Krull",
  "Kruschinski",
  "Krmer",
  "Krckert",
  "Krger",
  "Krger",
  "Kubera",
  "Kufahl",
  "Kuhlee",
  "Kuhnen",
  "Kulimann",
  "Kulma",
  "Kumbernuss",
  "Kummle",
  "Kunz",
  "Kupfer",
  "Kupprion",
  "Kuprion",
  "Kurnicki",
  "Kurrat",
  "Kurschilgen",
  "Kuschewitz",
  "Kuschmann",
  "Kuske",
  "Kustermann",
  "Kutscherauer",
  "Kutzner",
  "Kwadwo",
  "Khler",
  "Kther",
  "Khler",
  "Khrbrck",
  "Khre",
  "Klotzei",
  "Knig",
  "Kpernick",
  "Kseoglu",
  "Khn",
  "Khnert",
  "Khn",
  "Khnel",
  "Khnemund",
  "Khnert",
  "Khnke",
  "Ksters",
  "Kter",
  "Laack",
  "Lack",
  "Ladewig",
  "Lakomy",
  "Lammert",
  "Lamos",
  "Landmann",
  "Lang",
  "Lange",
  "Langfeld",
  "Langhirt",
  "Lanig",
  "Lauckner",
  "Lauinger",
  "Laurn",
  "Lausecker",
  "Laux",
  "Laws",
  "Lax",
  "Leberer",
  "Lehmann",
  "Lehner",
  "Leibold",
  "Leide",
  "Leimbach",
  "Leipold",
  "Leist",
  "Leiter",
  "Leiteritz",
  "Leitheim",
  "Leiwesmeier",
  "Lenfers",
  "Lenk",
  "Lenz",
  "Lenzen",
  "Leo",
  "Lepthin",
  "Lesch",
  "Leschnik",
  "Letzelter",
  "Lewin",
  "Lewke",
  "Leyckes",
  "Lg",
  "Lichtenfeld",
  "Lichtenhagen",
  "Lichtl",
  "Liebach",
  "Liebe",
  "Liebich",
  "Liebold",
  "Lieder",
  "Lienshft",
  "Linden",
  "Lindenberg",
  "Lindenmayer",
  "Lindner",
  "Linke",
  "Linnenbaum",
  "Lippe",
  "Lipske",
  "Lipus",
  "Lischka",
  "Lobinger",
  "Logsch",
  "Lohmann",
  "Lohre",
  "Lohse",
  "Lokar",
  "Loogen",
  "Lorenz",
  "Losch",
  "Loska",
  "Lott",
  "Loy",
  "Lubina",
  "Ludolf",
  "Lufft",
  "Lukoschek",
  "Lutje",
  "Lutz",
  "Lser",
  "Lwa",
  "Lbke",
  "Maak",
  "Maczey",
  "Madetzky",
  "Madubuko",
  "Mai",
  "Maier",
  "Maisch",
  "Malek",
  "Malkus",
  "Mallmann",
  "Malucha",
  "Manns",
  "Manz",
  "Marahrens",
  "Marchewski",
  "Margis",
  "Markowski",
  "Marl",
  "Marner",
  "Marquart",
  "Marschek",
  "Martel",
  "Marten",
  "Martin",
  "Marx",
  "Marxen",
  "Mathes",
  "Mathies",
  "Mathiszik",
  "Matschke",
  "Mattern",
  "Matthes",
  "Matula",
  "Mau",
  "Maurer",
  "Mauroff",
  "May",
  "Maybach",
  "Mayer",
  "Mebold",
  "Mehl",
  "Mehlhorn",
  "Mehlorn",
  "Meier",
  "Meisch",
  "Meissner",
  "Meloni",
  "Melzer",
  "Menga",
  "Menne",
  "Mensah",
  "Mensing",
  "Merkel",
  "Merseburg",
  "Mertens",
  "Mesloh",
  "Metzger",
  "Metzner",
  "Mewes",
  "Meyer",
  "Michallek",
  "Michel",
  "Mielke",
  "Mikitenko",
  "Milde",
  "Minah",
  "Mintzlaff",
  "Mockenhaupt",
  "Moede",
  "Moedl",
  "Moeller",
  "Moguenara",
  "Mohr",
  "Mohrhard",
  "Molitor",
  "Moll",
  "Moller",
  "Molzan",
  "Montag",
  "Moormann",
  "Mordhorst",
  "Morgenstern",
  "Morhelfer",
  "Moritz",
  "Moser",
  "Motchebon",
  "Motzenbbcker",
  "Mrugalla",
  "Muckenthaler",
  "Mues",
  "Muller",
  "Mulrain",
  "Mchtig",
  "Mder",
  "Mcks",
  "Mgenburg",
  "Mhsner",
  "Mldner",
  "Mllenbeck",
  "Mller",
  "Mllinger",
  "Mrsch",
  "Mhleis",
  "Mller",
  "Mnch",
  "Nabein",
  "Nabow",
  "Nagel",
  "Nannen",
  "Nastvogel",
  "Nau",
  "Naubert",
  "Naumann",
  "Ne",
  "Neimke",
  "Nerius",
  "Neubauer",
  "Neubert",
  "Neuendorf",
  "Neumair",
  "Neumann",
  "Neupert",
  "Neurohr",
  "Neuschwander",
  "Newton",
  "Ney",
  "Nicolay",
  "Niedermeier",
  "Nieklauson",
  "Niklaus",
  "Nitzsche",
  "Noack",
  "Nodler",
  "Nolte",
  "Normann",
  "Norris",
  "Northoff",
  "Nowak",
  "Nussbeck",
  "Nwachukwu",
  "Nytra",
  "Nh",
  "Oberem",
  "Obergfll",
  "Obermaier",
  "Ochs",
  "Oeser",
  "Olbrich",
  "Onnen",
  "Ophey",
  "Oppong",
  "Orth",
  "Orthmann",
  "Oschkenat",
  "Osei",
  "Osenberg",
  "Ostendarp",
  "Ostwald",
  "Otte",
  "Otto",
  "Paesler",
  "Pajonk",
  "Pallentin",
  "Panzig",
  "Paschke",
  "Patzwahl",
  "Paukner",
  "Peselman",
  "Peter",
  "Peters",
  "Petzold",
  "Pfeiffer",
  "Pfennig",
  "Pfersich",
  "Pfingsten",
  "Pflieger",
  "Pflgner",
  "Philipp",
  "Pichlmaier",
  "Piesker",
  "Pietsch",
  "Pingpank",
  "Pinnock",
  "Pippig",
  "Pitschugin",
  "Plank",
  "Plass",
  "Platzer",
  "Plauk",
  "Plautz",
  "Pletsch",
  "Plotzitzka",
  "Poehn",
  "Poeschl",
  "Pogorzelski",
  "Pohl",
  "Pohland",
  "Pohle",
  "Polifka",
  "Polizzi",
  "Pollmcher",
  "Pomp",
  "Ponitzsch",
  "Porsche",
  "Porth",
  "Poschmann",
  "Poser",
  "Pottel",
  "Prah",
  "Prange",
  "Prediger",
  "Pressler",
  "Preuk",
  "Preuss",
  "Prey",
  "Priemer",
  "Proske",
  "Pusch",
  "Pche",
  "Pge",
  "Raabe",
  "Rabenstein",
  "Rach",
  "Radtke",
  "Rahn",
  "Ranftl",
  "Rangen",
  "Ranz",
  "Rapp",
  "Rath",
  "Rau",
  "Raubuch",
  "Raukuc",
  "Rautenkranz",
  "Rehwagen",
  "Reiber",
  "Reichardt",
  "Reichel",
  "Reichling",
  "Reif",
  "Reifenrath",
  "Reimann",
  "Reinberg",
  "Reinelt",
  "Reinhardt",
  "Reinke",
  "Reitze",
  "Renk",
  "Rentz",
  "Renz",
  "Reppin",
  "Restle",
  "Restorff",
  "Retzke",
  "Reuber",
  "Reumann",
  "Reus",
  "Reuss",
  "Reusse",
  "Rheder",
  "Rhoden",
  "Richards",
  "Richter",
  "Riedel",
  "Riediger",
  "Rieger",
  "Riekmann",
  "Riepl",
  "Riermeier",
  "Riester",
  "Riethmller",
  "Rietmller",
  "Rietscher",
  "Ringel",
  "Ringer",
  "Rink",
  "Ripken",
  "Ritosek",
  "Ritschel",
  "Ritter",
  "Rittweg",
  "Ritz",
  "Roba",
  "Rockmeier",
  "Rodehau",
  "Rodowski",
  "Roecker",
  "Roggatz",
  "Rohlnder",
  "Rohrer",
  "Rokossa",
  "Roleder",
  "Roloff",
  "Roos",
  "Rosbach",
  "Roschinsky",
  "Rose",
  "Rosenauer",
  "Rosenbauer",
  "Rosenthal",
  "Rosksch",
  "Rossberg",
  "Rossler",
  "Roth",
  "Rother",
  "Ruch",
  "Ruckdeschel",
  "Rumpf",
  "Rupprecht",
  "Ruth",
  "Ryjikh",
  "Ryzih",
  "Rdler",
  "Rntsch",
  "Rdiger",
  "Rse",
  "Rttger",
  "Rcker",
  "Rdiger",
  "Rter",
  "Sachse",
  "Sack",
  "Saflanis",
  "Sagafe",
  "Sagonas",
  "Sahner",
  "Saile",
  "Sailer",
  "Salow",
  "Salzer",
  "Salzmann",
  "Sammert",
  "Sander",
  "Sarvari",
  "Sattelmaier",
  "Sauer",
  "Sauerland",
  "Saumweber",
  "Savoia",
  "Scc",
  "Schacht",
  "Schaefer",
  "Schaffarzik",
  "Schahbasian",
  "Scharf",
  "Schedler",
  "Scheer",
  "Schelk",
  "Schellenbeck",
  "Schembera",
  "Schenk",
  "Scherbarth",
  "Scherer",
  "Schersing",
  "Scherz",
  "Scheurer",
  "Scheuring",
  "Scheytt",
  "Schielke",
  "Schieskow",
  "Schildhauer",
  "Schilling",
  "Schima",
  "Schimmer",
  "Schindzielorz",
  "Schirmer",
  "Schirrmeister",
  "Schlachter",
  "Schlangen",
  "Schlawitz",
  "Schlechtweg",
  "Schley",
  "Schlicht",
  "Schlitzer",
  "Schmalzle",
  "Schmid",
  "Schmidt",
  "Schmidtchen",
  "Schmitt",
  "Schmitz",
  "Schmuhl",
  "Schneider",
  "Schnelting",
  "Schnieder",
  "Schniedermeier",
  "Schnrer",
  "Schoberg",
  "Scholz",
  "Schonberg",
  "Schondelmaier",
  "Schorr",
  "Schott",
  "Schottmann",
  "Schouren",
  "Schrader",
  "Schramm",
  "Schreck",
  "Schreiber",
  "Schreiner",
  "Schreiter",
  "Schroder",
  "Schrder",
  "Schuermann",
  "Schuff",
  "Schuhaj",
  "Schuldt",
  "Schult",
  "Schulte",
  "Schultz",
  "Schultze",
  "Schulz",
  "Schulze",
  "Schumacher",
  "Schumann",
  "Schupp",
  "Schuri",
  "Schuster",
  "Schwab",
  "Schwalm",
  "Schwanbeck",
  "Schwandke",
  "Schwanitz",
  "Schwarthoff",
  "Schwartz",
  "Schwarz",
  "Schwarzer",
  "Schwarzkopf",
  "Schwarzmeier",
  "Schwatlo",
  "Schweisfurth",
  "Schwennen",
  "Schwerdtner",
  "Schwidde",
  "Schwirkschlies",
  "Schwuchow",
  "Schfer",
  "Schffel",
  "Schffer",
  "Schning",
  "Schckel",
  "Schnball",
  "Schnbeck",
  "Schnberg",
  "Schnebeck",
  "Schnenberger",
  "Schnfeld",
  "Schnherr",
  "Schnlebe",
  "Schtz",
  "Schler",
  "Schppel",
  "Schtz",
  "Schtze",
  "Seeger",
  "Seelig",
  "Sehls",
  "Seibold",
  "Seidel",
  "Seiders",
  "Seigel",
  "Seiler",
  "Seitz",
  "Semisch",
  "Senkel",
  "Sewald",
  "Siebel",
  "Siebert",
  "Siegling",
  "Sielemann",
  "Siemon",
  "Siener",
  "Sievers",
  "Siewert",
  "Sihler",
  "Sillah",
  "Simon",
  "Sinnhuber",
  "Sischka",
  "Skibicki",
  "Sladek",
  "Slotta",
  "Smieja",
  "Soboll",
  "Sokolowski",
  "Soller",
  "Sollner",
  "Sommer",
  "Somssich",
  "Sonn",
  "Sonnabend",
  "Spahn",
  "Spank",
  "Spelmeyer",
  "Spiegelburg",
  "Spielvogel",
  "Spinner",
  "Spitzmller",
  "Splinter",
  "Sporrer",
  "Sprenger",
  "Spttel",
  "Stahl",
  "Stang",
  "Stanger",
  "Stauss",
  "Steding",
  "Steffen",
  "Steffny",
  "Steidl",
  "Steigauf",
  "Stein",
  "Steinecke",
  "Steinert",
  "Steinkamp",
  "Steinmetz",
  "Stelkens",
  "Stengel",
  "Stengl",
  "Stenzel",
  "Stepanov",
  "Stephan",
  "Stern",
  "Steuk",
  "Stief",
  "Stifel",
  "Stoll",
  "Stolle",
  "Stolz",
  "Storl",
  "Storp",
  "Stoutjesdijk",
  "Stratmann",
  "Straub",
  "Strausa",
  "Streck",
  "Streese",
  "Strege",
  "Streit",
  "Streller",
  "Strieder",
  "Striezel",
  "Strogies",
  "Strohschank",
  "Strunz",
  "Strutz",
  "Stube",
  "Stckert",
  "Stppler",
  "Stwer",
  "Strmer",
  "Suffa",
  "Sujew",
  "Sussmann",
  "Suthe",
  "Sutschet",
  "Swillims",
  "Szendrei",
  "Sren",
  "Srth",
  "Tafelmeier",
  "Tang",
  "Tasche",
  "Taufratshofer",
  "Tegethof",
  "Teichmann",
  "Tepper",
  "Terheiden",
  "Terlecki",
  "Teufel",
  "Theele",
  "Thieke",
  "Thimm",
  "Thiomas",
  "Thomas",
  "Thriene",
  "Thrnhardt",
  "Thust",
  "Thyssen",
  "Thne",
  "Tidow",
  "Tiedtke",
  "Tietze",
  "Tilgner",
  "Tillack",
  "Timmermann",
  "Tischler",
  "Tischmann",
  "Tittman",
  "Tivontschik",
  "Tonat",
  "Tonn",
  "Trampeli",
  "Trauth",
  "Trautmann",
  "Travan",
  "Treff",
  "Tremmel",
  "Tress",
  "Tsamonikian",
  "Tschiers",
  "Tschirch",
  "Tuch",
  "Tucholke",
  "Tudow",
  "Tuschmo",
  "Tchl",
  "Tbben",
  "Tpfer",
  "Uhlemann",
  "Uhlig",
  "Uhrig",
  "Uibel",
  "Uliczka",
  "Ullmann",
  "Ullrich",
  "Umbach",
  "Umlauft",
  "Umminger",
  "Unger",
  "Unterpaintner",
  "Urban",
  "Urbaniak",
  "Urbansky",
  "Urhig",
  "Vahlensieck",
  "Van",
  "Vangermain",
  "Vater",
  "Venghaus",
  "Verniest",
  "Verzi",
  "Vey",
  "Viellehner",
  "Vieweg",
  "Voelkel",
  "Vogel",
  "Vogelgsang",
  "Vogt",
  "Voigt",
  "Vokuhl",
  "Volk",
  "Volker",
  "Volkmann",
  "Von",
  "Vona",
  "Vontein",
  "Wachenbrunner",
  "Wachtel",
  "Wagner",
  "Waibel",
  "Wakan",
  "Waldmann",
  "Wallner",
  "Wallstab",
  "Walter",
  "Walther",
  "Walton",
  "Walz",
  "Wanner",
  "Wartenberg",
  "Waschbsch",
  "Wassilew",
  "Wassiluk",
  "Weber",
  "Wehrsen",
  "Weidlich",
  "Weidner",
  "Weigel",
  "Weight",
  "Weiler",
  "Weimer",
  "Weis",
  "Weiss",
  "Weller",
  "Welsch",
  "Welz",
  "Welzel",
  "Weniger",
  "Wenk",
  "Werle",
  "Werner",
  "Werrmann",
  "Wessel",
  "Wessinghage",
  "Weyel",
  "Wezel",
  "Wichmann",
  "Wickert",
  "Wiebe",
  "Wiechmann",
  "Wiegelmann",
  "Wierig",
  "Wiese",
  "Wieser",
  "Wilhelm",
  "Wilky",
  "Will",
  "Willwacher",
  "Wilts",
  "Wimmer",
  "Winkelmann",
  "Winkler",
  "Winter",
  "Wischek",
  "Wischer",
  "Wissing",
  "Wittich",
  "Wittl",
  "Wolf",
  "Wolfarth",
  "Wolff",
  "Wollenberg",
  "Wollmann",
  "Woytkowska",
  "Wujak",
  "Wurm",
  "Wyludda",
  "Wlpert",
  "Wschler",
  "Whn",
  "Wnsche",
  "Zach",
  "Zaczkiewicz",
  "Zahn",
  "Zaituc",
  "Zandt",
  "Zanner",
  "Zapletal",
  "Zauber",
  "Zeidler",
  "Zekl",
  "Zender",
  "Zeuch",
  "Zeyen",
  "Zeyhle",
  "Ziegler",
  "Zimanyi",
  "Zimmer",
  "Zimmermann",
  "Zinser",
  "Zintl",
  "Zipp",
  "Zipse",
  "Zschunke",
  "Zuber",
  "Zwiener",
  "Zmsande",
  "stringer",
  "beracker"
];

},{}],385:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{first_name} #{last_name}",
  "#{first_name} #{nobility_title_prefix} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}"
];

},{}],386:[function(require,module,exports){
module["exports"] = [
  "zu",
  "von",
  "vom",
  "von der"
];

},{}],387:[function(require,module,exports){
module["exports"] = [
  "Hr.",
  "Fr.",
  "Dr.",
  "Prof. Dr."
];

},{}],388:[function(require,module,exports){
module["exports"] = [
  "(0###) #########",
  "(0####) #######",
  "+49-###-#######",
  "+49-####-########"
];

},{}],389:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":388,"dup":312}],390:[function(require,module,exports){
arguments[4][356][0].apply(exports,arguments)
},{"dup":356}],391:[function(require,module,exports){
arguments[4][314][0].apply(exports,arguments)
},{"dup":314}],392:[function(require,module,exports){
module["exports"] = [
  "Aigen im Mhlkreis",
  "Allerheiligen bei Wildon",
  "Altenfelden",
  "Arriach",
  "Axams",
  "Baumgartenberg",
  "Bergern im Dunkelsteinerwald",
  "Berndorf bei Salzburg",
  "Bregenz",
  "Breitenbach am Inn",
  "Deutsch-Wagram",
  "Dienten am Hochknig",
  "Dietach",
  "Dornbirn",
  "Drnkrut",
  "Eben im Pongau",
  "Ebenthal in Krnten",
  "Eichgraben",
  "Eisenstadt",
  "Ellmau",
  "Feistritz am Wechsel",
  "Finkenberg",
  "Fiss",
  "Frantschach-St. Gertraud",
  "Fritzens",
  "Gams bei Hieflau",
  "Geiersberg",
  "Graz",
  "Grohflein",
  "Gnitz",
  "Hartl",
  "Hausleiten",
  "Herzogenburg",
  "Hinterhornbach",
  "Hochwolkersdorf",
  "Ilz",
  "Ilztal",
  "Innerbraz",
  "Innsbruck",
  "Itter",
  "Jagerberg",
  "Jeging",
  "Johnsbach",
  "Johnsdorf-Brunn",
  "Jungholz",
  "Kirchdorf am Inn",
  "Klagenfurt",
  "Kottes-Purk",
  "Krumau am Kamp",
  "Krumbach",
  "Lavamnd",
  "Lech",
  "Linz",
  "Ludesch",
  "Ldersdorf",
  "Marbach an der Donau",
  "Mattsee",
  "Mautern an der Donau",
  "Mauterndorf",
  "Mitterbach am Erlaufsee",
  "Neudorf bei Passail",
  "Neudorf bei Staatz",
  "Neukirchen an der Enknach",
  "Neustift an der Lafnitz",
  "Niederleis",
  "Oberndorf in Tirol",
  "Oberstorcha",
  "Oberwaltersdorf",
  "Oed-Oehling",
  "Ort im Innkreis",
  "Pilgersdorf",
  "Pitschgau",
  "Pollham",
  "Preitenegg",
  "Purbach am Neusiedler See",
  "Rabenwald",
  "Raiding",
  "Rastenfeld",
  "Ratten",
  "Rettenegg",
  "Salzburg",
  "Sankt Johann im Saggautal",
  "St. Peter am Kammersberg",
  "St. Plten",
  "St. Veit an der Glan",
  "Taxenbach",
  "Tragwein",
  "Trebesing",
  "Trieben",
  "Turnau",
  "Ungerdorf",
  "Unterauersbach",
  "Unterstinkenbrunn",
  "Untertilliach",
  "Uttendorf",
  "Vals",
  "Velden am Wrther See",
  "Viehhofen",
  "Villach",
  "Vitis",
  "Waidhofen an der Thaya",
  "Waldkirchen am Wesen",
  "Weikirchen an der Traun",
  "Wien",
  "Wimpassing im Schwarzatale",
  "Ybbs an der Donau",
  "Ybbsitz",
  "Yspertal",
  "Zeillern",
  "Zell am Pettenfirst",
  "Zell an der Pram",
  "Zerlach",
  "Zwlfaxing",
  "blarn",
  "belbach",
  "berackern",
  "bersaxen",
  "bersbach"
];

},{}],393:[function(require,module,exports){
arguments[4][360][0].apply(exports,arguments)
},{"dup":360}],394:[function(require,module,exports){
module["exports"] = [
  "sterreich"
];

},{}],395:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.country = require("./country");
address.street_root = require("./street_root");
address.building_number = require("./building_number");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.city_name = require("./city_name");
address.city = require("./city");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":390,"./city":391,"./city_name":392,"./country":393,"./default_country":394,"./postcode":396,"./secondary_address":397,"./state":398,"./state_abbr":399,"./street_address":400,"./street_name":401,"./street_root":402}],396:[function(require,module,exports){
module["exports"] = [
  "####"
];

},{}],397:[function(require,module,exports){
arguments[4][364][0].apply(exports,arguments)
},{"dup":364}],398:[function(require,module,exports){
module["exports"] = [
  "Burgenland",
  "Krnten",
  "Niedersterreich",
  "Obersterreich",
  "Salzburg",
  "Steiermark",
  "Tirol",
  "Vorarlberg",
  "Wien"
];

},{}],399:[function(require,module,exports){
module["exports"] = [
  "Bgld.",
  "Ktn.",
  "N",
  "O",
  "Sbg.",
  "Stmk.",
  "T",
  "Vbg.",
  "W"
];

},{}],400:[function(require,module,exports){
arguments[4][324][0].apply(exports,arguments)
},{"dup":324}],401:[function(require,module,exports){
arguments[4][368][0].apply(exports,arguments)
},{"dup":368}],402:[function(require,module,exports){
module["exports"] = [
  "Ahorn",
  "Ahorngasse (St. Andr)",
  "Alleestrae (Poysbrunn)",
  "Alpenlandstrae",
  "Alte Poststrae",
  "Alte Ufergasse",
  "Am Kronawett (Hagenbrunn)",
  "Am Mhlwasser",
  "Am Rebenhang",
  "Am Sternweg",
  "Anton Wildgans-Strae",
  "Auer-von-Welsbach-Weg",
  "Auf der Stift",
  "Aufeldgasse",
  "Bahngasse",
  "Bahnhofstrae",
  "Bahnstrae (Gerhaus)",
  "Basteigasse",
  "Berggasse",
  "Bergstrae",
  "Birkenweg",
  "Blasiussteig",
  "Blattur",
  "Bruderhofgasse",
  "Brunnelligasse",
  "Bhelweg",
  "Darnautgasse",
  "Donaugasse",
  "Dorfplatz (Haselbach)",
  "Dr.-Oberreiter-Strae",
  "Dr.Karl Holoubek-Str.",
  "Drautal Bundesstrae",
  "Drnrohrer Strae",
  "Ebenthalerstrae",
  "Eckgrabenweg",
  "Erlenstrae",
  "Erlenweg",
  "Eschenweg",
  "Etrichgasse",
  "Fassergasse",
  "Feichteggerwiese",
  "Feld-Weg",
  "Feldgasse",
  "Feldstapfe",
  "Fischpointweg",
  "Flachbergstrae",
  "Flurweg",
  "Franz Schubert-Gasse",
  "Franz-Schneewei-Weg",
  "Franz-von-Assisi-Strae",
  "Fritz-Pregl-Strae",
  "Fuchsgrubenweg",
  "Fdlerweg",
  "Fhrenweg",
  "Fnfhaus (Paasdorf)",
  "Gabelsbergerstrae",
  "Gartenstrae",
  "Geigen",
  "Geigergasse",
  "Gemeindeaugasse",
  "Gemeindeplatz",
  "Georg-Aichinger-Strae",
  "Glanfeldbachweg",
  "Graben (Burgauberg)",
  "Grub",
  "Grretgasse",
  "Grnbach",
  "Gsting",
  "Hainschwang",
  "Hans-Mauracher-Strae",
  "Hart",
  "Teichstrae",
  "Hauptplatz",
  "Hauptstrae",
  "Heideweg",
  "Heinrich Landauer Gasse",
  "Helenengasse",
  "Hermann von Gilmweg",
  "Hermann-Lns-Gasse",
  "Herminengasse",
  "Hernstorferstrae",
  "Hirsdorf",
  "Hochfeistritz",
  "Hochhaus Neue Donau",
  "Hof",
  "Hussovits Gasse",
  "Hggen",
  "Htten",
  "Janzgasse",
  "Jochriemgutstrae",
  "Johann-Strau-Gasse",
  "Julius-Raab-Strae",
  "Kahlenberger Strae",
  "Karl Kraft-Strae",
  "Kegelprielstrae",
  "Keltenberg-Eponaweg",
  "Kennedybrcke",
  "Kerpelystrae",
  "Kindergartenstrae",
  "Kinderheimgasse",
  "Kirchenplatz",
  "Kirchweg",
  "Klagenfurter Strae",
  "Klamm",
  "Kleinbaumgarten",
  "Klingergasse",
  "Koloniestrae",
  "Konrad-Duden-Gasse",
  "Krankenhausstrae",
  "Kubinstrae",
  "Khldorfergasse",
  "Lackenweg",
  "Lange Mekotte",
  "Leifling",
  "Leopold Frank-Strae (Pellendorf)",
  "Lerchengasse (Pirka)",
  "Lichtensternsiedlung V",
  "Lindenhofstrae",
  "Lindenweg",
  "Luegstrae",
  "Maierhof",
  "Malerweg",
  "Mitterweg",
  "Mittlere Hauptstrae",
  "Moosbachgasse",
  "Morettigasse",
  "Musikpavillon Riezlern",
  "Mhlboden",
  "Mhle",
  "Mhlenweg",
  "Neustiftgasse",
  "Niederegg",
  "Niedergams",
  "Nordwestbahnbrcke",
  "Oberbdenalm",
  "Obere Berggasse",
  "Oedt",
  "Am Frberberg",
  "Ottogasse",
  "Paul Peters-Gasse",
  "Perspektivstrae",
  "Poppichl",
  "Privatweg",
  "Prixgasse",
  "Pyhra",
  "Radetzkystrae",
  "Raiden",
  "Reichensteinstrae",
  "Reitbauernstrae",
  "Reiterweg",
  "Reitschulgasse",
  "Ringweg",
  "Rupertistrae",
  "Rmerstrae",
  "Rmerweg",
  "Sackgasse",
  "Schaunbergerstrae",
  "Schloweg",
  "Schulgasse (Langeck)",
  "Schnholdsiedlung",
  "Seeblick",
  "Seestrae",
  "Semriacherstrae",
  "Simling",
  "Sipbachzeller Strae",
  "Sonnenweg",
  "Spargelfeldgasse",
  "Spiesmayrweg",
  "Sportplatzstrae",
  "St.Ulrich",
  "Steilmannstrae",
  "Steingrneredt",
  "Strassfeld",
  "Straerau",
  "Stpflweg",
  "Stra",
  "Taferngasse",
  "Tennweg",
  "Thomas Koschat-Gasse",
  "Tiroler Strae",
  "Torrogasse",
  "Uferstrae (Schwarzau am Steinfeld)",
  "Unterdrfl",
  "Unterer Sonnrainweg",
  "Verwaltersiedlung",
  "Waldhang",
  "Wasen",
  "Weidenstrae",
  "Weiherweg",
  "Wettsteingasse",
  "Wiener Strae",
  "Windisch",
  "Zebragasse",
  "Zellerstrae",
  "Ziehrerstrae",
  "Zulechnerweg",
  "Zwergjoch",
  "tzbruck"
];

},{}],403:[function(require,module,exports){
module["exports"] = [
  "+43-6##-#######",
  "06##-########",
  "+436#########",
  "06##########"
];

},{}],404:[function(require,module,exports){
arguments[4][371][0].apply(exports,arguments)
},{"./formats":403,"dup":371}],405:[function(require,module,exports){
arguments[4][372][0].apply(exports,arguments)
},{"./legal_form":406,"./name":407,"./suffix":408,"dup":372}],406:[function(require,module,exports){
arguments[4][373][0].apply(exports,arguments)
},{"dup":373}],407:[function(require,module,exports){
arguments[4][374][0].apply(exports,arguments)
},{"dup":374}],408:[function(require,module,exports){
arguments[4][373][0].apply(exports,arguments)
},{"dup":373}],409:[function(require,module,exports){
var de_AT = {};
module['exports'] = de_AT;
de_AT.title = "German (Austria)";
de_AT.address = require("./address");
de_AT.company = require("./company");
de_AT.internet = require("./internet");
de_AT.name = require("./name");
de_AT.phone_number = require("./phone_number");
de_AT.cell_phone = require("./cell_phone");

},{"./address":395,"./cell_phone":404,"./company":405,"./internet":412,"./name":414,"./phone_number":420}],410:[function(require,module,exports){
module["exports"] = [
  "com",
  "info",
  "name",
  "net",
  "org",
  "de",
  "ch",
  "at"
];

},{}],411:[function(require,module,exports){
arguments[4][378][0].apply(exports,arguments)
},{"dup":378}],412:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":410,"./free_email":411,"dup":302}],413:[function(require,module,exports){
arguments[4][382][0].apply(exports,arguments)
},{"dup":382}],414:[function(require,module,exports){
arguments[4][383][0].apply(exports,arguments)
},{"./first_name":413,"./last_name":415,"./name":416,"./nobility_title_prefix":417,"./prefix":418,"dup":383}],415:[function(require,module,exports){
arguments[4][384][0].apply(exports,arguments)
},{"dup":384}],416:[function(require,module,exports){
arguments[4][385][0].apply(exports,arguments)
},{"dup":385}],417:[function(require,module,exports){
arguments[4][386][0].apply(exports,arguments)
},{"dup":386}],418:[function(require,module,exports){
module["exports"] = [
  "Dr.",
  "Prof. Dr."
];

},{}],419:[function(require,module,exports){
module["exports"] = [
  "01 #######",
  "01#######",
  "+43-1-#######",
  "+431#######",
  "0#### ####",
  "0#########",
  "+43-####-####",
  "+43 ########"
];

},{}],420:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":419,"dup":312}],421:[function(require,module,exports){
module["exports"] = [
  "CH",
  "CH",
  "CH",
  "DE",
  "AT",
  "US",
  "LI",
  "US",
  "HK",
  "VN"
];

},{}],422:[function(require,module,exports){
module["exports"] = [
  "Schweiz"
];

},{}],423:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.country_code = require("./country_code");
address.postcode = require("./postcode");
address.default_country = require("./default_country");

},{"./country_code":421,"./default_country":422,"./postcode":424}],424:[function(require,module,exports){
module["exports"] = [
  "1###",
  "2###",
  "3###",
  "4###",
  "5###",
  "6###",
  "7###",
  "8###",
  "9###"
];

},{}],425:[function(require,module,exports){
var company = {};
module['exports'] = company;
company.suffix = require("./suffix");
company.name = require("./name");

},{"./name":426,"./suffix":427}],426:[function(require,module,exports){
arguments[4][374][0].apply(exports,arguments)
},{"dup":374}],427:[function(require,module,exports){
module["exports"] = [
  "AG",
  "GmbH",
  "und Shne",
  "und Partner",
  "& Co.",
  "Gruppe",
  "LLC",
  "Inc."
];

},{}],428:[function(require,module,exports){
var de_CH = {};
module['exports'] = de_CH;
de_CH.title = "German (Switzerland)";
de_CH.address = require("./address");
de_CH.company = require("./company");
de_CH.internet = require("./internet");
de_CH.name = require("./name");
de_CH.phone_number = require("./phone_number");

},{"./address":423,"./company":425,"./internet":430,"./name":432,"./phone_number":437}],429:[function(require,module,exports){
module["exports"] = [
  "com",
  "net",
  "biz",
  "ch",
  "de",
  "li",
  "at",
  "ch",
  "ch"
];

},{}],430:[function(require,module,exports){
var internet = {};
module['exports'] = internet;
internet.domain_suffix = require("./domain_suffix");

},{"./domain_suffix":429}],431:[function(require,module,exports){
module["exports"] = [
    "Adolf",
    "Adrian",
    "Agnes",
    "Alain",
    "Albert",
    "Alberto",
    "Aldo",
    "Alex",
    "Alexander",
    "Alexandre",
    "Alfons",
    "Alfred",
    "Alice",
    "Alois",
    "Andr",
    "Andrea",
    "Andreas",
    "Angela",
    "Angelo",
    "Anita",
    "Anna",
    "Anne",
    "Anne-Marie",
    "Annemarie",
    "Antoine",
    "Anton",
    "Antonio",
    "Armin",
    "Arnold",
    "Arthur",
    "Astrid",
    "Barbara",
    "Beat",
    "Beatrice",
    "Beatrix",
    "Bernadette",
    "Bernard",
    "Bernhard",
    "Bettina",
    "Brigitta",
    "Brigitte",
    "Bruno",
    "Carlo",
    "Carmen",
    "Caroline",
    "Catherine",
    "Chantal",
    "Charles",
    "Charlotte",
    "Christa",
    "Christian",
    "Christiane",
    "Christina",
    "Christine",
    "Christoph",
    "Christophe",
    "Claire",
    "Claude",
    "Claudia",
    "Claudine",
    "Claudio",
    "Corinne",
    "Cornelia",
    "Daniel",
    "Daniela",
    "Daniele",
    "Danielle",
    "David",
    "Denis",
    "Denise",
    "Didier",
    "Dieter",
    "Dominik",
    "Dominique",
    "Dora",
    "Doris",
    "Edgar",
    "Edith",
    "Eduard",
    "Edwin",
    "Eliane",
    "Elisabeth",
    "Elsa",
    "Elsbeth",
    "Emil",
    "Enrico",
    "Eric",
    "Erica",
    "Erich",
    "Erika",
    "Ernst",
    "Erwin",
    "Esther",
    "Eugen",
    "Eva",
    "Eveline",
    "Evelyne",
    "Fabienne",
    "Felix",
    "Ferdinand",
    "Florence",
    "Francesco",
    "Francis",
    "Franco",
    "Franois",
    "Franoise",
    "Frank",
    "Franz",
    "Franziska",
    "Frdric",
    "Fredy",
    "Fridolin",
    "Friedrich",
    "Fritz",
    "Gabriel",
    "Gabriela",
    "Gabrielle",
    "Georg",
    "Georges",
    "Grald",
    "Grard",
    "Gerhard",
    "Gertrud",
    "Gianni",
    "Gilbert",
    "Giorgio",
    "Giovanni",
    "Gisela",
    "Giuseppe",
    "Gottfried",
    "Guido",
    "Guy",
    "Hanna",
    "Hans",
    "Hans-Peter",
    "Hans-Rudolf",
    "Hans-Ulrich",
    "Hansjrg",
    "Hanspeter",
    "Hansruedi",
    "Hansueli",
    "Harry",
    "Heidi",
    "Heinrich",
    "Heinz",
    "Helen",
    "Helena",
    "Helene",
    "Helmut",
    "Henri",
    "Herbert",
    "Hermann",
    "Hildegard",
    "Hubert",
    "Hugo",
    "Ingrid",
    "Irene",
    "Iris",
    "Isabelle",
    "Jacqueline",
    "Jacques",
    "Jakob",
    "Jan",
    "Janine",
    "Jean",
    "Jean-Claude",
    "Jean-Daniel",
    "Jean-Franois",
    "Jean-Jacques",
    "Jean-Louis",
    "Jean-Luc",
    "Jean-Marc",
    "Jean-Marie",
    "Jean-Paul",
    "Jean-Pierre",
    "Johann",
    "Johanna",
    "Johannes",
    "John",
    "Jolanda",
    "Jrg",
    "Josef",
    "Joseph",
    "Josette",
    "Josiane",
    "Judith",
    "Julia",
    "Jrg",
    "Karin",
    "Karl",
    "Katharina",
    "Klaus",
    "Konrad",
    "Kurt",
    "Laura",
    "Laurence",
    "Laurent",
    "Leo",
    "Liliane",
    "Liselotte",
    "Louis",
    "Luca",
    "Luigi",
    "Lukas",
    "Lydia",
    "Madeleine",
    "Maja",
    "Manfred",
    "Manuel",
    "Manuela",
    "Marc",
    "Marcel",
    "Marco",
    "Margrit",
    "Margrith",
    "Maria",
    "Marianne",
    "Mario",
    "Marion",
    "Markus",
    "Marlne",
    "Marlies",
    "Marlis",
    "Martha",
    "Martin",
    "Martina",
    "Martine",
    "Massimo",
    "Matthias",
    "Maurice",
    "Max",
    "Maya",
    "Michael",
    "Michel",
    "Michele",
    "Micheline",
    "Monica",
    "Monika",
    "Monique",
    "Myriam",
    "Nadia",
    "Nadja",
    "Nathalie",
    "Nelly",
    "Nicolas",
    "Nicole",
    "Niklaus",
    "Norbert",
    "Olivier",
    "Oskar",
    "Otto",
    "Paola",
    "Paolo",
    "Pascal",
    "Patricia",
    "Patrick",
    "Paul",
    "Peter",
    "Petra",
    "Philipp",
    "Philippe",
    "Pia",
    "Pierre",
    "Pierre-Alain",
    "Pierre-Andr",
    "Pius",
    "Priska",
    "Rainer",
    "Raymond",
    "Regina",
    "Regula",
    "Reinhard",
    "Remo",
    "Renata",
    "Renate",
    "Renato",
    "Rene",
    "Ren",
    "Reto",
    "Richard",
    "Rita",
    "Robert",
    "Roberto",
    "Roger",
    "Roland",
    "Rolf",
    "Roman",
    "Rosa",
    "Rosemarie",
    "Rosmarie",
    "Rudolf",
    "Ruedi",
    "Ruth",
    "Sabine",
    "Samuel",
    "Sandra",
    "Sandro",
    "Serge",
    "Silvia",
    "Silvio",
    "Simon",
    "Simone",
    "Sonia",
    "Sonja",
    "Stefan",
    "Stephan",
    "Stphane",
    "Stphanie",
    "Susanna",
    "Susanne",
    "Suzanne",
    "Sylvia",
    "Sylvie",
    "Theo",
    "Theodor",
    "Therese",
    "Thomas",
    "Toni",
    "Ueli",
    "Ulrich",
    "Urs",
    "Ursula",
    "Verena",
    "Vronique",
    "Victor",
    "Viktor",
    "Vreni",
    "Walter",
    "Werner",
    "Willi",
    "Willy",
    "Wolfgang",
    "Yolande",
    "Yves",
    "Yvette",
    "Yvonne",

];

},{}],432:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.last_name = require("./last_name");
name.prefix = require("./prefix");
name.name = require("./name");

},{"./first_name":431,"./last_name":433,"./name":434,"./prefix":435}],433:[function(require,module,exports){
module["exports"] = [
    "Ackermann",
    "Aebi",
    "Albrecht",
    "Ammann",
    "Amrein",
    "Arnold",
    "Bachmann",
    "Bader",
    "Br",
    "Bttig",
    "Bauer",
    "Baumann",
    "Baumgartner",
    "Baur",
    "Beck",
    "Benz",
    "Berger",
    "Bernasconi",
    "Betschart",
    "Bianchi",
    "Bieri",
    "Blaser",
    "Blum",
    "Bolliger",
    "Bosshard",
    "Braun",
    "Brun",
    "Brunner",
    "Bucher",
    "Bhler",
    "Bhlmann",
    "Burri",
    "Christen",
    "Egger",
    "Egli",
    "Eichenberger",
    "Erni",
    "Ernst",
    "Eugster",
    "Fankhauser",
    "Favre",
    "Fehr",
    "Felber",
    "Felder",
    "Ferrari",
    "Fischer",
    "Flckiger",
    "Forster",
    "Frei",
    "Frey",
    "Frick",
    "Friedli",
    "Fuchs",
    "Furrer",
    "Gasser",
    "Geiger",
    "Gerber",
    "Gfeller",
    "Giger",
    "Gloor",
    "Graf",
    "Grob",
    "Gross",
    "Gut",
    "Haas",
    "Hfliger",
    "Hafner",
    "Hartmann",
    "Hasler",
    "Hauser",
    "Hermann",
    "Herzog",
    "Hess",
    "Hirt",
    "Hodel",
    "Hofer",
    "Hoffmann",
    "Hofmann",
    "Hofstetter",
    "Hotz",
    "Huber",
    "Hug",
    "Hunziker",
    "Hrlimann",
    "Imhof",
    "Isler",
    "Iten",
    "Jggi",
    "Jenni",
    "Jost",
    "Kgi",
    "Kaiser",
    "Klin",
    "Kser",
    "Kaufmann",
    "Keller",
    "Kern",
    "Kessler",
    "Knecht",
    "Koch",
    "Kohler",
    "Kuhn",
    "Kng",
    "Kunz",
    "Lang",
    "Lanz",
    "Lehmann",
    "Leu",
    "Leunberger",
    "Lscher",
    "Lustenberger",
    "Lthi",
    "Lutz",
    "Mder",
    "Maier",
    "Marti",
    "Martin",
    "Maurer",
    "Mayer",
    "Meier",
    "Meili",
    "Meister",
    "Merz",
    "Mettler",
    "Meyer",
    "Michel",
    "Moser",
    "Mller",
    "Nf",
    "Ott",
    "Peter",
    "Pfister",
    "Portmann",
    "Probst",
    "Rey",
    "Ritter",
    "Roos",
    "Roth",
    "Regg",
    "Schfer",
    "Schaller",
    "Schr",
    "Schrer",
    "Schaub",
    "Scheidegger",
    "Schenk",
    "Scherrer",
    "Schlatter",
    "Schmid",
    "Schmidt",
    "Schneider",
    "Schnyder",
    "Schoch",
    "Schuler",
    "Schumacher",
    "Schrch",
    "Schwab",
    "Schwarz",
    "Schweizer",
    "Seiler",
    "Senn",
    "Sidler",
    "Siegrist",
    "Sigrist",
    "Sprri",
    "Stadelmann",
    "Stalder",
    "Staub",
    "Stauffer",
    "Steffen",
    "Steiger",
    "Steiner",
    "Steinmann",
    "Stettler",
    "Stocker",
    "Stckli",
    "Stucki",
    "Studer",
    "Stutz",
    "Suter",
    "Sutter",
    "Tanner",
    "Thommen",
    "Tobler",
    "Vogel",
    "Vogt",
    "Wagner",
    "Walder",
    "Walter",
    "Weber",
    "Wegmann",
    "Wehrli",
    "Weibel",
    "Wenger",
    "Wettstein",
    "Widmer",
    "Winkler",
    "Wirth",
    "Wirz",
    "Wolf",
    "Wthrich",
    "Wyss",
    "Zbinden",
    "Zehnder",
    "Ziegler",
    "Zimmermann",
    "Zingg",
    "Zollinger",
    "Zrcher"
];

},{}],434:[function(require,module,exports){
module["exports"] = [
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}"
];

},{}],435:[function(require,module,exports){
module["exports"] = [
  "Hr.",
  "Fr.",
  "Dr."
];

},{}],436:[function(require,module,exports){
module["exports"] = [
  "0800 ### ###",
  "0800 ## ## ##",
  "0## ### ## ##",
  "0## ### ## ##",
  "+41 ## ### ## ##",
  "0900 ### ###",
  "076 ### ## ##",
  "+4178 ### ## ##",
  "0041 79 ### ## ##"
];

},{}],437:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":436,"dup":312}],438:[function(require,module,exports){
module["exports"] = [
  "#####",
  "####",
  "###"
];

},{}],439:[function(require,module,exports){
arguments[4][357][0].apply(exports,arguments)
},{"dup":357}],440:[function(require,module,exports){
module["exports"] = [
  "North",
  "East",
  "West",
  "South",
  "New",
  "Lake",
  "Port"
];

},{}],441:[function(require,module,exports){
module["exports"] = [
  "town",
  "ton",
  "land",
  "ville",
  "berg",
  "burgh",
  "borough",
  "bury",
  "view",
  "port",
  "mouth",
  "stad",
  "furt",
  "chester",
  "mouth",
  "fort",
  "haven",
  "side",
  "shire"
];

},{}],442:[function(require,module,exports){
module["exports"] = [
  "Afghanistan",
  "Albania",
  "Algeria",
  "American Samoa",
  "Andorra",
  "Angola",
  "Anguilla",
  "Antarctica (the territory South of 60 deg S)",
  "Antigua and Barbuda",
  "Argentina",
  "Armenia",
  "Aruba",
  "Australia",
  "Austria",
  "Azerbaijan",
  "Bahamas",
  "Bahrain",
  "Bangladesh",
  "Barbados",
  "Belarus",
  "Belgium",
  "Belize",
  "Benin",
  "Bermuda",
  "Bhutan",
  "Bolivia",
  "Bosnia and Herzegovina",
  "Botswana",
  "Bouvet Island (Bouvetoya)",
  "Brazil",
  "British Indian Ocean Territory (Chagos Archipelago)",
  "Brunei Darussalam",
  "Bulgaria",
  "Burkina Faso",
  "Burundi",
  "Cambodia",
  "Cameroon",
  "Canada",
  "Cape Verde",
  "Cayman Islands",
  "Central African Republic",
  "Chad",
  "Chile",
  "China",
  "Christmas Island",
  "Cocos (Keeling) Islands",
  "Colombia",
  "Comoros",
  "Congo",
  "Cook Islands",
  "Costa Rica",
  "Cote d'Ivoire",
  "Croatia",
  "Cuba",
  "Cyprus",
  "Czech Republic",
  "Denmark",
  "Djibouti",
  "Dominica",
  "Dominican Republic",
  "Ecuador",
  "Egypt",
  "El Salvador",
  "Equatorial Guinea",
  "Eritrea",
  "Estonia",
  "Ethiopia",
  "Faroe Islands",
  "Falkland Islands (Malvinas)",
  "Fiji",
  "Finland",
  "France",
  "French Guiana",
  "French Polynesia",
  "French Southern Territories",
  "Gabon",
  "Gambia",
  "Georgia",
  "Germany",
  "Ghana",
  "Gibraltar",
  "Greece",
  "Greenland",
  "Grenada",
  "Guadeloupe",
  "Guam",
  "Guatemala",
  "Guernsey",
  "Guinea",
  "Guinea-Bissau",
  "Guyana",
  "Haiti",
  "Heard Island and McDonald Islands",
  "Holy See (Vatican City State)",
  "Honduras",
  "Hong Kong",
  "Hungary",
  "Iceland",
  "India",
  "Indonesia",
  "Iran",
  "Iraq",
  "Ireland",
  "Isle of Man",
  "Israel",
  "Italy",
  "Jamaica",
  "Japan",
  "Jersey",
  "Jordan",
  "Kazakhstan",
  "Kenya",
  "Kiribati",
  "Democratic People's Republic of Korea",
  "Republic of Korea",
  "Kuwait",
  "Kyrgyz Republic",
  "Lao People's Democratic Republic",
  "Latvia",
  "Lebanon",
  "Lesotho",
  "Liberia",
  "Libyan Arab Jamahiriya",
  "Liechtenstein",
  "Lithuania",
  "Luxembourg",
  "Macao",
  "Macedonia",
  "Madagascar",
  "Malawi",
  "Malaysia",
  "Maldives",
  "Mali",
  "Malta",
  "Marshall Islands",
  "Martinique",
  "Mauritania",
  "Mauritius",
  "Mayotte",
  "Mexico",
  "Micronesia",
  "Moldova",
  "Monaco",
  "Mongolia",
  "Montenegro",
  "Montserrat",
  "Morocco",
  "Mozambique",
  "Myanmar",
  "Namibia",
  "Nauru",
  "Nepal",
  "Netherlands Antilles",
  "Netherlands",
  "New Caledonia",
  "New Zealand",
  "Nicaragua",
  "Niger",
  "Nigeria",
  "Niue",
  "Norfolk Island",
  "Northern Mariana Islands",
  "Norway",
  "Oman",
  "Pakistan",
  "Palau",
  "Palestinian Territory",
  "Panama",
  "Papua New Guinea",
  "Paraguay",
  "Peru",
  "Philippines",
  "Pitcairn Islands",
  "Poland",
  "Portugal",
  "Puerto Rico",
  "Qatar",
  "Reunion",
  "Romania",
  "Russian Federation",
  "Rwanda",
  "Saint Barthelemy",
  "Saint Helena",
  "Saint Kitts and Nevis",
  "Saint Lucia",
  "Saint Martin",
  "Saint Pierre and Miquelon",
  "Saint Vincent and the Grenadines",
  "Samoa",
  "San Marino",
  "Sao Tome and Principe",
  "Saudi Arabia",
  "Senegal",
  "Serbia",
  "Seychelles",
  "Sierra Leone",
  "Singapore",
  "Slovakia (Slovak Republic)",
  "Slovenia",
  "Solomon Islands",
  "Somalia",
  "South Africa",
  "South Georgia and the South Sandwich Islands",
  "Spain",
  "Sri Lanka",
  "Sudan",
  "Suriname",
  "Svalbard & Jan Mayen Islands",
  "Swaziland",
  "Sweden",
  "Switzerland",
  "Syrian Arab Republic",
  "Taiwan",
  "Tajikistan",
  "Tanzania",
  "Thailand",
  "Timor-Leste",
  "Togo",
  "Tokelau",
  "Tonga",
  "Trinidad and Tobago",
  "Tunisia",
  "Turkey",
  "Turkmenistan",
  "Turks and Caicos Islands",
  "Tuvalu",
  "Uganda",
  "Ukraine",
  "United Arab Emirates",
  "United Kingdom",
  "United States of America",
  "United States Minor Outlying Islands",
  "Uruguay",
  "Uzbekistan",
  "Vanuatu",
  "Venezuela",
  "Vietnam",
  "Virgin Islands, British",
  "Virgin Islands, U.S.",
  "Wallis and Futuna",
  "Western Sahara",
  "Yemen",
  "Zambia",
  "Zimbabwe"
];

},{}],443:[function(require,module,exports){
module["exports"] = [
  "AD",
  "AE",
  "AF",
  "AG",
  "AI",
  "AL",
  "AM",
  "AO",
  "AQ",
  "AR",
  "AS",
  "AT",
  "AU",
  "AW",
  "AX",
  "AZ",
  "BA",
  "BB",
  "BD",
  "BE",
  "BF",
  "BG",
  "BH",
  "BI",
  "BJ",
  "BL",
  "BM",
  "BN",
  "BO",
  "BQ",
  "BQ",
  "BR",
  "BS",
  "BT",
  "BV",
  "BW",
  "BY",
  "BZ",
  "CA",
  "CC",
  "CD",
  "CF",
  "CG",
  "CH",
  "CI",
  "CK",
  "CL",
  "CM",
  "CN",
  "CO",
  "CR",
  "CU",
  "CV",
  "CW",
  "CX",
  "CY",
  "CZ",
  "DE",
  "DJ",
  "DK",
  "DM",
  "DO",
  "DZ",
  "EC",
  "EE",
  "EG",
  "EH",
  "ER",
  "ES",
  "ET",
  "FI",
  "FJ",
  "FK",
  "FM",
  "FO",
  "FR",
  "GA",
  "GB",
  "GD",
  "GE",
  "GF",
  "GG",
  "GH",
  "GI",
  "GL",
  "GM",
  "GN",
  "GP",
  "GQ",
  "GR",
  "GS",
  "GT",
  "GU",
  "GW",
  "GY",
  "HK",
  "HM",
  "HN",
  "HR",
  "HT",
  "HU",
  "ID",
  "IE",
  "IL",
  "IM",
  "IN",
  "IO",
  "IQ",
  "IR",
  "IS",
  "IT",
  "JE",
  "JM",
  "JO",
  "JP",
  "KE",
  "KG",
  "KH",
  "KI",
  "KM",
  "KN",
  "KP",
  "KR",
  "KW",
  "KY",
  "KZ",
  "LA",
  "LB",
  "LC",
  "LI",
  "LK",
  "LR",
  "LS",
  "LT",
  "LU",
  "LV",
  "LY",
  "MA",
  "MC",
  "MD",
  "ME",
  "MF",
  "MG",
  "MH",
  "MK",
  "ML",
  "MM",
  "MN",
  "MO",
  "MP",
  "MQ",
  "MR",
  "MS",
  "MT",
  "MU",
  "MV",
  "MW",
  "MX",
  "MY",
  "MZ",
  "NA",
  "NC",
  "NE",
  "NF",
  "NG",
  "NI",
  "NL",
  "NO",
  "NP",
  "NR",
  "NU",
  "NZ",
  "OM",
  "PA",
  "PE",
  "PF",
  "PG",
  "PH",
  "PK",
  "PL",
  "PM",
  "PN",
  "PR",
  "PS",
  "PT",
  "PW",
  "PY",
  "QA",
  "RE",
  "RO",
  "RS",
  "RU",
  "RW",
  "SA",
  "SB",
  "SC",
  "SD",
  "SE",
  "SG",
  "SH",
  "SI",
  "SJ",
  "SK",
  "SL",
  "SM",
  "SN",
  "SO",
  "SR",
  "SS",
  "ST",
  "SV",
  "SX",
  "SY",
  "SZ",
  "TC",
  "TD",
  "TF",
  "TG",
  "TH",
  "TJ",
  "TK",
  "TL",
  "TM",
  "TN",
  "TO",
  "TR",
  "TT",
  "TV",
  "TW",
  "TZ",
  "UA",
  "UG",
  "UM",
  "US",
  "UY",
  "UZ",
  "VA",
  "VC",
  "VE",
  "VG",
  "VI",
  "VN",
  "VU",
  "WF",
  "WS",
  "YE",
  "YT",
  "ZA",
  "ZM",
  "ZW"
];

},{}],444:[function(require,module,exports){
module["exports"] = [
  "Avon",
  "Bedfordshire",
  "Berkshire",
  "Borders",
  "Buckinghamshire",
  "Cambridgeshire"
];

},{}],445:[function(require,module,exports){
module["exports"] = [
  "United States of America"
];

},{}],446:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.county = require("./county");
address.country = require("./country");
address.country_code = require("./country_code");
address.building_number = require("./building_number");
address.street_suffix = require("./street_suffix");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.postcode_by_state = require("./postcode_by_state");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.time_zone = require("./time_zone");
address.city = require("./city");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":438,"./city":439,"./city_prefix":440,"./city_suffix":441,"./country":442,"./country_code":443,"./county":444,"./default_country":445,"./postcode":447,"./postcode_by_state":448,"./secondary_address":449,"./state":450,"./state_abbr":451,"./street_address":452,"./street_name":453,"./street_suffix":454,"./time_zone":455}],447:[function(require,module,exports){
module["exports"] = [
  "#####",
  "#####-####"
];

},{}],448:[function(require,module,exports){
arguments[4][447][0].apply(exports,arguments)
},{"dup":447}],449:[function(require,module,exports){
arguments[4][320][0].apply(exports,arguments)
},{"dup":320}],450:[function(require,module,exports){
module["exports"] = [
  "Alabama",
  "Alaska",
  "Arizona",
  "Arkansas",
  "California",
  "Colorado",
  "Connecticut",
  "Delaware",
  "Florida",
  "Georgia",
  "Hawaii",
  "Idaho",
  "Illinois",
  "Indiana",
  "Iowa",
  "Kansas",
  "Kentucky",
  "Louisiana",
  "Maine",
  "Maryland",
  "Massachusetts",
  "Michigan",
  "Minnesota",
  "Mississippi",
  "Missouri",
  "Montana",
  "Nebraska",
  "Nevada",
  "New Hampshire",
  "New Jersey",
  "New Mexico",
  "New York",
  "North Carolina",
  "North Dakota",
  "Ohio",
  "Oklahoma",
  "Oregon",
  "Pennsylvania",
  "Rhode Island",
  "South Carolina",
  "South Dakota",
  "Tennessee",
  "Texas",
  "Utah",
  "Vermont",
  "Virginia",
  "Washington",
  "West Virginia",
  "Wisconsin",
  "Wyoming"
];

},{}],451:[function(require,module,exports){
module["exports"] = [
  "AL",
  "AK",
  "AZ",
  "AR",
  "CA",
  "CO",
  "CT",
  "DE",
  "FL",
  "GA",
  "HI",
  "ID",
  "IL",
  "IN",
  "IA",
  "KS",
  "KY",
  "LA",
  "ME",
  "MD",
  "MA",
  "MI",
  "MN",
  "MS",
  "MO",
  "MT",
  "NE",
  "NV",
  "NH",
  "NJ",
  "NM",
  "NY",
  "NC",
  "ND",
  "OH",
  "OK",
  "OR",
  "PA",
  "RI",
  "SC",
  "SD",
  "TN",
  "TX",
  "UT",
  "VT",
  "VA",
  "WA",
  "WV",
  "WI",
  "WY"
];

},{}],452:[function(require,module,exports){
module["exports"] = [
  "#{building_number} #{street_name}"
];

},{}],453:[function(require,module,exports){
module["exports"] = [
  "#{Name.first_name} #{street_suffix}",
  "#{Name.last_name} #{street_suffix}"
];

},{}],454:[function(require,module,exports){
module["exports"] = [
  "Alley",
  "Avenue",
  "Branch",
  "Bridge",
  "Brook",
  "Brooks",
  "Burg",
  "Burgs",
  "Bypass",
  "Camp",
  "Canyon",
  "Cape",
  "Causeway",
  "Center",
  "Centers",
  "Circle",
  "Circles",
  "Cliff",
  "Cliffs",
  "Club",
  "Common",
  "Corner",
  "Corners",
  "Course",
  "Court",
  "Courts",
  "Cove",
  "Coves",
  "Creek",
  "Crescent",
  "Crest",
  "Crossing",
  "Crossroad",
  "Curve",
  "Dale",
  "Dam",
  "Divide",
  "Drive",
  "Drive",
  "Drives",
  "Estate",
  "Estates",
  "Expressway",
  "Extension",
  "Extensions",
  "Fall",
  "Falls",
  "Ferry",
  "Field",
  "Fields",
  "Flat",
  "Flats",
  "Ford",
  "Fords",
  "Forest",
  "Forge",
  "Forges",
  "Fork",
  "Forks",
  "Fort",
  "Freeway",
  "Garden",
  "Gardens",
  "Gateway",
  "Glen",
  "Glens",
  "Green",
  "Greens",
  "Grove",
  "Groves",
  "Harbor",
  "Harbors",
  "Haven",
  "Heights",
  "Highway",
  "Hill",
  "Hills",
  "Hollow",
  "Inlet",
  "Inlet",
  "Island",
  "Island",
  "Islands",
  "Islands",
  "Isle",
  "Isle",
  "Junction",
  "Junctions",
  "Key",
  "Keys",
  "Knoll",
  "Knolls",
  "Lake",
  "Lakes",
  "Land",
  "Landing",
  "Lane",
  "Light",
  "Lights",
  "Loaf",
  "Lock",
  "Locks",
  "Locks",
  "Lodge",
  "Lodge",
  "Loop",
  "Mall",
  "Manor",
  "Manors",
  "Meadow",
  "Meadows",
  "Mews",
  "Mill",
  "Mills",
  "Mission",
  "Mission",
  "Motorway",
  "Mount",
  "Mountain",
  "Mountain",
  "Mountains",
  "Mountains",
  "Neck",
  "Orchard",
  "Oval",
  "Overpass",
  "Park",
  "Parks",
  "Parkway",
  "Parkways",
  "Pass",
  "Passage",
  "Path",
  "Pike",
  "Pine",
  "Pines",
  "Place",
  "Plain",
  "Plains",
  "Plains",
  "Plaza",
  "Plaza",
  "Point",
  "Points",
  "Port",
  "Port",
  "Ports",
  "Ports",
  "Prairie",
  "Prairie",
  "Radial",
  "Ramp",
  "Ranch",
  "Rapid",
  "Rapids",
  "Rest",
  "Ridge",
  "Ridges",
  "River",
  "Road",
  "Road",
  "Roads",
  "Roads",
  "Route",
  "Row",
  "Rue",
  "Run",
  "Shoal",
  "Shoals",
  "Shore",
  "Shores",
  "Skyway",
  "Spring",
  "Springs",
  "Springs",
  "Spur",
  "Spurs",
  "Square",
  "Square",
  "Squares",
  "Squares",
  "Station",
  "Station",
  "Stravenue",
  "Stravenue",
  "Stream",
  "Stream",
  "Street",
  "Street",
  "Streets",
  "Summit",
  "Summit",
  "Terrace",
  "Throughway",
  "Trace",
  "Track",
  "Trafficway",
  "Trail",
  "Trail",
  "Tunnel",
  "Tunnel",
  "Turnpike",
  "Turnpike",
  "Underpass",
  "Union",
  "Unions",
  "Valley",
  "Valleys",
  "Via",
  "Viaduct",
  "View",
  "Views",
  "Village",
  "Village",
  "Villages",
  "Ville",
  "Vista",
  "Vista",
  "Walk",
  "Walks",
  "Wall",
  "Way",
  "Ways",
  "Well",
  "Wells"
];

},{}],455:[function(require,module,exports){
arguments[4][326][0].apply(exports,arguments)
},{"dup":326}],456:[function(require,module,exports){
module["exports"] = [
  "#{Name.name}",
  "#{Company.name}"
];

},{}],457:[function(require,module,exports){
var app = {};
module['exports'] = app;
app.name = require("./name");
app.version = require("./version");
app.author = require("./author");

},{"./author":456,"./name":458,"./version":459}],458:[function(require,module,exports){
module["exports"] = [
  "Redhold",
  "Treeflex",
  "Trippledex",
  "Kanlam",
  "Bigtax",
  "Daltfresh",
  "Toughjoyfax",
  "Mat Lam Tam",
  "Otcom",
  "Tres-Zap",
  "Y-Solowarm",
  "Tresom",
  "Voltsillam",
  "Biodex",
  "Greenlam",
  "Viva",
  "Matsoft",
  "Temp",
  "Zoolab",
  "Subin",
  "Rank",
  "Job",
  "Stringtough",
  "Tin",
  "It",
  "Home Ing",
  "Zamit",
  "Sonsing",
  "Konklab",
  "Alpha",
  "Latlux",
  "Voyatouch",
  "Alphazap",
  "Holdlamis",
  "Zaam-Dox",
  "Sub-Ex",
  "Quo Lux",
  "Bamity",
  "Ventosanzap",
  "Lotstring",
  "Hatity",
  "Tempsoft",
  "Overhold",
  "Fixflex",
  "Konklux",
  "Zontrax",
  "Tampflex",
  "Span",
  "Namfix",
  "Transcof",
  "Stim",
  "Fix San",
  "Sonair",
  "Stronghold",
  "Fintone",
  "Y-find",
  "Opela",
  "Lotlux",
  "Ronstring",
  "Zathin",
  "Duobam",
  "Keylex"
];

},{}],459:[function(require,module,exports){
module["exports"] = [
  "0.#.#",
  "0.##",
  "#.##",
  "#.#",
  "#.#.#"
];

},{}],460:[function(require,module,exports){
module["exports"] = [
  "2011-10-12",
  "2012-11-12",
  "2015-11-11",
  "2013-9-12"
];

},{}],461:[function(require,module,exports){
module["exports"] = [
  "1234-2121-1221-1211",
  "1212-1221-1121-1234",
  "1211-1221-1234-2201",
  "1228-1221-1221-1431"
];

},{}],462:[function(require,module,exports){
module["exports"] = [
  "visa",
  "mastercard",
  "americanexpress",
  "discover"
];

},{}],463:[function(require,module,exports){
var business = {};
module['exports'] = business;
business.credit_card_numbers = require("./credit_card_numbers");
business.credit_card_expiry_dates = require("./credit_card_expiry_dates");
business.credit_card_types = require("./credit_card_types");

},{"./credit_card_expiry_dates":460,"./credit_card_numbers":461,"./credit_card_types":462}],464:[function(require,module,exports){
module["exports"] = [
  "###-###-####",
  "(###) ###-####",
  "1-###-###-####",
  "###.###.####"
];

},{}],465:[function(require,module,exports){
arguments[4][371][0].apply(exports,arguments)
},{"./formats":464,"dup":371}],466:[function(require,module,exports){
module["exports"] = [
  "red",
  "green",
  "blue",
  "yellow",
  "purple",
  "mint green",
  "teal",
  "white",
  "black",
  "orange",
  "pink",
  "grey",
  "maroon",
  "violet",
  "turquoise",
  "tan",
  "sky blue",
  "salmon",
  "plum",
  "orchid",
  "olive",
  "magenta",
  "lime",
  "ivory",
  "indigo",
  "gold",
  "fuchsia",
  "cyan",
  "azure",
  "lavender",
  "silver"
];

},{}],467:[function(require,module,exports){
module["exports"] = [
  "Books",
  "Movies",
  "Music",
  "Games",
  "Electronics",
  "Computers",
  "Home",
  "Garden",
  "Tools",
  "Grocery",
  "Health",
  "Beauty",
  "Toys",
  "Kids",
  "Baby",
  "Clothing",
  "Shoes",
  "Jewelery",
  "Sports",
  "Outdoors",
  "Automotive",
  "Industrial"
];

},{}],468:[function(require,module,exports){
arguments[4][290][0].apply(exports,arguments)
},{"./color":466,"./department":467,"./product_name":469,"dup":290}],469:[function(require,module,exports){
module["exports"] = {
  "adjective": [
    "Small",
    "Ergonomic",
    "Rustic",
    "Intelligent",
    "Gorgeous",
    "Incredible",
    "Fantastic",
    "Practical",
    "Sleek",
    "Awesome",
    "Generic",
    "Handcrafted",
    "Handmade",
    "Licensed",
    "Refined",
    "Unbranded",
    "Tasty"
  ],
  "material": [
    "Steel",
    "Wooden",
    "Concrete",
    "Plastic",
    "Cotton",
    "Granite",
    "Rubber",
    "Metal",
    "Soft",
    "Fresh",
    "Frozen"
  ],
  "product": [
    "Chair",
    "Car",
    "Computer",
    "Keyboard",
    "Mouse",
    "Bike",
    "Ball",
    "Gloves",
    "Pants",
    "Shirt",
    "Table",
    "Shoes",
    "Hat",
    "Towels",
    "Soap",
    "Tuna",
    "Chicken",
    "Fish",
    "Cheese",
    "Bacon",
    "Pizza",
    "Salad",
    "Sausages",
    "Chips"
  ]
};

},{}],470:[function(require,module,exports){
arguments[4][327][0].apply(exports,arguments)
},{"dup":327}],471:[function(require,module,exports){
module["exports"] = [
  "clicks-and-mortar",
  "value-added",
  "vertical",
  "proactive",
  "robust",
  "revolutionary",
  "scalable",
  "leading-edge",
  "innovative",
  "intuitive",
  "strategic",
  "e-business",
  "mission-critical",
  "sticky",
  "one-to-one",
  "24/7",
  "end-to-end",
  "global",
  "B2B",
  "B2C",
  "granular",
  "frictionless",
  "virtual",
  "viral",
  "dynamic",
  "24/365",
  "best-of-breed",
  "killer",
  "magnetic",
  "bleeding-edge",
  "web-enabled",
  "interactive",
  "dot-com",
  "sexy",
  "back-end",
  "real-time",
  "efficient",
  "front-end",
  "distributed",
  "seamless",
  "extensible",
  "turn-key",
  "world-class",
  "open-source",
  "cross-platform",
  "cross-media",
  "synergistic",
  "bricks-and-clicks",
  "out-of-the-box",
  "enterprise",
  "integrated",
  "impactful",
  "wireless",
  "transparent",
  "next-generation",
  "cutting-edge",
  "user-centric",
  "visionary",
  "customized",
  "ubiquitous",
  "plug-and-play",
  "collaborative",
  "compelling",
  "holistic",
  "rich"
];

},{}],472:[function(require,module,exports){
module["exports"] = [
  "synergies",
  "web-readiness",
  "paradigms",
  "markets",
  "partnerships",
  "infrastructures",
  "platforms",
  "initiatives",
  "channels",
  "eyeballs",
  "communities",
  "ROI",
  "solutions",
  "e-tailers",
  "e-services",
  "action-items",
  "portals",
  "niches",
  "technologies",
  "content",
  "vortals",
  "supply-chains",
  "convergence",
  "relationships",
  "architectures",
  "interfaces",
  "e-markets",
  "e-commerce",
  "systems",
  "bandwidth",
  "infomediaries",
  "models",
  "mindshare",
  "deliverables",
  "users",
  "schemas",
  "networks",
  "applications",
  "metrics",
  "e-business",
  "functionalities",
  "experiences",
  "web services",
  "methodologies"
];

},{}],473:[function(require,module,exports){
arguments[4][329][0].apply(exports,arguments)
},{"dup":329}],474:[function(require,module,exports){
arguments[4][330][0].apply(exports,arguments)
},{"dup":330}],475:[function(require,module,exports){
var company = {};
module['exports'] = company;
company.suffix = require("./suffix");
company.adjective = require("./adjective");
company.descriptor = require("./descriptor");
company.noun = require("./noun");
company.bs_verb = require("./bs_verb");
company.bs_adjective = require("./bs_adjective");
company.bs_noun = require("./bs_noun");
company.name = require("./name");

},{"./adjective":470,"./bs_adjective":471,"./bs_noun":472,"./bs_verb":473,"./descriptor":474,"./name":476,"./noun":477,"./suffix":478}],476:[function(require,module,exports){
module["exports"] = [
  "#{Name.last_name} #{suffix}",
  "#{Name.last_name}-#{Name.last_name}",
  "#{Name.last_name}, #{Name.last_name} and #{Name.last_name}"
];

},{}],477:[function(require,module,exports){
arguments[4][333][0].apply(exports,arguments)
},{"dup":333}],478:[function(require,module,exports){
module["exports"] = [
  "Inc",
  "and Sons",
  "LLC",
  "Group"
];

},{}],479:[function(require,module,exports){
module["exports"] = [
  "/34##-######-####L/",
  "/37##-######-####L/"
];

},{}],480:[function(require,module,exports){
module["exports"] = [
  "/30[0-5]#-######-###L/",
  "/368#-######-###L/"
];

},{}],481:[function(require,module,exports){
module["exports"] = [
  "/6011-####-####-###L/",
  "/65##-####-####-###L/",
  "/64[4-9]#-####-####-###L/",
  "/6011-62##-####-####-###L/",
  "/65##-62##-####-####-###L/",
  "/64[4-9]#-62##-####-####-###L/"
];

},{}],482:[function(require,module,exports){
var credit_card = {};
module['exports'] = credit_card;
credit_card.visa = require("./visa");
credit_card.mastercard = require("./mastercard");
credit_card.discover = require("./discover");
credit_card.american_express = require("./american_express");
credit_card.diners_club = require("./diners_club");
credit_card.jcb = require("./jcb");
credit_card.switch = require("./switch");
credit_card.solo = require("./solo");
credit_card.maestro = require("./maestro");
credit_card.laser = require("./laser");

},{"./american_express":479,"./diners_club":480,"./discover":481,"./jcb":483,"./laser":484,"./maestro":485,"./mastercard":486,"./solo":487,"./switch":488,"./visa":489}],483:[function(require,module,exports){
module["exports"] = [
  "/3528-####-####-###L/",
  "/3529-####-####-###L/",
  "/35[3-8]#-####-####-###L/"
];

},{}],484:[function(require,module,exports){
module["exports"] = [
  "/6304###########L/",
  "/6706###########L/",
  "/6771###########L/",
  "/6709###########L/",
  "/6304#########{5,6}L/",
  "/6706#########{5,6}L/",
  "/6771#########{5,6}L/",
  "/6709#########{5,6}L/"
];

},{}],485:[function(require,module,exports){
module["exports"] = [
  "/50#{9,16}L/",
  "/5[6-8]#{9,16}L/",
  "/56##{9,16}L/"
];

},{}],486:[function(require,module,exports){
module["exports"] = [
  "/5[1-5]##-####-####-###L/",
  "/6771-89##-####-###L/"
];

},{}],487:[function(require,module,exports){
module["exports"] = [
  "/6767-####-####-###L/",
  "/6767-####-####-####-#L/",
  "/6767-####-####-####-##L/"
];

},{}],488:[function(require,module,exports){
module["exports"] = [
  "/6759-####-####-###L/",
  "/6759-####-####-####-#L/",
  "/6759-####-####-####-##L/"
];

},{}],489:[function(require,module,exports){
module["exports"] = [
  "/4###########L/",
  "/4###-####-####-###L/"
];

},{}],490:[function(require,module,exports){
module["exports"] = [
  "utf8_unicode_ci",
  "utf8_general_ci",
  "utf8_bin",
  "ascii_bin",
  "ascii_general_ci",
  "cp1250_bin",
  "cp1250_general_ci"
];

},{}],491:[function(require,module,exports){
module["exports"] = [
  "id",
  "title",
  "name",
  "email",
  "phone",
  "token",
  "group",
  "category",
  "password",
  "comment",
  "avatar",
  "status",
  "createdAt",
  "updatedAt"
];

},{}],492:[function(require,module,exports){
module["exports"] = [
  "InnoDB",
  "MyISAM",
  "MEMORY",
  "CSV",
  "BLACKHOLE",
  "ARCHIVE"
];

},{}],493:[function(require,module,exports){
var database = {};
module['exports'] = database;
database.collation = require("./collation");
database.column = require("./column");
database.engine = require("./engine");
database.type = require("./type");
},{"./collation":490,"./column":491,"./engine":492,"./type":494}],494:[function(require,module,exports){
module["exports"] = [
  "int",
  "varchar",
  "text",
  "date",
  "datetime",
  "tinyint",
  "time",
  "timestamp",
  "smallint",
  "mediumint",
  "bigint",
  "decimal",
  "float",
  "double",
  "real",
  "bit",
  "boolean",
  "serial",
  "blob",
  "binary",
  "enum",
  "set",
  "geometry",
  "point"
];

},{}],495:[function(require,module,exports){
arguments[4][296][0].apply(exports,arguments)
},{"./month":496,"./weekday":497,"dup":296}],496:[function(require,module,exports){
// Source: http://unicode.org/cldr/trac/browser/tags/release-27/common/main/en.xml#L1799
module["exports"] = {
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  // Property "wide_context" is optional, if not set then "wide" will be used instead
  // It is used to specify a word in context, which may differ from a stand-alone word
  wide_context: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  abbr: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  // Property "abbr_context" is optional, if not set then "abbr" will be used instead
  // It is used to specify a word in context, which may differ from a stand-alone word
  abbr_context: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ]
};

},{}],497:[function(require,module,exports){
// Source: http://unicode.org/cldr/trac/browser/tags/release-27/common/main/en.xml#L1847
module["exports"] = {
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  // Property "wide_context" is optional, if not set then "wide" will be used instead
  // It is used to specify a word in context, which may differ from a stand-alone word
  wide_context: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  abbr: [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ],
  // Property "abbr_context" is optional, if not set then "abbr" will be used instead
  // It is used to specify a word in context, which may differ from a stand-alone word
  abbr_context: [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ]
};

},{}],498:[function(require,module,exports){
module["exports"] = [
  "Checking",
  "Savings",
  "Money Market",
  "Investment",
  "Home Loan",
  "Credit Card",
  "Auto Loan",
  "Personal Loan"
];

},{}],499:[function(require,module,exports){
module["exports"] = {
  "UAE Dirham": {
    "code": "AED",
    "symbol": ""
  },
  "Afghani": {
    "code": "AFN",
    "symbol": ""
  },
  "Lek": {
    "code": "ALL",
    "symbol": "Lek"
  },
  "Armenian Dram": {
    "code": "AMD",
    "symbol": ""
  },
  "Netherlands Antillian Guilder": {
    "code": "ANG",
    "symbol": ""
  },
  "Kwanza": {
    "code": "AOA",
    "symbol": ""
  },
  "Argentine Peso": {
    "code": "ARS",
    "symbol": "$"
  },
  "Australian Dollar": {
    "code": "AUD",
    "symbol": "$"
  },
  "Aruban Guilder": {
    "code": "AWG",
    "symbol": ""
  },
  "Azerbaijanian Manat": {
    "code": "AZN",
    "symbol": ""
  },
  "Convertible Marks": {
    "code": "BAM",
    "symbol": "KM"
  },
  "Barbados Dollar": {
    "code": "BBD",
    "symbol": "$"
  },
  "Taka": {
    "code": "BDT",
    "symbol": ""
  },
  "Bulgarian Lev": {
    "code": "BGN",
    "symbol": ""
  },
  "Bahraini Dinar": {
    "code": "BHD",
    "symbol": ""
  },
  "Burundi Franc": {
    "code": "BIF",
    "symbol": ""
  },
  "Bermudian Dollar (customarily known as Bermuda Dollar)": {
    "code": "BMD",
    "symbol": "$"
  },
  "Brunei Dollar": {
    "code": "BND",
    "symbol": "$"
  },
  "Boliviano Mvdol": {
    "code": "BOB BOV",
    "symbol": "$b"
  },
  "Brazilian Real": {
    "code": "BRL",
    "symbol": "R$"
  },
  "Bahamian Dollar": {
    "code": "BSD",
    "symbol": "$"
  },
  "Pula": {
    "code": "BWP",
    "symbol": "P"
  },
  "Belarussian Ruble": {
    "code": "BYR",
    "symbol": "p."
  },
  "Belize Dollar": {
    "code": "BZD",
    "symbol": "BZ$"
  },
  "Canadian Dollar": {
    "code": "CAD",
    "symbol": "$"
  },
  "Congolese Franc": {
    "code": "CDF",
    "symbol": ""
  },
  "Swiss Franc": {
    "code": "CHF",
    "symbol": "CHF"
  },
  "Chilean Peso Unidades de fomento": {
    "code": "CLP CLF",
    "symbol": "$"
  },
  "Yuan Renminbi": {
    "code": "CNY",
    "symbol": ""
  },
  "Colombian Peso Unidad de Valor Real": {
    "code": "COP COU",
    "symbol": "$"
  },
  "Costa Rican Colon": {
    "code": "CRC",
    "symbol": ""
  },
  "Cuban Peso Peso Convertible": {
    "code": "CUP CUC",
    "symbol": ""
  },
  "Cape Verde Escudo": {
    "code": "CVE",
    "symbol": ""
  },
  "Czech Koruna": {
    "code": "CZK",
    "symbol": "K"
  },
  "Djibouti Franc": {
    "code": "DJF",
    "symbol": ""
  },
  "Danish Krone": {
    "code": "DKK",
    "symbol": "kr"
  },
  "Dominican Peso": {
    "code": "DOP",
    "symbol": "RD$"
  },
  "Algerian Dinar": {
    "code": "DZD",
    "symbol": ""
  },
  "Kroon": {
    "code": "EEK",
    "symbol": ""
  },
  "Egyptian Pound": {
    "code": "EGP",
    "symbol": ""
  },
  "Nakfa": {
    "code": "ERN",
    "symbol": ""
  },
  "Ethiopian Birr": {
    "code": "ETB",
    "symbol": ""
  },
  "Euro": {
    "code": "EUR",
    "symbol": ""
  },
  "Fiji Dollar": {
    "code": "FJD",
    "symbol": "$"
  },
  "Falkland Islands Pound": {
    "code": "FKP",
    "symbol": ""
  },
  "Pound Sterling": {
    "code": "GBP",
    "symbol": ""
  },
  "Lari": {
    "code": "GEL",
    "symbol": ""
  },
  "Cedi": {
    "code": "GHS",
    "symbol": ""
  },
  "Gibraltar Pound": {
    "code": "GIP",
    "symbol": ""
  },
  "Dalasi": {
    "code": "GMD",
    "symbol": ""
  },
  "Guinea Franc": {
    "code": "GNF",
    "symbol": ""
  },
  "Quetzal": {
    "code": "GTQ",
    "symbol": "Q"
  },
  "Guyana Dollar": {
    "code": "GYD",
    "symbol": "$"
  },
  "Hong Kong Dollar": {
    "code": "HKD",
    "symbol": "$"
  },
  "Lempira": {
    "code": "HNL",
    "symbol": "L"
  },
  "Croatian Kuna": {
    "code": "HRK",
    "symbol": "kn"
  },
  "Gourde US Dollar": {
    "code": "HTG USD",
    "symbol": ""
  },
  "Forint": {
    "code": "HUF",
    "symbol": "Ft"
  },
  "Rupiah": {
    "code": "IDR",
    "symbol": "Rp"
  },
  "New Israeli Sheqel": {
    "code": "ILS",
    "symbol": ""
  },
  "Indian Rupee": {
    "code": "INR",
    "symbol": ""
  },
  "Indian Rupee Ngultrum": {
    "code": "INR BTN",
    "symbol": ""
  },
  "Iraqi Dinar": {
    "code": "IQD",
    "symbol": ""
  },
  "Iranian Rial": {
    "code": "IRR",
    "symbol": ""
  },
  "Iceland Krona": {
    "code": "ISK",
    "symbol": "kr"
  },
  "Jamaican Dollar": {
    "code": "JMD",
    "symbol": "J$"
  },
  "Jordanian Dinar": {
    "code": "JOD",
    "symbol": ""
  },
  "Yen": {
    "code": "JPY",
    "symbol": ""
  },
  "Kenyan Shilling": {
    "code": "KES",
    "symbol": ""
  },
  "Som": {
    "code": "KGS",
    "symbol": ""
  },
  "Riel": {
    "code": "KHR",
    "symbol": ""
  },
  "Comoro Franc": {
    "code": "KMF",
    "symbol": ""
  },
  "North Korean Won": {
    "code": "KPW",
    "symbol": ""
  },
  "Won": {
    "code": "KRW",
    "symbol": ""
  },
  "Kuwaiti Dinar": {
    "code": "KWD",
    "symbol": ""
  },
  "Cayman Islands Dollar": {
    "code": "KYD",
    "symbol": "$"
  },
  "Tenge": {
    "code": "KZT",
    "symbol": ""
  },
  "Kip": {
    "code": "LAK",
    "symbol": ""
  },
  "Lebanese Pound": {
    "code": "LBP",
    "symbol": ""
  },
  "Sri Lanka Rupee": {
    "code": "LKR",
    "symbol": ""
  },
  "Liberian Dollar": {
    "code": "LRD",
    "symbol": "$"
  },
  "Lithuanian Litas": {
    "code": "LTL",
    "symbol": "Lt"
  },
  "Latvian Lats": {
    "code": "LVL",
    "symbol": "Ls"
  },
  "Libyan Dinar": {
    "code": "LYD",
    "symbol": ""
  },
  "Moroccan Dirham": {
    "code": "MAD",
    "symbol": ""
  },
  "Moldovan Leu": {
    "code": "MDL",
    "symbol": ""
  },
  "Malagasy Ariary": {
    "code": "MGA",
    "symbol": ""
  },
  "Denar": {
    "code": "MKD",
    "symbol": ""
  },
  "Kyat": {
    "code": "MMK",
    "symbol": ""
  },
  "Tugrik": {
    "code": "MNT",
    "symbol": ""
  },
  "Pataca": {
    "code": "MOP",
    "symbol": ""
  },
  "Ouguiya": {
    "code": "MRO",
    "symbol": ""
  },
  "Mauritius Rupee": {
    "code": "MUR",
    "symbol": ""
  },
  "Rufiyaa": {
    "code": "MVR",
    "symbol": ""
  },
  "Kwacha": {
    "code": "MWK",
    "symbol": ""
  },
  "Mexican Peso Mexican Unidad de Inversion (UDI)": {
    "code": "MXN MXV",
    "symbol": "$"
  },
  "Malaysian Ringgit": {
    "code": "MYR",
    "symbol": "RM"
  },
  "Metical": {
    "code": "MZN",
    "symbol": "MT"
  },
  "Naira": {
    "code": "NGN",
    "symbol": ""
  },
  "Cordoba Oro": {
    "code": "NIO",
    "symbol": "C$"
  },
  "Norwegian Krone": {
    "code": "NOK",
    "symbol": "kr"
  },
  "Nepalese Rupee": {
    "code": "NPR",
    "symbol": ""
  },
  "New Zealand Dollar": {
    "code": "NZD",
    "symbol": "$"
  },
  "Rial Omani": {
    "code": "OMR",
    "symbol": ""
  },
  "Balboa US Dollar": {
    "code": "PAB USD",
    "symbol": "B/."
  },
  "Nuevo Sol": {
    "code": "PEN",
    "symbol": "S/."
  },
  "Kina": {
    "code": "PGK",
    "symbol": ""
  },
  "Philippine Peso": {
    "code": "PHP",
    "symbol": "Php"
  },
  "Pakistan Rupee": {
    "code": "PKR",
    "symbol": ""
  },
  "Zloty": {
    "code": "PLN",
    "symbol": "z"
  },
  "Guarani": {
    "code": "PYG",
    "symbol": "Gs"
  },
  "Qatari Rial": {
    "code": "QAR",
    "symbol": ""
  },
  "New Leu": {
    "code": "RON",
    "symbol": "lei"
  },
  "Serbian Dinar": {
    "code": "RSD",
    "symbol": "."
  },
  "Russian Ruble": {
    "code": "RUB",
    "symbol": ""
  },
  "Rwanda Franc": {
    "code": "RWF",
    "symbol": ""
  },
  "Saudi Riyal": {
    "code": "SAR",
    "symbol": ""
  },
  "Solomon Islands Dollar": {
    "code": "SBD",
    "symbol": "$"
  },
  "Seychelles Rupee": {
    "code": "SCR",
    "symbol": ""
  },
  "Sudanese Pound": {
    "code": "SDG",
    "symbol": ""
  },
  "Swedish Krona": {
    "code": "SEK",
    "symbol": "kr"
  },
  "Singapore Dollar": {
    "code": "SGD",
    "symbol": "$"
  },
  "Saint Helena Pound": {
    "code": "SHP",
    "symbol": ""
  },
  "Leone": {
    "code": "SLL",
    "symbol": ""
  },
  "Somali Shilling": {
    "code": "SOS",
    "symbol": "S"
  },
  "Surinam Dollar": {
    "code": "SRD",
    "symbol": "$"
  },
  "Dobra": {
    "code": "STD",
    "symbol": ""
  },
  "El Salvador Colon US Dollar": {
    "code": "SVC USD",
    "symbol": "$"
  },
  "Syrian Pound": {
    "code": "SYP",
    "symbol": ""
  },
  "Lilangeni": {
    "code": "SZL",
    "symbol": ""
  },
  "Baht": {
    "code": "THB",
    "symbol": ""
  },
  "Somoni": {
    "code": "TJS",
    "symbol": ""
  },
  "Manat": {
    "code": "TMT",
    "symbol": ""
  },
  "Tunisian Dinar": {
    "code": "TND",
    "symbol": ""
  },
  "Pa'anga": {
    "code": "TOP",
    "symbol": ""
  },
  "Turkish Lira": {
    "code": "TRY",
    "symbol": "TL"
  },
  "Trinidad and Tobago Dollar": {
    "code": "TTD",
    "symbol": "TT$"
  },
  "New Taiwan Dollar": {
    "code": "TWD",
    "symbol": "NT$"
  },
  "Tanzanian Shilling": {
    "code": "TZS",
    "symbol": ""
  },
  "Hryvnia": {
    "code": "UAH",
    "symbol": ""
  },
  "Uganda Shilling": {
    "code": "UGX",
    "symbol": ""
  },
  "US Dollar": {
    "code": "USD",
    "symbol": "$"
  },
  "Peso Uruguayo Uruguay Peso en Unidades Indexadas": {
    "code": "UYU UYI",
    "symbol": "$U"
  },
  "Uzbekistan Sum": {
    "code": "UZS",
    "symbol": ""
  },
  "Bolivar Fuerte": {
    "code": "VEF",
    "symbol": "Bs"
  },
  "Dong": {
    "code": "VND",
    "symbol": ""
  },
  "Vatu": {
    "code": "VUV",
    "symbol": ""
  },
  "Tala": {
    "code": "WST",
    "symbol": ""
  },
  "CFA Franc BEAC": {
    "code": "XAF",
    "symbol": ""
  },
  "Silver": {
    "code": "XAG",
    "symbol": ""
  },
  "Gold": {
    "code": "XAU",
    "symbol": ""
  },
  "Bond Markets Units European Composite Unit (EURCO)": {
    "code": "XBA",
    "symbol": ""
  },
  "European Monetary Unit (E.M.U.-6)": {
    "code": "XBB",
    "symbol": ""
  },
  "European Unit of Account 9(E.U.A.-9)": {
    "code": "XBC",
    "symbol": ""
  },
  "European Unit of Account 17(E.U.A.-17)": {
    "code": "XBD",
    "symbol": ""
  },
  "East Caribbean Dollar": {
    "code": "XCD",
    "symbol": "$"
  },
  "SDR": {
    "code": "XDR",
    "symbol": ""
  },
  "UIC-Franc": {
    "code": "XFU",
    "symbol": ""
  },
  "CFA Franc BCEAO": {
    "code": "XOF",
    "symbol": ""
  },
  "Palladium": {
    "code": "XPD",
    "symbol": ""
  },
  "CFP Franc": {
    "code": "XPF",
    "symbol": ""
  },
  "Platinum": {
    "code": "XPT",
    "symbol": ""
  },
  "Codes specifically reserved for testing purposes": {
    "code": "XTS",
    "symbol": ""
  },
  "Yemeni Rial": {
    "code": "YER",
    "symbol": ""
  },
  "Rand": {
    "code": "ZAR",
    "symbol": "R"
  },
  "Rand Loti": {
    "code": "ZAR LSL",
    "symbol": ""
  },
  "Rand Namibia Dollar": {
    "code": "ZAR NAD",
    "symbol": ""
  },
  "Zambian Kwacha": {
    "code": "ZMK",
    "symbol": ""
  },
  "Zimbabwe Dollar": {
    "code": "ZWL",
    "symbol": ""
  }
};

},{}],500:[function(require,module,exports){
var finance = {};
module['exports'] = finance;
finance.account_type = require("./account_type");
finance.transaction_type = require("./transaction_type");
finance.currency = require("./currency");

},{"./account_type":498,"./currency":499,"./transaction_type":501}],501:[function(require,module,exports){
module["exports"] = [
  "deposit",
  "withdrawal",
  "payment",
  "invoice"
];

},{}],502:[function(require,module,exports){
module["exports"] = [
  "TCP",
  "HTTP",
  "SDD",
  "RAM",
  "GB",
  "CSS",
  "SSL",
  "AGP",
  "SQL",
  "FTP",
  "PCI",
  "AI",
  "ADP",
  "RSS",
  "XML",
  "EXE",
  "COM",
  "HDD",
  "THX",
  "SMTP",
  "SMS",
  "USB",
  "PNG",
  "SAS",
  "IB",
  "SCSI",
  "JSON",
  "XSS",
  "JBOD"
];

},{}],503:[function(require,module,exports){
module["exports"] = [
  "auxiliary",
  "primary",
  "back-end",
  "digital",
  "open-source",
  "virtual",
  "cross-platform",
  "redundant",
  "online",
  "haptic",
  "multi-byte",
  "bluetooth",
  "wireless",
  "1080p",
  "neural",
  "optical",
  "solid state",
  "mobile"
];

},{}],504:[function(require,module,exports){
var hacker = {};
module['exports'] = hacker;
hacker.abbreviation = require("./abbreviation");
hacker.adjective = require("./adjective");
hacker.noun = require("./noun");
hacker.verb = require("./verb");
hacker.ingverb = require("./ingverb");

},{"./abbreviation":502,"./adjective":503,"./ingverb":505,"./noun":506,"./verb":507}],505:[function(require,module,exports){
module["exports"] = [
  "backing up",
  "bypassing",
  "hacking",
  "overriding",
  "compressing",
  "copying",
  "navigating",
  "indexing",
  "connecting",
  "generating",
  "quantifying",
  "calculating",
  "synthesizing",
  "transmitting",
  "programming",
  "parsing"
];

},{}],506:[function(require,module,exports){
module["exports"] = [
  "driver",
  "protocol",
  "bandwidth",
  "panel",
  "microchip",
  "program",
  "port",
  "card",
  "array",
  "interface",
  "system",
  "sensor",
  "firewall",
  "hard drive",
  "pixel",
  "alarm",
  "feed",
  "monitor",
  "application",
  "transmitter",
  "bus",
  "circuit",
  "capacitor",
  "matrix"
];

},{}],507:[function(require,module,exports){
module["exports"] = [
  "back up",
  "bypass",
  "hack",
  "override",
  "compress",
  "copy",
  "navigate",
  "index",
  "connect",
  "generate",
  "quantify",
  "calculate",
  "synthesize",
  "input",
  "transmit",
  "program",
  "reboot",
  "parse"
];

},{}],508:[function(require,module,exports){
var en = {};
module['exports'] = en;
en.title = "English";
en.separator = " & ";
en.address = require("./address");
en.credit_card = require("./credit_card");
en.company = require("./company");
en.internet = require("./internet");
en.database = require("./database");
en.lorem = require("./lorem");
en.name = require("./name");
en.phone_number = require("./phone_number");
en.cell_phone = require("./cell_phone");
en.business = require("./business");
en.commerce = require("./commerce");
en.team = require("./team");
en.hacker = require("./hacker");
en.app = require("./app");
en.finance = require("./finance");
en.date = require("./date");
en.system = require("./system");

},{"./address":446,"./app":457,"./business":463,"./cell_phone":465,"./commerce":468,"./company":475,"./credit_card":482,"./database":493,"./date":495,"./finance":500,"./hacker":504,"./internet":513,"./lorem":514,"./name":518,"./phone_number":525,"./system":526,"./team":529}],509:[function(require,module,exports){
module["exports"] = [
  "https://s3.amazonaws.com/uifaces/faces/twitter/jarjan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mahdif/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sprayaga/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ruzinav/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/Skyhartman/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/moscoz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kurafire/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/91bilal/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/igorgarybaldi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/calebogden/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/malykhinv/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joelhelin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kushsolitary/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/coreyweb/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/snowshade/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/areus/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/holdenweb/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/heyimjuani/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/envex/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/unterdreht/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/collegeman/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/peejfancher/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/andyisonline/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ultragex/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/fuck_you_two/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/adellecharles/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ateneupopular/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ahmetalpbalkan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/Stievius/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kerem/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/osvaldas/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/angelceballos/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thierrykoblentz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/peterlandt/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/catarino/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/weglov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/brandclay/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ahmetsulek/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nicolasfolliot/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jayrobinson/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/victorerixon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kolage/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/michzen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/markjenkins/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nicolai_larsen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gt/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/noxdzine/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/alagoon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/idiot/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mizko/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chadengle/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mutlu82/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/simobenso/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vocino/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/guiiipontes/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/soyjavi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joshaustin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tomaslau/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/VinThomas/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ManikRathee/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/langate/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cemshid/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/leemunroe/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/_shahedk/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/enda/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/BillSKenney/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/divya/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joshhemsley/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sindresorhus/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/soffes/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/9lessons/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/linux29/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/Chakintosh/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/anaami/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joreira/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/shadeed9/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/scottkclark/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jedbridges/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/salleedesign/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/marakasina/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ariil/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/BrianPurkiss/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/michaelmartinho/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bublienko/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/devankoshal/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ZacharyZorbas/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/timmillwood/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joshuasortino/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/damenleeturks/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tomas_janousek/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/herrhaase/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/RussellBishop/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/brajeshwar/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cbracco/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bermonpainter/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/abdullindenis/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/isacosta/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/suprb/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/yalozhkin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chandlervdw/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/iamgarth/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/_victa/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/commadelimited/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/roybarberuk/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/axel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vladarbatov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ffbel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/syropian/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ankitind/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/traneblow/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/flashmurphy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ChrisFarina78/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/baliomega/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/saschamt/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jm_denis/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/anoff/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kennyadr/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chatyrko/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dingyi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mds/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/terryxlife/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aaroni/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kinday/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/prrstn/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/eduardostuart/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dhilipsiva/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/GavicoInd/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/baires/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rohixx/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bigmancho/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/blakesimkins/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/leeiio/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tjrus/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/uberschizo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kylefoundry/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/claudioguglieri/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ripplemdk/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/exentrich/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jakemoore/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joaoedumedeiros/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/poormini/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tereshenkov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/keryilmaz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/haydn_woods/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rude/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/llun/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sgaurav_baghel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jamiebrittain/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/badlittleduck/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/pifagor/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/agromov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/benefritz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/erwanhesry/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/diesellaws/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jeremiaha/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/koridhandy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chaensel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/andrewcohen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/smaczny/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gonzalorobaina/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nandini_m/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sydlawrence/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cdharrison/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tgerken/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lewisainslie/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/charliecwaite/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/robbschiller/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/flexrs/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mattdetails/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/raquelwilson/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/karsh/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mrmartineau/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/opnsrce/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hgharrygo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/maximseshuk/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/uxalex/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/samihah/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chanpory/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sharvin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/josemarques/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jefffis/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/krystalfister/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lokesh_coder/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thedamianhdez/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dpmachado/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/funwatercat/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/timothycd/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ivanfilipovbg/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/picard102/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/marcobarbosa/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/krasnoukhov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/g3d/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ademilter/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rickdt/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/operatino/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bungiwan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hugomano/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/logorado/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dc_user/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/horaciobella/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/SlaapMe/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/teeragit/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/iqonicd/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ilya_pestov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/andrewarrow/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ssiskind/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/stan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/HenryHoffman/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rdsaunders/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/adamsxu/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/curiousoffice/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/themadray/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/michigangraham/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kohette/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nickfratter/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/runningskull/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/madysondesigns/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/brenton_clarke/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jennyshen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bradenhamm/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kurtinc/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/amanruzaini/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/coreyhaggard/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/Karimmove/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aaronalfred/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/wtrsld/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jitachi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/therealmarvin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/pmeissner/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ooomz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chacky14/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jesseddy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/shanehudson/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/akmur/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/IsaryAmairani/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/arthurholcombe1/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/boxmodel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ehsandiary/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/LucasPerdidao/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/shalt0ni/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/swaplord/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kaelifa/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/plbabin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/guillemboti/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/arindam_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/renbyrd/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thiagovernetti/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jmillspaysbills/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mikemai2awesome/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jervo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mekal/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sta1ex/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/robergd/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/felipecsl/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/andrea211087/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/garand/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dhooyenga/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/abovefunction/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/pcridesagain/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/randomlies/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/BryanHorsey/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/heykenneth/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dahparra/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/allthingssmitty/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/danvernon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/beweinreich/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/increase/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/falvarad/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/alxndrustinov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/souuf/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/orkuncaylar/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/AM_Kn2/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gearpixels/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bassamology/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vimarethomas/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kosmar/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/SULiik/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mrjamesnoble/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/silvanmuhlemann/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/shaneIxD/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nacho/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/yigitpinarbasi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/buzzusborne/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aaronkwhite/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rmlewisuk/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/giancarlon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nbirckel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/d_nny_m_cher/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sdidonato/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/atariboy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/abotap/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/karalek/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/psdesignuk/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ludwiczakpawel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nemanjaivanovic/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/baluli/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ahmadajmi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vovkasolovev/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/samgrover/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/derienzo777/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jonathansimmons/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nelsonjoyce/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/S0ufi4n3/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/xtopherpaul/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/oaktreemedia/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nateschulte/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/findingjenny/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/namankreative/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/antonyzotov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/we_social/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/leehambley/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/solid_color/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/abelcabans/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mbilderbach/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kkusaa/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jordyvdboom/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/carlosgavina/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/pechkinator/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vc27/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rdbannon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/croakx/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/suribbles/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kerihenare/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/catadeleon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gcmorley/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/duivvv/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/saschadroste/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/victorDubugras/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/wintopia/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mattbilotti/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/taylorling/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/megdraws/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/meln1ks/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mahmoudmetwally/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/Silveredge9/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/derekebradley/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/happypeter1983/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/travis_arnold/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/artem_kostenko/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/adobi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/daykiine/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/alek_djuric/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/scips/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/miguelmendes/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/justinrhee/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/alsobrooks/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/fronx/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mcflydesign/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/santi_urso/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/allfordesign/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/stayuber/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bertboerland/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/marosholly/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/adamnac/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cynthiasavard/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/muringa/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/danro/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hiemil/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jackiesaik/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/iduuck/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/antjanus/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aroon_sharma/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dshster/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thehacker/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/michaelbrooksjr/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ryanmclaughlin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/clubb3rry/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/taybenlor/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/xripunov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/myastro/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/adityasutomo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/digitalmaverick/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hjartstrorn/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/itolmach/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vaughanmoffitt/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/abdots/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/isnifer/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sergeysafonov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/maz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/scrapdnb/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chrismj83/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vitorleal/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sokaniwaal/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/zaki3d/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/illyzoren/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mocabyte/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/osmanince/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/djsherman/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/davidhemphill/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/waghner/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/necodymiconer/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/praveen_vijaya/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/fabbrucci/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/travishines/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kuldarkalvik/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/Elt_n/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/phillapier/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/okseanjay/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/id835559/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kudretkeskin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/anjhero/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/duck4fuck/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/scott_riley/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/noufalibrahim/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/h1brd/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/borges_marcos/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/devinhalladay/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ciaranr/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/stefooo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mikebeecham/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tonymillion/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joshuaraichur/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/irae/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/petrangr/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dmitriychuta/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/charliegann/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/arashmanteghi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/adhamdannaway/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ainsleywagon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/svenlen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/faisalabid/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/beshur/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/carlyson/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dutchnadia/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/teddyzetterlund/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/samuelkraft/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aoimedia/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/toddrew/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/codepoet_ru/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/artvavs/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/benoitboucart/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jomarmen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kolmarlopez/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/creartinc/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/homka/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gaborenton/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/robinclediere/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/maximsorokin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/plasticine/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/j2deme/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/peachananr/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kapaluccio/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/de_ascanio/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rikas/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dawidwu/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/marcoramires/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/angelcreative/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rpatey/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/popey/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rehatkathuria/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/the_purplebunny/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/1markiz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ajaxy_ru/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/brenmurrell/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dudestein/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/oskarlevinson/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/victorstuber/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nehfy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vicivadeline/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/leandrovaranda/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/scottgallant/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/victor_haydin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sawrb/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ryhanhassan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/amayvs/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/a_brixen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/karolkrakowiak_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/herkulano/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/geran7/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cggaurav/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chris_witko/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lososina/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/polarity/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mattlat/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/brandonburke/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/constantx/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/teylorfeliz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/craigelimeliah/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rachelreveley/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/reabo101/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rahmeen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ky/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rickyyean/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/j04ntoh/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/spbroma/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sebashton/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jpenico/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/francis_vega/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/oktayelipek/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kikillo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/fabbianz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/larrygerard/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/BroumiYoussef/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/0therplanet/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mbilalsiddique1/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ionuss/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/grrr_nl/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/liminha/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rawdiggie/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ryandownie/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sethlouey/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/pixage/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/arpitnj/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/switmer777/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/josevnclch/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kanickairaj/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/puzik/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tbakdesigns/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/besbujupi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/supjoey/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lowie/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/linkibol/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/balintorosz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/imcoding/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/agustincruiz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gusoto/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thomasschrijer/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/superoutman/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kalmerrautam/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gabrielizalo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gojeanyn/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/davidbaldie/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/_vojto/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/laurengray/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jydesign/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mymyboy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nellleo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/marciotoledo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ninjad3m0/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/to_soham/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hasslunsford/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/muridrahhal/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/levisan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/grahamkennery/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lepetitogre/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/antongenkin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nessoila/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/amandabuzard/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/safrankov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cocolero/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dss49/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/matt3224/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bluesix/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/quailandquasar/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/AlbertoCococi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lepinski/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sementiy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mhudobivnik/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thibaut_re/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/olgary/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/shojberg/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mtolokonnikov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bereto/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/naupintos/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/wegotvices/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/xadhix/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/macxim/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rodnylobos/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/madcampos/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/madebyvadim/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bartoszdawydzik/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/supervova/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/markretzloff/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vonachoo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/darylws/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/stevedesigner/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mylesb/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/herbigt/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/depaulawagner/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/geshan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gizmeedevil1991/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/_scottburgess/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lisovsky/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/davidsasda/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/artd_sign/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/YoungCutlass/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mgonto/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/itstotallyamy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/victorquinn/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/osmond/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/oksanafrewer/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/zauerkraut/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/iamkeithmason/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nitinhayaran/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lmjabreu/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mandalareopens/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thinkleft/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ponchomendivil/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/juamperro/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/brunodesign1206/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/caseycavanagh/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/luxe/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dotgridline/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/spedwig/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/madewulf/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mattsapii/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/helderleal/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chrisstumph/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jayphen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nsamoylov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chrisvanderkooi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/justme_timothyg/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/otozk/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/prinzadi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gu5taf/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cyril_gaillard/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/d_kobelyatsky/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/daniloc/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nwdsha/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/romanbulah/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/skkirilov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dvdwinden/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dannol/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thekevinjones/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jwalter14/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/timgthomas/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/buddhasource/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/uxpiper/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thatonetommy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/diansigitp/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/adrienths/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/klimmka/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gkaam/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/derekcramer/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jennyyo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nerrsoft/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/xalionmalik/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/edhenderson/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/keyuri85/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/roxanejammet/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kimcool/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/edkf/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/matkins/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/alessandroribe/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jacksonlatka/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lebronjennan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kostaspt/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/karlkanall/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/moynihan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/danpliego/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/saulihirvi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/wesleytrankin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/fjaguero/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bowbrick/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mashaaaaal/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/yassiryahya/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dparrelli/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/fotomagin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aka_james/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/denisepires/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/iqbalperkasa/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/martinansty/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jarsen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/r_oy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/justinrob/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gabrielrosser/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/malgordon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/carlfairclough/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/michaelabehsera/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/pierrestoffe/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/enjoythetau/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/loganjlambert/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rpeezy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/coreyginnivan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/michalhron/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/msveet/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lingeswaran/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kolsvein/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/peter576/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/reideiredale/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joeymurdah/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/raphaelnikson/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mvdheuvel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/maxlinderman/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jimmuirhead/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/begreative/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/frankiefreesbie/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/robturlinckx/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/Talbi_ConSept/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/longlivemyword/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vanchesz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/maiklam/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hermanobrother/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rez___a/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gregsqueeb/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/greenbes/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/_ragzor/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/anthonysukow/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/fluidbrush/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dactrtr/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jehnglynn/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bergmartin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hugocornejo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/_kkga/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dzantievm/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sawalazar/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sovesove/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jonsgotwood/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/byryan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vytautas_a/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mizhgan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cicerobr/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nilshelmersson/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/d33pthought/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/davecraige/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nckjrvs/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/alexandermayes/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jcubic/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/craigrcoles/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bagawarman/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rob_thomas10/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cofla/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/maikelk/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rtgibbons/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/russell_baylis/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mhesslow/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/codysanfilippo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/webtanya/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/madebybrenton/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dcalonaci/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/perfectflow/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jjsiii/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/saarabpreet/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kumarrajan12123/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/iamsteffen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/themikenagle/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ceekaytweet/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/larrybolt/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/conspirator/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dallasbpeters/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/n3dmax/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/terpimost/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/byrnecore/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/j_drake_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/calebjoyce/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/russoedu/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hoangloi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tobysaxon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gofrasdesign/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dimaposnyy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tjisousa/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/okandungel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/billyroshan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/oskamaya/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/motionthinks/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/knilob/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ashocka18/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/marrimo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bartjo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/omnizya/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ernestsemerda/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/andreas_pr/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/edgarchris99/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thomasgeisen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gseguin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joannefournier/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/demersdesigns/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/adammarsbar/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nasirwd/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/n_tassone/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/javorszky/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/themrdave/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/yecidsm/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nicollerich/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/canapud/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nicoleglynn/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/judzhin_miles/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/designervzm/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kianoshp/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/evandrix/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/alterchuca/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dhrubo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ma_tiax/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ssbb_me/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dorphern/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mauriolg/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bruno_mart/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mactopus/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/the_winslet/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joemdesign/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/Shriiiiimp/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jacobbennett/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nfedoroff/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/iamglimy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/allagringaus/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aiiaiiaii/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/olaolusoga/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/buryaknick/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/wim1k/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nicklacke/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/a1chapone/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/steynviljoen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/strikewan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ryankirkman/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/andrewabogado/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/doooon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jagan123/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ariffsetiawan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/elenadissi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mwarkentin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thierrymeier_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/r_garcia/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dmackerman/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/borantula/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/konus/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/spacewood_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ryuchi311/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/evanshajed/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tristanlegros/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/shoaib253/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aislinnkelly/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/okcoker/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/timpetricola/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sunshinedgirl/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chadami/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aleclarsoniv/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nomidesigns/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/petebernardo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/scottiedude/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/millinet/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/imsoper/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/imammuht/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/benjamin_knight/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nepdud/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joki4/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lanceguyatt/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bboy1895/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/amywebbb/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rweve/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/haruintesettden/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ricburton/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nelshd/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/batsirai/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/primozcigler/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jffgrdnr/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/8d3k/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/geneseleznev/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/al_li/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/souperphly/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mslarkina/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/2fockus/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cdavis565/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/xiel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/turkutuuli/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/uxward/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lebinoclard/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gauravjassal/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/davidmerrique/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mdsisto/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/andrewofficer/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kojourin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dnirmal/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kevka/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mr_shiznit/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aluisio_azevedo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cloudstudio/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/danvierich/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/alexivanichkin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/fran_mchamy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/perretmagali/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/betraydan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cadikkara/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/matbeedotcom/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jeremyworboys/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bpartridge/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/michaelkoper/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/silv3rgvn/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/alevizio/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/johnsmithagency/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lawlbwoy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vitor376/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/desastrozo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thimo_cz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jasonmarkjones/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lhausermann/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/xravil/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/guischmitt/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vigobronx/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/panghal0/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/miguelkooreman/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/surgeonist/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/christianoliff/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/caspergrl/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/iamkarna/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ipavelek/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/pierre_nel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/y2graphic/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sterlingrules/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/elbuscainfo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bennyjien/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/stushona/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/estebanuribe/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/embrcecreations/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/danillos/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/elliotlewis/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/charlesrpratt/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vladyn/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/emmeffess/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/carlosblanco_eu/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/leonfedotov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rangafangs/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chris_frees/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tgormtx/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bryan_topham/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jpscribbles/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mighty55/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/carbontwelve/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/isaacfifth/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/iamjdeleon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/snowwrite/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/barputro/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/drewbyreese/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sachacorazzi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bistrianiosip/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/magoo04/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/pehamondello/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/yayteejay/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/a_harris88/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/algunsanabria/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/zforrester/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ovall/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/carlosjgsousa/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/geobikas/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ah_lice/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/looneydoodle/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nerdgr8/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ddggccaa/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/zackeeler/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/normanbox/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/el_fuertisimo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ismail_biltagi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/juangomezw/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jnmnrd/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/patrickcoombe/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ryanjohnson_me/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/markolschesky/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jeffgolenski/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kvasnic/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gauchomatt/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/afusinatto/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kevinoh/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/okansurreel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/adamawesomeface/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/emileboudeling/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/arishi_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/juanmamartinez/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/wikiziner/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/danthms/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mkginfo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/terrorpixel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/curiousonaut/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/prheemo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/michaelcolenso/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/foczzi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/martip07/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thaodang17/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/johncafazza/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/robinlayfield/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/franciscoamk/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/abdulhyeuk/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/marklamb/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/edobene/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/andresenfredrik/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mikaeljorhult/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chrisslowik/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vinciarts/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/meelford/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/elliotnolten/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/yehudab/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vijaykarthik/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bfrohs/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/josep_martins/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/attacks/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sur4dye/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tumski/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/instalox/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mangosango/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/paulfarino/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kazaky999/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kiwiupover/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nvkznemo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tom_even/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ratbus/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/woodsman001/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joshmedeski/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thewillbeard/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/psaikali/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joe_black/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aleinadsays/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/marcusgorillius/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hota_v/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jghyllebert/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/shinze/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/janpalounek/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jeremiespoken/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/her_ruu/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dansowter/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/felipeapiress/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/magugzbrand2d/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/posterjob/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nathalie_fs/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bobbytwoshoes/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dreizle/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jeremymouton/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/elisabethkjaer/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/notbadart/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mohanrohith/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jlsolerdeltoro/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/itskawsar/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/slowspock/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/zvchkelly/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/wiljanslofstra/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/craighenneberry/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/trubeatto/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/juaumlol/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/samscouto/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/BenouarradeM/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gipsy_raf/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/netonet_il/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/arkokoley/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/itsajimithing/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/smalonso/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/victordeanda/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/_dwite_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/richardgarretts/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gregrwilkinson/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/anatolinicolae/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lu4sh1i/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/stefanotirloni/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ostirbu/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/darcystonge/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/naitanamoreno/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/michaelcomiskey/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/adhiardana/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/marcomano_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/davidcazalis/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/falconerie/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gregkilian/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bcrad/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bolzanmarco/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/low_res/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vlajki/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/petar_prog/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jonkspr/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/akmalfikri/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mfacchinello/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/atanism/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/harry_sistalam/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/murrayswift/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bobwassermann/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gavr1l0/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/madshensel/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mr_subtle/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/deviljho_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/salimianoff/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joetruesdell/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/twittypork/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/airskylar/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dnezkumar/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dgajjar/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cherif_b/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/salvafc/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/louis_currie/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/deeenright/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cybind/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/eyronn/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vickyshits/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sweetdelisa/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/cboller1/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/andresdjasso/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/melvindidit/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/andysolomon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thaisselenator_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lvovenok/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/giuliusa/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/belyaev_rs/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/overcloacked/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kamal_chaneman/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/incubo82/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hellofeverrrr/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mhaligowski/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sunlandictwin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bu7921/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/andytlaw/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jeremery/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/finchjke/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/manigm/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/umurgdk/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/scottfeltham/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ganserene/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mutu_krish/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jodytaggart/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ntfblog/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tanveerrao/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hfalucas/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/alxleroydeval/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kucingbelang4/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bargaorobalo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/colgruv/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/stalewine/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kylefrost/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/baumannzone/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/angelcolberg/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sachingawas/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jjshaw14/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ramanathan_pdy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/johndezember/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nilshoenson/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/brandonmorreale/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nutzumi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/brandonflatsoda/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sergeyalmone/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/klefue/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kirangopal/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/baumann_alex/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/matthewkay_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jay_wilburn/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/shesgared/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/apriendeau/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/johnriordan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/wake_gs/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aleksitappura/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/emsgulam/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/xilantra/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/imomenui/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sircalebgrove/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/newbrushes/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hsinyo23/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/m4rio/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/katiemdaly/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/s4f1/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ecommerceil/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/marlinjayakody/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/swooshycueb/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sangdth/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/coderdiaz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bluefx_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vivekprvr/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sasha_shestakov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/eugeneeweb/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dgclegg/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/n1ght_coder/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dixchen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/blakehawksworth/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/trueblood_33/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hai_ninh_nguyen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/marclgonzales/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/yesmeck/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/stephcoue/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/doronmalki/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ruehldesign/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/anasnakawa/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kijanmaharjan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/wearesavas/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/stefvdham/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tweetubhai/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/alecarpentier/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/fiterik/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/antonyryndya/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/d00maz/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/theonlyzeke/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/missaaamy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/carlosm/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/manekenthe/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/reetajayendra/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jeremyshimko/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/justinrgraham/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/stefanozoffoli/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/overra/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mrebay007/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/shvelo96/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/pyronite/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/thedjpetersen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/rtyukmaev/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/_williamguerra/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/albertaugustin/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vikashpathak18/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kevinjohndayy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vj_demien/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/colirpixoil/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/goddardlewis/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/laasli/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jqiuss/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/heycamtaylor/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nastya_mane/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mastermindesign/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ccinojasso1/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/nyancecom/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sandywoodruff/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/bighanddesign/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sbtransparent/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aviddayentonbay/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/richwild/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kaysix_dizzy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/tur8le/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/seyedhossein1/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/privetwagner/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/emmandenn/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dev_essentials/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jmfsocial/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/_yardenoon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mateaodviteza/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/weavermedia/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mufaddal_mw/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hafeeskhan/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ashernatali/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sulaqo/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/eddiechen/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/josecarlospsh/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vm_f/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/enricocicconi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/danmartin70/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/gmourier/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/donjain/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mrxloka/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/_pedropinho/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/eitarafa/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/oscarowusu/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ralph_lam/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/panchajanyag/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/woodydotmx/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/jerrybai1907/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/marshallchen_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/xamorep/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aio___/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/chaabane_wail/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/txcx/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/akashsharma39/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/falling_soul/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sainraja/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mugukamil/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/johannesneu/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/markwienands/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/karthipanraj/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/balakayuriy/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/alan_zhang_/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/layerssss/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/kaspernordkvist/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/mirfanqureshi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/hanna_smi/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/VMilescu/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/aeon56/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/m_kalibry/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/sreejithexp/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dicesales/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/dhoot_amit/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/smenov/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/lonesomelemon/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vladimirdevic/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/joelcipriano/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/haligaliharun/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/buleswapnil/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/serefka/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/ifarafonow/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/vikasvinfotech/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/urrutimeoli/128.jpg",
  "https://s3.amazonaws.com/uifaces/faces/twitter/areandacom/128.jpg"
];

},{}],510:[function(require,module,exports){
module["exports"] = [
  "com",
  "biz",
  "info",
  "name",
  "net",
  "org"
];

},{}],511:[function(require,module,exports){
module["exports"] = [
  "example.org",
  "example.com",
  "example.net"
];

},{}],512:[function(require,module,exports){
arguments[4][378][0].apply(exports,arguments)
},{"dup":378}],513:[function(require,module,exports){
var internet = {};
module['exports'] = internet;
internet.free_email = require("./free_email");
internet.example_email = require("./example_email");
internet.domain_suffix = require("./domain_suffix");
internet.avatar_uri = require("./avatar_uri");

},{"./avatar_uri":509,"./domain_suffix":510,"./example_email":511,"./free_email":512}],514:[function(require,module,exports){
arguments[4][342][0].apply(exports,arguments)
},{"./supplemental":515,"./words":516,"dup":342}],515:[function(require,module,exports){
arguments[4][343][0].apply(exports,arguments)
},{"dup":343}],516:[function(require,module,exports){
arguments[4][344][0].apply(exports,arguments)
},{"dup":344}],517:[function(require,module,exports){
module["exports"] = [
  "Aaliyah",
  "Aaron",
  "Abagail",
  "Abbey",
  "Abbie",
  "Abbigail",
  "Abby",
  "Abdiel",
  "Abdul",
  "Abdullah",
  "Abe",
  "Abel",
  "Abelardo",
  "Abigail",
  "Abigale",
  "Abigayle",
  "Abner",
  "Abraham",
  "Ada",
  "Adah",
  "Adalberto",
  "Adaline",
  "Adam",
  "Adan",
  "Addie",
  "Addison",
  "Adela",
  "Adelbert",
  "Adele",
  "Adelia",
  "Adeline",
  "Adell",
  "Adella",
  "Adelle",
  "Aditya",
  "Adolf",
  "Adolfo",
  "Adolph",
  "Adolphus",
  "Adonis",
  "Adrain",
  "Adrian",
  "Adriana",
  "Adrianna",
  "Adriel",
  "Adrien",
  "Adrienne",
  "Afton",
  "Aglae",
  "Agnes",
  "Agustin",
  "Agustina",
  "Ahmad",
  "Ahmed",
  "Aida",
  "Aidan",
  "Aiden",
  "Aileen",
  "Aimee",
  "Aisha",
  "Aiyana",
  "Akeem",
  "Al",
  "Alaina",
  "Alan",
  "Alana",
  "Alanis",
  "Alanna",
  "Alayna",
  "Alba",
  "Albert",
  "Alberta",
  "Albertha",
  "Alberto",
  "Albin",
  "Albina",
  "Alda",
  "Alden",
  "Alec",
  "Aleen",
  "Alejandra",
  "Alejandrin",
  "Alek",
  "Alena",
  "Alene",
  "Alessandra",
  "Alessandro",
  "Alessia",
  "Aletha",
  "Alex",
  "Alexa",
  "Alexander",
  "Alexandra",
  "Alexandre",
  "Alexandrea",
  "Alexandria",
  "Alexandrine",
  "Alexandro",
  "Alexane",
  "Alexanne",
  "Alexie",
  "Alexis",
  "Alexys",
  "Alexzander",
  "Alf",
  "Alfonso",
  "Alfonzo",
  "Alford",
  "Alfred",
  "Alfreda",
  "Alfredo",
  "Ali",
  "Alia",
  "Alice",
  "Alicia",
  "Alisa",
  "Alisha",
  "Alison",
  "Alivia",
  "Aliya",
  "Aliyah",
  "Aliza",
  "Alize",
  "Allan",
  "Allen",
  "Allene",
  "Allie",
  "Allison",
  "Ally",
  "Alphonso",
  "Alta",
  "Althea",
  "Alva",
  "Alvah",
  "Alvena",
  "Alvera",
  "Alverta",
  "Alvina",
  "Alvis",
  "Alyce",
  "Alycia",
  "Alysa",
  "Alysha",
  "Alyson",
  "Alysson",
  "Amalia",
  "Amanda",
  "Amani",
  "Amara",
  "Amari",
  "Amaya",
  "Amber",
  "Ambrose",
  "Amelia",
  "Amelie",
  "Amely",
  "America",
  "Americo",
  "Amie",
  "Amina",
  "Amir",
  "Amira",
  "Amiya",
  "Amos",
  "Amparo",
  "Amy",
  "Amya",
  "Ana",
  "Anabel",
  "Anabelle",
  "Anahi",
  "Anais",
  "Anastacio",
  "Anastasia",
  "Anderson",
  "Andre",
  "Andreane",
  "Andreanne",
  "Andres",
  "Andrew",
  "Andy",
  "Angel",
  "Angela",
  "Angelica",
  "Angelina",
  "Angeline",
  "Angelita",
  "Angelo",
  "Angie",
  "Angus",
  "Anibal",
  "Anika",
  "Anissa",
  "Anita",
  "Aniya",
  "Aniyah",
  "Anjali",
  "Anna",
  "Annabel",
  "Annabell",
  "Annabelle",
  "Annalise",
  "Annamae",
  "Annamarie",
  "Anne",
  "Annetta",
  "Annette",
  "Annie",
  "Ansel",
  "Ansley",
  "Anthony",
  "Antoinette",
  "Antone",
  "Antonetta",
  "Antonette",
  "Antonia",
  "Antonietta",
  "Antonina",
  "Antonio",
  "Antwan",
  "Antwon",
  "Anya",
  "April",
  "Ara",
  "Araceli",
  "Aracely",
  "Arch",
  "Archibald",
  "Ardella",
  "Arden",
  "Ardith",
  "Arely",
  "Ari",
  "Ariane",
  "Arianna",
  "Aric",
  "Ariel",
  "Arielle",
  "Arjun",
  "Arlene",
  "Arlie",
  "Arlo",
  "Armand",
  "Armando",
  "Armani",
  "Arnaldo",
  "Arne",
  "Arno",
  "Arnold",
  "Arnoldo",
  "Arnulfo",
  "Aron",
  "Art",
  "Arthur",
  "Arturo",
  "Arvel",
  "Arvid",
  "Arvilla",
  "Aryanna",
  "Asa",
  "Asha",
  "Ashlee",
  "Ashleigh",
  "Ashley",
  "Ashly",
  "Ashlynn",
  "Ashton",
  "Ashtyn",
  "Asia",
  "Assunta",
  "Astrid",
  "Athena",
  "Aubree",
  "Aubrey",
  "Audie",
  "Audra",
  "Audreanne",
  "Audrey",
  "August",
  "Augusta",
  "Augustine",
  "Augustus",
  "Aurelia",
  "Aurelie",
  "Aurelio",
  "Aurore",
  "Austen",
  "Austin",
  "Austyn",
  "Autumn",
  "Ava",
  "Avery",
  "Avis",
  "Axel",
  "Ayana",
  "Ayden",
  "Ayla",
  "Aylin",
  "Baby",
  "Bailee",
  "Bailey",
  "Barbara",
  "Barney",
  "Baron",
  "Barrett",
  "Barry",
  "Bart",
  "Bartholome",
  "Barton",
  "Baylee",
  "Beatrice",
  "Beau",
  "Beaulah",
  "Bell",
  "Bella",
  "Belle",
  "Ben",
  "Benedict",
  "Benjamin",
  "Bennett",
  "Bennie",
  "Benny",
  "Benton",
  "Berenice",
  "Bernadette",
  "Bernadine",
  "Bernard",
  "Bernardo",
  "Berneice",
  "Bernhard",
  "Bernice",
  "Bernie",
  "Berniece",
  "Bernita",
  "Berry",
  "Bert",
  "Berta",
  "Bertha",
  "Bertram",
  "Bertrand",
  "Beryl",
  "Bessie",
  "Beth",
  "Bethany",
  "Bethel",
  "Betsy",
  "Bette",
  "Bettie",
  "Betty",
  "Bettye",
  "Beulah",
  "Beverly",
  "Bianka",
  "Bill",
  "Billie",
  "Billy",
  "Birdie",
  "Blair",
  "Blaise",
  "Blake",
  "Blanca",
  "Blanche",
  "Blaze",
  "Bo",
  "Bobbie",
  "Bobby",
  "Bonita",
  "Bonnie",
  "Boris",
  "Boyd",
  "Brad",
  "Braden",
  "Bradford",
  "Bradley",
  "Bradly",
  "Brady",
  "Braeden",
  "Brain",
  "Brandi",
  "Brando",
  "Brandon",
  "Brandt",
  "Brandy",
  "Brandyn",
  "Brannon",
  "Branson",
  "Brant",
  "Braulio",
  "Braxton",
  "Brayan",
  "Breana",
  "Breanna",
  "Breanne",
  "Brenda",
  "Brendan",
  "Brenden",
  "Brendon",
  "Brenna",
  "Brennan",
  "Brennon",
  "Brent",
  "Bret",
  "Brett",
  "Bria",
  "Brian",
  "Briana",
  "Brianne",
  "Brice",
  "Bridget",
  "Bridgette",
  "Bridie",
  "Brielle",
  "Brigitte",
  "Brionna",
  "Brisa",
  "Britney",
  "Brittany",
  "Brock",
  "Broderick",
  "Brody",
  "Brook",
  "Brooke",
  "Brooklyn",
  "Brooks",
  "Brown",
  "Bruce",
  "Bryana",
  "Bryce",
  "Brycen",
  "Bryon",
  "Buck",
  "Bud",
  "Buddy",
  "Buford",
  "Bulah",
  "Burdette",
  "Burley",
  "Burnice",
  "Buster",
  "Cade",
  "Caden",
  "Caesar",
  "Caitlyn",
  "Cale",
  "Caleb",
  "Caleigh",
  "Cali",
  "Calista",
  "Callie",
  "Camden",
  "Cameron",
  "Camila",
  "Camilla",
  "Camille",
  "Camren",
  "Camron",
  "Camryn",
  "Camylle",
  "Candace",
  "Candelario",
  "Candice",
  "Candida",
  "Candido",
  "Cara",
  "Carey",
  "Carissa",
  "Carlee",
  "Carleton",
  "Carley",
  "Carli",
  "Carlie",
  "Carlo",
  "Carlos",
  "Carlotta",
  "Carmel",
  "Carmela",
  "Carmella",
  "Carmelo",
  "Carmen",
  "Carmine",
  "Carol",
  "Carolanne",
  "Carole",
  "Carolina",
  "Caroline",
  "Carolyn",
  "Carolyne",
  "Carrie",
  "Carroll",
  "Carson",
  "Carter",
  "Cary",
  "Casandra",
  "Casey",
  "Casimer",
  "Casimir",
  "Casper",
  "Cassandra",
  "Cassandre",
  "Cassidy",
  "Cassie",
  "Catalina",
  "Caterina",
  "Catharine",
  "Catherine",
  "Cathrine",
  "Cathryn",
  "Cathy",
  "Cayla",
  "Ceasar",
  "Cecelia",
  "Cecil",
  "Cecile",
  "Cecilia",
  "Cedrick",
  "Celestine",
  "Celestino",
  "Celia",
  "Celine",
  "Cesar",
  "Chad",
  "Chadd",
  "Chadrick",
  "Chaim",
  "Chance",
  "Chandler",
  "Chanel",
  "Chanelle",
  "Charity",
  "Charlene",
  "Charles",
  "Charley",
  "Charlie",
  "Charlotte",
  "Chase",
  "Chasity",
  "Chauncey",
  "Chaya",
  "Chaz",
  "Chelsea",
  "Chelsey",
  "Chelsie",
  "Chesley",
  "Chester",
  "Chet",
  "Cheyanne",
  "Cheyenne",
  "Chloe",
  "Chris",
  "Christ",
  "Christa",
  "Christelle",
  "Christian",
  "Christiana",
  "Christina",
  "Christine",
  "Christop",
  "Christophe",
  "Christopher",
  "Christy",
  "Chyna",
  "Ciara",
  "Cicero",
  "Cielo",
  "Cierra",
  "Cindy",
  "Citlalli",
  "Clair",
  "Claire",
  "Clara",
  "Clarabelle",
  "Clare",
  "Clarissa",
  "Clark",
  "Claud",
  "Claude",
  "Claudia",
  "Claudie",
  "Claudine",
  "Clay",
  "Clemens",
  "Clement",
  "Clementina",
  "Clementine",
  "Clemmie",
  "Cleo",
  "Cleora",
  "Cleta",
  "Cletus",
  "Cleve",
  "Cleveland",
  "Clifford",
  "Clifton",
  "Clint",
  "Clinton",
  "Clotilde",
  "Clovis",
  "Cloyd",
  "Clyde",
  "Coby",
  "Cody",
  "Colby",
  "Cole",
  "Coleman",
  "Colin",
  "Colleen",
  "Collin",
  "Colt",
  "Colten",
  "Colton",
  "Columbus",
  "Concepcion",
  "Conner",
  "Connie",
  "Connor",
  "Conor",
  "Conrad",
  "Constance",
  "Constantin",
  "Consuelo",
  "Cooper",
  "Cora",
  "Coralie",
  "Corbin",
  "Cordelia",
  "Cordell",
  "Cordia",
  "Cordie",
  "Corene",
  "Corine",
  "Cornelius",
  "Cornell",
  "Corrine",
  "Cortez",
  "Cortney",
  "Cory",
  "Coty",
  "Courtney",
  "Coy",
  "Craig",
  "Crawford",
  "Creola",
  "Cristal",
  "Cristian",
  "Cristina",
  "Cristobal",
  "Cristopher",
  "Cruz",
  "Crystal",
  "Crystel",
  "Cullen",
  "Curt",
  "Curtis",
  "Cydney",
  "Cynthia",
  "Cyril",
  "Cyrus",
  "Dagmar",
  "Dahlia",
  "Daija",
  "Daisha",
  "Daisy",
  "Dakota",
  "Dale",
  "Dallas",
  "Dallin",
  "Dalton",
  "Damaris",
  "Dameon",
  "Damian",
  "Damien",
  "Damion",
  "Damon",
  "Dan",
  "Dana",
  "Dandre",
  "Dane",
  "D'angelo",
  "Dangelo",
  "Danial",
  "Daniela",
  "Daniella",
  "Danielle",
  "Danika",
  "Dannie",
  "Danny",
  "Dante",
  "Danyka",
  "Daphne",
  "Daphnee",
  "Daphney",
  "Darby",
  "Daren",
  "Darian",
  "Dariana",
  "Darien",
  "Dario",
  "Darion",
  "Darius",
  "Darlene",
  "Daron",
  "Darrel",
  "Darrell",
  "Darren",
  "Darrick",
  "Darrin",
  "Darrion",
  "Darron",
  "Darryl",
  "Darwin",
  "Daryl",
  "Dashawn",
  "Dasia",
  "Dave",
  "David",
  "Davin",
  "Davion",
  "Davon",
  "Davonte",
  "Dawn",
  "Dawson",
  "Dax",
  "Dayana",
  "Dayna",
  "Dayne",
  "Dayton",
  "Dean",
  "Deangelo",
  "Deanna",
  "Deborah",
  "Declan",
  "Dedric",
  "Dedrick",
  "Dee",
  "Deion",
  "Deja",
  "Dejah",
  "Dejon",
  "Dejuan",
  "Delaney",
  "Delbert",
  "Delfina",
  "Delia",
  "Delilah",
  "Dell",
  "Della",
  "Delmer",
  "Delores",
  "Delpha",
  "Delphia",
  "Delphine",
  "Delta",
  "Demarco",
  "Demarcus",
  "Demario",
  "Demetris",
  "Demetrius",
  "Demond",
  "Dena",
  "Denis",
  "Dennis",
  "Deon",
  "Deondre",
  "Deontae",
  "Deonte",
  "Dereck",
  "Derek",
  "Derick",
  "Deron",
  "Derrick",
  "Deshaun",
  "Deshawn",
  "Desiree",
  "Desmond",
  "Dessie",
  "Destany",
  "Destin",
  "Destinee",
  "Destiney",
  "Destini",
  "Destiny",
  "Devan",
  "Devante",
  "Deven",
  "Devin",
  "Devon",
  "Devonte",
  "Devyn",
  "Dewayne",
  "Dewitt",
  "Dexter",
  "Diamond",
  "Diana",
  "Dianna",
  "Diego",
  "Dillan",
  "Dillon",
  "Dimitri",
  "Dina",
  "Dino",
  "Dion",
  "Dixie",
  "Dock",
  "Dolly",
  "Dolores",
  "Domenic",
  "Domenica",
  "Domenick",
  "Domenico",
  "Domingo",
  "Dominic",
  "Dominique",
  "Don",
  "Donald",
  "Donato",
  "Donavon",
  "Donna",
  "Donnell",
  "Donnie",
  "Donny",
  "Dora",
  "Dorcas",
  "Dorian",
  "Doris",
  "Dorothea",
  "Dorothy",
  "Dorris",
  "Dortha",
  "Dorthy",
  "Doug",
  "Douglas",
  "Dovie",
  "Doyle",
  "Drake",
  "Drew",
  "Duane",
  "Dudley",
  "Dulce",
  "Duncan",
  "Durward",
  "Dustin",
  "Dusty",
  "Dwight",
  "Dylan",
  "Earl",
  "Earlene",
  "Earline",
  "Earnest",
  "Earnestine",
  "Easter",
  "Easton",
  "Ebba",
  "Ebony",
  "Ed",
  "Eda",
  "Edd",
  "Eddie",
  "Eden",
  "Edgar",
  "Edgardo",
  "Edison",
  "Edmond",
  "Edmund",
  "Edna",
  "Eduardo",
  "Edward",
  "Edwardo",
  "Edwin",
  "Edwina",
  "Edyth",
  "Edythe",
  "Effie",
  "Efrain",
  "Efren",
  "Eileen",
  "Einar",
  "Eino",
  "Eladio",
  "Elaina",
  "Elbert",
  "Elda",
  "Eldon",
  "Eldora",
  "Eldred",
  "Eldridge",
  "Eleanora",
  "Eleanore",
  "Eleazar",
  "Electa",
  "Elena",
  "Elenor",
  "Elenora",
  "Eleonore",
  "Elfrieda",
  "Eli",
  "Elian",
  "Eliane",
  "Elias",
  "Eliezer",
  "Elijah",
  "Elinor",
  "Elinore",
  "Elisa",
  "Elisabeth",
  "Elise",
  "Eliseo",
  "Elisha",
  "Elissa",
  "Eliza",
  "Elizabeth",
  "Ella",
  "Ellen",
  "Ellie",
  "Elliot",
  "Elliott",
  "Ellis",
  "Ellsworth",
  "Elmer",
  "Elmira",
  "Elmo",
  "Elmore",
  "Elna",
  "Elnora",
  "Elody",
  "Eloisa",
  "Eloise",
  "Elouise",
  "Eloy",
  "Elroy",
  "Elsa",
  "Else",
  "Elsie",
  "Elta",
  "Elton",
  "Elva",
  "Elvera",
  "Elvie",
  "Elvis",
  "Elwin",
  "Elwyn",
  "Elyse",
  "Elyssa",
  "Elza",
  "Emanuel",
  "Emelia",
  "Emelie",
  "Emely",
  "Emerald",
  "Emerson",
  "Emery",
  "Emie",
  "Emil",
  "Emile",
  "Emilia",
  "Emiliano",
  "Emilie",
  "Emilio",
  "Emily",
  "Emma",
  "Emmalee",
  "Emmanuel",
  "Emmanuelle",
  "Emmet",
  "Emmett",
  "Emmie",
  "Emmitt",
  "Emmy",
  "Emory",
  "Ena",
  "Enid",
  "Enoch",
  "Enola",
  "Enos",
  "Enrico",
  "Enrique",
  "Ephraim",
  "Era",
  "Eriberto",
  "Eric",
  "Erica",
  "Erich",
  "Erick",
  "Ericka",
  "Erik",
  "Erika",
  "Erin",
  "Erling",
  "Erna",
  "Ernest",
  "Ernestina",
  "Ernestine",
  "Ernesto",
  "Ernie",
  "Ervin",
  "Erwin",
  "Eryn",
  "Esmeralda",
  "Esperanza",
  "Esta",
  "Esteban",
  "Estefania",
  "Estel",
  "Estell",
  "Estella",
  "Estelle",
  "Estevan",
  "Esther",
  "Estrella",
  "Etha",
  "Ethan",
  "Ethel",
  "Ethelyn",
  "Ethyl",
  "Ettie",
  "Eudora",
  "Eugene",
  "Eugenia",
  "Eula",
  "Eulah",
  "Eulalia",
  "Euna",
  "Eunice",
  "Eusebio",
  "Eva",
  "Evalyn",
  "Evan",
  "Evangeline",
  "Evans",
  "Eve",
  "Eveline",
  "Evelyn",
  "Everardo",
  "Everett",
  "Everette",
  "Evert",
  "Evie",
  "Ewald",
  "Ewell",
  "Ezekiel",
  "Ezequiel",
  "Ezra",
  "Fabian",
  "Fabiola",
  "Fae",
  "Fannie",
  "Fanny",
  "Fatima",
  "Faustino",
  "Fausto",
  "Favian",
  "Fay",
  "Faye",
  "Federico",
  "Felicia",
  "Felicita",
  "Felicity",
  "Felipa",
  "Felipe",
  "Felix",
  "Felton",
  "Fermin",
  "Fern",
  "Fernando",
  "Ferne",
  "Fidel",
  "Filiberto",
  "Filomena",
  "Finn",
  "Fiona",
  "Flavie",
  "Flavio",
  "Fleta",
  "Fletcher",
  "Flo",
  "Florence",
  "Florencio",
  "Florian",
  "Florida",
  "Florine",
  "Flossie",
  "Floy",
  "Floyd",
  "Ford",
  "Forest",
  "Forrest",
  "Foster",
  "Frances",
  "Francesca",
  "Francesco",
  "Francis",
  "Francisca",
  "Francisco",
  "Franco",
  "Frank",
  "Frankie",
  "Franz",
  "Fred",
  "Freda",
  "Freddie",
  "Freddy",
  "Frederic",
  "Frederick",
  "Frederik",
  "Frederique",
  "Fredrick",
  "Fredy",
  "Freeda",
  "Freeman",
  "Freida",
  "Frida",
  "Frieda",
  "Friedrich",
  "Fritz",
  "Furman",
  "Gabe",
  "Gabriel",
  "Gabriella",
  "Gabrielle",
  "Gaetano",
  "Gage",
  "Gail",
  "Gardner",
  "Garett",
  "Garfield",
  "Garland",
  "Garnet",
  "Garnett",
  "Garret",
  "Garrett",
  "Garrick",
  "Garrison",
  "Garry",
  "Garth",
  "Gaston",
  "Gavin",
  "Gay",
  "Gayle",
  "Gaylord",
  "Gene",
  "General",
  "Genesis",
  "Genevieve",
  "Gennaro",
  "Genoveva",
  "Geo",
  "Geoffrey",
  "George",
  "Georgette",
  "Georgiana",
  "Georgianna",
  "Geovanni",
  "Geovanny",
  "Geovany",
  "Gerald",
  "Geraldine",
  "Gerard",
  "Gerardo",
  "Gerda",
  "Gerhard",
  "Germaine",
  "German",
  "Gerry",
  "Gerson",
  "Gertrude",
  "Gia",
  "Gianni",
  "Gideon",
  "Gilbert",
  "Gilberto",
  "Gilda",
  "Giles",
  "Gillian",
  "Gina",
  "Gino",
  "Giovani",
  "Giovanna",
  "Giovanni",
  "Giovanny",
  "Gisselle",
  "Giuseppe",
  "Gladyce",
  "Gladys",
  "Glen",
  "Glenda",
  "Glenna",
  "Glennie",
  "Gloria",
  "Godfrey",
  "Golda",
  "Golden",
  "Gonzalo",
  "Gordon",
  "Grace",
  "Gracie",
  "Graciela",
  "Grady",
  "Graham",
  "Grant",
  "Granville",
  "Grayce",
  "Grayson",
  "Green",
  "Greg",
  "Gregg",
  "Gregoria",
  "Gregorio",
  "Gregory",
  "Greta",
  "Gretchen",
  "Greyson",
  "Griffin",
  "Grover",
  "Guadalupe",
  "Gudrun",
  "Guido",
  "Guillermo",
  "Guiseppe",
  "Gunnar",
  "Gunner",
  "Gus",
  "Gussie",
  "Gust",
  "Gustave",
  "Guy",
  "Gwen",
  "Gwendolyn",
  "Hadley",
  "Hailee",
  "Hailey",
  "Hailie",
  "Hal",
  "Haleigh",
  "Haley",
  "Halie",
  "Halle",
  "Hallie",
  "Hank",
  "Hanna",
  "Hannah",
  "Hans",
  "Hardy",
  "Harley",
  "Harmon",
  "Harmony",
  "Harold",
  "Harrison",
  "Harry",
  "Harvey",
  "Haskell",
  "Hassan",
  "Hassie",
  "Hattie",
  "Haven",
  "Hayden",
  "Haylee",
  "Hayley",
  "Haylie",
  "Hazel",
  "Hazle",
  "Heath",
  "Heather",
  "Heaven",
  "Heber",
  "Hector",
  "Heidi",
  "Helen",
  "Helena",
  "Helene",
  "Helga",
  "Hellen",
  "Helmer",
  "Heloise",
  "Henderson",
  "Henri",
  "Henriette",
  "Henry",
  "Herbert",
  "Herman",
  "Hermann",
  "Hermina",
  "Herminia",
  "Herminio",
  "Hershel",
  "Herta",
  "Hertha",
  "Hester",
  "Hettie",
  "Hilario",
  "Hilbert",
  "Hilda",
  "Hildegard",
  "Hillard",
  "Hillary",
  "Hilma",
  "Hilton",
  "Hipolito",
  "Hiram",
  "Hobart",
  "Holden",
  "Hollie",
  "Hollis",
  "Holly",
  "Hope",
  "Horace",
  "Horacio",
  "Hortense",
  "Hosea",
  "Houston",
  "Howard",
  "Howell",
  "Hoyt",
  "Hubert",
  "Hudson",
  "Hugh",
  "Hulda",
  "Humberto",
  "Hunter",
  "Hyman",
  "Ian",
  "Ibrahim",
  "Icie",
  "Ida",
  "Idell",
  "Idella",
  "Ignacio",
  "Ignatius",
  "Ike",
  "Ila",
  "Ilene",
  "Iliana",
  "Ima",
  "Imani",
  "Imelda",
  "Immanuel",
  "Imogene",
  "Ines",
  "Irma",
  "Irving",
  "Irwin",
  "Isaac",
  "Isabel",
  "Isabell",
  "Isabella",
  "Isabelle",
  "Isac",
  "Isadore",
  "Isai",
  "Isaiah",
  "Isaias",
  "Isidro",
  "Ismael",
  "Isobel",
  "Isom",
  "Israel",
  "Issac",
  "Itzel",
  "Iva",
  "Ivah",
  "Ivory",
  "Ivy",
  "Izabella",
  "Izaiah",
  "Jabari",
  "Jace",
  "Jacey",
  "Jacinthe",
  "Jacinto",
  "Jack",
  "Jackeline",
  "Jackie",
  "Jacklyn",
  "Jackson",
  "Jacky",
  "Jaclyn",
  "Jacquelyn",
  "Jacques",
  "Jacynthe",
  "Jada",
  "Jade",
  "Jaden",
  "Jadon",
  "Jadyn",
  "Jaeden",
  "Jaida",
  "Jaiden",
  "Jailyn",
  "Jaime",
  "Jairo",
  "Jakayla",
  "Jake",
  "Jakob",
  "Jaleel",
  "Jalen",
  "Jalon",
  "Jalyn",
  "Jamaal",
  "Jamal",
  "Jamar",
  "Jamarcus",
  "Jamel",
  "Jameson",
  "Jamey",
  "Jamie",
  "Jamil",
  "Jamir",
  "Jamison",
  "Jammie",
  "Jan",
  "Jana",
  "Janae",
  "Jane",
  "Janelle",
  "Janessa",
  "Janet",
  "Janice",
  "Janick",
  "Janie",
  "Janis",
  "Janiya",
  "Jannie",
  "Jany",
  "Jaquan",
  "Jaquelin",
  "Jaqueline",
  "Jared",
  "Jaren",
  "Jarod",
  "Jaron",
  "Jarred",
  "Jarrell",
  "Jarret",
  "Jarrett",
  "Jarrod",
  "Jarvis",
  "Jasen",
  "Jasmin",
  "Jason",
  "Jasper",
  "Jaunita",
  "Javier",
  "Javon",
  "Javonte",
  "Jay",
  "Jayce",
  "Jaycee",
  "Jayda",
  "Jayde",
  "Jayden",
  "Jaydon",
  "Jaylan",
  "Jaylen",
  "Jaylin",
  "Jaylon",
  "Jayme",
  "Jayne",
  "Jayson",
  "Jazlyn",
  "Jazmin",
  "Jazmyn",
  "Jazmyne",
  "Jean",
  "Jeanette",
  "Jeanie",
  "Jeanne",
  "Jed",
  "Jedediah",
  "Jedidiah",
  "Jeff",
  "Jefferey",
  "Jeffery",
  "Jeffrey",
  "Jeffry",
  "Jena",
  "Jenifer",
  "Jennie",
  "Jennifer",
  "Jennings",
  "Jennyfer",
  "Jensen",
  "Jerad",
  "Jerald",
  "Jeramie",
  "Jeramy",
  "Jerel",
  "Jeremie",
  "Jeremy",
  "Jermain",
  "Jermaine",
  "Jermey",
  "Jerod",
  "Jerome",
  "Jeromy",
  "Jerrell",
  "Jerrod",
  "Jerrold",
  "Jerry",
  "Jess",
  "Jesse",
  "Jessica",
  "Jessie",
  "Jessika",
  "Jessy",
  "Jessyca",
  "Jesus",
  "Jett",
  "Jettie",
  "Jevon",
  "Jewel",
  "Jewell",
  "Jillian",
  "Jimmie",
  "Jimmy",
  "Jo",
  "Joan",
  "Joana",
  "Joanie",
  "Joanne",
  "Joannie",
  "Joanny",
  "Joany",
  "Joaquin",
  "Jocelyn",
  "Jodie",
  "Jody",
  "Joe",
  "Joel",
  "Joelle",
  "Joesph",
  "Joey",
  "Johan",
  "Johann",
  "Johanna",
  "Johathan",
  "John",
  "Johnathan",
  "Johnathon",
  "Johnnie",
  "Johnny",
  "Johnpaul",
  "Johnson",
  "Jolie",
  "Jon",
  "Jonas",
  "Jonatan",
  "Jonathan",
  "Jonathon",
  "Jordan",
  "Jordane",
  "Jordi",
  "Jordon",
  "Jordy",
  "Jordyn",
  "Jorge",
  "Jose",
  "Josefa",
  "Josefina",
  "Joseph",
  "Josephine",
  "Josh",
  "Joshua",
  "Joshuah",
  "Josiah",
  "Josiane",
  "Josianne",
  "Josie",
  "Josue",
  "Jovan",
  "Jovani",
  "Jovanny",
  "Jovany",
  "Joy",
  "Joyce",
  "Juana",
  "Juanita",
  "Judah",
  "Judd",
  "Jude",
  "Judge",
  "Judson",
  "Judy",
  "Jules",
  "Julia",
  "Julian",
  "Juliana",
  "Julianne",
  "Julie",
  "Julien",
  "Juliet",
  "Julio",
  "Julius",
  "June",
  "Junior",
  "Junius",
  "Justen",
  "Justice",
  "Justina",
  "Justine",
  "Juston",
  "Justus",
  "Justyn",
  "Juvenal",
  "Juwan",
  "Kacey",
  "Kaci",
  "Kacie",
  "Kade",
  "Kaden",
  "Kadin",
  "Kaela",
  "Kaelyn",
  "Kaia",
  "Kailee",
  "Kailey",
  "Kailyn",
  "Kaitlin",
  "Kaitlyn",
  "Kale",
  "Kaleb",
  "Kaleigh",
  "Kaley",
  "Kali",
  "Kallie",
  "Kameron",
  "Kamille",
  "Kamren",
  "Kamron",
  "Kamryn",
  "Kane",
  "Kara",
  "Kareem",
  "Karelle",
  "Karen",
  "Kari",
  "Kariane",
  "Karianne",
  "Karina",
  "Karine",
  "Karl",
  "Karlee",
  "Karley",
  "Karli",
  "Karlie",
  "Karolann",
  "Karson",
  "Kasandra",
  "Kasey",
  "Kassandra",
  "Katarina",
  "Katelin",
  "Katelyn",
  "Katelynn",
  "Katharina",
  "Katherine",
  "Katheryn",
  "Kathleen",
  "Kathlyn",
  "Kathryn",
  "Kathryne",
  "Katlyn",
  "Katlynn",
  "Katrina",
  "Katrine",
  "Kattie",
  "Kavon",
  "Kay",
  "Kaya",
  "Kaycee",
  "Kayden",
  "Kayla",
  "Kaylah",
  "Kaylee",
  "Kayleigh",
  "Kayley",
  "Kayli",
  "Kaylie",
  "Kaylin",
  "Keagan",
  "Keanu",
  "Keara",
  "Keaton",
  "Keegan",
  "Keeley",
  "Keely",
  "Keenan",
  "Keira",
  "Keith",
  "Kellen",
  "Kelley",
  "Kelli",
  "Kellie",
  "Kelly",
  "Kelsi",
  "Kelsie",
  "Kelton",
  "Kelvin",
  "Ken",
  "Kendall",
  "Kendra",
  "Kendrick",
  "Kenna",
  "Kennedi",
  "Kennedy",
  "Kenneth",
  "Kennith",
  "Kenny",
  "Kenton",
  "Kenya",
  "Kenyatta",
  "Kenyon",
  "Keon",
  "Keshaun",
  "Keshawn",
  "Keven",
  "Kevin",
  "Kevon",
  "Keyon",
  "Keyshawn",
  "Khalid",
  "Khalil",
  "Kian",
  "Kiana",
  "Kianna",
  "Kiara",
  "Kiarra",
  "Kiel",
  "Kiera",
  "Kieran",
  "Kiley",
  "Kim",
  "Kimberly",
  "King",
  "Kip",
  "Kira",
  "Kirk",
  "Kirsten",
  "Kirstin",
  "Kitty",
  "Kobe",
  "Koby",
  "Kody",
  "Kolby",
  "Kole",
  "Korbin",
  "Korey",
  "Kory",
  "Kraig",
  "Kris",
  "Krista",
  "Kristian",
  "Kristin",
  "Kristina",
  "Kristofer",
  "Kristoffer",
  "Kristopher",
  "Kristy",
  "Krystal",
  "Krystel",
  "Krystina",
  "Kurt",
  "Kurtis",
  "Kyla",
  "Kyle",
  "Kylee",
  "Kyleigh",
  "Kyler",
  "Kylie",
  "Kyra",
  "Lacey",
  "Lacy",
  "Ladarius",
  "Lafayette",
  "Laila",
  "Laisha",
  "Lamar",
  "Lambert",
  "Lamont",
  "Lance",
  "Landen",
  "Lane",
  "Laney",
  "Larissa",
  "Laron",
  "Larry",
  "Larue",
  "Laura",
  "Laurel",
  "Lauren",
  "Laurence",
  "Lauretta",
  "Lauriane",
  "Laurianne",
  "Laurie",
  "Laurine",
  "Laury",
  "Lauryn",
  "Lavada",
  "Lavern",
  "Laverna",
  "Laverne",
  "Lavina",
  "Lavinia",
  "Lavon",
  "Lavonne",
  "Lawrence",
  "Lawson",
  "Layla",
  "Layne",
  "Lazaro",
  "Lea",
  "Leann",
  "Leanna",
  "Leanne",
  "Leatha",
  "Leda",
  "Lee",
  "Leif",
  "Leila",
  "Leilani",
  "Lela",
  "Lelah",
  "Leland",
  "Lelia",
  "Lempi",
  "Lemuel",
  "Lenna",
  "Lennie",
  "Lenny",
  "Lenora",
  "Lenore",
  "Leo",
  "Leola",
  "Leon",
  "Leonard",
  "Leonardo",
  "Leone",
  "Leonel",
  "Leonie",
  "Leonor",
  "Leonora",
  "Leopold",
  "Leopoldo",
  "Leora",
  "Lera",
  "Lesley",
  "Leslie",
  "Lesly",
  "Lessie",
  "Lester",
  "Leta",
  "Letha",
  "Letitia",
  "Levi",
  "Lew",
  "Lewis",
  "Lexi",
  "Lexie",
  "Lexus",
  "Lia",
  "Liam",
  "Liana",
  "Libbie",
  "Libby",
  "Lila",
  "Lilian",
  "Liliana",
  "Liliane",
  "Lilla",
  "Lillian",
  "Lilliana",
  "Lillie",
  "Lilly",
  "Lily",
  "Lilyan",
  "Lina",
  "Lincoln",
  "Linda",
  "Lindsay",
  "Lindsey",
  "Linnea",
  "Linnie",
  "Linwood",
  "Lionel",
  "Lisa",
  "Lisandro",
  "Lisette",
  "Litzy",
  "Liza",
  "Lizeth",
  "Lizzie",
  "Llewellyn",
  "Lloyd",
  "Logan",
  "Lois",
  "Lola",
  "Lolita",
  "Loma",
  "Lon",
  "London",
  "Lonie",
  "Lonnie",
  "Lonny",
  "Lonzo",
  "Lora",
  "Loraine",
  "Loren",
  "Lorena",
  "Lorenz",
  "Lorenza",
  "Lorenzo",
  "Lori",
  "Lorine",
  "Lorna",
  "Lottie",
  "Lou",
  "Louie",
  "Louisa",
  "Lourdes",
  "Louvenia",
  "Lowell",
  "Loy",
  "Loyal",
  "Loyce",
  "Lucas",
  "Luciano",
  "Lucie",
  "Lucienne",
  "Lucile",
  "Lucinda",
  "Lucio",
  "Lucious",
  "Lucius",
  "Lucy",
  "Ludie",
  "Ludwig",
  "Lue",
  "Luella",
  "Luigi",
  "Luis",
  "Luisa",
  "Lukas",
  "Lula",
  "Lulu",
  "Luna",
  "Lupe",
  "Lura",
  "Lurline",
  "Luther",
  "Luz",
  "Lyda",
  "Lydia",
  "Lyla",
  "Lynn",
  "Lyric",
  "Lysanne",
  "Mabel",
  "Mabelle",
  "Mable",
  "Mac",
  "Macey",
  "Maci",
  "Macie",
  "Mack",
  "Mackenzie",
  "Macy",
  "Madaline",
  "Madalyn",
  "Maddison",
  "Madeline",
  "Madelyn",
  "Madelynn",
  "Madge",
  "Madie",
  "Madilyn",
  "Madisen",
  "Madison",
  "Madisyn",
  "Madonna",
  "Madyson",
  "Mae",
  "Maegan",
  "Maeve",
  "Mafalda",
  "Magali",
  "Magdalen",
  "Magdalena",
  "Maggie",
  "Magnolia",
  "Magnus",
  "Maia",
  "Maida",
  "Maiya",
  "Major",
  "Makayla",
  "Makenna",
  "Makenzie",
  "Malachi",
  "Malcolm",
  "Malika",
  "Malinda",
  "Mallie",
  "Mallory",
  "Malvina",
  "Mandy",
  "Manley",
  "Manuel",
  "Manuela",
  "Mara",
  "Marc",
  "Marcel",
  "Marcelina",
  "Marcelino",
  "Marcella",
  "Marcelle",
  "Marcellus",
  "Marcelo",
  "Marcia",
  "Marco",
  "Marcos",
  "Marcus",
  "Margaret",
  "Margarete",
  "Margarett",
  "Margaretta",
  "Margarette",
  "Margarita",
  "Marge",
  "Margie",
  "Margot",
  "Margret",
  "Marguerite",
  "Maria",
  "Mariah",
  "Mariam",
  "Marian",
  "Mariana",
  "Mariane",
  "Marianna",
  "Marianne",
  "Mariano",
  "Maribel",
  "Marie",
  "Mariela",
  "Marielle",
  "Marietta",
  "Marilie",
  "Marilou",
  "Marilyne",
  "Marina",
  "Mario",
  "Marion",
  "Marisa",
  "Marisol",
  "Maritza",
  "Marjolaine",
  "Marjorie",
  "Marjory",
  "Mark",
  "Markus",
  "Marlee",
  "Marlen",
  "Marlene",
  "Marley",
  "Marlin",
  "Marlon",
  "Marques",
  "Marquis",
  "Marquise",
  "Marshall",
  "Marta",
  "Martin",
  "Martina",
  "Martine",
  "Marty",
  "Marvin",
  "Mary",
  "Maryam",
  "Maryjane",
  "Maryse",
  "Mason",
  "Mateo",
  "Mathew",
  "Mathias",
  "Mathilde",
  "Matilda",
  "Matilde",
  "Matt",
  "Matteo",
  "Mattie",
  "Maud",
  "Maude",
  "Maudie",
  "Maureen",
  "Maurice",
  "Mauricio",
  "Maurine",
  "Maverick",
  "Mavis",
  "Max",
  "Maxie",
  "Maxime",
  "Maximilian",
  "Maximillia",
  "Maximillian",
  "Maximo",
  "Maximus",
  "Maxine",
  "Maxwell",
  "May",
  "Maya",
  "Maybell",
  "Maybelle",
  "Maye",
  "Maymie",
  "Maynard",
  "Mayra",
  "Mazie",
  "Mckayla",
  "Mckenna",
  "Mckenzie",
  "Meagan",
  "Meaghan",
  "Meda",
  "Megane",
  "Meggie",
  "Meghan",
  "Mekhi",
  "Melany",
  "Melba",
  "Melisa",
  "Melissa",
  "Mellie",
  "Melody",
  "Melvin",
  "Melvina",
  "Melyna",
  "Melyssa",
  "Mercedes",
  "Meredith",
  "Merl",
  "Merle",
  "Merlin",
  "Merritt",
  "Mertie",
  "Mervin",
  "Meta",
  "Mia",
  "Micaela",
  "Micah",
  "Michael",
  "Michaela",
  "Michale",
  "Micheal",
  "Michel",
  "Michele",
  "Michelle",
  "Miguel",
  "Mikayla",
  "Mike",
  "Mikel",
  "Milan",
  "Miles",
  "Milford",
  "Miller",
  "Millie",
  "Milo",
  "Milton",
  "Mina",
  "Minerva",
  "Minnie",
  "Miracle",
  "Mireille",
  "Mireya",
  "Misael",
  "Missouri",
  "Misty",
  "Mitchel",
  "Mitchell",
  "Mittie",
  "Modesta",
  "Modesto",
  "Mohamed",
  "Mohammad",
  "Mohammed",
  "Moises",
  "Mollie",
  "Molly",
  "Mona",
  "Monica",
  "Monique",
  "Monroe",
  "Monserrat",
  "Monserrate",
  "Montana",
  "Monte",
  "Monty",
  "Morgan",
  "Moriah",
  "Morris",
  "Mortimer",
  "Morton",
  "Mose",
  "Moses",
  "Moshe",
  "Mossie",
  "Mozell",
  "Mozelle",
  "Muhammad",
  "Muriel",
  "Murl",
  "Murphy",
  "Murray",
  "Mustafa",
  "Mya",
  "Myah",
  "Mylene",
  "Myles",
  "Myra",
  "Myriam",
  "Myrl",
  "Myrna",
  "Myron",
  "Myrtice",
  "Myrtie",
  "Myrtis",
  "Myrtle",
  "Nadia",
  "Nakia",
  "Name",
  "Nannie",
  "Naomi",
  "Naomie",
  "Napoleon",
  "Narciso",
  "Nash",
  "Nasir",
  "Nat",
  "Natalia",
  "Natalie",
  "Natasha",
  "Nathan",
  "Nathanael",
  "Nathanial",
  "Nathaniel",
  "Nathen",
  "Nayeli",
  "Neal",
  "Ned",
  "Nedra",
  "Neha",
  "Neil",
  "Nelda",
  "Nella",
  "Nelle",
  "Nellie",
  "Nels",
  "Nelson",
  "Neoma",
  "Nestor",
  "Nettie",
  "Neva",
  "Newell",
  "Newton",
  "Nia",
  "Nicholas",
  "Nicholaus",
  "Nichole",
  "Nick",
  "Nicklaus",
  "Nickolas",
  "Nico",
  "Nicola",
  "Nicolas",
  "Nicole",
  "Nicolette",
  "Nigel",
  "Nikita",
  "Nikki",
  "Nikko",
  "Niko",
  "Nikolas",
  "Nils",
  "Nina",
  "Noah",
  "Noble",
  "Noe",
  "Noel",
  "Noelia",
  "Noemi",
  "Noemie",
  "Noemy",
  "Nola",
  "Nolan",
  "Nona",
  "Nora",
  "Norbert",
  "Norberto",
  "Norene",
  "Norma",
  "Norris",
  "Norval",
  "Norwood",
  "Nova",
  "Novella",
  "Nya",
  "Nyah",
  "Nyasia",
  "Obie",
  "Oceane",
  "Ocie",
  "Octavia",
  "Oda",
  "Odell",
  "Odessa",
  "Odie",
  "Ofelia",
  "Okey",
  "Ola",
  "Olaf",
  "Ole",
  "Olen",
  "Oleta",
  "Olga",
  "Olin",
  "Oliver",
  "Ollie",
  "Oma",
  "Omari",
  "Omer",
  "Ona",
  "Onie",
  "Opal",
  "Ophelia",
  "Ora",
  "Oral",
  "Oran",
  "Oren",
  "Orie",
  "Orin",
  "Orion",
  "Orland",
  "Orlando",
  "Orlo",
  "Orpha",
  "Orrin",
  "Orval",
  "Orville",
  "Osbaldo",
  "Osborne",
  "Oscar",
  "Osvaldo",
  "Oswald",
  "Oswaldo",
  "Otha",
  "Otho",
  "Otilia",
  "Otis",
  "Ottilie",
  "Ottis",
  "Otto",
  "Ova",
  "Owen",
  "Ozella",
  "Pablo",
  "Paige",
  "Palma",
  "Pamela",
  "Pansy",
  "Paolo",
  "Paris",
  "Parker",
  "Pascale",
  "Pasquale",
  "Pat",
  "Patience",
  "Patricia",
  "Patrick",
  "Patsy",
  "Pattie",
  "Paul",
  "Paula",
  "Pauline",
  "Paxton",
  "Payton",
  "Pearl",
  "Pearlie",
  "Pearline",
  "Pedro",
  "Peggie",
  "Penelope",
  "Percival",
  "Percy",
  "Perry",
  "Pete",
  "Peter",
  "Petra",
  "Peyton",
  "Philip",
  "Phoebe",
  "Phyllis",
  "Pierce",
  "Pierre",
  "Pietro",
  "Pink",
  "Pinkie",
  "Piper",
  "Polly",
  "Porter",
  "Precious",
  "Presley",
  "Preston",
  "Price",
  "Prince",
  "Princess",
  "Priscilla",
  "Providenci",
  "Prudence",
  "Queen",
  "Queenie",
  "Quentin",
  "Quincy",
  "Quinn",
  "Quinten",
  "Quinton",
  "Rachael",
  "Rachel",
  "Rachelle",
  "Rae",
  "Raegan",
  "Rafael",
  "Rafaela",
  "Raheem",
  "Rahsaan",
  "Rahul",
  "Raina",
  "Raleigh",
  "Ralph",
  "Ramiro",
  "Ramon",
  "Ramona",
  "Randal",
  "Randall",
  "Randi",
  "Randy",
  "Ransom",
  "Raoul",
  "Raphael",
  "Raphaelle",
  "Raquel",
  "Rashad",
  "Rashawn",
  "Rasheed",
  "Raul",
  "Raven",
  "Ray",
  "Raymond",
  "Raymundo",
  "Reagan",
  "Reanna",
  "Reba",
  "Rebeca",
  "Rebecca",
  "Rebeka",
  "Rebekah",
  "Reece",
  "Reed",
  "Reese",
  "Regan",
  "Reggie",
  "Reginald",
  "Reid",
  "Reilly",
  "Reina",
  "Reinhold",
  "Remington",
  "Rene",
  "Renee",
  "Ressie",
  "Reta",
  "Retha",
  "Retta",
  "Reuben",
  "Reva",
  "Rex",
  "Rey",
  "Reyes",
  "Reymundo",
  "Reyna",
  "Reynold",
  "Rhea",
  "Rhett",
  "Rhianna",
  "Rhiannon",
  "Rhoda",
  "Ricardo",
  "Richard",
  "Richie",
  "Richmond",
  "Rick",
  "Rickey",
  "Rickie",
  "Ricky",
  "Rico",
  "Rigoberto",
  "Riley",
  "Rita",
  "River",
  "Robb",
  "Robbie",
  "Robert",
  "Roberta",
  "Roberto",
  "Robin",
  "Robyn",
  "Rocio",
  "Rocky",
  "Rod",
  "Roderick",
  "Rodger",
  "Rodolfo",
  "Rodrick",
  "Rodrigo",
  "Roel",
  "Rogelio",
  "Roger",
  "Rogers",
  "Rolando",
  "Rollin",
  "Roma",
  "Romaine",
  "Roman",
  "Ron",
  "Ronaldo",
  "Ronny",
  "Roosevelt",
  "Rory",
  "Rosa",
  "Rosalee",
  "Rosalia",
  "Rosalind",
  "Rosalinda",
  "Rosalyn",
  "Rosamond",
  "Rosanna",
  "Rosario",
  "Roscoe",
  "Rose",
  "Rosella",
  "Roselyn",
  "Rosemarie",
  "Rosemary",
  "Rosendo",
  "Rosetta",
  "Rosie",
  "Rosina",
  "Roslyn",
  "Ross",
  "Rossie",
  "Rowan",
  "Rowena",
  "Rowland",
  "Roxane",
  "Roxanne",
  "Roy",
  "Royal",
  "Royce",
  "Rozella",
  "Ruben",
  "Rubie",
  "Ruby",
  "Rubye",
  "Rudolph",
  "Rudy",
  "Rupert",
  "Russ",
  "Russel",
  "Russell",
  "Rusty",
  "Ruth",
  "Ruthe",
  "Ruthie",
  "Ryan",
  "Ryann",
  "Ryder",
  "Rylan",
  "Rylee",
  "Ryleigh",
  "Ryley",
  "Sabina",
  "Sabrina",
  "Sabryna",
  "Sadie",
  "Sadye",
  "Sage",
  "Saige",
  "Sallie",
  "Sally",
  "Salma",
  "Salvador",
  "Salvatore",
  "Sam",
  "Samanta",
  "Samantha",
  "Samara",
  "Samir",
  "Sammie",
  "Sammy",
  "Samson",
  "Sandra",
  "Sandrine",
  "Sandy",
  "Sanford",
  "Santa",
  "Santiago",
  "Santina",
  "Santino",
  "Santos",
  "Sarah",
  "Sarai",
  "Sarina",
  "Sasha",
  "Saul",
  "Savanah",
  "Savanna",
  "Savannah",
  "Savion",
  "Scarlett",
  "Schuyler",
  "Scot",
  "Scottie",
  "Scotty",
  "Seamus",
  "Sean",
  "Sebastian",
  "Sedrick",
  "Selena",
  "Selina",
  "Selmer",
  "Serena",
  "Serenity",
  "Seth",
  "Shad",
  "Shaina",
  "Shakira",
  "Shana",
  "Shane",
  "Shanel",
  "Shanelle",
  "Shania",
  "Shanie",
  "Shaniya",
  "Shanna",
  "Shannon",
  "Shanny",
  "Shanon",
  "Shany",
  "Sharon",
  "Shaun",
  "Shawn",
  "Shawna",
  "Shaylee",
  "Shayna",
  "Shayne",
  "Shea",
  "Sheila",
  "Sheldon",
  "Shemar",
  "Sheridan",
  "Sherman",
  "Sherwood",
  "Shirley",
  "Shyann",
  "Shyanne",
  "Sibyl",
  "Sid",
  "Sidney",
  "Sienna",
  "Sierra",
  "Sigmund",
  "Sigrid",
  "Sigurd",
  "Silas",
  "Sim",
  "Simeon",
  "Simone",
  "Sincere",
  "Sister",
  "Skye",
  "Skyla",
  "Skylar",
  "Sofia",
  "Soledad",
  "Solon",
  "Sonia",
  "Sonny",
  "Sonya",
  "Sophia",
  "Sophie",
  "Spencer",
  "Stacey",
  "Stacy",
  "Stan",
  "Stanford",
  "Stanley",
  "Stanton",
  "Stefan",
  "Stefanie",
  "Stella",
  "Stephan",
  "Stephania",
  "Stephanie",
  "Stephany",
  "Stephen",
  "Stephon",
  "Sterling",
  "Steve",
  "Stevie",
  "Stewart",
  "Stone",
  "Stuart",
  "Summer",
  "Sunny",
  "Susan",
  "Susana",
  "Susanna",
  "Susie",
  "Suzanne",
  "Sven",
  "Syble",
  "Sydnee",
  "Sydney",
  "Sydni",
  "Sydnie",
  "Sylvan",
  "Sylvester",
  "Sylvia",
  "Tabitha",
  "Tad",
  "Talia",
  "Talon",
  "Tamara",
  "Tamia",
  "Tania",
  "Tanner",
  "Tanya",
  "Tara",
  "Taryn",
  "Tate",
  "Tatum",
  "Tatyana",
  "Taurean",
  "Tavares",
  "Taya",
  "Taylor",
  "Teagan",
  "Ted",
  "Telly",
  "Terence",
  "Teresa",
  "Terrance",
  "Terrell",
  "Terrence",
  "Terrill",
  "Terry",
  "Tess",
  "Tessie",
  "Tevin",
  "Thad",
  "Thaddeus",
  "Thalia",
  "Thea",
  "Thelma",
  "Theo",
  "Theodora",
  "Theodore",
  "Theresa",
  "Therese",
  "Theresia",
  "Theron",
  "Thomas",
  "Thora",
  "Thurman",
  "Tia",
  "Tiana",
  "Tianna",
  "Tiara",
  "Tierra",
  "Tiffany",
  "Tillman",
  "Timmothy",
  "Timmy",
  "Timothy",
  "Tina",
  "Tito",
  "Titus",
  "Tobin",
  "Toby",
  "Tod",
  "Tom",
  "Tomas",
  "Tomasa",
  "Tommie",
  "Toney",
  "Toni",
  "Tony",
  "Torey",
  "Torrance",
  "Torrey",
  "Toy",
  "Trace",
  "Tracey",
  "Tracy",
  "Travis",
  "Travon",
  "Tre",
  "Tremaine",
  "Tremayne",
  "Trent",
  "Trenton",
  "Tressa",
  "Tressie",
  "Treva",
  "Trever",
  "Trevion",
  "Trevor",
  "Trey",
  "Trinity",
  "Trisha",
  "Tristian",
  "Tristin",
  "Triston",
  "Troy",
  "Trudie",
  "Trycia",
  "Trystan",
  "Turner",
  "Twila",
  "Tyler",
  "Tyra",
  "Tyree",
  "Tyreek",
  "Tyrel",
  "Tyrell",
  "Tyrese",
  "Tyrique",
  "Tyshawn",
  "Tyson",
  "Ubaldo",
  "Ulices",
  "Ulises",
  "Una",
  "Unique",
  "Urban",
  "Uriah",
  "Uriel",
  "Ursula",
  "Vada",
  "Valentin",
  "Valentina",
  "Valentine",
  "Valerie",
  "Vallie",
  "Van",
  "Vance",
  "Vanessa",
  "Vaughn",
  "Veda",
  "Velda",
  "Vella",
  "Velma",
  "Velva",
  "Vena",
  "Verda",
  "Verdie",
  "Vergie",
  "Verla",
  "Verlie",
  "Vern",
  "Verna",
  "Verner",
  "Vernice",
  "Vernie",
  "Vernon",
  "Verona",
  "Veronica",
  "Vesta",
  "Vicenta",
  "Vicente",
  "Vickie",
  "Vicky",
  "Victor",
  "Victoria",
  "Vida",
  "Vidal",
  "Vilma",
  "Vince",
  "Vincent",
  "Vincenza",
  "Vincenzo",
  "Vinnie",
  "Viola",
  "Violet",
  "Violette",
  "Virgie",
  "Virgil",
  "Virginia",
  "Virginie",
  "Vita",
  "Vito",
  "Viva",
  "Vivian",
  "Viviane",
  "Vivianne",
  "Vivien",
  "Vivienne",
  "Vladimir",
  "Wade",
  "Waino",
  "Waldo",
  "Walker",
  "Wallace",
  "Walter",
  "Walton",
  "Wanda",
  "Ward",
  "Warren",
  "Watson",
  "Wava",
  "Waylon",
  "Wayne",
  "Webster",
  "Weldon",
  "Wellington",
  "Wendell",
  "Wendy",
  "Werner",
  "Westley",
  "Weston",
  "Whitney",
  "Wilber",
  "Wilbert",
  "Wilburn",
  "Wiley",
  "Wilford",
  "Wilfred",
  "Wilfredo",
  "Wilfrid",
  "Wilhelm",
  "Wilhelmine",
  "Will",
  "Willa",
  "Willard",
  "William",
  "Willie",
  "Willis",
  "Willow",
  "Willy",
  "Wilma",
  "Wilmer",
  "Wilson",
  "Wilton",
  "Winfield",
  "Winifred",
  "Winnifred",
  "Winona",
  "Winston",
  "Woodrow",
  "Wyatt",
  "Wyman",
  "Xander",
  "Xavier",
  "Xzavier",
  "Yadira",
  "Yasmeen",
  "Yasmin",
  "Yasmine",
  "Yazmin",
  "Yesenia",
  "Yessenia",
  "Yolanda",
  "Yoshiko",
  "Yvette",
  "Yvonne",
  "Zachariah",
  "Zachary",
  "Zachery",
  "Zack",
  "Zackary",
  "Zackery",
  "Zakary",
  "Zander",
  "Zane",
  "Zaria",
  "Zechariah",
  "Zelda",
  "Zella",
  "Zelma",
  "Zena",
  "Zetta",
  "Zion",
  "Zita",
  "Zoe",
  "Zoey",
  "Zoie",
  "Zoila",
  "Zola",
  "Zora",
  "Zula"
];

},{}],518:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.last_name = require("./last_name");
name.prefix = require("./prefix");
name.suffix = require("./suffix");
name.title = require("./title");
name.name = require("./name");

},{"./first_name":517,"./last_name":519,"./name":520,"./prefix":521,"./suffix":522,"./title":523}],519:[function(require,module,exports){
module["exports"] = [
  "Abbott",
  "Abernathy",
  "Abshire",
  "Adams",
  "Altenwerth",
  "Anderson",
  "Ankunding",
  "Armstrong",
  "Auer",
  "Aufderhar",
  "Bahringer",
  "Bailey",
  "Balistreri",
  "Barrows",
  "Bartell",
  "Bartoletti",
  "Barton",
  "Bashirian",
  "Batz",
  "Bauch",
  "Baumbach",
  "Bayer",
  "Beahan",
  "Beatty",
  "Bechtelar",
  "Becker",
  "Bednar",
  "Beer",
  "Beier",
  "Berge",
  "Bergnaum",
  "Bergstrom",
  "Bernhard",
  "Bernier",
  "Bins",
  "Blanda",
  "Blick",
  "Block",
  "Bode",
  "Boehm",
  "Bogan",
  "Bogisich",
  "Borer",
  "Bosco",
  "Botsford",
  "Boyer",
  "Boyle",
  "Bradtke",
  "Brakus",
  "Braun",
  "Breitenberg",
  "Brekke",
  "Brown",
  "Bruen",
  "Buckridge",
  "Carroll",
  "Carter",
  "Cartwright",
  "Casper",
  "Cassin",
  "Champlin",
  "Christiansen",
  "Cole",
  "Collier",
  "Collins",
  "Conn",
  "Connelly",
  "Conroy",
  "Considine",
  "Corkery",
  "Cormier",
  "Corwin",
  "Cremin",
  "Crist",
  "Crona",
  "Cronin",
  "Crooks",
  "Cruickshank",
  "Cummerata",
  "Cummings",
  "Dach",
  "D'Amore",
  "Daniel",
  "Dare",
  "Daugherty",
  "Davis",
  "Deckow",
  "Denesik",
  "Dibbert",
  "Dickens",
  "Dicki",
  "Dickinson",
  "Dietrich",
  "Donnelly",
  "Dooley",
  "Douglas",
  "Doyle",
  "DuBuque",
  "Durgan",
  "Ebert",
  "Effertz",
  "Eichmann",
  "Emard",
  "Emmerich",
  "Erdman",
  "Ernser",
  "Fadel",
  "Fahey",
  "Farrell",
  "Fay",
  "Feeney",
  "Feest",
  "Feil",
  "Ferry",
  "Fisher",
  "Flatley",
  "Frami",
  "Franecki",
  "Friesen",
  "Fritsch",
  "Funk",
  "Gaylord",
  "Gerhold",
  "Gerlach",
  "Gibson",
  "Gislason",
  "Gleason",
  "Gleichner",
  "Glover",
  "Goldner",
  "Goodwin",
  "Gorczany",
  "Gottlieb",
  "Goyette",
  "Grady",
  "Graham",
  "Grant",
  "Green",
  "Greenfelder",
  "Greenholt",
  "Grimes",
  "Gulgowski",
  "Gusikowski",
  "Gutkowski",
  "Gutmann",
  "Haag",
  "Hackett",
  "Hagenes",
  "Hahn",
  "Haley",
  "Halvorson",
  "Hamill",
  "Hammes",
  "Hand",
  "Hane",
  "Hansen",
  "Harber",
  "Harris",
  "Hartmann",
  "Harvey",
  "Hauck",
  "Hayes",
  "Heaney",
  "Heathcote",
  "Hegmann",
  "Heidenreich",
  "Heller",
  "Herman",
  "Hermann",
  "Hermiston",
  "Herzog",
  "Hessel",
  "Hettinger",
  "Hickle",
  "Hilll",
  "Hills",
  "Hilpert",
  "Hintz",
  "Hirthe",
  "Hodkiewicz",
  "Hoeger",
  "Homenick",
  "Hoppe",
  "Howe",
  "Howell",
  "Hudson",
  "Huel",
  "Huels",
  "Hyatt",
  "Jacobi",
  "Jacobs",
  "Jacobson",
  "Jakubowski",
  "Jaskolski",
  "Jast",
  "Jenkins",
  "Jerde",
  "Johns",
  "Johnson",
  "Johnston",
  "Jones",
  "Kassulke",
  "Kautzer",
  "Keebler",
  "Keeling",
  "Kemmer",
  "Kerluke",
  "Kertzmann",
  "Kessler",
  "Kiehn",
  "Kihn",
  "Kilback",
  "King",
  "Kirlin",
  "Klein",
  "Kling",
  "Klocko",
  "Koch",
  "Koelpin",
  "Koepp",
  "Kohler",
  "Konopelski",
  "Koss",
  "Kovacek",
  "Kozey",
  "Krajcik",
  "Kreiger",
  "Kris",
  "Kshlerin",
  "Kub",
  "Kuhic",
  "Kuhlman",
  "Kuhn",
  "Kulas",
  "Kunde",
  "Kunze",
  "Kuphal",
  "Kutch",
  "Kuvalis",
  "Labadie",
  "Lakin",
  "Lang",
  "Langosh",
  "Langworth",
  "Larkin",
  "Larson",
  "Leannon",
  "Lebsack",
  "Ledner",
  "Leffler",
  "Legros",
  "Lehner",
  "Lemke",
  "Lesch",
  "Leuschke",
  "Lind",
  "Lindgren",
  "Littel",
  "Little",
  "Lockman",
  "Lowe",
  "Lubowitz",
  "Lueilwitz",
  "Luettgen",
  "Lynch",
  "Macejkovic",
  "MacGyver",
  "Maggio",
  "Mann",
  "Mante",
  "Marks",
  "Marquardt",
  "Marvin",
  "Mayer",
  "Mayert",
  "McClure",
  "McCullough",
  "McDermott",
  "McGlynn",
  "McKenzie",
  "McLaughlin",
  "Medhurst",
  "Mertz",
  "Metz",
  "Miller",
  "Mills",
  "Mitchell",
  "Moen",
  "Mohr",
  "Monahan",
  "Moore",
  "Morar",
  "Morissette",
  "Mosciski",
  "Mraz",
  "Mueller",
  "Muller",
  "Murazik",
  "Murphy",
  "Murray",
  "Nader",
  "Nicolas",
  "Nienow",
  "Nikolaus",
  "Nitzsche",
  "Nolan",
  "Oberbrunner",
  "O'Connell",
  "O'Conner",
  "O'Hara",
  "O'Keefe",
  "O'Kon",
  "Okuneva",
  "Olson",
  "Ondricka",
  "O'Reilly",
  "Orn",
  "Ortiz",
  "Osinski",
  "Pacocha",
  "Padberg",
  "Pagac",
  "Parisian",
  "Parker",
  "Paucek",
  "Pfannerstill",
  "Pfeffer",
  "Pollich",
  "Pouros",
  "Powlowski",
  "Predovic",
  "Price",
  "Prohaska",
  "Prosacco",
  "Purdy",
  "Quigley",
  "Quitzon",
  "Rath",
  "Ratke",
  "Rau",
  "Raynor",
  "Reichel",
  "Reichert",
  "Reilly",
  "Reinger",
  "Rempel",
  "Renner",
  "Reynolds",
  "Rice",
  "Rippin",
  "Ritchie",
  "Robel",
  "Roberts",
  "Rodriguez",
  "Rogahn",
  "Rohan",
  "Rolfson",
  "Romaguera",
  "Roob",
  "Rosenbaum",
  "Rowe",
  "Ruecker",
  "Runolfsdottir",
  "Runolfsson",
  "Runte",
  "Russel",
  "Rutherford",
  "Ryan",
  "Sanford",
  "Satterfield",
  "Sauer",
  "Sawayn",
  "Schaden",
  "Schaefer",
  "Schamberger",
  "Schiller",
  "Schimmel",
  "Schinner",
  "Schmeler",
  "Schmidt",
  "Schmitt",
  "Schneider",
  "Schoen",
  "Schowalter",
  "Schroeder",
  "Schulist",
  "Schultz",
  "Schumm",
  "Schuppe",
  "Schuster",
  "Senger",
  "Shanahan",
  "Shields",
  "Simonis",
  "Sipes",
  "Skiles",
  "Smith",
  "Smitham",
  "Spencer",
  "Spinka",
  "Sporer",
  "Stamm",
  "Stanton",
  "Stark",
  "Stehr",
  "Steuber",
  "Stiedemann",
  "Stokes",
  "Stoltenberg",
  "Stracke",
  "Streich",
  "Stroman",
  "Strosin",
  "Swaniawski",
  "Swift",
  "Terry",
  "Thiel",
  "Thompson",
  "Tillman",
  "Torp",
  "Torphy",
  "Towne",
  "Toy",
  "Trantow",
  "Tremblay",
  "Treutel",
  "Tromp",
  "Turcotte",
  "Turner",
  "Ullrich",
  "Upton",
  "Vandervort",
  "Veum",
  "Volkman",
  "Von",
  "VonRueden",
  "Waelchi",
  "Walker",
  "Walsh",
  "Walter",
  "Ward",
  "Waters",
  "Watsica",
  "Weber",
  "Wehner",
  "Weimann",
  "Weissnat",
  "Welch",
  "West",
  "White",
  "Wiegand",
  "Wilderman",
  "Wilkinson",
  "Will",
  "Williamson",
  "Willms",
  "Windler",
  "Wintheiser",
  "Wisoky",
  "Wisozk",
  "Witting",
  "Wiza",
  "Wolf",
  "Wolff",
  "Wuckert",
  "Wunsch",
  "Wyman",
  "Yost",
  "Yundt",
  "Zboncak",
  "Zemlak",
  "Ziemann",
  "Zieme",
  "Zulauf"
];

},{}],520:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{first_name} #{last_name}",
  "#{first_name} #{last_name} #{suffix}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}"
];

},{}],521:[function(require,module,exports){
module["exports"] = [
  "Mr.",
  "Mrs.",
  "Ms.",
  "Miss",
  "Dr."
];

},{}],522:[function(require,module,exports){
module["exports"] = [
  "Jr.",
  "Sr.",
  "I",
  "II",
  "III",
  "IV",
  "V",
  "MD",
  "DDS",
  "PhD",
  "DVM"
];

},{}],523:[function(require,module,exports){
module["exports"] = {
  "descriptor": [
    "Lead",
    "Senior",
    "Direct",
    "Corporate",
    "Dynamic",
    "Future",
    "Product",
    "National",
    "Regional",
    "District",
    "Central",
    "Global",
    "Customer",
    "Investor",
    "Dynamic",
    "International",
    "Legacy",
    "Forward",
    "Internal",
    "Human",
    "Chief",
    "Principal"
  ],
  "level": [
    "Solutions",
    "Program",
    "Brand",
    "Security",
    "Research",
    "Marketing",
    "Directives",
    "Implementation",
    "Integration",
    "Functionality",
    "Response",
    "Paradigm",
    "Tactics",
    "Identity",
    "Markets",
    "Group",
    "Division",
    "Applications",
    "Optimization",
    "Operations",
    "Infrastructure",
    "Intranet",
    "Communications",
    "Web",
    "Branding",
    "Quality",
    "Assurance",
    "Mobility",
    "Accounts",
    "Data",
    "Creative",
    "Configuration",
    "Accountability",
    "Interactions",
    "Factors",
    "Usability",
    "Metrics"
  ],
  "job": [
    "Supervisor",
    "Associate",
    "Executive",
    "Liaison",
    "Officer",
    "Manager",
    "Engineer",
    "Specialist",
    "Director",
    "Coordinator",
    "Administrator",
    "Architect",
    "Analyst",
    "Designer",
    "Planner",
    "Orchestrator",
    "Technician",
    "Developer",
    "Producer",
    "Consultant",
    "Assistant",
    "Facilitator",
    "Agent",
    "Representative",
    "Strategist"
  ]
};

},{}],524:[function(require,module,exports){
module["exports"] = [
  "###-###-####",
  "(###) ###-####",
  "1-###-###-####",
  "###.###.####",
  "###-###-####",
  "(###) ###-####",
  "1-###-###-####",
  "###.###.####",
  "###-###-#### x###",
  "(###) ###-#### x###",
  "1-###-###-#### x###",
  "###.###.#### x###",
  "###-###-#### x####",
  "(###) ###-#### x####",
  "1-###-###-#### x####",
  "###.###.#### x####",
  "###-###-#### x#####",
  "(###) ###-#### x#####",
  "1-###-###-#### x#####",
  "###.###.#### x#####"
];

},{}],525:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":524,"dup":312}],526:[function(require,module,exports){
var system = {};
module['exports'] = system;
system.mimeTypes = require("./mimeTypes");
},{"./mimeTypes":527}],527:[function(require,module,exports){
/*

The MIT License (MIT)

Copyright (c) 2014 Jonathan Ong me@jongleberry.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

Definitions from mime-db v1.21.0
For updates check: https://github.com/jshttp/mime-db/blob/master/db.json

*/

module['exports'] = {
  "application/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    "source": "iana"
  },
  "application/3gpp-ims+xml": {
    "source": "iana"
  },
  "application/a2l": {
    "source": "iana"
  },
  "application/activemessage": {
    "source": "iana"
  },
  "application/alto-costmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-costmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-directory+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcost+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcostparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointprop+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointpropparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-error+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/aml": {
    "source": "iana"
  },
  "application/andrew-inset": {
    "source": "iana",
    "extensions": ["ez"]
  },
  "application/applefile": {
    "source": "iana"
  },
  "application/applixware": {
    "source": "apache",
    "extensions": ["aw"]
  },
  "application/atf": {
    "source": "iana"
  },
  "application/atfx": {
    "source": "iana"
  },
  "application/atom+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atom"]
  },
  "application/atomcat+xml": {
    "source": "iana",
    "extensions": ["atomcat"]
  },
  "application/atomdeleted+xml": {
    "source": "iana"
  },
  "application/atomicmail": {
    "source": "iana"
  },
  "application/atomsvc+xml": {
    "source": "iana",
    "extensions": ["atomsvc"]
  },
  "application/atxml": {
    "source": "iana"
  },
  "application/auth-policy+xml": {
    "source": "iana"
  },
  "application/bacnet-xdd+zip": {
    "source": "iana"
  },
  "application/batch-smtp": {
    "source": "iana"
  },
  "application/bdoc": {
    "compressible": false,
    "extensions": ["bdoc"]
  },
  "application/beep+xml": {
    "source": "iana"
  },
  "application/calendar+json": {
    "source": "iana",
    "compressible": true
  },
  "application/calendar+xml": {
    "source": "iana"
  },
  "application/call-completion": {
    "source": "iana"
  },
  "application/cals-1840": {
    "source": "iana"
  },
  "application/cbor": {
    "source": "iana"
  },
  "application/ccmp+xml": {
    "source": "iana"
  },
  "application/ccxml+xml": {
    "source": "iana",
    "extensions": ["ccxml"]
  },
  "application/cdfx+xml": {
    "source": "iana"
  },
  "application/cdmi-capability": {
    "source": "iana",
    "extensions": ["cdmia"]
  },
  "application/cdmi-container": {
    "source": "iana",
    "extensions": ["cdmic"]
  },
  "application/cdmi-domain": {
    "source": "iana",
    "extensions": ["cdmid"]
  },
  "application/cdmi-object": {
    "source": "iana",
    "extensions": ["cdmio"]
  },
  "application/cdmi-queue": {
    "source": "iana",
    "extensions": ["cdmiq"]
  },
  "application/cdni": {
    "source": "iana"
  },
  "application/cea": {
    "source": "iana"
  },
  "application/cea-2018+xml": {
    "source": "iana"
  },
  "application/cellml+xml": {
    "source": "iana"
  },
  "application/cfw": {
    "source": "iana"
  },
  "application/cms": {
    "source": "iana"
  },
  "application/cnrp+xml": {
    "source": "iana"
  },
  "application/coap-group+json": {
    "source": "iana",
    "compressible": true
  },
  "application/commonground": {
    "source": "iana"
  },
  "application/conference-info+xml": {
    "source": "iana"
  },
  "application/cpl+xml": {
    "source": "iana"
  },
  "application/csrattrs": {
    "source": "iana"
  },
  "application/csta+xml": {
    "source": "iana"
  },
  "application/cstadata+xml": {
    "source": "iana"
  },
  "application/csvm+json": {
    "source": "iana",
    "compressible": true
  },
  "application/cu-seeme": {
    "source": "apache",
    "extensions": ["cu"]
  },
  "application/cybercash": {
    "source": "iana"
  },
  "application/dart": {
    "compressible": true
  },
  "application/dash+xml": {
    "source": "iana",
    "extensions": ["mdp"]
  },
  "application/dashdelta": {
    "source": "iana"
  },
  "application/davmount+xml": {
    "source": "iana",
    "extensions": ["davmount"]
  },
  "application/dca-rft": {
    "source": "iana"
  },
  "application/dcd": {
    "source": "iana"
  },
  "application/dec-dx": {
    "source": "iana"
  },
  "application/dialog-info+xml": {
    "source": "iana"
  },
  "application/dicom": {
    "source": "iana"
  },
  "application/dii": {
    "source": "iana"
  },
  "application/dit": {
    "source": "iana"
  },
  "application/dns": {
    "source": "iana"
  },
  "application/docbook+xml": {
    "source": "apache",
    "extensions": ["dbk"]
  },
  "application/dskpp+xml": {
    "source": "iana"
  },
  "application/dssc+der": {
    "source": "iana",
    "extensions": ["dssc"]
  },
  "application/dssc+xml": {
    "source": "iana",
    "extensions": ["xdssc"]
  },
  "application/dvcs": {
    "source": "iana"
  },
  "application/ecmascript": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ecma"]
  },
  "application/edi-consent": {
    "source": "iana"
  },
  "application/edi-x12": {
    "source": "iana",
    "compressible": false
  },
  "application/edifact": {
    "source": "iana",
    "compressible": false
  },
  "application/emergencycalldata.comment+xml": {
    "source": "iana"
  },
  "application/emergencycalldata.deviceinfo+xml": {
    "source": "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    "source": "iana"
  },
  "application/emergencycalldata.serviceinfo+xml": {
    "source": "iana"
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    "source": "iana"
  },
  "application/emma+xml": {
    "source": "iana",
    "extensions": ["emma"]
  },
  "application/emotionml+xml": {
    "source": "iana"
  },
  "application/encaprtp": {
    "source": "iana"
  },
  "application/epp+xml": {
    "source": "iana"
  },
  "application/epub+zip": {
    "source": "iana",
    "extensions": ["epub"]
  },
  "application/eshop": {
    "source": "iana"
  },
  "application/exi": {
    "source": "iana",
    "extensions": ["exi"]
  },
  "application/fastinfoset": {
    "source": "iana"
  },
  "application/fastsoap": {
    "source": "iana"
  },
  "application/fdt+xml": {
    "source": "iana"
  },
  "application/fits": {
    "source": "iana"
  },
  "application/font-sfnt": {
    "source": "iana"
  },
  "application/font-tdpfr": {
    "source": "iana",
    "extensions": ["pfr"]
  },
  "application/font-woff": {
    "source": "iana",
    "compressible": false,
    "extensions": ["woff"]
  },
  "application/font-woff2": {
    "compressible": false,
    "extensions": ["woff2"]
  },
  "application/framework-attributes+xml": {
    "source": "iana"
  },
  "application/gml+xml": {
    "source": "apache",
    "extensions": ["gml"]
  },
  "application/gpx+xml": {
    "source": "apache",
    "extensions": ["gpx"]
  },
  "application/gxf": {
    "source": "apache",
    "extensions": ["gxf"]
  },
  "application/gzip": {
    "source": "iana",
    "compressible": false
  },
  "application/h224": {
    "source": "iana"
  },
  "application/held+xml": {
    "source": "iana"
  },
  "application/http": {
    "source": "iana"
  },
  "application/hyperstudio": {
    "source": "iana",
    "extensions": ["stk"]
  },
  "application/ibe-key-request+xml": {
    "source": "iana"
  },
  "application/ibe-pkg-reply+xml": {
    "source": "iana"
  },
  "application/ibe-pp-data": {
    "source": "iana"
  },
  "application/iges": {
    "source": "iana"
  },
  "application/im-iscomposing+xml": {
    "source": "iana"
  },
  "application/index": {
    "source": "iana"
  },
  "application/index.cmd": {
    "source": "iana"
  },
  "application/index.obj": {
    "source": "iana"
  },
  "application/index.response": {
    "source": "iana"
  },
  "application/index.vnd": {
    "source": "iana"
  },
  "application/inkml+xml": {
    "source": "iana",
    "extensions": ["ink","inkml"]
  },
  "application/iotp": {
    "source": "iana"
  },
  "application/ipfix": {
    "source": "iana",
    "extensions": ["ipfix"]
  },
  "application/ipp": {
    "source": "iana"
  },
  "application/isup": {
    "source": "iana"
  },
  "application/its+xml": {
    "source": "iana"
  },
  "application/java-archive": {
    "source": "apache",
    "compressible": false,
    "extensions": ["jar","war","ear"]
  },
  "application/java-serialized-object": {
    "source": "apache",
    "compressible": false,
    "extensions": ["ser"]
  },
  "application/java-vm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["class"]
  },
  "application/javascript": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["js"]
  },
  "application/jose": {
    "source": "iana"
  },
  "application/jose+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jrd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["json","map"]
  },
  "application/json-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/json-seq": {
    "source": "iana"
  },
  "application/json5": {
    "extensions": ["json5"]
  },
  "application/jsonml+json": {
    "source": "apache",
    "compressible": true,
    "extensions": ["jsonml"]
  },
  "application/jwk+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jwk-set+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jwt": {
    "source": "iana"
  },
  "application/kpml-request+xml": {
    "source": "iana"
  },
  "application/kpml-response+xml": {
    "source": "iana"
  },
  "application/ld+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["jsonld"]
  },
  "application/link-format": {
    "source": "iana"
  },
  "application/load-control+xml": {
    "source": "iana"
  },
  "application/lost+xml": {
    "source": "iana",
    "extensions": ["lostxml"]
  },
  "application/lostsync+xml": {
    "source": "iana"
  },
  "application/lxf": {
    "source": "iana"
  },
  "application/mac-binhex40": {
    "source": "iana",
    "extensions": ["hqx"]
  },
  "application/mac-compactpro": {
    "source": "apache",
    "extensions": ["cpt"]
  },
  "application/macwriteii": {
    "source": "iana"
  },
  "application/mads+xml": {
    "source": "iana",
    "extensions": ["mads"]
  },
  "application/manifest+json": {
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["webmanifest"]
  },
  "application/marc": {
    "source": "iana",
    "extensions": ["mrc"]
  },
  "application/marcxml+xml": {
    "source": "iana",
    "extensions": ["mrcx"]
  },
  "application/mathematica": {
    "source": "iana",
    "extensions": ["ma","nb","mb"]
  },
  "application/mathml+xml": {
    "source": "iana",
    "extensions": ["mathml"]
  },
  "application/mathml-content+xml": {
    "source": "iana"
  },
  "application/mathml-presentation+xml": {
    "source": "iana"
  },
  "application/mbms-associated-procedure-description+xml": {
    "source": "iana"
  },
  "application/mbms-deregister+xml": {
    "source": "iana"
  },
  "application/mbms-envelope+xml": {
    "source": "iana"
  },
  "application/mbms-msk+xml": {
    "source": "iana"
  },
  "application/mbms-msk-response+xml": {
    "source": "iana"
  },
  "application/mbms-protection-description+xml": {
    "source": "iana"
  },
  "application/mbms-reception-report+xml": {
    "source": "iana"
  },
  "application/mbms-register+xml": {
    "source": "iana"
  },
  "application/mbms-register-response+xml": {
    "source": "iana"
  },
  "application/mbms-schedule+xml": {
    "source": "iana"
  },
  "application/mbms-user-service-description+xml": {
    "source": "iana"
  },
  "application/mbox": {
    "source": "iana",
    "extensions": ["mbox"]
  },
  "application/media-policy-dataset+xml": {
    "source": "iana"
  },
  "application/media_control+xml": {
    "source": "iana"
  },
  "application/mediaservercontrol+xml": {
    "source": "iana",
    "extensions": ["mscml"]
  },
  "application/merge-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/metalink+xml": {
    "source": "apache",
    "extensions": ["metalink"]
  },
  "application/metalink4+xml": {
    "source": "iana",
    "extensions": ["meta4"]
  },
  "application/mets+xml": {
    "source": "iana",
    "extensions": ["mets"]
  },
  "application/mf4": {
    "source": "iana"
  },
  "application/mikey": {
    "source": "iana"
  },
  "application/mods+xml": {
    "source": "iana",
    "extensions": ["mods"]
  },
  "application/moss-keys": {
    "source": "iana"
  },
  "application/moss-signature": {
    "source": "iana"
  },
  "application/mosskey-data": {
    "source": "iana"
  },
  "application/mosskey-request": {
    "source": "iana"
  },
  "application/mp21": {
    "source": "iana",
    "extensions": ["m21","mp21"]
  },
  "application/mp4": {
    "source": "iana",
    "extensions": ["mp4s","m4p"]
  },
  "application/mpeg4-generic": {
    "source": "iana"
  },
  "application/mpeg4-iod": {
    "source": "iana"
  },
  "application/mpeg4-iod-xmt": {
    "source": "iana"
  },
  "application/mrb-consumer+xml": {
    "source": "iana"
  },
  "application/mrb-publish+xml": {
    "source": "iana"
  },
  "application/msc-ivr+xml": {
    "source": "iana"
  },
  "application/msc-mixer+xml": {
    "source": "iana"
  },
  "application/msword": {
    "source": "iana",
    "compressible": false,
    "extensions": ["doc","dot"]
  },
  "application/mxf": {
    "source": "iana",
    "extensions": ["mxf"]
  },
  "application/nasdata": {
    "source": "iana"
  },
  "application/news-checkgroups": {
    "source": "iana"
  },
  "application/news-groupinfo": {
    "source": "iana"
  },
  "application/news-transmission": {
    "source": "iana"
  },
  "application/nlsml+xml": {
    "source": "iana"
  },
  "application/nss": {
    "source": "iana"
  },
  "application/ocsp-request": {
    "source": "iana"
  },
  "application/ocsp-response": {
    "source": "iana"
  },
  "application/octet-stream": {
    "source": "iana",
    "compressible": false,
    "extensions": ["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]
  },
  "application/oda": {
    "source": "iana",
    "extensions": ["oda"]
  },
  "application/odx": {
    "source": "iana"
  },
  "application/oebps-package+xml": {
    "source": "iana",
    "extensions": ["opf"]
  },
  "application/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ogx"]
  },
  "application/omdoc+xml": {
    "source": "apache",
    "extensions": ["omdoc"]
  },
  "application/onenote": {
    "source": "apache",
    "extensions": ["onetoc","onetoc2","onetmp","onepkg"]
  },
  "application/oxps": {
    "source": "iana",
    "extensions": ["oxps"]
  },
  "application/p2p-overlay+xml": {
    "source": "iana"
  },
  "application/parityfec": {
    "source": "iana"
  },
  "application/patch-ops-error+xml": {
    "source": "iana",
    "extensions": ["xer"]
  },
  "application/pdf": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pdf"]
  },
  "application/pdx": {
    "source": "iana"
  },
  "application/pgp-encrypted": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pgp"]
  },
  "application/pgp-keys": {
    "source": "iana"
  },
  "application/pgp-signature": {
    "source": "iana",
    "extensions": ["asc","sig"]
  },
  "application/pics-rules": {
    "source": "apache",
    "extensions": ["prf"]
  },
  "application/pidf+xml": {
    "source": "iana"
  },
  "application/pidf-diff+xml": {
    "source": "iana"
  },
  "application/pkcs10": {
    "source": "iana",
    "extensions": ["p10"]
  },
  "application/pkcs12": {
    "source": "iana"
  },
  "application/pkcs7-mime": {
    "source": "iana",
    "extensions": ["p7m","p7c"]
  },
  "application/pkcs7-signature": {
    "source": "iana",
    "extensions": ["p7s"]
  },
  "application/pkcs8": {
    "source": "iana",
    "extensions": ["p8"]
  },
  "application/pkix-attr-cert": {
    "source": "iana",
    "extensions": ["ac"]
  },
  "application/pkix-cert": {
    "source": "iana",
    "extensions": ["cer"]
  },
  "application/pkix-crl": {
    "source": "iana",
    "extensions": ["crl"]
  },
  "application/pkix-pkipath": {
    "source": "iana",
    "extensions": ["pkipath"]
  },
  "application/pkixcmp": {
    "source": "iana",
    "extensions": ["pki"]
  },
  "application/pls+xml": {
    "source": "iana",
    "extensions": ["pls"]
  },
  "application/poc-settings+xml": {
    "source": "iana"
  },
  "application/postscript": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ai","eps","ps"]
  },
  "application/provenance+xml": {
    "source": "iana"
  },
  "application/prs.alvestrand.titrax-sheet": {
    "source": "iana"
  },
  "application/prs.cww": {
    "source": "iana",
    "extensions": ["cww"]
  },
  "application/prs.hpub+zip": {
    "source": "iana"
  },
  "application/prs.nprend": {
    "source": "iana"
  },
  "application/prs.plucker": {
    "source": "iana"
  },
  "application/prs.rdf-xml-crypt": {
    "source": "iana"
  },
  "application/prs.xsf+xml": {
    "source": "iana"
  },
  "application/pskc+xml": {
    "source": "iana",
    "extensions": ["pskcxml"]
  },
  "application/qsig": {
    "source": "iana"
  },
  "application/raptorfec": {
    "source": "iana"
  },
  "application/rdap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/rdf+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rdf"]
  },
  "application/reginfo+xml": {
    "source": "iana",
    "extensions": ["rif"]
  },
  "application/relax-ng-compact-syntax": {
    "source": "iana",
    "extensions": ["rnc"]
  },
  "application/remote-printing": {
    "source": "iana"
  },
  "application/reputon+json": {
    "source": "iana",
    "compressible": true
  },
  "application/resource-lists+xml": {
    "source": "iana",
    "extensions": ["rl"]
  },
  "application/resource-lists-diff+xml": {
    "source": "iana",
    "extensions": ["rld"]
  },
  "application/rfc+xml": {
    "source": "iana"
  },
  "application/riscos": {
    "source": "iana"
  },
  "application/rlmi+xml": {
    "source": "iana"
  },
  "application/rls-services+xml": {
    "source": "iana",
    "extensions": ["rs"]
  },
  "application/rpki-ghostbusters": {
    "source": "iana",
    "extensions": ["gbr"]
  },
  "application/rpki-manifest": {
    "source": "iana",
    "extensions": ["mft"]
  },
  "application/rpki-roa": {
    "source": "iana",
    "extensions": ["roa"]
  },
  "application/rpki-updown": {
    "source": "iana"
  },
  "application/rsd+xml": {
    "source": "apache",
    "extensions": ["rsd"]
  },
  "application/rss+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["rss"]
  },
  "application/rtf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtf"]
  },
  "application/rtploopback": {
    "source": "iana"
  },
  "application/rtx": {
    "source": "iana"
  },
  "application/samlassertion+xml": {
    "source": "iana"
  },
  "application/samlmetadata+xml": {
    "source": "iana"
  },
  "application/sbml+xml": {
    "source": "iana",
    "extensions": ["sbml"]
  },
  "application/scaip+xml": {
    "source": "iana"
  },
  "application/scim+json": {
    "source": "iana",
    "compressible": true
  },
  "application/scvp-cv-request": {
    "source": "iana",
    "extensions": ["scq"]
  },
  "application/scvp-cv-response": {
    "source": "iana",
    "extensions": ["scs"]
  },
  "application/scvp-vp-request": {
    "source": "iana",
    "extensions": ["spq"]
  },
  "application/scvp-vp-response": {
    "source": "iana",
    "extensions": ["spp"]
  },
  "application/sdp": {
    "source": "iana",
    "extensions": ["sdp"]
  },
  "application/sep+xml": {
    "source": "iana"
  },
  "application/sep-exi": {
    "source": "iana"
  },
  "application/session-info": {
    "source": "iana"
  },
  "application/set-payment": {
    "source": "iana"
  },
  "application/set-payment-initiation": {
    "source": "iana",
    "extensions": ["setpay"]
  },
  "application/set-registration": {
    "source": "iana"
  },
  "application/set-registration-initiation": {
    "source": "iana",
    "extensions": ["setreg"]
  },
  "application/sgml": {
    "source": "iana"
  },
  "application/sgml-open-catalog": {
    "source": "iana"
  },
  "application/shf+xml": {
    "source": "iana",
    "extensions": ["shf"]
  },
  "application/sieve": {
    "source": "iana"
  },
  "application/simple-filter+xml": {
    "source": "iana"
  },
  "application/simple-message-summary": {
    "source": "iana"
  },
  "application/simplesymbolcontainer": {
    "source": "iana"
  },
  "application/slate": {
    "source": "iana"
  },
  "application/smil": {
    "source": "iana"
  },
  "application/smil+xml": {
    "source": "iana",
    "extensions": ["smi","smil"]
  },
  "application/smpte336m": {
    "source": "iana"
  },
  "application/soap+fastinfoset": {
    "source": "iana"
  },
  "application/soap+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sparql-query": {
    "source": "iana",
    "extensions": ["rq"]
  },
  "application/sparql-results+xml": {
    "source": "iana",
    "extensions": ["srx"]
  },
  "application/spirits-event+xml": {
    "source": "iana"
  },
  "application/sql": {
    "source": "iana"
  },
  "application/srgs": {
    "source": "iana",
    "extensions": ["gram"]
  },
  "application/srgs+xml": {
    "source": "iana",
    "extensions": ["grxml"]
  },
  "application/sru+xml": {
    "source": "iana",
    "extensions": ["sru"]
  },
  "application/ssdl+xml": {
    "source": "apache",
    "extensions": ["ssdl"]
  },
  "application/ssml+xml": {
    "source": "iana",
    "extensions": ["ssml"]
  },
  "application/tamp-apex-update": {
    "source": "iana"
  },
  "application/tamp-apex-update-confirm": {
    "source": "iana"
  },
  "application/tamp-community-update": {
    "source": "iana"
  },
  "application/tamp-community-update-confirm": {
    "source": "iana"
  },
  "application/tamp-error": {
    "source": "iana"
  },
  "application/tamp-sequence-adjust": {
    "source": "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    "source": "iana"
  },
  "application/tamp-status-query": {
    "source": "iana"
  },
  "application/tamp-status-response": {
    "source": "iana"
  },
  "application/tamp-update": {
    "source": "iana"
  },
  "application/tamp-update-confirm": {
    "source": "iana"
  },
  "application/tar": {
    "compressible": true
  },
  "application/tei+xml": {
    "source": "iana",
    "extensions": ["tei","teicorpus"]
  },
  "application/thraud+xml": {
    "source": "iana",
    "extensions": ["tfi"]
  },
  "application/timestamp-query": {
    "source": "iana"
  },
  "application/timestamp-reply": {
    "source": "iana"
  },
  "application/timestamped-data": {
    "source": "iana",
    "extensions": ["tsd"]
  },
  "application/ttml+xml": {
    "source": "iana"
  },
  "application/tve-trigger": {
    "source": "iana"
  },
  "application/ulpfec": {
    "source": "iana"
  },
  "application/urc-grpsheet+xml": {
    "source": "iana"
  },
  "application/urc-ressheet+xml": {
    "source": "iana"
  },
  "application/urc-targetdesc+xml": {
    "source": "iana"
  },
  "application/urc-uisocketdesc+xml": {
    "source": "iana"
  },
  "application/vcard+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vcard+xml": {
    "source": "iana"
  },
  "application/vemmi": {
    "source": "iana"
  },
  "application/vividence.scriptfile": {
    "source": "apache"
  },
  "application/vnd.3gpp-prose+xml": {
    "source": "iana"
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    "source": "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    "source": "iana"
  },
  "application/vnd.3gpp.bsf+xml": {
    "source": "iana"
  },
  "application/vnd.3gpp.mid-call+xml": {
    "source": "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    "source": "iana",
    "extensions": ["plb"]
  },
  "application/vnd.3gpp.pic-bw-small": {
    "source": "iana",
    "extensions": ["psb"]
  },
  "application/vnd.3gpp.pic-bw-var": {
    "source": "iana",
    "extensions": ["pvb"]
  },
  "application/vnd.3gpp.sms": {
    "source": "iana"
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    "source": "iana"
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    "source": "iana"
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    "source": "iana"
  },
  "application/vnd.3gpp.ussd+xml": {
    "source": "iana"
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    "source": "iana"
  },
  "application/vnd.3gpp2.sms": {
    "source": "iana"
  },
  "application/vnd.3gpp2.tcap": {
    "source": "iana",
    "extensions": ["tcap"]
  },
  "application/vnd.3m.post-it-notes": {
    "source": "iana",
    "extensions": ["pwn"]
  },
  "application/vnd.accpac.simply.aso": {
    "source": "iana",
    "extensions": ["aso"]
  },
  "application/vnd.accpac.simply.imp": {
    "source": "iana",
    "extensions": ["imp"]
  },
  "application/vnd.acucobol": {
    "source": "iana",
    "extensions": ["acu"]
  },
  "application/vnd.acucorp": {
    "source": "iana",
    "extensions": ["atc","acutc"]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    "source": "apache",
    "extensions": ["air"]
  },
  "application/vnd.adobe.flash.movie": {
    "source": "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    "source": "iana",
    "extensions": ["fcdt"]
  },
  "application/vnd.adobe.fxp": {
    "source": "iana",
    "extensions": ["fxp","fxpl"]
  },
  "application/vnd.adobe.partial-upload": {
    "source": "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    "source": "iana",
    "extensions": ["xdp"]
  },
  "application/vnd.adobe.xfdf": {
    "source": "iana",
    "extensions": ["xfdf"]
  },
  "application/vnd.aether.imp": {
    "source": "iana"
  },
  "application/vnd.ah-barcode": {
    "source": "iana"
  },
  "application/vnd.ahead.space": {
    "source": "iana",
    "extensions": ["ahead"]
  },
  "application/vnd.airzip.filesecure.azf": {
    "source": "iana",
    "extensions": ["azf"]
  },
  "application/vnd.airzip.filesecure.azs": {
    "source": "iana",
    "extensions": ["azs"]
  },
  "application/vnd.amazon.ebook": {
    "source": "apache",
    "extensions": ["azw"]
  },
  "application/vnd.americandynamics.acc": {
    "source": "iana",
    "extensions": ["acc"]
  },
  "application/vnd.amiga.ami": {
    "source": "iana",
    "extensions": ["ami"]
  },
  "application/vnd.amundsen.maze+xml": {
    "source": "iana"
  },
  "application/vnd.android.package-archive": {
    "source": "apache",
    "compressible": false,
    "extensions": ["apk"]
  },
  "application/vnd.anki": {
    "source": "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    "source": "iana",
    "extensions": ["cii"]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    "source": "apache",
    "extensions": ["fti"]
  },
  "application/vnd.antix.game-component": {
    "source": "iana",
    "extensions": ["atx"]
  },
  "application/vnd.apache.thrift.binary": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.compact": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.json": {
    "source": "iana"
  },
  "application/vnd.api+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.apple.installer+xml": {
    "source": "iana",
    "extensions": ["mpkg"]
  },
  "application/vnd.apple.mpegurl": {
    "source": "iana",
    "extensions": ["m3u8"]
  },
  "application/vnd.apple.pkpass": {
    "compressible": false,
    "extensions": ["pkpass"]
  },
  "application/vnd.arastra.swi": {
    "source": "iana"
  },
  "application/vnd.aristanetworks.swi": {
    "source": "iana",
    "extensions": ["swi"]
  },
  "application/vnd.artsquare": {
    "source": "iana"
  },
  "application/vnd.astraea-software.iota": {
    "source": "iana",
    "extensions": ["iota"]
  },
  "application/vnd.audiograph": {
    "source": "iana",
    "extensions": ["aep"]
  },
  "application/vnd.autopackage": {
    "source": "iana"
  },
  "application/vnd.avistar+xml": {
    "source": "iana"
  },
  "application/vnd.balsamiq.bmml+xml": {
    "source": "iana"
  },
  "application/vnd.balsamiq.bmpr": {
    "source": "iana"
  },
  "application/vnd.bekitzur-stech+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.biopax.rdf+xml": {
    "source": "iana"
  },
  "application/vnd.blueice.multipass": {
    "source": "iana",
    "extensions": ["mpm"]
  },
  "application/vnd.bluetooth.ep.oob": {
    "source": "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    "source": "iana"
  },
  "application/vnd.bmi": {
    "source": "iana",
    "extensions": ["bmi"]
  },
  "application/vnd.businessobjects": {
    "source": "iana",
    "extensions": ["rep"]
  },
  "application/vnd.cab-jscript": {
    "source": "iana"
  },
  "application/vnd.canon-cpdl": {
    "source": "iana"
  },
  "application/vnd.canon-lips": {
    "source": "iana"
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    "source": "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    "source": "iana"
  },
  "application/vnd.chemdraw+xml": {
    "source": "iana",
    "extensions": ["cdxml"]
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    "source": "iana",
    "extensions": ["mmd"]
  },
  "application/vnd.cinderella": {
    "source": "iana",
    "extensions": ["cdy"]
  },
  "application/vnd.cirpack.isdn-ext": {
    "source": "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    "source": "iana"
  },
  "application/vnd.claymore": {
    "source": "iana",
    "extensions": ["cla"]
  },
  "application/vnd.cloanto.rp9": {
    "source": "iana",
    "extensions": ["rp9"]
  },
  "application/vnd.clonk.c4group": {
    "source": "iana",
    "extensions": ["c4g","c4d","c4f","c4p","c4u"]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    "source": "iana",
    "extensions": ["c11amc"]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    "source": "iana",
    "extensions": ["c11amz"]
  },
  "application/vnd.coffeescript": {
    "source": "iana"
  },
  "application/vnd.collection+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.collection.doc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.collection.next+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.commerce-battelle": {
    "source": "iana"
  },
  "application/vnd.commonspace": {
    "source": "iana",
    "extensions": ["csp"]
  },
  "application/vnd.contact.cmsg": {
    "source": "iana",
    "extensions": ["cdbcmsg"]
  },
  "application/vnd.cosmocaller": {
    "source": "iana",
    "extensions": ["cmc"]
  },
  "application/vnd.crick.clicker": {
    "source": "iana",
    "extensions": ["clkx"]
  },
  "application/vnd.crick.clicker.keyboard": {
    "source": "iana",
    "extensions": ["clkk"]
  },
  "application/vnd.crick.clicker.palette": {
    "source": "iana",
    "extensions": ["clkp"]
  },
  "application/vnd.crick.clicker.template": {
    "source": "iana",
    "extensions": ["clkt"]
  },
  "application/vnd.crick.clicker.wordbank": {
    "source": "iana",
    "extensions": ["clkw"]
  },
  "application/vnd.criticaltools.wbs+xml": {
    "source": "iana",
    "extensions": ["wbs"]
  },
  "application/vnd.ctc-posml": {
    "source": "iana",
    "extensions": ["pml"]
  },
  "application/vnd.ctct.ws+xml": {
    "source": "iana"
  },
  "application/vnd.cups-pdf": {
    "source": "iana"
  },
  "application/vnd.cups-postscript": {
    "source": "iana"
  },
  "application/vnd.cups-ppd": {
    "source": "iana",
    "extensions": ["ppd"]
  },
  "application/vnd.cups-raster": {
    "source": "iana"
  },
  "application/vnd.cups-raw": {
    "source": "iana"
  },
  "application/vnd.curl": {
    "source": "iana"
  },
  "application/vnd.curl.car": {
    "source": "apache",
    "extensions": ["car"]
  },
  "application/vnd.curl.pcurl": {
    "source": "apache",
    "extensions": ["pcurl"]
  },
  "application/vnd.cyan.dean.root+xml": {
    "source": "iana"
  },
  "application/vnd.cybank": {
    "source": "iana"
  },
  "application/vnd.dart": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dart"]
  },
  "application/vnd.data-vision.rdz": {
    "source": "iana",
    "extensions": ["rdz"]
  },
  "application/vnd.debian.binary-package": {
    "source": "iana"
  },
  "application/vnd.dece.data": {
    "source": "iana",
    "extensions": ["uvf","uvvf","uvd","uvvd"]
  },
  "application/vnd.dece.ttml+xml": {
    "source": "iana",
    "extensions": ["uvt","uvvt"]
  },
  "application/vnd.dece.unspecified": {
    "source": "iana",
    "extensions": ["uvx","uvvx"]
  },
  "application/vnd.dece.zip": {
    "source": "iana",
    "extensions": ["uvz","uvvz"]
  },
  "application/vnd.denovo.fcselayout-link": {
    "source": "iana",
    "extensions": ["fe_launch"]
  },
  "application/vnd.desmume-movie": {
    "source": "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    "source": "iana"
  },
  "application/vnd.dm.delegation+xml": {
    "source": "iana"
  },
  "application/vnd.dna": {
    "source": "iana",
    "extensions": ["dna"]
  },
  "application/vnd.document+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dolby.mlp": {
    "source": "apache",
    "extensions": ["mlp"]
  },
  "application/vnd.dolby.mobile.1": {
    "source": "iana"
  },
  "application/vnd.dolby.mobile.2": {
    "source": "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    "source": "iana"
  },
  "application/vnd.dpgraph": {
    "source": "iana",
    "extensions": ["dpg"]
  },
  "application/vnd.dreamfactory": {
    "source": "iana",
    "extensions": ["dfac"]
  },
  "application/vnd.drive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ds-keypoint": {
    "source": "apache",
    "extensions": ["kpxx"]
  },
  "application/vnd.dtg.local": {
    "source": "iana"
  },
  "application/vnd.dtg.local.flash": {
    "source": "iana"
  },
  "application/vnd.dtg.local.html": {
    "source": "iana"
  },
  "application/vnd.dvb.ait": {
    "source": "iana",
    "extensions": ["ait"]
  },
  "application/vnd.dvb.dvbj": {
    "source": "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    "source": "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    "source": "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    "source": "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    "source": "iana"
  },
  "application/vnd.dvb.notif-container+xml": {
    "source": "iana"
  },
  "application/vnd.dvb.notif-generic+xml": {
    "source": "iana"
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    "source": "iana"
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    "source": "iana"
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    "source": "iana"
  },
  "application/vnd.dvb.notif-init+xml": {
    "source": "iana"
  },
  "application/vnd.dvb.pfr": {
    "source": "iana"
  },
  "application/vnd.dvb.service": {
    "source": "iana",
    "extensions": ["svc"]
  },
  "application/vnd.dxr": {
    "source": "iana"
  },
  "application/vnd.dynageo": {
    "source": "iana",
    "extensions": ["geo"]
  },
  "application/vnd.dzr": {
    "source": "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    "source": "iana"
  },
  "application/vnd.ecdis-update": {
    "source": "iana"
  },
  "application/vnd.ecowin.chart": {
    "source": "iana",
    "extensions": ["mag"]
  },
  "application/vnd.ecowin.filerequest": {
    "source": "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    "source": "iana"
  },
  "application/vnd.ecowin.series": {
    "source": "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    "source": "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    "source": "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    "source": "iana"
  },
  "application/vnd.enliven": {
    "source": "iana",
    "extensions": ["nml"]
  },
  "application/vnd.enphase.envoy": {
    "source": "iana"
  },
  "application/vnd.eprints.data+xml": {
    "source": "iana"
  },
  "application/vnd.epson.esf": {
    "source": "iana",
    "extensions": ["esf"]
  },
  "application/vnd.epson.msf": {
    "source": "iana",
    "extensions": ["msf"]
  },
  "application/vnd.epson.quickanime": {
    "source": "iana",
    "extensions": ["qam"]
  },
  "application/vnd.epson.salt": {
    "source": "iana",
    "extensions": ["slt"]
  },
  "application/vnd.epson.ssf": {
    "source": "iana",
    "extensions": ["ssf"]
  },
  "application/vnd.ericsson.quickcall": {
    "source": "iana"
  },
  "application/vnd.eszigno3+xml": {
    "source": "iana",
    "extensions": ["es3","et3"]
  },
  "application/vnd.etsi.aoc+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.asic-e+zip": {
    "source": "iana"
  },
  "application/vnd.etsi.asic-s+zip": {
    "source": "iana"
  },
  "application/vnd.etsi.cug+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.iptvcommand+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.iptvprofile+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.iptvservice+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.iptvsync+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.mcid+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.mheg5": {
    "source": "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.pstn+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.sci+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.simservs+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.timestamp-token": {
    "source": "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    "source": "iana"
  },
  "application/vnd.etsi.tsl.der": {
    "source": "iana"
  },
  "application/vnd.eudora.data": {
    "source": "iana"
  },
  "application/vnd.ezpix-album": {
    "source": "iana",
    "extensions": ["ez2"]
  },
  "application/vnd.ezpix-package": {
    "source": "iana",
    "extensions": ["ez3"]
  },
  "application/vnd.f-secure.mobile": {
    "source": "iana"
  },
  "application/vnd.fastcopy-disk-image": {
    "source": "iana"
  },
  "application/vnd.fdf": {
    "source": "iana",
    "extensions": ["fdf"]
  },
  "application/vnd.fdsn.mseed": {
    "source": "iana",
    "extensions": ["mseed"]
  },
  "application/vnd.fdsn.seed": {
    "source": "iana",
    "extensions": ["seed","dataless"]
  },
  "application/vnd.ffsns": {
    "source": "iana"
  },
  "application/vnd.filmit.zfc": {
    "source": "iana"
  },
  "application/vnd.fints": {
    "source": "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    "source": "iana"
  },
  "application/vnd.flographit": {
    "source": "iana",
    "extensions": ["gph"]
  },
  "application/vnd.fluxtime.clip": {
    "source": "iana",
    "extensions": ["ftc"]
  },
  "application/vnd.font-fontforge-sfd": {
    "source": "iana"
  },
  "application/vnd.framemaker": {
    "source": "iana",
    "extensions": ["fm","frame","maker","book"]
  },
  "application/vnd.frogans.fnc": {
    "source": "iana",
    "extensions": ["fnc"]
  },
  "application/vnd.frogans.ltf": {
    "source": "iana",
    "extensions": ["ltf"]
  },
  "application/vnd.fsc.weblaunch": {
    "source": "iana",
    "extensions": ["fsc"]
  },
  "application/vnd.fujitsu.oasys": {
    "source": "iana",
    "extensions": ["oas"]
  },
  "application/vnd.fujitsu.oasys2": {
    "source": "iana",
    "extensions": ["oa2"]
  },
  "application/vnd.fujitsu.oasys3": {
    "source": "iana",
    "extensions": ["oa3"]
  },
  "application/vnd.fujitsu.oasysgp": {
    "source": "iana",
    "extensions": ["fg5"]
  },
  "application/vnd.fujitsu.oasysprs": {
    "source": "iana",
    "extensions": ["bh2"]
  },
  "application/vnd.fujixerox.art-ex": {
    "source": "iana"
  },
  "application/vnd.fujixerox.art4": {
    "source": "iana"
  },
  "application/vnd.fujixerox.ddd": {
    "source": "iana",
    "extensions": ["ddd"]
  },
  "application/vnd.fujixerox.docuworks": {
    "source": "iana",
    "extensions": ["xdw"]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    "source": "iana",
    "extensions": ["xbd"]
  },
  "application/vnd.fujixerox.docuworks.container": {
    "source": "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    "source": "iana"
  },
  "application/vnd.fut-misnet": {
    "source": "iana"
  },
  "application/vnd.fuzzysheet": {
    "source": "iana",
    "extensions": ["fzs"]
  },
  "application/vnd.genomatix.tuxedo": {
    "source": "iana",
    "extensions": ["txd"]
  },
  "application/vnd.geo+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.geocube+xml": {
    "source": "iana"
  },
  "application/vnd.geogebra.file": {
    "source": "iana",
    "extensions": ["ggb"]
  },
  "application/vnd.geogebra.tool": {
    "source": "iana",
    "extensions": ["ggt"]
  },
  "application/vnd.geometry-explorer": {
    "source": "iana",
    "extensions": ["gex","gre"]
  },
  "application/vnd.geonext": {
    "source": "iana",
    "extensions": ["gxt"]
  },
  "application/vnd.geoplan": {
    "source": "iana",
    "extensions": ["g2w"]
  },
  "application/vnd.geospace": {
    "source": "iana",
    "extensions": ["g3w"]
  },
  "application/vnd.gerber": {
    "source": "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    "source": "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    "source": "iana"
  },
  "application/vnd.gmx": {
    "source": "iana",
    "extensions": ["gmx"]
  },
  "application/vnd.google-apps.document": {
    "compressible": false,
    "extensions": ["gdoc"]
  },
  "application/vnd.google-apps.presentation": {
    "compressible": false,
    "extensions": ["gslides"]
  },
  "application/vnd.google-apps.spreadsheet": {
    "compressible": false,
    "extensions": ["gsheet"]
  },
  "application/vnd.google-earth.kml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["kml"]
  },
  "application/vnd.google-earth.kmz": {
    "source": "iana",
    "compressible": false,
    "extensions": ["kmz"]
  },
  "application/vnd.gov.sk.e-form+xml": {
    "source": "iana"
  },
  "application/vnd.gov.sk.e-form+zip": {
    "source": "iana"
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    "source": "iana"
  },
  "application/vnd.grafeq": {
    "source": "iana",
    "extensions": ["gqf","gqs"]
  },
  "application/vnd.gridmp": {
    "source": "iana"
  },
  "application/vnd.groove-account": {
    "source": "iana",
    "extensions": ["gac"]
  },
  "application/vnd.groove-help": {
    "source": "iana",
    "extensions": ["ghf"]
  },
  "application/vnd.groove-identity-message": {
    "source": "iana",
    "extensions": ["gim"]
  },
  "application/vnd.groove-injector": {
    "source": "iana",
    "extensions": ["grv"]
  },
  "application/vnd.groove-tool-message": {
    "source": "iana",
    "extensions": ["gtm"]
  },
  "application/vnd.groove-tool-template": {
    "source": "iana",
    "extensions": ["tpl"]
  },
  "application/vnd.groove-vcard": {
    "source": "iana",
    "extensions": ["vcg"]
  },
  "application/vnd.hal+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hal+xml": {
    "source": "iana",
    "extensions": ["hal"]
  },
  "application/vnd.handheld-entertainment+xml": {
    "source": "iana",
    "extensions": ["zmm"]
  },
  "application/vnd.hbci": {
    "source": "iana",
    "extensions": ["hbci"]
  },
  "application/vnd.hcl-bireports": {
    "source": "iana"
  },
  "application/vnd.heroku+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hhe.lesson-player": {
    "source": "iana",
    "extensions": ["les"]
  },
  "application/vnd.hp-hpgl": {
    "source": "iana",
    "extensions": ["hpgl"]
  },
  "application/vnd.hp-hpid": {
    "source": "iana",
    "extensions": ["hpid"]
  },
  "application/vnd.hp-hps": {
    "source": "iana",
    "extensions": ["hps"]
  },
  "application/vnd.hp-jlyt": {
    "source": "iana",
    "extensions": ["jlt"]
  },
  "application/vnd.hp-pcl": {
    "source": "iana",
    "extensions": ["pcl"]
  },
  "application/vnd.hp-pclxl": {
    "source": "iana",
    "extensions": ["pclxl"]
  },
  "application/vnd.httphone": {
    "source": "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    "source": "iana",
    "extensions": ["sfd-hdstx"]
  },
  "application/vnd.hyperdrive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hzn-3d-crossword": {
    "source": "iana"
  },
  "application/vnd.ibm.afplinedata": {
    "source": "iana"
  },
  "application/vnd.ibm.electronic-media": {
    "source": "iana"
  },
  "application/vnd.ibm.minipay": {
    "source": "iana",
    "extensions": ["mpy"]
  },
  "application/vnd.ibm.modcap": {
    "source": "iana",
    "extensions": ["afp","listafp","list3820"]
  },
  "application/vnd.ibm.rights-management": {
    "source": "iana",
    "extensions": ["irm"]
  },
  "application/vnd.ibm.secure-container": {
    "source": "iana",
    "extensions": ["sc"]
  },
  "application/vnd.iccprofile": {
    "source": "iana",
    "extensions": ["icc","icm"]
  },
  "application/vnd.ieee.1905": {
    "source": "iana"
  },
  "application/vnd.igloader": {
    "source": "iana",
    "extensions": ["igl"]
  },
  "application/vnd.immervision-ivp": {
    "source": "iana",
    "extensions": ["ivp"]
  },
  "application/vnd.immervision-ivu": {
    "source": "iana",
    "extensions": ["ivu"]
  },
  "application/vnd.ims.imsccv1p1": {
    "source": "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    "source": "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    "source": "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.informedcontrol.rms+xml": {
    "source": "iana"
  },
  "application/vnd.informix-visionary": {
    "source": "iana"
  },
  "application/vnd.infotech.project": {
    "source": "iana"
  },
  "application/vnd.infotech.project+xml": {
    "source": "iana"
  },
  "application/vnd.innopath.wamp.notification": {
    "source": "iana"
  },
  "application/vnd.insors.igm": {
    "source": "iana",
    "extensions": ["igm"]
  },
  "application/vnd.intercon.formnet": {
    "source": "iana",
    "extensions": ["xpw","xpx"]
  },
  "application/vnd.intergeo": {
    "source": "iana",
    "extensions": ["i2g"]
  },
  "application/vnd.intertrust.digibox": {
    "source": "iana"
  },
  "application/vnd.intertrust.nncp": {
    "source": "iana"
  },
  "application/vnd.intu.qbo": {
    "source": "iana",
    "extensions": ["qbo"]
  },
  "application/vnd.intu.qfx": {
    "source": "iana",
    "extensions": ["qfx"]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    "source": "iana"
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    "source": "iana"
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    "source": "iana"
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    "source": "iana"
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    "source": "iana"
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    "source": "iana"
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    "source": "iana"
  },
  "application/vnd.ipunplugged.rcprofile": {
    "source": "iana",
    "extensions": ["rcprofile"]
  },
  "application/vnd.irepository.package+xml": {
    "source": "iana",
    "extensions": ["irp"]
  },
  "application/vnd.is-xpr": {
    "source": "iana",
    "extensions": ["xpr"]
  },
  "application/vnd.isac.fcs": {
    "source": "iana",
    "extensions": ["fcs"]
  },
  "application/vnd.jam": {
    "source": "iana",
    "extensions": ["jam"]
  },
  "application/vnd.japannet-directory-service": {
    "source": "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-registration": {
    "source": "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-verification": {
    "source": "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    "source": "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    "source": "iana",
    "extensions": ["rms"]
  },
  "application/vnd.jisp": {
    "source": "iana",
    "extensions": ["jisp"]
  },
  "application/vnd.joost.joda-archive": {
    "source": "iana",
    "extensions": ["joda"]
  },
  "application/vnd.jsk.isdn-ngn": {
    "source": "iana"
  },
  "application/vnd.kahootz": {
    "source": "iana",
    "extensions": ["ktz","ktr"]
  },
  "application/vnd.kde.karbon": {
    "source": "iana",
    "extensions": ["karbon"]
  },
  "application/vnd.kde.kchart": {
    "source": "iana",
    "extensions": ["chrt"]
  },
  "application/vnd.kde.kformula": {
    "source": "iana",
    "extensions": ["kfo"]
  },
  "application/vnd.kde.kivio": {
    "source": "iana",
    "extensions": ["flw"]
  },
  "application/vnd.kde.kontour": {
    "source": "iana",
    "extensions": ["kon"]
  },
  "application/vnd.kde.kpresenter": {
    "source": "iana",
    "extensions": ["kpr","kpt"]
  },
  "application/vnd.kde.kspread": {
    "source": "iana",
    "extensions": ["ksp"]
  },
  "application/vnd.kde.kword": {
    "source": "iana",
    "extensions": ["kwd","kwt"]
  },
  "application/vnd.kenameaapp": {
    "source": "iana",
    "extensions": ["htke"]
  },
  "application/vnd.kidspiration": {
    "source": "iana",
    "extensions": ["kia"]
  },
  "application/vnd.kinar": {
    "source": "iana",
    "extensions": ["kne","knp"]
  },
  "application/vnd.koan": {
    "source": "iana",
    "extensions": ["skp","skd","skt","skm"]
  },
  "application/vnd.kodak-descriptor": {
    "source": "iana",
    "extensions": ["sse"]
  },
  "application/vnd.las.las+xml": {
    "source": "iana",
    "extensions": ["lasxml"]
  },
  "application/vnd.liberty-request+xml": {
    "source": "iana"
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    "source": "iana",
    "extensions": ["lbd"]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    "source": "iana",
    "extensions": ["lbe"]
  },
  "application/vnd.lotus-1-2-3": {
    "source": "iana",
    "extensions": ["123"]
  },
  "application/vnd.lotus-approach": {
    "source": "iana",
    "extensions": ["apr"]
  },
  "application/vnd.lotus-freelance": {
    "source": "iana",
    "extensions": ["pre"]
  },
  "application/vnd.lotus-notes": {
    "source": "iana",
    "extensions": ["nsf"]
  },
  "application/vnd.lotus-organizer": {
    "source": "iana",
    "extensions": ["org"]
  },
  "application/vnd.lotus-screencam": {
    "source": "iana",
    "extensions": ["scm"]
  },
  "application/vnd.lotus-wordpro": {
    "source": "iana",
    "extensions": ["lwp"]
  },
  "application/vnd.macports.portpkg": {
    "source": "iana",
    "extensions": ["portpkg"]
  },
  "application/vnd.mapbox-vector-tile": {
    "source": "iana"
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    "source": "iana"
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    "source": "iana"
  },
  "application/vnd.marlin.drm.license+xml": {
    "source": "iana"
  },
  "application/vnd.marlin.drm.mdcf": {
    "source": "iana"
  },
  "application/vnd.mason+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.maxmind.maxmind-db": {
    "source": "iana"
  },
  "application/vnd.mcd": {
    "source": "iana",
    "extensions": ["mcd"]
  },
  "application/vnd.medcalcdata": {
    "source": "iana",
    "extensions": ["mc1"]
  },
  "application/vnd.mediastation.cdkey": {
    "source": "iana",
    "extensions": ["cdkey"]
  },
  "application/vnd.meridian-slingshot": {
    "source": "iana"
  },
  "application/vnd.mfer": {
    "source": "iana",
    "extensions": ["mwf"]
  },
  "application/vnd.mfmp": {
    "source": "iana",
    "extensions": ["mfm"]
  },
  "application/vnd.micro+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.micrografx.flo": {
    "source": "iana",
    "extensions": ["flo"]
  },
  "application/vnd.micrografx.igx": {
    "source": "iana",
    "extensions": ["igx"]
  },
  "application/vnd.microsoft.portable-executable": {
    "source": "iana"
  },
  "application/vnd.miele+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.mif": {
    "source": "iana",
    "extensions": ["mif"]
  },
  "application/vnd.minisoft-hp3000-save": {
    "source": "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    "source": "iana"
  },
  "application/vnd.mobius.daf": {
    "source": "iana",
    "extensions": ["daf"]
  },
  "application/vnd.mobius.dis": {
    "source": "iana",
    "extensions": ["dis"]
  },
  "application/vnd.mobius.mbk": {
    "source": "iana",
    "extensions": ["mbk"]
  },
  "application/vnd.mobius.mqy": {
    "source": "iana",
    "extensions": ["mqy"]
  },
  "application/vnd.mobius.msl": {
    "source": "iana",
    "extensions": ["msl"]
  },
  "application/vnd.mobius.plc": {
    "source": "iana",
    "extensions": ["plc"]
  },
  "application/vnd.mobius.txf": {
    "source": "iana",
    "extensions": ["txf"]
  },
  "application/vnd.mophun.application": {
    "source": "iana",
    "extensions": ["mpn"]
  },
  "application/vnd.mophun.certificate": {
    "source": "iana",
    "extensions": ["mpc"]
  },
  "application/vnd.motorola.flexsuite": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    "source": "iana"
  },
  "application/vnd.motorola.iprm": {
    "source": "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xul"]
  },
  "application/vnd.ms-3mfdocument": {
    "source": "iana"
  },
  "application/vnd.ms-artgalry": {
    "source": "iana",
    "extensions": ["cil"]
  },
  "application/vnd.ms-asf": {
    "source": "iana"
  },
  "application/vnd.ms-cab-compressed": {
    "source": "iana",
    "extensions": ["cab"]
  },
  "application/vnd.ms-color.iccprofile": {
    "source": "apache"
  },
  "application/vnd.ms-excel": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xls","xlm","xla","xlc","xlt","xlw"]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlam"]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlsb"]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlsm"]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["xltm"]
  },
  "application/vnd.ms-fontobject": {
    "source": "iana",
    "compressible": true,
    "extensions": ["eot"]
  },
  "application/vnd.ms-htmlhelp": {
    "source": "iana",
    "extensions": ["chm"]
  },
  "application/vnd.ms-ims": {
    "source": "iana",
    "extensions": ["ims"]
  },
  "application/vnd.ms-lrm": {
    "source": "iana",
    "extensions": ["lrm"]
  },
  "application/vnd.ms-office.activex+xml": {
    "source": "iana"
  },
  "application/vnd.ms-officetheme": {
    "source": "iana",
    "extensions": ["thmx"]
  },
  "application/vnd.ms-opentype": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    "source": "apache"
  },
  "application/vnd.ms-pki.seccat": {
    "source": "apache",
    "extensions": ["cat"]
  },
  "application/vnd.ms-pki.stl": {
    "source": "apache",
    "extensions": ["stl"]
  },
  "application/vnd.ms-playready.initiator+xml": {
    "source": "iana"
  },
  "application/vnd.ms-powerpoint": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ppt","pps","pot"]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    "source": "iana",
    "extensions": ["ppam"]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    "source": "iana",
    "extensions": ["pptm"]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    "source": "iana",
    "extensions": ["sldm"]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    "source": "iana",
    "extensions": ["ppsm"]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["potm"]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    "source": "iana"
  },
  "application/vnd.ms-printing.printticket+xml": {
    "source": "apache"
  },
  "application/vnd.ms-project": {
    "source": "iana",
    "extensions": ["mpp","mpt"]
  },
  "application/vnd.ms-tnef": {
    "source": "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    "source": "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    "source": "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    "source": "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    "source": "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    "source": "iana",
    "extensions": ["docm"]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["dotm"]
  },
  "application/vnd.ms-works": {
    "source": "iana",
    "extensions": ["wps","wks","wcm","wdb"]
  },
  "application/vnd.ms-wpl": {
    "source": "iana",
    "extensions": ["wpl"]
  },
  "application/vnd.ms-xpsdocument": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xps"]
  },
  "application/vnd.msa-disk-image": {
    "source": "iana"
  },
  "application/vnd.mseq": {
    "source": "iana",
    "extensions": ["mseq"]
  },
  "application/vnd.msign": {
    "source": "iana"
  },
  "application/vnd.multiad.creator": {
    "source": "iana"
  },
  "application/vnd.multiad.creator.cif": {
    "source": "iana"
  },
  "application/vnd.music-niff": {
    "source": "iana"
  },
  "application/vnd.musician": {
    "source": "iana",
    "extensions": ["mus"]
  },
  "application/vnd.muvee.style": {
    "source": "iana",
    "extensions": ["msty"]
  },
  "application/vnd.mynfc": {
    "source": "iana",
    "extensions": ["taglet"]
  },
  "application/vnd.ncd.control": {
    "source": "iana"
  },
  "application/vnd.ncd.reference": {
    "source": "iana"
  },
  "application/vnd.nervana": {
    "source": "iana"
  },
  "application/vnd.netfpx": {
    "source": "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    "source": "iana",
    "extensions": ["nlu"]
  },
  "application/vnd.nintendo.nitro.rom": {
    "source": "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    "source": "iana"
  },
  "application/vnd.nitf": {
    "source": "iana",
    "extensions": ["ntf","nitf"]
  },
  "application/vnd.noblenet-directory": {
    "source": "iana",
    "extensions": ["nnd"]
  },
  "application/vnd.noblenet-sealer": {
    "source": "iana",
    "extensions": ["nns"]
  },
  "application/vnd.noblenet-web": {
    "source": "iana",
    "extensions": ["nnw"]
  },
  "application/vnd.nokia.catalogs": {
    "source": "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.conml+xml": {
    "source": "iana"
  },
  "application/vnd.nokia.iptv.config+xml": {
    "source": "iana"
  },
  "application/vnd.nokia.isds-radio-presets": {
    "source": "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    "source": "iana"
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    "source": "iana"
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    "source": "iana"
  },
  "application/vnd.nokia.n-gage.data": {
    "source": "iana",
    "extensions": ["ngdat"]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    "source": "iana",
    "extensions": ["n-gage"]
  },
  "application/vnd.nokia.ncd": {
    "source": "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    "source": "iana"
  },
  "application/vnd.nokia.radio-preset": {
    "source": "iana",
    "extensions": ["rpst"]
  },
  "application/vnd.nokia.radio-presets": {
    "source": "iana",
    "extensions": ["rpss"]
  },
  "application/vnd.novadigm.edm": {
    "source": "iana",
    "extensions": ["edm"]
  },
  "application/vnd.novadigm.edx": {
    "source": "iana",
    "extensions": ["edx"]
  },
  "application/vnd.novadigm.ext": {
    "source": "iana",
    "extensions": ["ext"]
  },
  "application/vnd.ntt-local.content-share": {
    "source": "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    "source": "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    "source": "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    "source": "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    "source": "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    "source": "iana",
    "extensions": ["odc"]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    "source": "iana",
    "extensions": ["otc"]
  },
  "application/vnd.oasis.opendocument.database": {
    "source": "iana",
    "extensions": ["odb"]
  },
  "application/vnd.oasis.opendocument.formula": {
    "source": "iana",
    "extensions": ["odf"]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    "source": "iana",
    "extensions": ["odft"]
  },
  "application/vnd.oasis.opendocument.graphics": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odg"]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    "source": "iana",
    "extensions": ["otg"]
  },
  "application/vnd.oasis.opendocument.image": {
    "source": "iana",
    "extensions": ["odi"]
  },
  "application/vnd.oasis.opendocument.image-template": {
    "source": "iana",
    "extensions": ["oti"]
  },
  "application/vnd.oasis.opendocument.presentation": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odp"]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    "source": "iana",
    "extensions": ["otp"]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ods"]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    "source": "iana",
    "extensions": ["ots"]
  },
  "application/vnd.oasis.opendocument.text": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odt"]
  },
  "application/vnd.oasis.opendocument.text-master": {
    "source": "iana",
    "extensions": ["odm"]
  },
  "application/vnd.oasis.opendocument.text-template": {
    "source": "iana",
    "extensions": ["ott"]
  },
  "application/vnd.oasis.opendocument.text-web": {
    "source": "iana",
    "extensions": ["oth"]
  },
  "application/vnd.obn": {
    "source": "iana"
  },
  "application/vnd.oftn.l10n+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    "source": "iana"
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    "source": "iana"
  },
  "application/vnd.oipf.cspg-hexbinary": {
    "source": "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    "source": "iana"
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    "source": "iana"
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    "source": "iana"
  },
  "application/vnd.oipf.pae.gem": {
    "source": "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    "source": "iana"
  },
  "application/vnd.oipf.spdlist+xml": {
    "source": "iana"
  },
  "application/vnd.oipf.ueprofile+xml": {
    "source": "iana"
  },
  "application/vnd.oipf.userprofile+xml": {
    "source": "iana"
  },
  "application/vnd.olpc-sugar": {
    "source": "iana",
    "extensions": ["xo"]
  },
  "application/vnd.oma-scws-config": {
    "source": "iana"
  },
  "application/vnd.oma-scws-http-request": {
    "source": "iana"
  },
  "application/vnd.oma-scws-http-response": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.imd+xml": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.ltkm": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sgdu": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sprov+xml": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.stkm": {
    "source": "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    "source": "iana"
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    "source": "iana"
  },
  "application/vnd.oma.cab-pcc+xml": {
    "source": "iana"
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    "source": "iana"
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    "source": "iana"
  },
  "application/vnd.oma.dcd": {
    "source": "iana"
  },
  "application/vnd.oma.dcdc": {
    "source": "iana"
  },
  "application/vnd.oma.dd2+xml": {
    "source": "iana",
    "extensions": ["dd2"]
  },
  "application/vnd.oma.drm.risd+xml": {
    "source": "iana"
  },
  "application/vnd.oma.group-usage-list+xml": {
    "source": "iana"
  },
  "application/vnd.oma.pal+xml": {
    "source": "iana"
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    "source": "iana"
  },
  "application/vnd.oma.poc.final-report+xml": {
    "source": "iana"
  },
  "application/vnd.oma.poc.groups+xml": {
    "source": "iana"
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    "source": "iana"
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    "source": "iana"
  },
  "application/vnd.oma.push": {
    "source": "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    "source": "iana"
  },
  "application/vnd.oma.xcap-directory+xml": {
    "source": "iana"
  },
  "application/vnd.omads-email+xml": {
    "source": "iana"
  },
  "application/vnd.omads-file+xml": {
    "source": "iana"
  },
  "application/vnd.omads-folder+xml": {
    "source": "iana"
  },
  "application/vnd.omaloc-supl-init": {
    "source": "iana"
  },
  "application/vnd.openblox.game+xml": {
    "source": "iana"
  },
  "application/vnd.openblox.game-binary": {
    "source": "iana"
  },
  "application/vnd.openeye.oeb": {
    "source": "iana"
  },
  "application/vnd.openofficeorg.extension": {
    "source": "apache",
    "extensions": ["oxt"]
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml-template": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pptx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    "source": "iana",
    "extensions": ["sldx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    "source": "iana",
    "extensions": ["ppsx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    "source": "apache",
    "extensions": ["potx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml-template": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xlsx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    "source": "apache",
    "extensions": ["xltx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml-template": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    "source": "iana",
    "compressible": false,
    "extensions": ["docx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    "source": "apache",
    "extensions": ["dotx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    "source": "iana"
  },
  "application/vnd.oracle.resource+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.orange.indata": {
    "source": "iana"
  },
  "application/vnd.osa.netdeploy": {
    "source": "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    "source": "iana",
    "extensions": ["mgp"]
  },
  "application/vnd.osgi.bundle": {
    "source": "iana"
  },
  "application/vnd.osgi.dp": {
    "source": "iana",
    "extensions": ["dp"]
  },
  "application/vnd.osgi.subsystem": {
    "source": "iana",
    "extensions": ["esa"]
  },
  "application/vnd.otps.ct-kip+xml": {
    "source": "iana"
  },
  "application/vnd.oxli.countgraph": {
    "source": "iana"
  },
  "application/vnd.pagerduty+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.palm": {
    "source": "iana",
    "extensions": ["pdb","pqa","oprc"]
  },
  "application/vnd.panoply": {
    "source": "iana"
  },
  "application/vnd.paos+xml": {
    "source": "iana"
  },
  "application/vnd.paos.xml": {
    "source": "apache"
  },
  "application/vnd.pawaafile": {
    "source": "iana",
    "extensions": ["paw"]
  },
  "application/vnd.pcos": {
    "source": "iana"
  },
  "application/vnd.pg.format": {
    "source": "iana",
    "extensions": ["str"]
  },
  "application/vnd.pg.osasli": {
    "source": "iana",
    "extensions": ["ei6"]
  },
  "application/vnd.piaccess.application-licence": {
    "source": "iana"
  },
  "application/vnd.picsel": {
    "source": "iana",
    "extensions": ["efif"]
  },
  "application/vnd.pmi.widget": {
    "source": "iana",
    "extensions": ["wg"]
  },
  "application/vnd.poc.group-advertisement+xml": {
    "source": "iana"
  },
  "application/vnd.pocketlearn": {
    "source": "iana",
    "extensions": ["plf"]
  },
  "application/vnd.powerbuilder6": {
    "source": "iana",
    "extensions": ["pbd"]
  },
  "application/vnd.powerbuilder6-s": {
    "source": "iana"
  },
  "application/vnd.powerbuilder7": {
    "source": "iana"
  },
  "application/vnd.powerbuilder7-s": {
    "source": "iana"
  },
  "application/vnd.powerbuilder75": {
    "source": "iana"
  },
  "application/vnd.powerbuilder75-s": {
    "source": "iana"
  },
  "application/vnd.preminet": {
    "source": "iana"
  },
  "application/vnd.previewsystems.box": {
    "source": "iana",
    "extensions": ["box"]
  },
  "application/vnd.proteus.magazine": {
    "source": "iana",
    "extensions": ["mgz"]
  },
  "application/vnd.publishare-delta-tree": {
    "source": "iana",
    "extensions": ["qps"]
  },
  "application/vnd.pvi.ptid1": {
    "source": "iana",
    "extensions": ["ptid"]
  },
  "application/vnd.pwg-multiplexed": {
    "source": "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    "source": "iana"
  },
  "application/vnd.qualcomm.brew-app-res": {
    "source": "iana"
  },
  "application/vnd.quark.quarkxpress": {
    "source": "iana",
    "extensions": ["qxd","qxt","qwd","qwt","qxl","qxb"]
  },
  "application/vnd.quobject-quoxdocument": {
    "source": "iana"
  },
  "application/vnd.radisys.moml+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml-audit+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml-conf+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml-dialog+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    "source": "iana"
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    "source": "iana"
  },
  "application/vnd.rainstor.data": {
    "source": "iana"
  },
  "application/vnd.rapid": {
    "source": "iana"
  },
  "application/vnd.realvnc.bed": {
    "source": "iana",
    "extensions": ["bed"]
  },
  "application/vnd.recordare.musicxml": {
    "source": "iana",
    "extensions": ["mxl"]
  },
  "application/vnd.recordare.musicxml+xml": {
    "source": "iana",
    "extensions": ["musicxml"]
  },
  "application/vnd.renlearn.rlprint": {
    "source": "iana"
  },
  "application/vnd.rig.cryptonote": {
    "source": "iana",
    "extensions": ["cryptonote"]
  },
  "application/vnd.rim.cod": {
    "source": "apache",
    "extensions": ["cod"]
  },
  "application/vnd.rn-realmedia": {
    "source": "apache",
    "extensions": ["rm"]
  },
  "application/vnd.rn-realmedia-vbr": {
    "source": "apache",
    "extensions": ["rmvb"]
  },
  "application/vnd.route66.link66+xml": {
    "source": "iana",
    "extensions": ["link66"]
  },
  "application/vnd.rs-274x": {
    "source": "iana"
  },
  "application/vnd.ruckus.download": {
    "source": "iana"
  },
  "application/vnd.s3sms": {
    "source": "iana"
  },
  "application/vnd.sailingtracker.track": {
    "source": "iana",
    "extensions": ["st"]
  },
  "application/vnd.sbm.cid": {
    "source": "iana"
  },
  "application/vnd.sbm.mid2": {
    "source": "iana"
  },
  "application/vnd.scribus": {
    "source": "iana"
  },
  "application/vnd.sealed.3df": {
    "source": "iana"
  },
  "application/vnd.sealed.csf": {
    "source": "iana"
  },
  "application/vnd.sealed.doc": {
    "source": "iana"
  },
  "application/vnd.sealed.eml": {
    "source": "iana"
  },
  "application/vnd.sealed.mht": {
    "source": "iana"
  },
  "application/vnd.sealed.net": {
    "source": "iana"
  },
  "application/vnd.sealed.ppt": {
    "source": "iana"
  },
  "application/vnd.sealed.tiff": {
    "source": "iana"
  },
  "application/vnd.sealed.xls": {
    "source": "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    "source": "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    "source": "iana"
  },
  "application/vnd.seemail": {
    "source": "iana",
    "extensions": ["see"]
  },
  "application/vnd.sema": {
    "source": "iana",
    "extensions": ["sema"]
  },
  "application/vnd.semd": {
    "source": "iana",
    "extensions": ["semd"]
  },
  "application/vnd.semf": {
    "source": "iana",
    "extensions": ["semf"]
  },
  "application/vnd.shana.informed.formdata": {
    "source": "iana",
    "extensions": ["ifm"]
  },
  "application/vnd.shana.informed.formtemplate": {
    "source": "iana",
    "extensions": ["itp"]
  },
  "application/vnd.shana.informed.interchange": {
    "source": "iana",
    "extensions": ["iif"]
  },
  "application/vnd.shana.informed.package": {
    "source": "iana",
    "extensions": ["ipk"]
  },
  "application/vnd.simtech-mindmapper": {
    "source": "iana",
    "extensions": ["twd","twds"]
  },
  "application/vnd.siren+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.smaf": {
    "source": "iana",
    "extensions": ["mmf"]
  },
  "application/vnd.smart.notebook": {
    "source": "iana"
  },
  "application/vnd.smart.teacher": {
    "source": "iana",
    "extensions": ["teacher"]
  },
  "application/vnd.software602.filler.form+xml": {
    "source": "iana"
  },
  "application/vnd.software602.filler.form-xml-zip": {
    "source": "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    "source": "iana",
    "extensions": ["sdkm","sdkd"]
  },
  "application/vnd.spotfire.dxp": {
    "source": "iana",
    "extensions": ["dxp"]
  },
  "application/vnd.spotfire.sfs": {
    "source": "iana",
    "extensions": ["sfs"]
  },
  "application/vnd.sss-cod": {
    "source": "iana"
  },
  "application/vnd.sss-dtf": {
    "source": "iana"
  },
  "application/vnd.sss-ntf": {
    "source": "iana"
  },
  "application/vnd.stardivision.calc": {
    "source": "apache",
    "extensions": ["sdc"]
  },
  "application/vnd.stardivision.draw": {
    "source": "apache",
    "extensions": ["sda"]
  },
  "application/vnd.stardivision.impress": {
    "source": "apache",
    "extensions": ["sdd"]
  },
  "application/vnd.stardivision.math": {
    "source": "apache",
    "extensions": ["smf"]
  },
  "application/vnd.stardivision.writer": {
    "source": "apache",
    "extensions": ["sdw","vor"]
  },
  "application/vnd.stardivision.writer-global": {
    "source": "apache",
    "extensions": ["sgl"]
  },
  "application/vnd.stepmania.package": {
    "source": "iana",
    "extensions": ["smzip"]
  },
  "application/vnd.stepmania.stepchart": {
    "source": "iana",
    "extensions": ["sm"]
  },
  "application/vnd.street-stream": {
    "source": "iana"
  },
  "application/vnd.sun.wadl+xml": {
    "source": "iana"
  },
  "application/vnd.sun.xml.calc": {
    "source": "apache",
    "extensions": ["sxc"]
  },
  "application/vnd.sun.xml.calc.template": {
    "source": "apache",
    "extensions": ["stc"]
  },
  "application/vnd.sun.xml.draw": {
    "source": "apache",
    "extensions": ["sxd"]
  },
  "application/vnd.sun.xml.draw.template": {
    "source": "apache",
    "extensions": ["std"]
  },
  "application/vnd.sun.xml.impress": {
    "source": "apache",
    "extensions": ["sxi"]
  },
  "application/vnd.sun.xml.impress.template": {
    "source": "apache",
    "extensions": ["sti"]
  },
  "application/vnd.sun.xml.math": {
    "source": "apache",
    "extensions": ["sxm"]
  },
  "application/vnd.sun.xml.writer": {
    "source": "apache",
    "extensions": ["sxw"]
  },
  "application/vnd.sun.xml.writer.global": {
    "source": "apache",
    "extensions": ["sxg"]
  },
  "application/vnd.sun.xml.writer.template": {
    "source": "apache",
    "extensions": ["stw"]
  },
  "application/vnd.sus-calendar": {
    "source": "iana",
    "extensions": ["sus","susp"]
  },
  "application/vnd.svd": {
    "source": "iana",
    "extensions": ["svd"]
  },
  "application/vnd.swiftview-ics": {
    "source": "iana"
  },
  "application/vnd.symbian.install": {
    "source": "apache",
    "extensions": ["sis","sisx"]
  },
  "application/vnd.syncml+xml": {
    "source": "iana",
    "extensions": ["xsm"]
  },
  "application/vnd.syncml.dm+wbxml": {
    "source": "iana",
    "extensions": ["bdm"]
  },
  "application/vnd.syncml.dm+xml": {
    "source": "iana",
    "extensions": ["xdm"]
  },
  "application/vnd.syncml.dm.notification": {
    "source": "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    "source": "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    "source": "iana"
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    "source": "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    "source": "iana"
  },
  "application/vnd.syncml.ds.notification": {
    "source": "iana"
  },
  "application/vnd.tao.intent-module-archive": {
    "source": "iana",
    "extensions": ["tao"]
  },
  "application/vnd.tcpdump.pcap": {
    "source": "iana",
    "extensions": ["pcap","cap","dmp"]
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    "source": "iana"
  },
  "application/vnd.tml": {
    "source": "iana"
  },
  "application/vnd.tmobile-livetv": {
    "source": "iana",
    "extensions": ["tmo"]
  },
  "application/vnd.trid.tpt": {
    "source": "iana",
    "extensions": ["tpt"]
  },
  "application/vnd.triscape.mxs": {
    "source": "iana",
    "extensions": ["mxs"]
  },
  "application/vnd.trueapp": {
    "source": "iana",
    "extensions": ["tra"]
  },
  "application/vnd.truedoc": {
    "source": "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    "source": "iana"
  },
  "application/vnd.ufdl": {
    "source": "iana",
    "extensions": ["ufd","ufdl"]
  },
  "application/vnd.uiq.theme": {
    "source": "iana",
    "extensions": ["utz"]
  },
  "application/vnd.umajin": {
    "source": "iana",
    "extensions": ["umj"]
  },
  "application/vnd.unity": {
    "source": "iana",
    "extensions": ["unityweb"]
  },
  "application/vnd.uoml+xml": {
    "source": "iana",
    "extensions": ["uoml"]
  },
  "application/vnd.uplanet.alert": {
    "source": "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    "source": "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.cacheop": {
    "source": "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.channel": {
    "source": "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.list": {
    "source": "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.listcmd": {
    "source": "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.signal": {
    "source": "iana"
  },
  "application/vnd.uri-map": {
    "source": "iana"
  },
  "application/vnd.valve.source.material": {
    "source": "iana"
  },
  "application/vnd.vcx": {
    "source": "iana",
    "extensions": ["vcx"]
  },
  "application/vnd.vd-study": {
    "source": "iana"
  },
  "application/vnd.vectorworks": {
    "source": "iana"
  },
  "application/vnd.verimatrix.vcas": {
    "source": "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    "source": "iana"
  },
  "application/vnd.visio": {
    "source": "iana",
    "extensions": ["vsd","vst","vss","vsw"]
  },
  "application/vnd.visionary": {
    "source": "iana",
    "extensions": ["vis"]
  },
  "application/vnd.vividence.scriptfile": {
    "source": "iana"
  },
  "application/vnd.vsf": {
    "source": "iana",
    "extensions": ["vsf"]
  },
  "application/vnd.wap.sic": {
    "source": "iana"
  },
  "application/vnd.wap.slc": {
    "source": "iana"
  },
  "application/vnd.wap.wbxml": {
    "source": "iana",
    "extensions": ["wbxml"]
  },
  "application/vnd.wap.wmlc": {
    "source": "iana",
    "extensions": ["wmlc"]
  },
  "application/vnd.wap.wmlscriptc": {
    "source": "iana",
    "extensions": ["wmlsc"]
  },
  "application/vnd.webturbo": {
    "source": "iana",
    "extensions": ["wtb"]
  },
  "application/vnd.wfa.p2p": {
    "source": "iana"
  },
  "application/vnd.wfa.wsc": {
    "source": "iana"
  },
  "application/vnd.windows.devicepairing": {
    "source": "iana"
  },
  "application/vnd.wmc": {
    "source": "iana"
  },
  "application/vnd.wmf.bootstrap": {
    "source": "iana"
  },
  "application/vnd.wolfram.mathematica": {
    "source": "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    "source": "iana"
  },
  "application/vnd.wolfram.player": {
    "source": "iana",
    "extensions": ["nbp"]
  },
  "application/vnd.wordperfect": {
    "source": "iana",
    "extensions": ["wpd"]
  },
  "application/vnd.wqd": {
    "source": "iana",
    "extensions": ["wqd"]
  },
  "application/vnd.wrq-hp3000-labelled": {
    "source": "iana"
  },
  "application/vnd.wt.stf": {
    "source": "iana",
    "extensions": ["stf"]
  },
  "application/vnd.wv.csp+wbxml": {
    "source": "iana"
  },
  "application/vnd.wv.csp+xml": {
    "source": "iana"
  },
  "application/vnd.wv.ssp+xml": {
    "source": "iana"
  },
  "application/vnd.xacml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xara": {
    "source": "iana",
    "extensions": ["xar"]
  },
  "application/vnd.xfdl": {
    "source": "iana",
    "extensions": ["xfdl"]
  },
  "application/vnd.xfdl.webform": {
    "source": "iana"
  },
  "application/vnd.xmi+xml": {
    "source": "iana"
  },
  "application/vnd.xmpie.cpkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.dpkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.plan": {
    "source": "iana"
  },
  "application/vnd.xmpie.ppkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.xlim": {
    "source": "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    "source": "iana",
    "extensions": ["hvd"]
  },
  "application/vnd.yamaha.hv-script": {
    "source": "iana",
    "extensions": ["hvs"]
  },
  "application/vnd.yamaha.hv-voice": {
    "source": "iana",
    "extensions": ["hvp"]
  },
  "application/vnd.yamaha.openscoreformat": {
    "source": "iana",
    "extensions": ["osf"]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    "source": "iana",
    "extensions": ["osfpvg"]
  },
  "application/vnd.yamaha.remote-setup": {
    "source": "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    "source": "iana",
    "extensions": ["saf"]
  },
  "application/vnd.yamaha.smaf-phrase": {
    "source": "iana",
    "extensions": ["spf"]
  },
  "application/vnd.yamaha.through-ngn": {
    "source": "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    "source": "iana"
  },
  "application/vnd.yaoweme": {
    "source": "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    "source": "iana",
    "extensions": ["cmp"]
  },
  "application/vnd.zul": {
    "source": "iana",
    "extensions": ["zir","zirz"]
  },
  "application/vnd.zzazz.deck+xml": {
    "source": "iana",
    "extensions": ["zaz"]
  },
  "application/voicexml+xml": {
    "source": "iana",
    "extensions": ["vxml"]
  },
  "application/vq-rtcpxr": {
    "source": "iana"
  },
  "application/watcherinfo+xml": {
    "source": "iana"
  },
  "application/whoispp-query": {
    "source": "iana"
  },
  "application/whoispp-response": {
    "source": "iana"
  },
  "application/widget": {
    "source": "iana",
    "extensions": ["wgt"]
  },
  "application/winhlp": {
    "source": "apache",
    "extensions": ["hlp"]
  },
  "application/wita": {
    "source": "iana"
  },
  "application/wordperfect5.1": {
    "source": "iana"
  },
  "application/wsdl+xml": {
    "source": "iana",
    "extensions": ["wsdl"]
  },
  "application/wspolicy+xml": {
    "source": "iana",
    "extensions": ["wspolicy"]
  },
  "application/x-7z-compressed": {
    "source": "apache",
    "compressible": false,
    "extensions": ["7z"]
  },
  "application/x-abiword": {
    "source": "apache",
    "extensions": ["abw"]
  },
  "application/x-ace-compressed": {
    "source": "apache",
    "extensions": ["ace"]
  },
  "application/x-amf": {
    "source": "apache"
  },
  "application/x-apple-diskimage": {
    "source": "apache",
    "extensions": ["dmg"]
  },
  "application/x-authorware-bin": {
    "source": "apache",
    "extensions": ["aab","x32","u32","vox"]
  },
  "application/x-authorware-map": {
    "source": "apache",
    "extensions": ["aam"]
  },
  "application/x-authorware-seg": {
    "source": "apache",
    "extensions": ["aas"]
  },
  "application/x-bcpio": {
    "source": "apache",
    "extensions": ["bcpio"]
  },
  "application/x-bdoc": {
    "compressible": false,
    "extensions": ["bdoc"]
  },
  "application/x-bittorrent": {
    "source": "apache",
    "extensions": ["torrent"]
  },
  "application/x-blorb": {
    "source": "apache",
    "extensions": ["blb","blorb"]
  },
  "application/x-bzip": {
    "source": "apache",
    "compressible": false,
    "extensions": ["bz"]
  },
  "application/x-bzip2": {
    "source": "apache",
    "compressible": false,
    "extensions": ["bz2","boz"]
  },
  "application/x-cbr": {
    "source": "apache",
    "extensions": ["cbr","cba","cbt","cbz","cb7"]
  },
  "application/x-cdlink": {
    "source": "apache",
    "extensions": ["vcd"]
  },
  "application/x-cfs-compressed": {
    "source": "apache",
    "extensions": ["cfs"]
  },
  "application/x-chat": {
    "source": "apache",
    "extensions": ["chat"]
  },
  "application/x-chess-pgn": {
    "source": "apache",
    "extensions": ["pgn"]
  },
  "application/x-chrome-extension": {
    "extensions": ["crx"]
  },
  "application/x-cocoa": {
    "source": "nginx",
    "extensions": ["cco"]
  },
  "application/x-compress": {
    "source": "apache"
  },
  "application/x-conference": {
    "source": "apache",
    "extensions": ["nsc"]
  },
  "application/x-cpio": {
    "source": "apache",
    "extensions": ["cpio"]
  },
  "application/x-csh": {
    "source": "apache",
    "extensions": ["csh"]
  },
  "application/x-deb": {
    "compressible": false
  },
  "application/x-debian-package": {
    "source": "apache",
    "extensions": ["deb","udeb"]
  },
  "application/x-dgc-compressed": {
    "source": "apache",
    "extensions": ["dgc"]
  },
  "application/x-director": {
    "source": "apache",
    "extensions": ["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]
  },
  "application/x-doom": {
    "source": "apache",
    "extensions": ["wad"]
  },
  "application/x-dtbncx+xml": {
    "source": "apache",
    "extensions": ["ncx"]
  },
  "application/x-dtbook+xml": {
    "source": "apache",
    "extensions": ["dtb"]
  },
  "application/x-dtbresource+xml": {
    "source": "apache",
    "extensions": ["res"]
  },
  "application/x-dvi": {
    "source": "apache",
    "compressible": false,
    "extensions": ["dvi"]
  },
  "application/x-envoy": {
    "source": "apache",
    "extensions": ["evy"]
  },
  "application/x-eva": {
    "source": "apache",
    "extensions": ["eva"]
  },
  "application/x-font-bdf": {
    "source": "apache",
    "extensions": ["bdf"]
  },
  "application/x-font-dos": {
    "source": "apache"
  },
  "application/x-font-framemaker": {
    "source": "apache"
  },
  "application/x-font-ghostscript": {
    "source": "apache",
    "extensions": ["gsf"]
  },
  "application/x-font-libgrx": {
    "source": "apache"
  },
  "application/x-font-linux-psf": {
    "source": "apache",
    "extensions": ["psf"]
  },
  "application/x-font-otf": {
    "source": "apache",
    "compressible": true,
    "extensions": ["otf"]
  },
  "application/x-font-pcf": {
    "source": "apache",
    "extensions": ["pcf"]
  },
  "application/x-font-snf": {
    "source": "apache",
    "extensions": ["snf"]
  },
  "application/x-font-speedo": {
    "source": "apache"
  },
  "application/x-font-sunos-news": {
    "source": "apache"
  },
  "application/x-font-ttf": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ttf","ttc"]
  },
  "application/x-font-type1": {
    "source": "apache",
    "extensions": ["pfa","pfb","pfm","afm"]
  },
  "application/x-font-vfont": {
    "source": "apache"
  },
  "application/x-freearc": {
    "source": "apache",
    "extensions": ["arc"]
  },
  "application/x-futuresplash": {
    "source": "apache",
    "extensions": ["spl"]
  },
  "application/x-gca-compressed": {
    "source": "apache",
    "extensions": ["gca"]
  },
  "application/x-glulx": {
    "source": "apache",
    "extensions": ["ulx"]
  },
  "application/x-gnumeric": {
    "source": "apache",
    "extensions": ["gnumeric"]
  },
  "application/x-gramps-xml": {
    "source": "apache",
    "extensions": ["gramps"]
  },
  "application/x-gtar": {
    "source": "apache",
    "extensions": ["gtar"]
  },
  "application/x-gzip": {
    "source": "apache"
  },
  "application/x-hdf": {
    "source": "apache",
    "extensions": ["hdf"]
  },
  "application/x-httpd-php": {
    "compressible": true,
    "extensions": ["php"]
  },
  "application/x-install-instructions": {
    "source": "apache",
    "extensions": ["install"]
  },
  "application/x-iso9660-image": {
    "source": "apache",
    "extensions": ["iso"]
  },
  "application/x-java-archive-diff": {
    "source": "nginx",
    "extensions": ["jardiff"]
  },
  "application/x-java-jnlp-file": {
    "source": "apache",
    "compressible": false,
    "extensions": ["jnlp"]
  },
  "application/x-javascript": {
    "compressible": true
  },
  "application/x-latex": {
    "source": "apache",
    "compressible": false,
    "extensions": ["latex"]
  },
  "application/x-lua-bytecode": {
    "extensions": ["luac"]
  },
  "application/x-lzh-compressed": {
    "source": "apache",
    "extensions": ["lzh","lha"]
  },
  "application/x-makeself": {
    "source": "nginx",
    "extensions": ["run"]
  },
  "application/x-mie": {
    "source": "apache",
    "extensions": ["mie"]
  },
  "application/x-mobipocket-ebook": {
    "source": "apache",
    "extensions": ["prc","mobi"]
  },
  "application/x-mpegurl": {
    "compressible": false
  },
  "application/x-ms-application": {
    "source": "apache",
    "extensions": ["application"]
  },
  "application/x-ms-shortcut": {
    "source": "apache",
    "extensions": ["lnk"]
  },
  "application/x-ms-wmd": {
    "source": "apache",
    "extensions": ["wmd"]
  },
  "application/x-ms-wmz": {
    "source": "apache",
    "extensions": ["wmz"]
  },
  "application/x-ms-xbap": {
    "source": "apache",
    "extensions": ["xbap"]
  },
  "application/x-msaccess": {
    "source": "apache",
    "extensions": ["mdb"]
  },
  "application/x-msbinder": {
    "source": "apache",
    "extensions": ["obd"]
  },
  "application/x-mscardfile": {
    "source": "apache",
    "extensions": ["crd"]
  },
  "application/x-msclip": {
    "source": "apache",
    "extensions": ["clp"]
  },
  "application/x-msdos-program": {
    "extensions": ["exe"]
  },
  "application/x-msdownload": {
    "source": "apache",
    "extensions": ["exe","dll","com","bat","msi"]
  },
  "application/x-msmediaview": {
    "source": "apache",
    "extensions": ["mvb","m13","m14"]
  },
  "application/x-msmetafile": {
    "source": "apache",
    "extensions": ["wmf","wmz","emf","emz"]
  },
  "application/x-msmoney": {
    "source": "apache",
    "extensions": ["mny"]
  },
  "application/x-mspublisher": {
    "source": "apache",
    "extensions": ["pub"]
  },
  "application/x-msschedule": {
    "source": "apache",
    "extensions": ["scd"]
  },
  "application/x-msterminal": {
    "source": "apache",
    "extensions": ["trm"]
  },
  "application/x-mswrite": {
    "source": "apache",
    "extensions": ["wri"]
  },
  "application/x-netcdf": {
    "source": "apache",
    "extensions": ["nc","cdf"]
  },
  "application/x-ns-proxy-autoconfig": {
    "compressible": true,
    "extensions": ["pac"]
  },
  "application/x-nzb": {
    "source": "apache",
    "extensions": ["nzb"]
  },
  "application/x-perl": {
    "source": "nginx",
    "extensions": ["pl","pm"]
  },
  "application/x-pilot": {
    "source": "nginx",
    "extensions": ["prc","pdb"]
  },
  "application/x-pkcs12": {
    "source": "apache",
    "compressible": false,
    "extensions": ["p12","pfx"]
  },
  "application/x-pkcs7-certificates": {
    "source": "apache",
    "extensions": ["p7b","spc"]
  },
  "application/x-pkcs7-certreqresp": {
    "source": "apache",
    "extensions": ["p7r"]
  },
  "application/x-rar-compressed": {
    "source": "apache",
    "compressible": false,
    "extensions": ["rar"]
  },
  "application/x-redhat-package-manager": {
    "source": "nginx",
    "extensions": ["rpm"]
  },
  "application/x-research-info-systems": {
    "source": "apache",
    "extensions": ["ris"]
  },
  "application/x-sea": {
    "source": "nginx",
    "extensions": ["sea"]
  },
  "application/x-sh": {
    "source": "apache",
    "compressible": true,
    "extensions": ["sh"]
  },
  "application/x-shar": {
    "source": "apache",
    "extensions": ["shar"]
  },
  "application/x-shockwave-flash": {
    "source": "apache",
    "compressible": false,
    "extensions": ["swf"]
  },
  "application/x-silverlight-app": {
    "source": "apache",
    "extensions": ["xap"]
  },
  "application/x-sql": {
    "source": "apache",
    "extensions": ["sql"]
  },
  "application/x-stuffit": {
    "source": "apache",
    "compressible": false,
    "extensions": ["sit"]
  },
  "application/x-stuffitx": {
    "source": "apache",
    "extensions": ["sitx"]
  },
  "application/x-subrip": {
    "source": "apache",
    "extensions": ["srt"]
  },
  "application/x-sv4cpio": {
    "source": "apache",
    "extensions": ["sv4cpio"]
  },
  "application/x-sv4crc": {
    "source": "apache",
    "extensions": ["sv4crc"]
  },
  "application/x-t3vm-image": {
    "source": "apache",
    "extensions": ["t3"]
  },
  "application/x-tads": {
    "source": "apache",
    "extensions": ["gam"]
  },
  "application/x-tar": {
    "source": "apache",
    "compressible": true,
    "extensions": ["tar"]
  },
  "application/x-tcl": {
    "source": "apache",
    "extensions": ["tcl","tk"]
  },
  "application/x-tex": {
    "source": "apache",
    "extensions": ["tex"]
  },
  "application/x-tex-tfm": {
    "source": "apache",
    "extensions": ["tfm"]
  },
  "application/x-texinfo": {
    "source": "apache",
    "extensions": ["texinfo","texi"]
  },
  "application/x-tgif": {
    "source": "apache",
    "extensions": ["obj"]
  },
  "application/x-ustar": {
    "source": "apache",
    "extensions": ["ustar"]
  },
  "application/x-wais-source": {
    "source": "apache",
    "extensions": ["src"]
  },
  "application/x-web-app-manifest+json": {
    "compressible": true,
    "extensions": ["webapp"]
  },
  "application/x-www-form-urlencoded": {
    "source": "iana",
    "compressible": true
  },
  "application/x-x509-ca-cert": {
    "source": "apache",
    "extensions": ["der","crt","pem"]
  },
  "application/x-xfig": {
    "source": "apache",
    "extensions": ["fig"]
  },
  "application/x-xliff+xml": {
    "source": "apache",
    "extensions": ["xlf"]
  },
  "application/x-xpinstall": {
    "source": "apache",
    "compressible": false,
    "extensions": ["xpi"]
  },
  "application/x-xz": {
    "source": "apache",
    "extensions": ["xz"]
  },
  "application/x-zmachine": {
    "source": "apache",
    "extensions": ["z1","z2","z3","z4","z5","z6","z7","z8"]
  },
  "application/x400-bp": {
    "source": "iana"
  },
  "application/xacml+xml": {
    "source": "iana"
  },
  "application/xaml+xml": {
    "source": "apache",
    "extensions": ["xaml"]
  },
  "application/xcap-att+xml": {
    "source": "iana"
  },
  "application/xcap-caps+xml": {
    "source": "iana"
  },
  "application/xcap-diff+xml": {
    "source": "iana",
    "extensions": ["xdf"]
  },
  "application/xcap-el+xml": {
    "source": "iana"
  },
  "application/xcap-error+xml": {
    "source": "iana"
  },
  "application/xcap-ns+xml": {
    "source": "iana"
  },
  "application/xcon-conference-info+xml": {
    "source": "iana"
  },
  "application/xcon-conference-info-diff+xml": {
    "source": "iana"
  },
  "application/xenc+xml": {
    "source": "iana",
    "extensions": ["xenc"]
  },
  "application/xhtml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xhtml","xht"]
  },
  "application/xhtml-voice+xml": {
    "source": "apache"
  },
  "application/xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xml","xsl","xsd"]
  },
  "application/xml-dtd": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dtd"]
  },
  "application/xml-external-parsed-entity": {
    "source": "iana"
  },
  "application/xml-patch+xml": {
    "source": "iana"
  },
  "application/xmpp+xml": {
    "source": "iana"
  },
  "application/xop+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xop"]
  },
  "application/xproc+xml": {
    "source": "apache",
    "extensions": ["xpl"]
  },
  "application/xslt+xml": {
    "source": "iana",
    "extensions": ["xslt"]
  },
  "application/xspf+xml": {
    "source": "apache",
    "extensions": ["xspf"]
  },
  "application/xv+xml": {
    "source": "iana",
    "extensions": ["mxml","xhvml","xvml","xvm"]
  },
  "application/yang": {
    "source": "iana",
    "extensions": ["yang"]
  },
  "application/yin+xml": {
    "source": "iana",
    "extensions": ["yin"]
  },
  "application/zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["zip"]
  },
  "application/zlib": {
    "source": "iana"
  },
  "audio/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "audio/32kadpcm": {
    "source": "iana"
  },
  "audio/3gpp": {
    "source": "iana"
  },
  "audio/3gpp2": {
    "source": "iana"
  },
  "audio/ac3": {
    "source": "iana"
  },
  "audio/adpcm": {
    "source": "apache",
    "extensions": ["adp"]
  },
  "audio/amr": {
    "source": "iana"
  },
  "audio/amr-wb": {
    "source": "iana"
  },
  "audio/amr-wb+": {
    "source": "iana"
  },
  "audio/aptx": {
    "source": "iana"
  },
  "audio/asc": {
    "source": "iana"
  },
  "audio/atrac-advanced-lossless": {
    "source": "iana"
  },
  "audio/atrac-x": {
    "source": "iana"
  },
  "audio/atrac3": {
    "source": "iana"
  },
  "audio/basic": {
    "source": "iana",
    "compressible": false,
    "extensions": ["au","snd"]
  },
  "audio/bv16": {
    "source": "iana"
  },
  "audio/bv32": {
    "source": "iana"
  },
  "audio/clearmode": {
    "source": "iana"
  },
  "audio/cn": {
    "source": "iana"
  },
  "audio/dat12": {
    "source": "iana"
  },
  "audio/dls": {
    "source": "iana"
  },
  "audio/dsr-es201108": {
    "source": "iana"
  },
  "audio/dsr-es202050": {
    "source": "iana"
  },
  "audio/dsr-es202211": {
    "source": "iana"
  },
  "audio/dsr-es202212": {
    "source": "iana"
  },
  "audio/dv": {
    "source": "iana"
  },
  "audio/dvi4": {
    "source": "iana"
  },
  "audio/eac3": {
    "source": "iana"
  },
  "audio/encaprtp": {
    "source": "iana"
  },
  "audio/evrc": {
    "source": "iana"
  },
  "audio/evrc-qcp": {
    "source": "iana"
  },
  "audio/evrc0": {
    "source": "iana"
  },
  "audio/evrc1": {
    "source": "iana"
  },
  "audio/evrcb": {
    "source": "iana"
  },
  "audio/evrcb0": {
    "source": "iana"
  },
  "audio/evrcb1": {
    "source": "iana"
  },
  "audio/evrcnw": {
    "source": "iana"
  },
  "audio/evrcnw0": {
    "source": "iana"
  },
  "audio/evrcnw1": {
    "source": "iana"
  },
  "audio/evrcwb": {
    "source": "iana"
  },
  "audio/evrcwb0": {
    "source": "iana"
  },
  "audio/evrcwb1": {
    "source": "iana"
  },
  "audio/evs": {
    "source": "iana"
  },
  "audio/fwdred": {
    "source": "iana"
  },
  "audio/g711-0": {
    "source": "iana"
  },
  "audio/g719": {
    "source": "iana"
  },
  "audio/g722": {
    "source": "iana"
  },
  "audio/g7221": {
    "source": "iana"
  },
  "audio/g723": {
    "source": "iana"
  },
  "audio/g726-16": {
    "source": "iana"
  },
  "audio/g726-24": {
    "source": "iana"
  },
  "audio/g726-32": {
    "source": "iana"
  },
  "audio/g726-40": {
    "source": "iana"
  },
  "audio/g728": {
    "source": "iana"
  },
  "audio/g729": {
    "source": "iana"
  },
  "audio/g7291": {
    "source": "iana"
  },
  "audio/g729d": {
    "source": "iana"
  },
  "audio/g729e": {
    "source": "iana"
  },
  "audio/gsm": {
    "source": "iana"
  },
  "audio/gsm-efr": {
    "source": "iana"
  },
  "audio/gsm-hr-08": {
    "source": "iana"
  },
  "audio/ilbc": {
    "source": "iana"
  },
  "audio/ip-mr_v2.5": {
    "source": "iana"
  },
  "audio/isac": {
    "source": "apache"
  },
  "audio/l16": {
    "source": "iana"
  },
  "audio/l20": {
    "source": "iana"
  },
  "audio/l24": {
    "source": "iana",
    "compressible": false
  },
  "audio/l8": {
    "source": "iana"
  },
  "audio/lpc": {
    "source": "iana"
  },
  "audio/midi": {
    "source": "apache",
    "extensions": ["mid","midi","kar","rmi"]
  },
  "audio/mobile-xmf": {
    "source": "iana"
  },
  "audio/mp4": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mp4a","m4a"]
  },
  "audio/mp4a-latm": {
    "source": "iana"
  },
  "audio/mpa": {
    "source": "iana"
  },
  "audio/mpa-robust": {
    "source": "iana"
  },
  "audio/mpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mpga","mp2","mp2a","mp3","m2a","m3a"]
  },
  "audio/mpeg4-generic": {
    "source": "iana"
  },
  "audio/musepack": {
    "source": "apache"
  },
  "audio/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["oga","ogg","spx"]
  },
  "audio/opus": {
    "source": "iana"
  },
  "audio/parityfec": {
    "source": "iana"
  },
  "audio/pcma": {
    "source": "iana"
  },
  "audio/pcma-wb": {
    "source": "iana"
  },
  "audio/pcmu": {
    "source": "iana"
  },
  "audio/pcmu-wb": {
    "source": "iana"
  },
  "audio/prs.sid": {
    "source": "iana"
  },
  "audio/qcelp": {
    "source": "iana"
  },
  "audio/raptorfec": {
    "source": "iana"
  },
  "audio/red": {
    "source": "iana"
  },
  "audio/rtp-enc-aescm128": {
    "source": "iana"
  },
  "audio/rtp-midi": {
    "source": "iana"
  },
  "audio/rtploopback": {
    "source": "iana"
  },
  "audio/rtx": {
    "source": "iana"
  },
  "audio/s3m": {
    "source": "apache",
    "extensions": ["s3m"]
  },
  "audio/silk": {
    "source": "apache",
    "extensions": ["sil"]
  },
  "audio/smv": {
    "source": "iana"
  },
  "audio/smv-qcp": {
    "source": "iana"
  },
  "audio/smv0": {
    "source": "iana"
  },
  "audio/sp-midi": {
    "source": "iana"
  },
  "audio/speex": {
    "source": "iana"
  },
  "audio/t140c": {
    "source": "iana"
  },
  "audio/t38": {
    "source": "iana"
  },
  "audio/telephone-event": {
    "source": "iana"
  },
  "audio/tone": {
    "source": "iana"
  },
  "audio/uemclip": {
    "source": "iana"
  },
  "audio/ulpfec": {
    "source": "iana"
  },
  "audio/vdvi": {
    "source": "iana"
  },
  "audio/vmr-wb": {
    "source": "iana"
  },
  "audio/vnd.3gpp.iufp": {
    "source": "iana"
  },
  "audio/vnd.4sb": {
    "source": "iana"
  },
  "audio/vnd.audiokoz": {
    "source": "iana"
  },
  "audio/vnd.celp": {
    "source": "iana"
  },
  "audio/vnd.cisco.nse": {
    "source": "iana"
  },
  "audio/vnd.cmles.radio-events": {
    "source": "iana"
  },
  "audio/vnd.cns.anp1": {
    "source": "iana"
  },
  "audio/vnd.cns.inf1": {
    "source": "iana"
  },
  "audio/vnd.dece.audio": {
    "source": "iana",
    "extensions": ["uva","uvva"]
  },
  "audio/vnd.digital-winds": {
    "source": "iana",
    "extensions": ["eol"]
  },
  "audio/vnd.dlna.adts": {
    "source": "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    "source": "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    "source": "iana"
  },
  "audio/vnd.dolby.mlp": {
    "source": "iana"
  },
  "audio/vnd.dolby.mps": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2x": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2z": {
    "source": "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    "source": "iana"
  },
  "audio/vnd.dra": {
    "source": "iana",
    "extensions": ["dra"]
  },
  "audio/vnd.dts": {
    "source": "iana",
    "extensions": ["dts"]
  },
  "audio/vnd.dts.hd": {
    "source": "iana",
    "extensions": ["dtshd"]
  },
  "audio/vnd.dvb.file": {
    "source": "iana"
  },
  "audio/vnd.everad.plj": {
    "source": "iana"
  },
  "audio/vnd.hns.audio": {
    "source": "iana"
  },
  "audio/vnd.lucent.voice": {
    "source": "iana",
    "extensions": ["lvp"]
  },
  "audio/vnd.ms-playready.media.pya": {
    "source": "iana",
    "extensions": ["pya"]
  },
  "audio/vnd.nokia.mobile-xmf": {
    "source": "iana"
  },
  "audio/vnd.nortel.vbk": {
    "source": "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    "source": "iana",
    "extensions": ["ecelp4800"]
  },
  "audio/vnd.nuera.ecelp7470": {
    "source": "iana",
    "extensions": ["ecelp7470"]
  },
  "audio/vnd.nuera.ecelp9600": {
    "source": "iana",
    "extensions": ["ecelp9600"]
  },
  "audio/vnd.octel.sbc": {
    "source": "iana"
  },
  "audio/vnd.qcelp": {
    "source": "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    "source": "iana"
  },
  "audio/vnd.rip": {
    "source": "iana",
    "extensions": ["rip"]
  },
  "audio/vnd.rn-realaudio": {
    "compressible": false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    "source": "iana"
  },
  "audio/vnd.vmx.cvsd": {
    "source": "iana"
  },
  "audio/vnd.wave": {
    "compressible": false
  },
  "audio/vorbis": {
    "source": "iana",
    "compressible": false
  },
  "audio/vorbis-config": {
    "source": "iana"
  },
  "audio/wav": {
    "compressible": false,
    "extensions": ["wav"]
  },
  "audio/wave": {
    "compressible": false,
    "extensions": ["wav"]
  },
  "audio/webm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["weba"]
  },
  "audio/x-aac": {
    "source": "apache",
    "compressible": false,
    "extensions": ["aac"]
  },
  "audio/x-aiff": {
    "source": "apache",
    "extensions": ["aif","aiff","aifc"]
  },
  "audio/x-caf": {
    "source": "apache",
    "compressible": false,
    "extensions": ["caf"]
  },
  "audio/x-flac": {
    "source": "apache",
    "extensions": ["flac"]
  },
  "audio/x-m4a": {
    "source": "nginx",
    "extensions": ["m4a"]
  },
  "audio/x-matroska": {
    "source": "apache",
    "extensions": ["mka"]
  },
  "audio/x-mpegurl": {
    "source": "apache",
    "extensions": ["m3u"]
  },
  "audio/x-ms-wax": {
    "source": "apache",
    "extensions": ["wax"]
  },
  "audio/x-ms-wma": {
    "source": "apache",
    "extensions": ["wma"]
  },
  "audio/x-pn-realaudio": {
    "source": "apache",
    "extensions": ["ram","ra"]
  },
  "audio/x-pn-realaudio-plugin": {
    "source": "apache",
    "extensions": ["rmp"]
  },
  "audio/x-realaudio": {
    "source": "nginx",
    "extensions": ["ra"]
  },
  "audio/x-tta": {
    "source": "apache"
  },
  "audio/x-wav": {
    "source": "apache",
    "extensions": ["wav"]
  },
  "audio/xm": {
    "source": "apache",
    "extensions": ["xm"]
  },
  "chemical/x-cdx": {
    "source": "apache",
    "extensions": ["cdx"]
  },
  "chemical/x-cif": {
    "source": "apache",
    "extensions": ["cif"]
  },
  "chemical/x-cmdf": {
    "source": "apache",
    "extensions": ["cmdf"]
  },
  "chemical/x-cml": {
    "source": "apache",
    "extensions": ["cml"]
  },
  "chemical/x-csml": {
    "source": "apache",
    "extensions": ["csml"]
  },
  "chemical/x-pdb": {
    "source": "apache"
  },
  "chemical/x-xyz": {
    "source": "apache",
    "extensions": ["xyz"]
  },
  "font/opentype": {
    "compressible": true,
    "extensions": ["otf"]
  },
  "image/bmp": {
    "source": "apache",
    "compressible": true,
    "extensions": ["bmp"]
  },
  "image/cgm": {
    "source": "iana",
    "extensions": ["cgm"]
  },
  "image/fits": {
    "source": "iana"
  },
  "image/g3fax": {
    "source": "iana",
    "extensions": ["g3"]
  },
  "image/gif": {
    "source": "iana",
    "compressible": false,
    "extensions": ["gif"]
  },
  "image/ief": {
    "source": "iana",
    "extensions": ["ief"]
  },
  "image/jp2": {
    "source": "iana"
  },
  "image/jpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpeg","jpg","jpe"]
  },
  "image/jpm": {
    "source": "iana"
  },
  "image/jpx": {
    "source": "iana"
  },
  "image/ktx": {
    "source": "iana",
    "extensions": ["ktx"]
  },
  "image/naplps": {
    "source": "iana"
  },
  "image/pjpeg": {
    "compressible": false
  },
  "image/png": {
    "source": "iana",
    "compressible": false,
    "extensions": ["png"]
  },
  "image/prs.btif": {
    "source": "iana",
    "extensions": ["btif"]
  },
  "image/prs.pti": {
    "source": "iana"
  },
  "image/pwg-raster": {
    "source": "iana"
  },
  "image/sgi": {
    "source": "apache",
    "extensions": ["sgi"]
  },
  "image/svg+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["svg","svgz"]
  },
  "image/t38": {
    "source": "iana"
  },
  "image/tiff": {
    "source": "iana",
    "compressible": false,
    "extensions": ["tiff","tif"]
  },
  "image/tiff-fx": {
    "source": "iana"
  },
  "image/vnd.adobe.photoshop": {
    "source": "iana",
    "compressible": true,
    "extensions": ["psd"]
  },
  "image/vnd.airzip.accelerator.azv": {
    "source": "iana"
  },
  "image/vnd.cns.inf2": {
    "source": "iana"
  },
  "image/vnd.dece.graphic": {
    "source": "iana",
    "extensions": ["uvi","uvvi","uvg","uvvg"]
  },
  "image/vnd.djvu": {
    "source": "iana",
    "extensions": ["djvu","djv"]
  },
  "image/vnd.dvb.subtitle": {
    "source": "iana",
    "extensions": ["sub"]
  },
  "image/vnd.dwg": {
    "source": "iana",
    "extensions": ["dwg"]
  },
  "image/vnd.dxf": {
    "source": "iana",
    "extensions": ["dxf"]
  },
  "image/vnd.fastbidsheet": {
    "source": "iana",
    "extensions": ["fbs"]
  },
  "image/vnd.fpx": {
    "source": "iana",
    "extensions": ["fpx"]
  },
  "image/vnd.fst": {
    "source": "iana",
    "extensions": ["fst"]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    "source": "iana",
    "extensions": ["mmr"]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    "source": "iana",
    "extensions": ["rlc"]
  },
  "image/vnd.globalgraphics.pgb": {
    "source": "iana"
  },
  "image/vnd.microsoft.icon": {
    "source": "iana"
  },
  "image/vnd.mix": {
    "source": "iana"
  },
  "image/vnd.mozilla.apng": {
    "source": "iana"
  },
  "image/vnd.ms-modi": {
    "source": "iana",
    "extensions": ["mdi"]
  },
  "image/vnd.ms-photo": {
    "source": "apache",
    "extensions": ["wdp"]
  },
  "image/vnd.net-fpx": {
    "source": "iana",
    "extensions": ["npx"]
  },
  "image/vnd.radiance": {
    "source": "iana"
  },
  "image/vnd.sealed.png": {
    "source": "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    "source": "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    "source": "iana"
  },
  "image/vnd.svf": {
    "source": "iana"
  },
  "image/vnd.tencent.tap": {
    "source": "iana"
  },
  "image/vnd.valve.source.texture": {
    "source": "iana"
  },
  "image/vnd.wap.wbmp": {
    "source": "iana",
    "extensions": ["wbmp"]
  },
  "image/vnd.xiff": {
    "source": "iana",
    "extensions": ["xif"]
  },
  "image/vnd.zbrush.pcx": {
    "source": "iana"
  },
  "image/webp": {
    "source": "apache",
    "extensions": ["webp"]
  },
  "image/x-3ds": {
    "source": "apache",
    "extensions": ["3ds"]
  },
  "image/x-cmu-raster": {
    "source": "apache",
    "extensions": ["ras"]
  },
  "image/x-cmx": {
    "source": "apache",
    "extensions": ["cmx"]
  },
  "image/x-freehand": {
    "source": "apache",
    "extensions": ["fh","fhc","fh4","fh5","fh7"]
  },
  "image/x-icon": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ico"]
  },
  "image/x-jng": {
    "source": "nginx",
    "extensions": ["jng"]
  },
  "image/x-mrsid-image": {
    "source": "apache",
    "extensions": ["sid"]
  },
  "image/x-ms-bmp": {
    "source": "nginx",
    "compressible": true,
    "extensions": ["bmp"]
  },
  "image/x-pcx": {
    "source": "apache",
    "extensions": ["pcx"]
  },
  "image/x-pict": {
    "source": "apache",
    "extensions": ["pic","pct"]
  },
  "image/x-portable-anymap": {
    "source": "apache",
    "extensions": ["pnm"]
  },
  "image/x-portable-bitmap": {
    "source": "apache",
    "extensions": ["pbm"]
  },
  "image/x-portable-graymap": {
    "source": "apache",
    "extensions": ["pgm"]
  },
  "image/x-portable-pixmap": {
    "source": "apache",
    "extensions": ["ppm"]
  },
  "image/x-rgb": {
    "source": "apache",
    "extensions": ["rgb"]
  },
  "image/x-tga": {
    "source": "apache",
    "extensions": ["tga"]
  },
  "image/x-xbitmap": {
    "source": "apache",
    "extensions": ["xbm"]
  },
  "image/x-xcf": {
    "compressible": false
  },
  "image/x-xpixmap": {
    "source": "apache",
    "extensions": ["xpm"]
  },
  "image/x-xwindowdump": {
    "source": "apache",
    "extensions": ["xwd"]
  },
  "message/cpim": {
    "source": "iana"
  },
  "message/delivery-status": {
    "source": "iana"
  },
  "message/disposition-notification": {
    "source": "iana"
  },
  "message/external-body": {
    "source": "iana"
  },
  "message/feedback-report": {
    "source": "iana"
  },
  "message/global": {
    "source": "iana"
  },
  "message/global-delivery-status": {
    "source": "iana"
  },
  "message/global-disposition-notification": {
    "source": "iana"
  },
  "message/global-headers": {
    "source": "iana"
  },
  "message/http": {
    "source": "iana",
    "compressible": false
  },
  "message/imdn+xml": {
    "source": "iana",
    "compressible": true
  },
  "message/news": {
    "source": "iana"
  },
  "message/partial": {
    "source": "iana",
    "compressible": false
  },
  "message/rfc822": {
    "source": "iana",
    "compressible": true,
    "extensions": ["eml","mime"]
  },
  "message/s-http": {
    "source": "iana"
  },
  "message/sip": {
    "source": "iana"
  },
  "message/sipfrag": {
    "source": "iana"
  },
  "message/tracking-status": {
    "source": "iana"
  },
  "message/vnd.si.simp": {
    "source": "iana"
  },
  "message/vnd.wfa.wsc": {
    "source": "iana"
  },
  "model/iges": {
    "source": "iana",
    "compressible": false,
    "extensions": ["igs","iges"]
  },
  "model/mesh": {
    "source": "iana",
    "compressible": false,
    "extensions": ["msh","mesh","silo"]
  },
  "model/vnd.collada+xml": {
    "source": "iana",
    "extensions": ["dae"]
  },
  "model/vnd.dwf": {
    "source": "iana",
    "extensions": ["dwf"]
  },
  "model/vnd.flatland.3dml": {
    "source": "iana"
  },
  "model/vnd.gdl": {
    "source": "iana",
    "extensions": ["gdl"]
  },
  "model/vnd.gs-gdl": {
    "source": "apache"
  },
  "model/vnd.gs.gdl": {
    "source": "iana"
  },
  "model/vnd.gtw": {
    "source": "iana",
    "extensions": ["gtw"]
  },
  "model/vnd.moml+xml": {
    "source": "iana"
  },
  "model/vnd.mts": {
    "source": "iana",
    "extensions": ["mts"]
  },
  "model/vnd.opengex": {
    "source": "iana"
  },
  "model/vnd.parasolid.transmit.binary": {
    "source": "iana"
  },
  "model/vnd.parasolid.transmit.text": {
    "source": "iana"
  },
  "model/vnd.valve.source.compiled-map": {
    "source": "iana"
  },
  "model/vnd.vtu": {
    "source": "iana",
    "extensions": ["vtu"]
  },
  "model/vrml": {
    "source": "iana",
    "compressible": false,
    "extensions": ["wrl","vrml"]
  },
  "model/x3d+binary": {
    "source": "apache",
    "compressible": false,
    "extensions": ["x3db","x3dbz"]
  },
  "model/x3d+fastinfoset": {
    "source": "iana"
  },
  "model/x3d+vrml": {
    "source": "apache",
    "compressible": false,
    "extensions": ["x3dv","x3dvz"]
  },
  "model/x3d+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["x3d","x3dz"]
  },
  "model/x3d-vrml": {
    "source": "iana"
  },
  "multipart/alternative": {
    "source": "iana",
    "compressible": false
  },
  "multipart/appledouble": {
    "source": "iana"
  },
  "multipart/byteranges": {
    "source": "iana"
  },
  "multipart/digest": {
    "source": "iana"
  },
  "multipart/encrypted": {
    "source": "iana",
    "compressible": false
  },
  "multipart/form-data": {
    "source": "iana",
    "compressible": false
  },
  "multipart/header-set": {
    "source": "iana"
  },
  "multipart/mixed": {
    "source": "iana",
    "compressible": false
  },
  "multipart/parallel": {
    "source": "iana"
  },
  "multipart/related": {
    "source": "iana",
    "compressible": false
  },
  "multipart/report": {
    "source": "iana"
  },
  "multipart/signed": {
    "source": "iana",
    "compressible": false
  },
  "multipart/voice-message": {
    "source": "iana"
  },
  "multipart/x-mixed-replace": {
    "source": "iana"
  },
  "text/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "text/cache-manifest": {
    "source": "iana",
    "compressible": true,
    "extensions": ["appcache","manifest"]
  },
  "text/calendar": {
    "source": "iana",
    "extensions": ["ics","ifb"]
  },
  "text/calender": {
    "compressible": true
  },
  "text/cmd": {
    "compressible": true
  },
  "text/coffeescript": {
    "extensions": ["coffee","litcoffee"]
  },
  "text/css": {
    "source": "iana",
    "compressible": true,
    "extensions": ["css"]
  },
  "text/csv": {
    "source": "iana",
    "compressible": true,
    "extensions": ["csv"]
  },
  "text/csv-schema": {
    "source": "iana"
  },
  "text/directory": {
    "source": "iana"
  },
  "text/dns": {
    "source": "iana"
  },
  "text/ecmascript": {
    "source": "iana"
  },
  "text/encaprtp": {
    "source": "iana"
  },
  "text/enriched": {
    "source": "iana"
  },
  "text/fwdred": {
    "source": "iana"
  },
  "text/grammar-ref-list": {
    "source": "iana"
  },
  "text/hjson": {
    "extensions": ["hjson"]
  },
  "text/html": {
    "source": "iana",
    "compressible": true,
    "extensions": ["html","htm","shtml"]
  },
  "text/jade": {
    "extensions": ["jade"]
  },
  "text/javascript": {
    "source": "iana",
    "compressible": true
  },
  "text/jcr-cnd": {
    "source": "iana"
  },
  "text/jsx": {
    "compressible": true,
    "extensions": ["jsx"]
  },
  "text/less": {
    "extensions": ["less"]
  },
  "text/markdown": {
    "source": "iana"
  },
  "text/mathml": {
    "source": "nginx",
    "extensions": ["mml"]
  },
  "text/mizar": {
    "source": "iana"
  },
  "text/n3": {
    "source": "iana",
    "compressible": true,
    "extensions": ["n3"]
  },
  "text/parameters": {
    "source": "iana"
  },
  "text/parityfec": {
    "source": "iana"
  },
  "text/plain": {
    "source": "iana",
    "compressible": true,
    "extensions": ["txt","text","conf","def","list","log","in","ini"]
  },
  "text/provenance-notation": {
    "source": "iana"
  },
  "text/prs.fallenstein.rst": {
    "source": "iana"
  },
  "text/prs.lines.tag": {
    "source": "iana",
    "extensions": ["dsc"]
  },
  "text/raptorfec": {
    "source": "iana"
  },
  "text/red": {
    "source": "iana"
  },
  "text/rfc822-headers": {
    "source": "iana"
  },
  "text/richtext": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtx"]
  },
  "text/rtf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtf"]
  },
  "text/rtp-enc-aescm128": {
    "source": "iana"
  },
  "text/rtploopback": {
    "source": "iana"
  },
  "text/rtx": {
    "source": "iana"
  },
  "text/sgml": {
    "source": "iana",
    "extensions": ["sgml","sgm"]
  },
  "text/stylus": {
    "extensions": ["stylus","styl"]
  },
  "text/t140": {
    "source": "iana"
  },
  "text/tab-separated-values": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tsv"]
  },
  "text/troff": {
    "source": "iana",
    "extensions": ["t","tr","roff","man","me","ms"]
  },
  "text/turtle": {
    "source": "iana",
    "extensions": ["ttl"]
  },
  "text/ulpfec": {
    "source": "iana"
  },
  "text/uri-list": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uri","uris","urls"]
  },
  "text/vcard": {
    "source": "iana",
    "compressible": true,
    "extensions": ["vcard"]
  },
  "text/vnd.a": {
    "source": "iana"
  },
  "text/vnd.abc": {
    "source": "iana"
  },
  "text/vnd.curl": {
    "source": "iana",
    "extensions": ["curl"]
  },
  "text/vnd.curl.dcurl": {
    "source": "apache",
    "extensions": ["dcurl"]
  },
  "text/vnd.curl.mcurl": {
    "source": "apache",
    "extensions": ["mcurl"]
  },
  "text/vnd.curl.scurl": {
    "source": "apache",
    "extensions": ["scurl"]
  },
  "text/vnd.debian.copyright": {
    "source": "iana"
  },
  "text/vnd.dmclientscript": {
    "source": "iana"
  },
  "text/vnd.dvb.subtitle": {
    "source": "iana",
    "extensions": ["sub"]
  },
  "text/vnd.esmertec.theme-descriptor": {
    "source": "iana"
  },
  "text/vnd.fly": {
    "source": "iana",
    "extensions": ["fly"]
  },
  "text/vnd.fmi.flexstor": {
    "source": "iana",
    "extensions": ["flx"]
  },
  "text/vnd.graphviz": {
    "source": "iana",
    "extensions": ["gv"]
  },
  "text/vnd.in3d.3dml": {
    "source": "iana",
    "extensions": ["3dml"]
  },
  "text/vnd.in3d.spot": {
    "source": "iana",
    "extensions": ["spot"]
  },
  "text/vnd.iptc.newsml": {
    "source": "iana"
  },
  "text/vnd.iptc.nitf": {
    "source": "iana"
  },
  "text/vnd.latex-z": {
    "source": "iana"
  },
  "text/vnd.motorola.reflex": {
    "source": "iana"
  },
  "text/vnd.ms-mediapackage": {
    "source": "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    "source": "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    "source": "iana"
  },
  "text/vnd.si.uricatalogue": {
    "source": "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    "source": "iana",
    "extensions": ["jad"]
  },
  "text/vnd.trolltech.linguist": {
    "source": "iana"
  },
  "text/vnd.wap.si": {
    "source": "iana"
  },
  "text/vnd.wap.sl": {
    "source": "iana"
  },
  "text/vnd.wap.wml": {
    "source": "iana",
    "extensions": ["wml"]
  },
  "text/vnd.wap.wmlscript": {
    "source": "iana",
    "extensions": ["wmls"]
  },
  "text/vtt": {
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["vtt"]
  },
  "text/x-asm": {
    "source": "apache",
    "extensions": ["s","asm"]
  },
  "text/x-c": {
    "source": "apache",
    "extensions": ["c","cc","cxx","cpp","h","hh","dic"]
  },
  "text/x-component": {
    "source": "nginx",
    "extensions": ["htc"]
  },
  "text/x-fortran": {
    "source": "apache",
    "extensions": ["f","for","f77","f90"]
  },
  "text/x-gwt-rpc": {
    "compressible": true
  },
  "text/x-handlebars-template": {
    "extensions": ["hbs"]
  },
  "text/x-java-source": {
    "source": "apache",
    "extensions": ["java"]
  },
  "text/x-jquery-tmpl": {
    "compressible": true
  },
  "text/x-lua": {
    "extensions": ["lua"]
  },
  "text/x-markdown": {
    "compressible": true,
    "extensions": ["markdown","md","mkd"]
  },
  "text/x-nfo": {
    "source": "apache",
    "extensions": ["nfo"]
  },
  "text/x-opml": {
    "source": "apache",
    "extensions": ["opml"]
  },
  "text/x-pascal": {
    "source": "apache",
    "extensions": ["p","pas"]
  },
  "text/x-processing": {
    "compressible": true,
    "extensions": ["pde"]
  },
  "text/x-sass": {
    "extensions": ["sass"]
  },
  "text/x-scss": {
    "extensions": ["scss"]
  },
  "text/x-setext": {
    "source": "apache",
    "extensions": ["etx"]
  },
  "text/x-sfv": {
    "source": "apache",
    "extensions": ["sfv"]
  },
  "text/x-suse-ymp": {
    "compressible": true,
    "extensions": ["ymp"]
  },
  "text/x-uuencode": {
    "source": "apache",
    "extensions": ["uu"]
  },
  "text/x-vcalendar": {
    "source": "apache",
    "extensions": ["vcs"]
  },
  "text/x-vcard": {
    "source": "apache",
    "extensions": ["vcf"]
  },
  "text/xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xml"]
  },
  "text/xml-external-parsed-entity": {
    "source": "iana"
  },
  "text/yaml": {
    "extensions": ["yaml","yml"]
  },
  "video/1d-interleaved-parityfec": {
    "source": "apache"
  },
  "video/3gpp": {
    "source": "apache",
    "extensions": ["3gp","3gpp"]
  },
  "video/3gpp-tt": {
    "source": "apache"
  },
  "video/3gpp2": {
    "source": "apache",
    "extensions": ["3g2"]
  },
  "video/bmpeg": {
    "source": "apache"
  },
  "video/bt656": {
    "source": "apache"
  },
  "video/celb": {
    "source": "apache"
  },
  "video/dv": {
    "source": "apache"
  },
  "video/h261": {
    "source": "apache",
    "extensions": ["h261"]
  },
  "video/h263": {
    "source": "apache",
    "extensions": ["h263"]
  },
  "video/h263-1998": {
    "source": "apache"
  },
  "video/h263-2000": {
    "source": "apache"
  },
  "video/h264": {
    "source": "apache",
    "extensions": ["h264"]
  },
  "video/h264-rcdo": {
    "source": "apache"
  },
  "video/h264-svc": {
    "source": "apache"
  },
  "video/jpeg": {
    "source": "apache",
    "extensions": ["jpgv"]
  },
  "video/jpeg2000": {
    "source": "apache"
  },
  "video/jpm": {
    "source": "apache",
    "extensions": ["jpm","jpgm"]
  },
  "video/mj2": {
    "source": "apache",
    "extensions": ["mj2","mjp2"]
  },
  "video/mp1s": {
    "source": "apache"
  },
  "video/mp2p": {
    "source": "apache"
  },
  "video/mp2t": {
    "source": "apache",
    "extensions": ["ts"]
  },
  "video/mp4": {
    "source": "apache",
    "compressible": false,
    "extensions": ["mp4","mp4v","mpg4"]
  },
  "video/mp4v-es": {
    "source": "apache"
  },
  "video/mpeg": {
    "source": "apache",
    "compressible": false,
    "extensions": ["mpeg","mpg","mpe","m1v","m2v"]
  },
  "video/mpeg4-generic": {
    "source": "apache"
  },
  "video/mpv": {
    "source": "apache"
  },
  "video/nv": {
    "source": "apache"
  },
  "video/ogg": {
    "source": "apache",
    "compressible": false,
    "extensions": ["ogv"]
  },
  "video/parityfec": {
    "source": "apache"
  },
  "video/pointer": {
    "source": "apache"
  },
  "video/quicktime": {
    "source": "apache",
    "compressible": false,
    "extensions": ["qt","mov"]
  },
  "video/raw": {
    "source": "apache"
  },
  "video/rtp-enc-aescm128": {
    "source": "apache"
  },
  "video/rtx": {
    "source": "apache"
  },
  "video/smpte292m": {
    "source": "apache"
  },
  "video/ulpfec": {
    "source": "apache"
  },
  "video/vc1": {
    "source": "apache"
  },
  "video/vnd.cctv": {
    "source": "apache"
  },
  "video/vnd.dece.hd": {
    "source": "apache",
    "extensions": ["uvh","uvvh"]
  },
  "video/vnd.dece.mobile": {
    "source": "apache",
    "extensions": ["uvm","uvvm"]
  },
  "video/vnd.dece.mp4": {
    "source": "apache"
  },
  "video/vnd.dece.pd": {
    "source": "apache",
    "extensions": ["uvp","uvvp"]
  },
  "video/vnd.dece.sd": {
    "source": "apache",
    "extensions": ["uvs","uvvs"]
  },
  "video/vnd.dece.video": {
    "source": "apache",
    "extensions": ["uvv","uvvv"]
  },
  "video/vnd.directv.mpeg": {
    "source": "apache"
  },
  "video/vnd.directv.mpeg-tts": {
    "source": "apache"
  },
  "video/vnd.dlna.mpeg-tts": {
    "source": "apache"
  },
  "video/vnd.dvb.file": {
    "source": "apache",
    "extensions": ["dvb"]
  },
  "video/vnd.fvt": {
    "source": "apache",
    "extensions": ["fvt"]
  },
  "video/vnd.hns.video": {
    "source": "apache"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    "source": "apache"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    "source": "apache"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    "source": "apache"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    "source": "apache"
  },
  "video/vnd.iptvforum.ttsavc": {
    "source": "apache"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    "source": "apache"
  },
  "video/vnd.motorola.video": {
    "source": "apache"
  },
  "video/vnd.motorola.videop": {
    "source": "apache"
  },
  "video/vnd.mpegurl": {
    "source": "apache",
    "extensions": ["mxu","m4u"]
  },
  "video/vnd.ms-playready.media.pyv": {
    "source": "apache",
    "extensions": ["pyv"]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    "source": "apache"
  },
  "video/vnd.nokia.videovoip": {
    "source": "apache"
  },
  "video/vnd.objectvideo": {
    "source": "apache"
  },
  "video/vnd.sealed.mpeg1": {
    "source": "apache"
  },
  "video/vnd.sealed.mpeg4": {
    "source": "apache"
  },
  "video/vnd.sealed.swf": {
    "source": "apache"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    "source": "apache"
  },
  "video/vnd.uvvu.mp4": {
    "source": "apache",
    "extensions": ["uvu","uvvu"]
  },
  "video/vnd.vivo": {
    "source": "apache",
    "extensions": ["viv"]
  },
  "video/webm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["webm"]
  },
  "video/x-f4v": {
    "source": "apache",
    "extensions": ["f4v"]
  },
  "video/x-fli": {
    "source": "apache",
    "extensions": ["fli"]
  },
  "video/x-flv": {
    "source": "apache",
    "compressible": false,
    "extensions": ["flv"]
  },
  "video/x-m4v": {
    "source": "apache",
    "extensions": ["m4v"]
  },
  "video/x-matroska": {
    "source": "apache",
    "compressible": false,
    "extensions": ["mkv","mk3d","mks"]
  },
  "video/x-mng": {
    "source": "apache",
    "extensions": ["mng"]
  },
  "video/x-ms-asf": {
    "source": "apache",
    "extensions": ["asf","asx"]
  },
  "video/x-ms-vob": {
    "source": "apache",
    "extensions": ["vob"]
  },
  "video/x-ms-wm": {
    "source": "apache",
    "extensions": ["wm"]
  },
  "video/x-ms-wmv": {
    "source": "apache",
    "compressible": false,
    "extensions": ["wmv"]
  },
  "video/x-ms-wmx": {
    "source": "apache",
    "extensions": ["wmx"]
  },
  "video/x-ms-wvx": {
    "source": "apache",
    "extensions": ["wvx"]
  },
  "video/x-msvideo": {
    "source": "apache",
    "extensions": ["avi"]
  },
  "video/x-sgi-movie": {
    "source": "apache",
    "extensions": ["movie"]
  },
  "video/x-smv": {
    "source": "apache",
    "extensions": ["smv"]
  },
  "x-conference/x-cooltalk": {
    "source": "apache",
    "extensions": ["ice"]
  },
  "x-shader/x-fragment": {
    "compressible": true
  },
  "x-shader/x-vertex": {
    "compressible": true
  }
}
},{}],528:[function(require,module,exports){
module["exports"] = [
  "ants",
  "bats",
  "bears",
  "bees",
  "birds",
  "buffalo",
  "cats",
  "chickens",
  "cattle",
  "dogs",
  "dolphins",
  "ducks",
  "elephants",
  "fishes",
  "foxes",
  "frogs",
  "geese",
  "goats",
  "horses",
  "kangaroos",
  "lions",
  "monkeys",
  "owls",
  "oxen",
  "penguins",
  "people",
  "pigs",
  "rabbits",
  "sheep",
  "tigers",
  "whales",
  "wolves",
  "zebras",
  "banshees",
  "crows",
  "black cats",
  "chimeras",
  "ghosts",
  "conspirators",
  "dragons",
  "dwarves",
  "elves",
  "enchanters",
  "exorcists",
  "sons",
  "foes",
  "giants",
  "gnomes",
  "goblins",
  "gooses",
  "griffins",
  "lycanthropes",
  "nemesis",
  "ogres",
  "oracles",
  "prophets",
  "sorcerors",
  "spiders",
  "spirits",
  "vampires",
  "warlocks",
  "vixens",
  "werewolves",
  "witches",
  "worshipers",
  "zombies",
  "druids"
];

},{}],529:[function(require,module,exports){
var team = {};
module['exports'] = team;
team.creature = require("./creature");
team.name = require("./name");

},{"./creature":528,"./name":530}],530:[function(require,module,exports){
module["exports"] = [
  "#{Address.state} #{creature}"
];

},{}],531:[function(require,module,exports){
module["exports"] = [
  "####",
  "###",
  "##"
];

},{}],532:[function(require,module,exports){
module["exports"] = [
  "Australia"
];

},{}],533:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.state_abbr = require("./state_abbr");
address.state = require("./state");
address.postcode = require("./postcode");
address.building_number = require("./building_number");
address.street_suffix = require("./street_suffix");
address.default_country = require("./default_country");

},{"./building_number":531,"./default_country":532,"./postcode":534,"./state":535,"./state_abbr":536,"./street_suffix":537}],534:[function(require,module,exports){
module["exports"] = [
  "0###",
  "2###",
  "3###",
  "4###",
  "5###",
  "6###",
  "7###"
];

},{}],535:[function(require,module,exports){
module["exports"] = [
  "New South Wales",
  "Queensland",
  "Northern Territory",
  "South Australia",
  "Western Australia",
  "Tasmania",
  "Australian Capital Territory",
  "Victoria"
];

},{}],536:[function(require,module,exports){
module["exports"] = [
  "NSW",
  "QLD",
  "NT",
  "SA",
  "WA",
  "TAS",
  "ACT",
  "VIC"
];

},{}],537:[function(require,module,exports){
module["exports"] = [
  "Avenue",
  "Boulevard",
  "Circle",
  "Circuit",
  "Court",
  "Crescent",
  "Crest",
  "Drive",
  "Estate Dr",
  "Grove",
  "Hill",
  "Island",
  "Junction",
  "Knoll",
  "Lane",
  "Loop",
  "Mall",
  "Manor",
  "Meadow",
  "Mews",
  "Parade",
  "Parkway",
  "Pass",
  "Place",
  "Plaza",
  "Ridge",
  "Road",
  "Run",
  "Square",
  "Station St",
  "Street",
  "Summit",
  "Terrace",
  "Track",
  "Trail",
  "View Rd",
  "Way"
];

},{}],538:[function(require,module,exports){
var company = {};
module['exports'] = company;
company.suffix = require("./suffix");

},{"./suffix":539}],539:[function(require,module,exports){
module["exports"] = [
  "Pty Ltd",
  "and Sons",
  "Corp",
  "Group",
  "Brothers",
  "Partners"
];

},{}],540:[function(require,module,exports){
var en_AU = {};
module['exports'] = en_AU;
en_AU.title = "Australia (English)";
en_AU.name = require("./name");
en_AU.company = require("./company");
en_AU.internet = require("./internet");
en_AU.address = require("./address");
en_AU.phone_number = require("./phone_number");

},{"./address":533,"./company":538,"./internet":542,"./name":544,"./phone_number":547}],541:[function(require,module,exports){
module["exports"] = [
  "com.au",
  "com",
  "net.au",
  "net",
  "org.au",
  "org"
];

},{}],542:[function(require,module,exports){
arguments[4][430][0].apply(exports,arguments)
},{"./domain_suffix":541,"dup":430}],543:[function(require,module,exports){
module["exports"] = [
  "William",
  "Jack",
  "Oliver",
  "Joshua",
  "Thomas",
  "Lachlan",
  "Cooper",
  "Noah",
  "Ethan",
  "Lucas",
  "James",
  "Samuel",
  "Jacob",
  "Liam",
  "Alexander",
  "Benjamin",
  "Max",
  "Isaac",
  "Daniel",
  "Riley",
  "Ryan",
  "Charlie",
  "Tyler",
  "Jake",
  "Matthew",
  "Xavier",
  "Harry",
  "Jayden",
  "Nicholas",
  "Harrison",
  "Levi",
  "Luke",
  "Adam",
  "Henry",
  "Aiden",
  "Dylan",
  "Oscar",
  "Michael",
  "Jackson",
  "Logan",
  "Joseph",
  "Blake",
  "Nathan",
  "Connor",
  "Elijah",
  "Nate",
  "Archie",
  "Bailey",
  "Marcus",
  "Cameron",
  "Jordan",
  "Zachary",
  "Caleb",
  "Hunter",
  "Ashton",
  "Toby",
  "Aidan",
  "Hayden",
  "Mason",
  "Hamish",
  "Edward",
  "Angus",
  "Eli",
  "Sebastian",
  "Christian",
  "Patrick",
  "Andrew",
  "Anthony",
  "Luca",
  "Kai",
  "Beau",
  "Alex",
  "George",
  "Callum",
  "Finn",
  "Zac",
  "Mitchell",
  "Jett",
  "Jesse",
  "Gabriel",
  "Leo",
  "Declan",
  "Charles",
  "Jasper",
  "Jonathan",
  "Aaron",
  "Hugo",
  "David",
  "Christopher",
  "Chase",
  "Owen",
  "Justin",
  "Ali",
  "Darcy",
  "Lincoln",
  "Cody",
  "Phoenix",
  "Sam",
  "John",
  "Joel",
  "Isabella",
  "Ruby",
  "Chloe",
  "Olivia",
  "Charlotte",
  "Mia",
  "Lily",
  "Emily",
  "Ella",
  "Sienna",
  "Sophie",
  "Amelia",
  "Grace",
  "Ava",
  "Zoe",
  "Emma",
  "Sophia",
  "Matilda",
  "Hannah",
  "Jessica",
  "Lucy",
  "Georgia",
  "Sarah",
  "Abigail",
  "Zara",
  "Eva",
  "Scarlett",
  "Jasmine",
  "Chelsea",
  "Lilly",
  "Ivy",
  "Isla",
  "Evie",
  "Isabelle",
  "Maddison",
  "Layla",
  "Summer",
  "Annabelle",
  "Alexis",
  "Elizabeth",
  "Bella",
  "Holly",
  "Lara",
  "Madison",
  "Alyssa",
  "Maya",
  "Tahlia",
  "Claire",
  "Hayley",
  "Imogen",
  "Jade",
  "Ellie",
  "Sofia",
  "Addison",
  "Molly",
  "Phoebe",
  "Alice",
  "Savannah",
  "Gabriella",
  "Kayla",
  "Mikayla",
  "Abbey",
  "Eliza",
  "Willow",
  "Alexandra",
  "Poppy",
  "Samantha",
  "Stella",
  "Amy",
  "Amelie",
  "Anna",
  "Piper",
  "Gemma",
  "Isabel",
  "Victoria",
  "Stephanie",
  "Caitlin",
  "Heidi",
  "Paige",
  "Rose",
  "Amber",
  "Audrey",
  "Claudia",
  "Taylor",
  "Madeline",
  "Angelina",
  "Natalie",
  "Charli",
  "Lauren",
  "Ashley",
  "Violet",
  "Mackenzie",
  "Abby",
  "Skye",
  "Lillian",
  "Alana",
  "Lola",
  "Leah",
  "Eve",
  "Kiara"
];

},{}],544:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.last_name = require("./last_name");

},{"./first_name":543,"./last_name":545}],545:[function(require,module,exports){
module["exports"] = [
  "Smith",
  "Jones",
  "Williams",
  "Brown",
  "Wilson",
  "Taylor",
  "Johnson",
  "White",
  "Martin",
  "Anderson",
  "Thompson",
  "Nguyen",
  "Thomas",
  "Walker",
  "Harris",
  "Lee",
  "Ryan",
  "Robinson",
  "Kelly",
  "King",
  "Davis",
  "Wright",
  "Evans",
  "Roberts",
  "Green",
  "Hall",
  "Wood",
  "Jackson",
  "Clarke",
  "Patel",
  "Khan",
  "Lewis",
  "James",
  "Phillips",
  "Mason",
  "Mitchell",
  "Rose",
  "Davies",
  "Rodriguez",
  "Cox",
  "Alexander",
  "Garden",
  "Campbell",
  "Johnston",
  "Moore",
  "Smyth",
  "O'neill",
  "Doherty",
  "Stewart",
  "Quinn",
  "Murphy",
  "Graham",
  "Mclaughlin",
  "Hamilton",
  "Murray",
  "Hughes",
  "Robertson",
  "Thomson",
  "Scott",
  "Macdonald",
  "Reid",
  "Clark",
  "Ross",
  "Young",
  "Watson",
  "Paterson",
  "Morrison",
  "Morgan",
  "Griffiths",
  "Edwards",
  "Rees",
  "Jenkins",
  "Owen",
  "Price",
  "Moss",
  "Richards",
  "Abbott",
  "Adams",
  "Armstrong",
  "Bahringer",
  "Bailey",
  "Barrows",
  "Bartell",
  "Bartoletti",
  "Barton",
  "Bauch",
  "Baumbach",
  "Bayer",
  "Beahan",
  "Beatty",
  "Becker",
  "Beier",
  "Berge",
  "Bergstrom",
  "Bode",
  "Bogan",
  "Borer",
  "Bosco",
  "Botsford",
  "Boyer",
  "Boyle",
  "Braun",
  "Bruen",
  "Carroll",
  "Carter",
  "Cartwright",
  "Casper",
  "Cassin",
  "Champlin",
  "Christiansen",
  "Cole",
  "Collier",
  "Collins",
  "Connelly",
  "Conroy",
  "Corkery",
  "Cormier",
  "Corwin",
  "Cronin",
  "Crooks",
  "Cruickshank",
  "Cummings",
  "D'amore",
  "Daniel",
  "Dare",
  "Daugherty",
  "Dickens",
  "Dickinson",
  "Dietrich",
  "Donnelly",
  "Dooley",
  "Douglas",
  "Doyle",
  "Durgan",
  "Ebert",
  "Emard",
  "Emmerich",
  "Erdman",
  "Ernser",
  "Fadel",
  "Fahey",
  "Farrell",
  "Fay",
  "Feeney",
  "Feil",
  "Ferry",
  "Fisher",
  "Flatley",
  "Gibson",
  "Gleason",
  "Glover",
  "Goldner",
  "Goodwin",
  "Grady",
  "Grant",
  "Greenfelder",
  "Greenholt",
  "Grimes",
  "Gutmann",
  "Hackett",
  "Hahn",
  "Haley",
  "Hammes",
  "Hand",
  "Hane",
  "Hansen",
  "Harber",
  "Hartmann",
  "Harvey",
  "Hayes",
  "Heaney",
  "Heathcote",
  "Heller",
  "Hermann",
  "Hermiston",
  "Hessel",
  "Hettinger",
  "Hickle",
  "Hill",
  "Hills",
  "Hoppe",
  "Howe",
  "Howell",
  "Hudson",
  "Huel",
  "Hyatt",
  "Jacobi",
  "Jacobs",
  "Jacobson",
  "Jerde",
  "Johns",
  "Keeling",
  "Kemmer",
  "Kessler",
  "Kiehn",
  "Kirlin",
  "Klein",
  "Koch",
  "Koelpin",
  "Kohler",
  "Koss",
  "Kovacek",
  "Kreiger",
  "Kris",
  "Kuhlman",
  "Kuhn",
  "Kulas",
  "Kunde",
  "Kutch",
  "Lakin",
  "Lang",
  "Langworth",
  "Larkin",
  "Larson",
  "Leannon",
  "Leffler",
  "Little",
  "Lockman",
  "Lowe",
  "Lynch",
  "Mann",
  "Marks",
  "Marvin",
  "Mayer",
  "Mccullough",
  "Mcdermott",
  "Mckenzie",
  "Miller",
  "Mills",
  "Monahan",
  "Morissette",
  "Mueller",
  "Muller",
  "Nader",
  "Nicolas",
  "Nolan",
  "O'connell",
  "O'conner",
  "O'hara",
  "O'keefe",
  "Olson",
  "O'reilly",
  "Parisian",
  "Parker",
  "Quigley",
  "Reilly",
  "Reynolds",
  "Rice",
  "Ritchie",
  "Rohan",
  "Rolfson",
  "Rowe",
  "Russel",
  "Rutherford",
  "Sanford",
  "Sauer",
  "Schmidt",
  "Schmitt",
  "Schneider",
  "Schroeder",
  "Schultz",
  "Shields",
  "Smitham",
  "Spencer",
  "Stanton",
  "Stark",
  "Stokes",
  "Swift",
  "Tillman",
  "Towne",
  "Tremblay",
  "Tromp",
  "Turcotte",
  "Turner",
  "Walsh",
  "Walter",
  "Ward",
  "Waters",
  "Weber",
  "Welch",
  "West",
  "Wilderman",
  "Wilkinson",
  "Williamson",
  "Windler",
  "Wolf"
];

},{}],546:[function(require,module,exports){
module["exports"] = [
  "0# #### ####",
  "+61 # #### ####",
  "04## ### ###",
  "+61 4## ### ###"
];

},{}],547:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":546,"dup":312}],548:[function(require,module,exports){
var en_BORK = {};
module['exports'] = en_BORK;
en_BORK.title = "Bork (English)";
en_BORK.lorem = require("./lorem");

},{"./lorem":549}],549:[function(require,module,exports){
arguments[4][380][0].apply(exports,arguments)
},{"./words":550,"dup":380}],550:[function(require,module,exports){
module["exports"] = [
  "Boot",
  "I",
  "Nu",
  "Nur",
  "Tu",
  "Um",
  "a",
  "becoose-a",
  "boot",
  "bork",
  "burn",
  "chuuses",
  "cumplete-a",
  "cun",
  "cunseqooences",
  "curcoomstunces",
  "dee",
  "deeslikes",
  "denuoonceeng",
  "desures",
  "du",
  "eccuoont",
  "ectooel",
  "edfuntege-a",
  "efueeds",
  "egeeen",
  "ell",
  "ere-a",
  "feend",
  "foolt",
  "frum",
  "geefe-a",
  "gesh",
  "greet",
  "heem",
  "heppeeness",
  "hes",
  "hoo",
  "hoomun",
  "idea",
  "ifer",
  "in",
  "incuoonter",
  "injuy",
  "itselff",
  "ixcept",
  "ixemple-a",
  "ixerceese-a",
  "ixpleeen",
  "ixplurer",
  "ixpuoond",
  "ixtremely",
  "knoo",
  "lebureeuoos",
  "lufes",
  "meestekee",
  "mester-booeelder",
  "moost",
  "mun",
  "nu",
  "nut",
  "oobteeen",
  "oocceseeunelly",
  "ooccoor",
  "ooff",
  "oone-a",
  "oor",
  "peeen",
  "peeenffool",
  "physeecel",
  "pleesoore-a",
  "poorsooe-a",
  "poorsooes",
  "preeesing",
  "prucoore-a",
  "prudooces",
  "reeght",
  "reshunelly",
  "resooltunt",
  "sume-a",
  "teecheengs",
  "teke-a",
  "thees",
  "thet",
  "thuse-a",
  "treefiel",
  "troot",
  "tu",
  "tueel",
  "und",
  "undertekes",
  "unnuyeeng",
  "uny",
  "unyune-a",
  "us",
  "veell",
  "veet",
  "ves",
  "vheech",
  "vhu",
  "yuoo",
  "zee",
  "zeere-a"
];

},{}],551:[function(require,module,exports){
module["exports"] = [
  "Canada"
];

},{}],552:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.default_country = require("./default_country");
address.postcode = require('./postcode.js');

},{"./default_country":551,"./postcode.js":553,"./state":554,"./state_abbr":555}],553:[function(require,module,exports){
module["exports"] = [
  "?#? #?#"
];

},{}],554:[function(require,module,exports){
module["exports"] = [
  "Alberta",
  "British Columbia",
  "Manitoba",
  "New Brunswick",
  "Newfoundland and Labrador",
  "Nova Scotia",
  "Northwest Territories",
  "Nunavut",
  "Ontario",
  "Prince Edward Island",
  "Quebec",
  "Saskatchewan",
  "Yukon"
];

},{}],555:[function(require,module,exports){
module["exports"] = [
  "AB",
  "BC",
  "MB",
  "NB",
  "NL",
  "NS",
  "NU",
  "NT",
  "ON",
  "PE",
  "QC",
  "SK",
  "YT"
];

},{}],556:[function(require,module,exports){
var en_CA = {};
module['exports'] = en_CA;
en_CA.title = "Canada (English)";
en_CA.address = require("./address");
en_CA.internet = require("./internet");
en_CA.phone_number = require("./phone_number");

},{"./address":552,"./internet":559,"./phone_number":561}],557:[function(require,module,exports){
module["exports"] = [
  "ca",
  "com",
  "biz",
  "info",
  "name",
  "net",
  "org"
];

},{}],558:[function(require,module,exports){
module["exports"] = [
  "gmail.com",
  "yahoo.ca",
  "hotmail.com"
];

},{}],559:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":557,"./free_email":558,"dup":302}],560:[function(require,module,exports){
module["exports"] = [
  "###-###-####",
  "(###)###-####",
  "###.###.####",
  "1-###-###-####",
  "###-###-#### x###",
  "(###)###-#### x###",
  "1-###-###-#### x###",
  "###.###.#### x###",
  "###-###-#### x####",
  "(###)###-#### x####",
  "1-###-###-#### x####",
  "###.###.#### x####",
  "###-###-#### x#####",
  "(###)###-#### x#####",
  "1-###-###-#### x#####",
  "###.###.#### x#####"
];

},{}],561:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":560,"dup":312}],562:[function(require,module,exports){
module["exports"] = [
  "Avon",
  "Bedfordshire",
  "Berkshire",
  "Borders",
  "Buckinghamshire",
  "Cambridgeshire",
  "Central",
  "Cheshire",
  "Cleveland",
  "Clwyd",
  "Cornwall",
  "County Antrim",
  "County Armagh",
  "County Down",
  "County Fermanagh",
  "County Londonderry",
  "County Tyrone",
  "Cumbria",
  "Derbyshire",
  "Devon",
  "Dorset",
  "Dumfries and Galloway",
  "Durham",
  "Dyfed",
  "East Sussex",
  "Essex",
  "Fife",
  "Gloucestershire",
  "Grampian",
  "Greater Manchester",
  "Gwent",
  "Gwynedd County",
  "Hampshire",
  "Herefordshire",
  "Hertfordshire",
  "Highlands and Islands",
  "Humberside",
  "Isle of Wight",
  "Kent",
  "Lancashire",
  "Leicestershire",
  "Lincolnshire",
  "Lothian",
  "Merseyside",
  "Mid Glamorgan",
  "Norfolk",
  "North Yorkshire",
  "Northamptonshire",
  "Northumberland",
  "Nottinghamshire",
  "Oxfordshire",
  "Powys",
  "Rutland",
  "Shropshire",
  "Somerset",
  "South Glamorgan",
  "South Yorkshire",
  "Staffordshire",
  "Strathclyde",
  "Suffolk",
  "Surrey",
  "Tayside",
  "Tyne and Wear",
  "Warwickshire",
  "West Glamorgan",
  "West Midlands",
  "West Sussex",
  "West Yorkshire",
  "Wiltshire",
  "Worcestershire"
];

},{}],563:[function(require,module,exports){
module["exports"] = [
  "England",
  "Scotland",
  "Wales",
  "Northern Ireland"
];

},{}],564:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.county = require("./county");
address.uk_country = require("./uk_country");
address.default_country = require("./default_country");
address.postcode = require("./postcode");

},{"./county":562,"./default_country":563,"./postcode":565,"./uk_country":566}],565:[function(require,module,exports){
module["exports"] = [
  "??# #??",
  "??## #??",
];

},{}],566:[function(require,module,exports){
arguments[4][563][0].apply(exports,arguments)
},{"dup":563}],567:[function(require,module,exports){
module["exports"] = [
  "074## ######",
  "075## ######",
  "076## ######",
  "077## ######",
  "078## ######",
  "079## ######"
];

},{}],568:[function(require,module,exports){
arguments[4][371][0].apply(exports,arguments)
},{"./formats":567,"dup":371}],569:[function(require,module,exports){
var en_GB = {};
module['exports'] = en_GB;
en_GB.title = "Great Britain (English)";
en_GB.address = require("./address");
en_GB.internet = require("./internet");
en_GB.phone_number = require("./phone_number");
en_GB.cell_phone = require("./cell_phone");

},{"./address":564,"./cell_phone":568,"./internet":571,"./phone_number":573}],570:[function(require,module,exports){
module["exports"] = [
  "co.uk",
  "com",
  "biz",
  "info",
  "name"
];

},{}],571:[function(require,module,exports){
arguments[4][430][0].apply(exports,arguments)
},{"./domain_suffix":570,"dup":430}],572:[function(require,module,exports){
module["exports"] = [
  "01#### #####",
  "01### ######",
  "01#1 ### ####",
  "011# ### ####",
  "02# #### ####",
  "03## ### ####",
  "055 #### ####",
  "056 #### ####",
  "0800 ### ####",
  "08## ### ####",
  "09## ### ####",
  "016977 ####",
  "01### #####",
  "0500 ######",
  "0800 ######"
];

},{}],573:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":572,"dup":312}],574:[function(require,module,exports){
module["exports"] = [
  "Carlow",
  "Cavan",
  "Clare",
  "Cork",
  "Donegal",
  "Dublin",
  "Galway",
  "Kerry",
  "Kildare",
  "Kilkenny",
  "Laois",
  "Leitrim",
  "Limerick",
  "Longford",
  "Louth",
  "Mayo",
  "Meath",
  "Monaghan",
  "Offaly",
  "Roscommon",
  "Sligo",
  "Tipperary",
  "Waterford",
  "Westmeath",
  "Wexford",
  "Wicklow"
];

},{}],575:[function(require,module,exports){
module["exports"] = [
  "Ireland"
];

},{}],576:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.county = require("./county");
address.default_country = require("./default_country");

},{"./county":574,"./default_country":575}],577:[function(require,module,exports){
module["exports"] = [
  "082 ### ####",
  "083 ### ####",
  "085 ### ####",
  "086 ### ####",
  "087 ### ####",
  "089 ### ####"
];

},{}],578:[function(require,module,exports){
arguments[4][371][0].apply(exports,arguments)
},{"./formats":577,"dup":371}],579:[function(require,module,exports){
var en_IE = {};
module['exports'] = en_IE;
en_IE.title = "Ireland (English)";
en_IE.address = require("./address");
en_IE.internet = require("./internet");
en_IE.phone_number = require("./phone_number");
en_IE.cell_phone = require("./cell_phone");

},{"./address":576,"./cell_phone":578,"./internet":581,"./phone_number":583}],580:[function(require,module,exports){
module["exports"] = [
  "ie",
  "com",
  "net",
  "info",
  "eu"
];

},{}],581:[function(require,module,exports){
arguments[4][430][0].apply(exports,arguments)
},{"./domain_suffix":580,"dup":430}],582:[function(require,module,exports){
module["exports"] = [
  "01 #######",
  "021 #######",
  "022 #######",
  "023 #######",
  "024 #######",
  "025 #######",
  "026 #######",
  "027 #######",
  "028 #######",
  "029 #######",
  "0402 #######",
  "0404 #######",
  "041 #######",
  "042 #######",
  "043 #######",
  "044 #######",
  "045 #######",
  "046 #######",
  "047 #######",
  "049 #######",
  "0504 #######",
  "0505 #######",
  "051 #######",
  "052 #######",
  "053 #######",
  "056 #######",
  "057 #######",
  "058 #######",
  "059 #######",
  "061 #######",
  "062 #######",
  "063 #######",
  "064 #######",
  "065 #######",
  "066 #######",
  "067 #######",
  "068 #######",
  "069 #######",
  "071 #######",
  "074 #######",
  "090 #######",
  "091 #######",
  "093 #######",
  "094 #######",
  "095 #######",
  "096 #######",
  "097 #######",
  "098 #######",
  "099 #######"
];

},{}],583:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":582,"dup":312}],584:[function(require,module,exports){
module["exports"] = [
  "India",
  "Indian Republic",
  "Bharat",
  "Hindustan"
];

},{}],585:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.default_country = require("./default_country");

},{"./default_country":584,"./postcode":586,"./state":587,"./state_abbr":588}],586:[function(require,module,exports){
arguments[4][553][0].apply(exports,arguments)
},{"dup":553}],587:[function(require,module,exports){
module["exports"] = [
  "Andra Pradesh",
  "Arunachal Pradesh",
  "Assam",
  "Bihar",
  "Chhattisgarh",
  "Goa",
  "Gujarat",
  "Haryana",
  "Himachal Pradesh",
  "Jammu and Kashmir",
  "Jharkhand",
  "Karnataka",
  "Kerala",
  "Madya Pradesh",
  "Maharashtra",
  "Manipur",
  "Meghalaya",
  "Mizoram",
  "Nagaland",
  "Orissa",
  "Punjab",
  "Rajasthan",
  "Sikkim",
  "Tamil Nadu",
  "Tripura",
  "Uttaranchal",
  "Uttar Pradesh",
  "West Bengal",
  "Andaman and Nicobar Islands",
  "Chandigarh",
  "Dadar and Nagar Haveli",
  "Daman and Diu",
  "Delhi",
  "Lakshadweep",
  "Pondicherry"
];

},{}],588:[function(require,module,exports){
module["exports"] = [
  "AP",
  "AR",
  "AS",
  "BR",
  "CG",
  "DL",
  "GA",
  "GJ",
  "HR",
  "HP",
  "JK",
  "JS",
  "KA",
  "KL",
  "MP",
  "MH",
  "MN",
  "ML",
  "MZ",
  "NL",
  "OR",
  "PB",
  "RJ",
  "SK",
  "TN",
  "TR",
  "UK",
  "UP",
  "WB",
  "AN",
  "CH",
  "DN",
  "DD",
  "LD",
  "PY"
];

},{}],589:[function(require,module,exports){
arguments[4][538][0].apply(exports,arguments)
},{"./suffix":590,"dup":538}],590:[function(require,module,exports){
module["exports"] = [
  "Pvt Ltd",
  "Limited",
  "Ltd",
  "and Sons",
  "Corp",
  "Group",
  "Brothers"
];

},{}],591:[function(require,module,exports){
var en_IND = {};
module['exports'] = en_IND;
en_IND.title = "India (English)";
en_IND.name = require("./name");
en_IND.address = require("./address");
en_IND.internet = require("./internet");
en_IND.company = require("./company");
en_IND.phone_number = require("./phone_number");

},{"./address":585,"./company":589,"./internet":594,"./name":596,"./phone_number":599}],592:[function(require,module,exports){
module["exports"] = [
  "in",
  "com",
  "biz",
  "info",
  "name",
  "net",
  "org",
  "co.in"
];

},{}],593:[function(require,module,exports){
module["exports"] = [
  "gmail.com",
  "yahoo.co.in",
  "hotmail.com"
];

},{}],594:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":592,"./free_email":593,"dup":302}],595:[function(require,module,exports){
module["exports"] = [
  "Aadrika",
  "Aanandinii",
  "Aaratrika",
  "Aarya",
  "Arya",
  "Aashritha",
  "Aatmaja",
  "Atmaja",
  "Abhaya",
  "Adwitiya",
  "Agrata",
  "Ahilya",
  "Ahalya",
  "Aishani",
  "Akshainie",
  "Akshata",
  "Akshita",
  "Akula",
  "Ambar",
  "Amodini",
  "Amrita",
  "Amritambu",
  "Anala",
  "Anamika",
  "Ananda",
  "Anandamayi",
  "Ananta",
  "Anila",
  "Anjali",
  "Anjushri",
  "Anjushree",
  "Annapurna",
  "Anshula",
  "Anuja",
  "Anusuya",
  "Anasuya",
  "Anasooya",
  "Anwesha",
  "Apsara",
  "Aruna",
  "Asha",
  "Aasa",
  "Aasha",
  "Aslesha",
  "Atreyi",
  "Atreyee",
  "Avani",
  "Abani",
  "Avantika",
  "Ayushmati",
  "Baidehi",
  "Vaidehi",
  "Bala",
  "Baala",
  "Balamani",
  "Basanti",
  "Vasanti",
  "Bela",
  "Bhadra",
  "Bhagirathi",
  "Bhagwanti",
  "Bhagwati",
  "Bhamini",
  "Bhanumati",
  "Bhaanumati",
  "Bhargavi",
  "Bhavani",
  "Bhilangana",
  "Bilwa",
  "Bilva",
  "Buddhana",
  "Chakrika",
  "Chanda",
  "Chandi",
  "Chandni",
  "Chandini",
  "Chandani",
  "Chandra",
  "Chandira",
  "Chandrabhaga",
  "Chandrakala",
  "Chandrakin",
  "Chandramani",
  "Chandrani",
  "Chandraprabha",
  "Chandraswaroopa",
  "Chandravati",
  "Chapala",
  "Charumati",
  "Charvi",
  "Chatura",
  "Chitrali",
  "Chitramala",
  "Chitrangada",
  "Daksha",
  "Dakshayani",
  "Damayanti",
  "Darshwana",
  "Deepali",
  "Dipali",
  "Deeptimoyee",
  "Deeptimayee",
  "Devangana",
  "Devani",
  "Devasree",
  "Devi",
  "Daevi",
  "Devika",
  "Daevika",
  "Dhaanyalakshmi",
  "Dhanalakshmi",
  "Dhana",
  "Dhanadeepa",
  "Dhara",
  "Dharani",
  "Dharitri",
  "Dhatri",
  "Diksha",
  "Deeksha",
  "Divya",
  "Draupadi",
  "Dulari",
  "Durga",
  "Durgeshwari",
  "Ekaparnika",
  "Elakshi",
  "Enakshi",
  "Esha",
  "Eshana",
  "Eshita",
  "Gautami",
  "Gayatri",
  "Geeta",
  "Geetanjali",
  "Gitanjali",
  "Gemine",
  "Gemini",
  "Girja",
  "Girija",
  "Gita",
  "Hamsini",
  "Harinakshi",
  "Harita",
  "Heema",
  "Himadri",
  "Himani",
  "Hiranya",
  "Indira",
  "Jaimini",
  "Jaya",
  "Jyoti",
  "Jyotsana",
  "Kali",
  "Kalinda",
  "Kalpana",
  "Kalyani",
  "Kama",
  "Kamala",
  "Kamla",
  "Kanchan",
  "Kanishka",
  "Kanti",
  "Kashyapi",
  "Kumari",
  "Kumuda",
  "Lakshmi",
  "Laxmi",
  "Lalita",
  "Lavanya",
  "Leela",
  "Lila",
  "Leela",
  "Madhuri",
  "Malti",
  "Malati",
  "Mandakini",
  "Mandaakin",
  "Mangala",
  "Mangalya",
  "Mani",
  "Manisha",
  "Manjusha",
  "Meena",
  "Mina",
  "Meenakshi",
  "Minakshi",
  "Menka",
  "Menaka",
  "Mohana",
  "Mohini",
  "Nalini",
  "Nikita",
  "Ojaswini",
  "Omana",
  "Oormila",
  "Urmila",
  "Opalina",
  "Opaline",
  "Padma",
  "Parvati",
  "Poornima",
  "Purnima",
  "Pramila",
  "Prasanna",
  "Preity",
  "Prema",
  "Priya",
  "Priyala",
  "Pushti",
  "Radha",
  "Rageswari",
  "Rageshwari",
  "Rajinder",
  "Ramaa",
  "Rati",
  "Rita",
  "Rohana",
  "Rukhmani",
  "Rukmin",
  "Rupinder",
  "Sanya",
  "Sarada",
  "Sharda",
  "Sarala",
  "Sarla",
  "Saraswati",
  "Sarisha",
  "Saroja",
  "Shakti",
  "Shakuntala",
  "Shanti",
  "Sharmila",
  "Shashi",
  "Shashikala",
  "Sheela",
  "Shivakari",
  "Shobhana",
  "Shresth",
  "Shresthi",
  "Shreya",
  "Shreyashi",
  "Shridevi",
  "Shrishti",
  "Shubha",
  "Shubhaprada",
  "Siddhi",
  "Sitara",
  "Sloka",
  "Smita",
  "Smriti",
  "Soma",
  "Subhashini",
  "Subhasini",
  "Sucheta",
  "Sudeva",
  "Sujata",
  "Sukanya",
  "Suma",
  "Suma",
  "Sumitra",
  "Sunita",
  "Suryakantam",
  "Sushma",
  "Swara",
  "Swarnalata",
  "Sweta",
  "Shwet",
  "Tanirika",
  "Tanushree",
  "Tanushri",
  "Tanushri",
  "Tanya",
  "Tara",
  "Trisha",
  "Uma",
  "Usha",
  "Vaijayanti",
  "Vaijayanthi",
  "Baijayanti",
  "Vaishvi",
  "Vaishnavi",
  "Vaishno",
  "Varalakshmi",
  "Vasudha",
  "Vasundhara",
  "Veda",
  "Vedanshi",
  "Vidya",
  "Vimala",
  "Vrinda",
  "Vrund",
  "Aadi",
  "Aadidev",
  "Aadinath",
  "Aaditya",
  "Aagam",
  "Aagney",
  "Aamod",
  "Aanandaswarup",
  "Anand Swarup",
  "Aanjaneya",
  "Anjaneya",
  "Aaryan",
  "Aryan",
  "Aatmaj",
  "Aatreya",
  "Aayushmaan",
  "Aayushman",
  "Abhaidev",
  "Abhaya",
  "Abhirath",
  "Abhisyanta",
  "Acaryatanaya",
  "Achalesvara",
  "Acharyanandana",
  "Acharyasuta",
  "Achintya",
  "Achyut",
  "Adheesh",
  "Adhiraj",
  "Adhrit",
  "Adikavi",
  "Adinath",
  "Aditeya",
  "Aditya",
  "Adityanandan",
  "Adityanandana",
  "Adripathi",
  "Advaya",
  "Agasti",
  "Agastya",
  "Agneya",
  "Aagneya",
  "Agnimitra",
  "Agniprava",
  "Agnivesh",
  "Agrata",
  "Ajit",
  "Ajeet",
  "Akroor",
  "Akshaj",
  "Akshat",
  "Akshayakeerti",
  "Alok",
  "Aalok",
  "Amaranaath",
  "Amarnath",
  "Amaresh",
  "Ambar",
  "Ameyatma",
  "Amish",
  "Amogh",
  "Amrit",
  "Anaadi",
  "Anagh",
  "Anal",
  "Anand",
  "Aanand",
  "Anang",
  "Anil",
  "Anilaabh",
  "Anilabh",
  "Anish",
  "Ankal",
  "Anunay",
  "Anurag",
  "Anuraag",
  "Archan",
  "Arindam",
  "Arjun",
  "Arnesh",
  "Arun",
  "Ashlesh",
  "Ashok",
  "Atmanand",
  "Atmananda",
  "Avadhesh",
  "Baalaaditya",
  "Baladitya",
  "Baalagopaal",
  "Balgopal",
  "Balagopal",
  "Bahula",
  "Bakula",
  "Bala",
  "Balaaditya",
  "Balachandra",
  "Balagovind",
  "Bandhu",
  "Bandhul",
  "Bankim",
  "Bankimchandra",
  "Bhadrak",
  "Bhadraksh",
  "Bhadran",
  "Bhagavaan",
  "Bhagvan",
  "Bharadwaj",
  "Bhardwaj",
  "Bharat",
  "Bhargava",
  "Bhasvan",
  "Bhaasvan",
  "Bhaswar",
  "Bhaaswar",
  "Bhaumik",
  "Bhaves",
  "Bheeshma",
  "Bhisham",
  "Bhishma",
  "Bhima",
  "Bhoj",
  "Bhramar",
  "Bhudev",
  "Bhudeva",
  "Bhupati",
  "Bhoopati",
  "Bhoopat",
  "Bhupen",
  "Bhushan",
  "Bhooshan",
  "Bhushit",
  "Bhooshit",
  "Bhuvanesh",
  "Bhuvaneshwar",
  "Bilva",
  "Bodhan",
  "Brahma",
  "Brahmabrata",
  "Brahmanandam",
  "Brahmaanand",
  "Brahmdev",
  "Brajendra",
  "Brajesh",
  "Brijesh",
  "Birjesh",
  "Budhil",
  "Chakor",
  "Chakradhar",
  "Chakravartee",
  "Chakravarti",
  "Chanakya",
  "Chaanakya",
  "Chandak",
  "Chandan",
  "Chandra",
  "Chandraayan",
  "Chandrabhan",
  "Chandradev",
  "Chandraketu",
  "Chandramauli",
  "Chandramohan",
  "Chandran",
  "Chandranath",
  "Chapal",
  "Charak",
  "Charuchandra",
  "Chaaruchandra",
  "Charuvrat",
  "Chatur",
  "Chaturaanan",
  "Chaturbhuj",
  "Chetan",
  "Chaten",
  "Chaitan",
  "Chetanaanand",
  "Chidaakaash",
  "Chidaatma",
  "Chidambar",
  "Chidambaram",
  "Chidananda",
  "Chinmayanand",
  "Chinmayananda",
  "Chiranjeev",
  "Chiranjeeve",
  "Chitraksh",
  "Daiwik",
  "Daksha",
  "Damodara",
  "Dandak",
  "Dandapaani",
  "Darshan",
  "Datta",
  "Dayaamay",
  "Dayamayee",
  "Dayaananda",
  "Dayaanidhi",
  "Kin",
  "Deenabandhu",
  "Deepan",
  "Deepankar",
  "Dipankar",
  "Deependra",
  "Dipendra",
  "Deepesh",
  "Dipesh",
  "Deeptanshu",
  "Deeptendu",
  "Diptendu",
  "Deeptiman",
  "Deeptimoy",
  "Deeptimay",
  "Dev",
  "Deb",
  "Devadatt",
  "Devagya",
  "Devajyoti",
  "Devak",
  "Devdan",
  "Deven",
  "Devesh",
  "Deveshwar",
  "Devi",
  "Devvrat",
  "Dhananjay",
  "Dhanapati",
  "Dhanpati",
  "Dhanesh",
  "Dhanu",
  "Dhanvin",
  "Dharmaketu",
  "Dhruv",
  "Dhyanesh",
  "Dhyaneshwar",
  "Digambar",
  "Digambara",
  "Dinakar",
  "Dinkar",
  "Dinesh",
  "Divaakar",
  "Divakar",
  "Deevakar",
  "Divjot",
  "Dron",
  "Drona",
  "Dwaipayan",
  "Dwaipayana",
  "Eekalabya",
  "Ekalavya",
  "Ekaksh",
  "Ekaaksh",
  "Ekaling",
  "Ekdant",
  "Ekadant",
  "Gajaadhar",
  "Gajadhar",
  "Gajbaahu",
  "Gajabahu",
  "Ganak",
  "Ganaka",
  "Ganapati",
  "Gandharv",
  "Gandharva",
  "Ganesh",
  "Gangesh",
  "Garud",
  "Garuda",
  "Gati",
  "Gatik",
  "Gaurang",
  "Gauraang",
  "Gauranga",
  "Gouranga",
  "Gautam",
  "Gautama",
  "Goutam",
  "Ghanaanand",
  "Ghanshyam",
  "Ghanashyam",
  "Giri",
  "Girik",
  "Girika",
  "Girindra",
  "Giriraaj",
  "Giriraj",
  "Girish",
  "Gopal",
  "Gopaal",
  "Gopi",
  "Gopee",
  "Gorakhnath",
  "Gorakhanatha",
  "Goswamee",
  "Goswami",
  "Gotum",
  "Gautam",
  "Govinda",
  "Gobinda",
  "Gudakesha",
  "Gudakesa",
  "Gurdev",
  "Guru",
  "Hari",
  "Harinarayan",
  "Harit",
  "Himadri",
  "Hiranmay",
  "Hiranmaya",
  "Hiranya",
  "Inder",
  "Indra",
  "Indra",
  "Jagadish",
  "Jagadisha",
  "Jagathi",
  "Jagdeep",
  "Jagdish",
  "Jagmeet",
  "Jahnu",
  "Jai",
  "Javas",
  "Jay",
  "Jitendra",
  "Jitender",
  "Jyotis",
  "Kailash",
  "Kama",
  "Kamalesh",
  "Kamlesh",
  "Kanak",
  "Kanaka",
  "Kannan",
  "Kannen",
  "Karan",
  "Karthik",
  "Kartik",
  "Karunanidhi",
  "Kashyap",
  "Kiran",
  "Kirti",
  "Keerti",
  "Krishna",
  "Krishnadas",
  "Krishnadasa",
  "Kumar",
  "Lai",
  "Lakshman",
  "Laxman",
  "Lakshmidhar",
  "Lakshminath",
  "Lal",
  "Laal",
  "Mahendra",
  "Mohinder",
  "Mahesh",
  "Maheswar",
  "Mani",
  "Manik",
  "Manikya",
  "Manoj",
  "Marut",
  "Mayoor",
  "Meghnad",
  "Meghnath",
  "Mohan",
  "Mukesh",
  "Mukul",
  "Nagabhushanam",
  "Nanda",
  "Narayan",
  "Narendra",
  "Narinder",
  "Naveen",
  "Navin",
  "Nawal",
  "Naval",
  "Nimit",
  "Niranjan",
  "Nirbhay",
  "Niro",
  "Param",
  "Paramartha",
  "Pran",
  "Pranay",
  "Prasad",
  "Prathamesh",
  "Prayag",
  "Prem",
  "Puneet",
  "Purushottam",
  "Rahul",
  "Raj",
  "Rajan",
  "Rajendra",
  "Rajinder",
  "Rajiv",
  "Rakesh",
  "Ramesh",
  "Rameshwar",
  "Ranjit",
  "Ranjeet",
  "Ravi",
  "Ritesh",
  "Rohan",
  "Rohit",
  "Rudra",
  "Sachin",
  "Sameer",
  "Samir",
  "Sanjay",
  "Sanka",
  "Sarvin",
  "Satish",
  "Satyen",
  "Shankar",
  "Shantanu",
  "Shashi",
  "Sher",
  "Shiv",
  "Siddarth",
  "Siddhran",
  "Som",
  "Somu",
  "Somnath",
  "Subhash",
  "Subodh",
  "Suman",
  "Suresh",
  "Surya",
  "Suryakant",
  "Suryakanta",
  "Sushil",
  "Susheel",
  "Swami",
  "Swapnil",
  "Tapan",
  "Tara",
  "Tarun",
  "Tej",
  "Tejas",
  "Trilochan",
  "Trilochana",
  "Trilok",
  "Trilokesh",
  "Triloki",
  "Triloki Nath",
  "Trilokanath",
  "Tushar",
  "Udai",
  "Udit",
  "Ujjawal",
  "Ujjwal",
  "Umang",
  "Upendra",
  "Uttam",
  "Vasudev",
  "Vasudeva",
  "Vedang",
  "Vedanga",
  "Vidhya",
  "Vidur",
  "Vidhur",
  "Vijay",
  "Vimal",
  "Vinay",
  "Vishnu",
  "Bishnu",
  "Vishwamitra",
  "Vyas",
  "Yogendra",
  "Yoginder",
  "Yogesh"
];

},{}],596:[function(require,module,exports){
arguments[4][544][0].apply(exports,arguments)
},{"./first_name":595,"./last_name":597,"dup":544}],597:[function(require,module,exports){
module["exports"] = [
  "Abbott",
  "Achari",
  "Acharya",
  "Adiga",
  "Agarwal",
  "Ahluwalia",
  "Ahuja",
  "Arora",
  "Asan",
  "Bandopadhyay",
  "Banerjee",
  "Bharadwaj",
  "Bhat",
  "Butt",
  "Bhattacharya",
  "Bhattathiri",
  "Chaturvedi",
  "Chattopadhyay",
  "Chopra",
  "Desai",
  "Deshpande",
  "Devar",
  "Dhawan",
  "Dubashi",
  "Dutta",
  "Dwivedi",
  "Embranthiri",
  "Ganaka",
  "Gandhi",
  "Gill",
  "Gowda",
  "Guha",
  "Guneta",
  "Gupta",
  "Iyer",
  "Iyengar",
  "Jain",
  "Jha",
  "Johar",
  "Joshi",
  "Kakkar",
  "Kaniyar",
  "Kapoor",
  "Kaul",
  "Kaur",
  "Khan",
  "Khanna",
  "Khatri",
  "Kocchar",
  "Mahajan",
  "Malik",
  "Marar",
  "Menon",
  "Mehra",
  "Mehrotra",
  "Mishra",
  "Mukhopadhyay",
  "Nayar",
  "Naik",
  "Nair",
  "Nambeesan",
  "Namboothiri",
  "Nehru",
  "Pandey",
  "Panicker",
  "Patel",
  "Patil",
  "Pilla",
  "Pillai",
  "Pothuvaal",
  "Prajapat",
  "Rana",
  "Reddy",
  "Saini",
  "Sethi",
  "Shah",
  "Sharma",
  "Shukla",
  "Singh",
  "Sinha",
  "Somayaji",
  "Tagore",
  "Talwar",
  "Tandon",
  "Trivedi",
  "Varrier",
  "Varma",
  "Varman",
  "Verma"
];

},{}],598:[function(require,module,exports){
module["exports"] = [
  "+91###-###-####",
  "+91##########",
  "+91-###-#######"
];

},{}],599:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":598,"dup":312}],600:[function(require,module,exports){
module["exports"] = [
  "United States",
  "United States of America",
  "USA"
];

},{}],601:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.default_country = require("./default_country");
address.postcode_by_state = require("./postcode_by_state");

},{"./default_country":600,"./postcode_by_state":602}],602:[function(require,module,exports){
module["exports"] = {
  "AL": "350##",
  "AK": "995##",
  "AS": "967##",
  "AZ": "850##",
  "AR": "717##",
  "CA": "900##",
  "CO": "800##",
  "CT": "061##",
  "DC": "204##",
  "DE": "198##",
  "FL": "322##",
  "GA": "301##",
  "HI": "967##",
  "ID": "832##",
  "IL": "600##",
  "IN": "463##",
  "IA": "510##",
  "KS": "666##",
  "KY": "404##",
  "LA": "701##",
  "ME": "042##",
  "MD": "210##",
  "MA": "026##",
  "MI": "480##",
  "MN": "555##",
  "MS": "387##",
  "MO": "650##",
  "MT": "590##",
  "NE": "688##",
  "NV": "898##",
  "NH": "036##",
  "NJ": "076##",
  "NM": "880##",
  "NY": "122##",
  "NC": "288##",
  "ND": "586##",
  "OH": "444##",
  "OK": "730##",
  "OR": "979##",
  "PA": "186##",
  "RI": "029##",
  "SC": "299##",
  "SD": "577##",
  "TN": "383##",
  "TX": "798##",
  "UT": "847##",
  "VT": "050##",
  "VA": "222##",
  "WA": "990##",
  "WV": "247##",
  "WI": "549##",
  "WY": "831##"
};

},{}],603:[function(require,module,exports){
var en_US = {};
module['exports'] = en_US;
en_US.title = "United States (English)";
en_US.internet = require("./internet");
en_US.address = require("./address");
en_US.phone_number = require("./phone_number");

},{"./address":601,"./internet":605,"./phone_number":608}],604:[function(require,module,exports){
module["exports"] = [
  "com",
  "us",
  "biz",
  "info",
  "name",
  "net",
  "org"
];

},{}],605:[function(require,module,exports){
arguments[4][430][0].apply(exports,arguments)
},{"./domain_suffix":604,"dup":430}],606:[function(require,module,exports){
module["exports"] = [
  "201",
  "202",
  "203",
  "205",
  "206",
  "207",
  "208",
  "209",
  "210",
  "212",
  "213",
  "214",
  "215",
  "216",
  "217",
  "218",
  "219",
  "224",
  "225",
  "227",
  "228",
  "229",
  "231",
  "234",
  "239",
  "240",
  "248",
  "251",
  "252",
  "253",
  "254",
  "256",
  "260",
  "262",
  "267",
  "269",
  "270",
  "276",
  "281",
  "283",
  "301",
  "302",
  "303",
  "304",
  "305",
  "307",
  "308",
  "309",
  "310",
  "312",
  "313",
  "314",
  "315",
  "316",
  "317",
  "318",
  "319",
  "320",
  "321",
  "323",
  "330",
  "331",
  "334",
  "336",
  "337",
  "339",
  "347",
  "351",
  "352",
  "360",
  "361",
  "386",
  "401",
  "402",
  "404",
  "405",
  "406",
  "407",
  "408",
  "409",
  "410",
  "412",
  "413",
  "414",
  "415",
  "417",
  "419",
  "423",
  "424",
  "425",
  "434",
  "435",
  "440",
  "443",
  "445",
  "464",
  "469",
  "470",
  "475",
  "478",
  "479",
  "480",
  "484",
  "501",
  "502",
  "503",
  "504",
  "505",
  "507",
  "508",
  "509",
  "510",
  "512",
  "513",
  "515",
  "516",
  "517",
  "518",
  "520",
  "530",
  "540",
  "541",
  "551",
  "557",
  "559",
  "561",
  "562",
  "563",
  "564",
  "567",
  "570",
  "571",
  "573",
  "574",
  "580",
  "585",
  "586",
  "601",
  "602",
  "603",
  "605",
  "606",
  "607",
  "608",
  "609",
  "610",
  "612",
  "614",
  "615",
  "616",
  "617",
  "618",
  "619",
  "620",
  "623",
  "626",
  "630",
  "631",
  "636",
  "641",
  "646",
  "650",
  "651",
  "660",
  "661",
  "662",
  "667",
  "678",
  "682",
  "701",
  "702",
  "703",
  "704",
  "706",
  "707",
  "708",
  "712",
  "713",
  "714",
  "715",
  "716",
  "717",
  "718",
  "719",
  "720",
  "724",
  "727",
  "731",
  "732",
  "734",
  "737",
  "740",
  "754",
  "757",
  "760",
  "763",
  "765",
  "770",
  "772",
  "773",
  "774",
  "775",
  "781",
  "785",
  "786",
  "801",
  "802",
  "803",
  "804",
  "805",
  "806",
  "808",
  "810",
  "812",
  "813",
  "814",
  "815",
  "816",
  "817",
  "818",
  "828",
  "830",
  "831",
  "832",
  "835",
  "843",
  "845",
  "847",
  "848",
  "850",
  "856",
  "857",
  "858",
  "859",
  "860",
  "862",
  "863",
  "864",
  "865",
  "870",
  "872",
  "878",
  "901",
  "903",
  "904",
  "906",
  "907",
  "908",
  "909",
  "910",
  "912",
  "913",
  "914",
  "915",
  "916",
  "917",
  "918",
  "919",
  "920",
  "925",
  "928",
  "931",
  "936",
  "937",
  "940",
  "941",
  "947",
  "949",
  "952",
  "954",
  "956",
  "959",
  "970",
  "971",
  "972",
  "973",
  "975",
  "978",
  "979",
  "980",
  "984",
  "985",
  "989"
];

},{}],607:[function(require,module,exports){
arguments[4][606][0].apply(exports,arguments)
},{"dup":606}],608:[function(require,module,exports){
var phone_number = {};
module['exports'] = phone_number;
phone_number.area_code = require("./area_code");
phone_number.exchange_code = require("./exchange_code");

},{"./area_code":606,"./exchange_code":607}],609:[function(require,module,exports){
arguments[4][531][0].apply(exports,arguments)
},{"dup":531}],610:[function(require,module,exports){
module["exports"] = [
  "#{city_prefix}"
];

},{}],611:[function(require,module,exports){
module["exports"] = [
  "Bondi",
  "Burleigh Heads",
  "Carlton",
  "Fitzroy",
  "Fremantle",
  "Glenelg",
  "Manly",
  "Noosa",
  "Stones Corner",
  "St Kilda",
  "Surry Hills",
  "Yarra Valley"
];

},{}],612:[function(require,module,exports){
arguments[4][532][0].apply(exports,arguments)
},{"dup":532}],613:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.street_root = require("./street_root");
address.street_name = require("./street_name");
address.city_prefix = require("./city_prefix");
address.city = require("./city");
address.state_abbr = require("./state_abbr");
address.region = require("./region");
address.state = require("./state");
address.postcode = require("./postcode");
address.building_number = require("./building_number");
address.street_suffix = require("./street_suffix");
address.default_country = require("./default_country");

},{"./building_number":609,"./city":610,"./city_prefix":611,"./default_country":612,"./postcode":614,"./region":615,"./state":616,"./state_abbr":617,"./street_name":618,"./street_root":619,"./street_suffix":620}],614:[function(require,module,exports){
arguments[4][534][0].apply(exports,arguments)
},{"dup":534}],615:[function(require,module,exports){
module["exports"] = [
  "South East Queensland",
  "Wide Bay Burnett",
  "Margaret River",
  "Port Pirie",
  "Gippsland",
  "Elizabeth",
  "Barossa"
];

},{}],616:[function(require,module,exports){
arguments[4][535][0].apply(exports,arguments)
},{"dup":535}],617:[function(require,module,exports){
arguments[4][536][0].apply(exports,arguments)
},{"dup":536}],618:[function(require,module,exports){
arguments[4][368][0].apply(exports,arguments)
},{"dup":368}],619:[function(require,module,exports){
module["exports"] = [
  "Ramsay Street",
  "Bonnie Doon",
  "Cavill Avenue",
  "Queen Street"
];

},{}],620:[function(require,module,exports){
arguments[4][537][0].apply(exports,arguments)
},{"dup":537}],621:[function(require,module,exports){
arguments[4][538][0].apply(exports,arguments)
},{"./suffix":622,"dup":538}],622:[function(require,module,exports){
arguments[4][539][0].apply(exports,arguments)
},{"dup":539}],623:[function(require,module,exports){
var en_au_ocker = {};
module['exports'] = en_au_ocker;
en_au_ocker.title = "Australia Ocker (English)";
en_au_ocker.name = require("./name");
en_au_ocker.company = require("./company");
en_au_ocker.internet = require("./internet");
en_au_ocker.address = require("./address");
en_au_ocker.phone_number = require("./phone_number");

},{"./address":613,"./company":621,"./internet":625,"./name":627,"./phone_number":631}],624:[function(require,module,exports){
arguments[4][541][0].apply(exports,arguments)
},{"dup":541}],625:[function(require,module,exports){
arguments[4][430][0].apply(exports,arguments)
},{"./domain_suffix":624,"dup":430}],626:[function(require,module,exports){
module["exports"] = [
  "Charlotte",
  "Ava",
  "Chloe",
  "Emily",
  "Olivia",
  "Zoe",
  "Lily",
  "Sophie",
  "Amelia",
  "Sofia",
  "Ella",
  "Isabella",
  "Ruby",
  "Sienna",
  "Mia+3",
  "Grace",
  "Emma",
  "Ivy",
  "Layla",
  "Abigail",
  "Isla",
  "Hannah",
  "Zara",
  "Lucy",
  "Evie",
  "Annabelle",
  "Madison",
  "Alice",
  "Georgia",
  "Maya",
  "Madeline",
  "Audrey",
  "Scarlett",
  "Isabelle",
  "Chelsea",
  "Mila",
  "Holly",
  "Indiana",
  "Poppy",
  "Harper",
  "Sarah",
  "Alyssa",
  "Jasmine",
  "Imogen",
  "Hayley",
  "Pheobe",
  "Eva",
  "Evelyn",
  "Mackenzie",
  "Ayla",
  "Oliver",
  "Jack",
  "Jackson",
  "William",
  "Ethan",
  "Charlie",
  "Lucas",
  "Cooper",
  "Lachlan",
  "Noah",
  "Liam",
  "Alexander",
  "Max",
  "Isaac",
  "Thomas",
  "Xavier",
  "Oscar",
  "Benjamin",
  "Aiden",
  "Mason",
  "Samuel",
  "James",
  "Levi",
  "Riley",
  "Harrison",
  "Ryan",
  "Henry",
  "Jacob",
  "Joshua",
  "Leo",
  "Zach",
  "Harry",
  "Hunter",
  "Flynn",
  "Archie",
  "Tyler",
  "Elijah",
  "Hayden",
  "Jayden",
  "Blake",
  "Archer",
  "Ashton",
  "Sebastian",
  "Zachery",
  "Lincoln",
  "Mitchell",
  "Luca",
  "Nathan",
  "Kai",
  "Connor",
  "Tom",
  "Nigel",
  "Matt",
  "Sean"
];

},{}],627:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.last_name = require("./last_name");
name.ocker_first_name = require("./ocker_first_name");

},{"./first_name":626,"./last_name":628,"./ocker_first_name":629}],628:[function(require,module,exports){
module["exports"] = [
  "Smith",
  "Jones",
  "Williams",
  "Brown",
  "Wilson",
  "Taylor",
  "Morton",
  "White",
  "Martin",
  "Anderson",
  "Thompson",
  "Nguyen",
  "Thomas",
  "Walker",
  "Harris",
  "Lee",
  "Ryan",
  "Robinson",
  "Kelly",
  "King",
  "Rausch",
  "Ridge",
  "Connolly",
  "LeQuesne"
];

},{}],629:[function(require,module,exports){
module["exports"] = [
  "Bazza",
  "Bluey",
  "Davo",
  "Johno",
  "Shano",
  "Shazza"
];

},{}],630:[function(require,module,exports){
arguments[4][546][0].apply(exports,arguments)
},{"dup":546}],631:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":630,"dup":312}],632:[function(require,module,exports){
module["exports"] = [
  " s/n.",
  ", #",
  ", ##",
  " #",
  " ##"
];

},{}],633:[function(require,module,exports){
arguments[4][610][0].apply(exports,arguments)
},{"dup":610}],634:[function(require,module,exports){
module["exports"] = [
  "Parla",
  "Telde",
  "Baracaldo",
  "San Fernando",
  "Torrevieja",
  "Lugo",
  "Santiago de Compostela",
  "Gerona",
  "Cceres",
  "Lorca",
  "Coslada",
  "Talavera de la Reina",
  "El Puerto de Santa Mara",
  "Cornell de Llobregat",
  "Avils",
  "Palencia",
  "Gecho",
  "Orihuela",
  "Pontevedra",
  "Pozuelo de Alarcn",
  "Toledo",
  "El Ejido",
  "Guadalajara",
  "Ganda",
  "Ceuta",
  "Ferrol",
  "Chiclana de la Frontera",
  "Manresa",
  "Roquetas de Mar",
  "Ciudad Real",
  "Rub",
  "Benidorm",
  "San Sebastan de los Reyes",
  "Ponferrada",
  "Zamora",
  "Alcal de Guadaira",
  "Fuengirola",
  "Mijas",
  "Sanlcar de Barrameda",
  "La Lnea de la Concepcin",
  "Majadahonda",
  "Sagunto",
  "El Prat de LLobregat",
  "Viladecans",
  "Linares",
  "Alcoy",
  "Irn",
  "Estepona",
  "Torremolinos",
  "Rivas-Vaciamadrid",
  "Molina de Segura",
  "Paterna",
  "Granollers",
  "Santa Luca de Tirajana",
  "Motril",
  "Cerdaola del Valls",
  "Arrecife",
  "Segovia",
  "Torrelavega",
  "Elda",
  "Mrida",
  "vila",
  "Valdemoro",
  "Cuenta",
  "Collado Villalba",
  "Benalmdena",
  "Mollet del Valls",
  "Puertollano",
  "Madrid",
  "Barcelona",
  "Valencia",
  "Sevilla",
  "Zaragoza",
  "Mlaga",
  "Murcia",
  "Palma de Mallorca",
  "Las Palmas de Gran Canaria",
  "Bilbao",
  "Crdoba",
  "Alicante",
  "Valladolid",
  "Vigo",
  "Gijn",
  "Hospitalet de LLobregat",
  "La Corua",
  "Granada",
  "Vitoria",
  "Elche",
  "Santa Cruz de Tenerife",
  "Oviedo",
  "Badalona",
  "Cartagena",
  "Mstoles",
  "Jerez de la Frontera",
  "Tarrasa",
  "Sabadell",
  "Alcal de Henares",
  "Pamplona",
  "Fuenlabrada",
  "Almera",
  "San Sebastin",
  "Legans",
  "Santander",
  "Burgos",
  "Castelln de la Plana",
  "Alcorcn",
  "Albacete",
  "Getafe",
  "Salamanca",
  "Huelva",
  "Logroo",
  "Badajoz",
  "San Cristrbal de la Laguna",
  "Len",
  "Tarragona",
  "Cdiz",
  "Lrida",
  "Marbella",
  "Matar",
  "Dos Hermanas",
  "Santa Coloma de Gramanet",
  "Jan",
  "Algeciras",
  "Torrejn de Ardoz",
  "Orense",
  "Alcobendas",
  "Reus",
  "Calahorra",
  "Inca"
];

},{}],635:[function(require,module,exports){
module["exports"] = [
  "Afganistn",
  "Albania",
  "Argelia",
  "Andorra",
  "Angola",
  "Argentina",
  "Armenia",
  "Aruba",
  "Australia",
  "Austria",
  "Azerbayn",
  "Bahamas",
  "Barein",
  "Bangladesh",
  "Barbados",
  "Bielorusia",
  "Blgica",
  "Belice",
  "Bermuda",
  "Butn",
  "Bolivia",
  "Bosnia Herzegovina",
  "Botswana",
  "Brasil",
  "Bulgaria",
  "Burkina Faso",
  "Burundi",
  "Camboya",
  "Camern",
  "Canada",
  "Cabo Verde",
  "Islas Caimn",
  "Chad",
  "Chile",
  "China",
  "Isla de Navidad",
  "Colombia",
  "Comodos",
  "Congo",
  "Costa Rica",
  "Costa de Marfil",
  "Croacia",
  "Cuba",
  "Chipre",
  "Repblica Checa",
  "Dinamarca",
  "Dominica",
  "Repblica Dominicana",
  "Ecuador",
  "Egipto",
  "El Salvador",
  "Guinea Ecuatorial",
  "Eritrea",
  "Estonia",
  "Etiopa",
  "Islas Faro",
  "Fiji",
  "Finlandia",
  "Francia",
  "Gabn",
  "Gambia",
  "Georgia",
  "Alemania",
  "Ghana",
  "Grecia",
  "Groenlandia",
  "Granada",
  "Guadalupe",
  "Guam",
  "Guatemala",
  "Guinea",
  "Guinea-Bisau",
  "Guayana",
  "Haiti",
  "Honduras",
  "Hong Kong",
  "Hungria",
  "Islandia",
  "India",
  "Indonesia",
  "Iran",
  "Irak",
  "Irlanda",
  "Italia",
  "Jamaica",
  "Japn",
  "Jordania",
  "Kazajistan",
  "Kenia",
  "Kiribati",
  "Corea",
  "Kuwait",
  "Letonia",
  "Lbano",
  "Liberia",
  "Liechtenstein",
  "Lituania",
  "Luxemburgo",
  "Macao",
  "Macedonia",
  "Madagascar",
  "Malawi",
  "Malasia",
  "Maldivas",
  "Mali",
  "Malta",
  "Martinica",
  "Mauritania",
  "Mjico",
  "Micronesia",
  "Moldavia",
  "Mnaco",
  "Mongolia",
  "Montenegro",
  "Montserrat",
  "Marruecos",
  "Mozambique",
  "Namibia",
  "Nauru",
  "Nepal",
  "Holanda",
  "Nueva Zelanda",
  "Nicaragua",
  "Niger",
  "Nigeria",
  "Noruega",
  "Omn",
  "Pakistan",
  "Panam",
  "Papa Nueva Guinea",
  "Paraguay",
  "Per",
  "Filipinas",
  "Poland",
  "Portugal",
  "Puerto Rico",
  "Rusia",
  "Ruanda",
  "Samoa",
  "San Marino",
  "Santo Tom y Principe",
  "Arabia Saud",
  "Senegal",
  "Serbia",
  "Seychelles",
  "Sierra Leona",
  "Singapur",
  "Eslovaquia",
  "Eslovenia",
  "Somalia",
  "Espaa",
  "Sri Lanka",
  "Sudn",
  "Suriname",
  "Suecia",
  "Suiza",
  "Siria",
  "Taiwan",
  "Tajikistan",
  "Tanzania",
  "Tailandia",
  "Timor-Leste",
  "Togo",
  "Tonga",
  "Trinidad y Tobago",
  "Tunez",
  "Turquia",
  "Uganda",
  "Ucrania",
  "Emiratos rabes Unidos",
  "Reino Unido",
  "Estados Unidos de Amrica",
  "Uruguay",
  "Uzbekistan",
  "Vanuatu",
  "Venezuela",
  "Vietnam",
  "Yemen",
  "Zambia",
  "Zimbabwe"
];

},{}],636:[function(require,module,exports){
module["exports"] = [
  "Espaa"
];

},{}],637:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city_prefix = require("./city_prefix");
address.country = require("./country");
address.building_number = require("./building_number");
address.street_suffix = require("./street_suffix");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.province = require("./province");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.time_zone = require("./time_zone");
address.city = require("./city");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":632,"./city":633,"./city_prefix":634,"./country":635,"./default_country":636,"./postcode":638,"./province":639,"./secondary_address":640,"./state":641,"./state_abbr":642,"./street_address":643,"./street_name":644,"./street_suffix":645,"./time_zone":646}],638:[function(require,module,exports){
module["exports"] = [
  "#####"
];

},{}],639:[function(require,module,exports){
module["exports"] = [
  "lava",
  "Albacete",
  "Alicante",
  "Almera",
  "Asturias",
  "vila",
  "Badajoz",
  "Barcelona",
  "Burgos",
  "Cantabria",
  "Castelln",
  "Ciudad Real",
  "Cuenca",
  "Cceres",
  "Cdiz",
  "Crdoba",
  "Gerona",
  "Granada",
  "Guadalajara",
  "Guipzcoa",
  "Huelva",
  "Huesca",
  "Islas Baleares",
  "Jan",
  "La Corua",
  "La Rioja",
  "Las Palmas",
  "Len",
  "Lugo",
  "lrida",
  "Madrid",
  "Murcia",
  "Mlaga",
  "Navarra",
  "Orense",
  "Palencia",
  "Pontevedra",
  "Salamanca",
  "Santa Cruz de Tenerife",
  "Segovia",
  "Sevilla",
  "Soria",
  "Tarragona",
  "Teruel",
  "Toledo",
  "Valencia",
  "Valladolid",
  "Vizcaya",
  "Zamora",
  "Zaragoza"
];

},{}],640:[function(require,module,exports){
module["exports"] = [
  "Esc. ###",
  "Puerta ###"
];

},{}],641:[function(require,module,exports){
module["exports"] = [
  "Andaluca",
  "Aragn",
  "Principado de Asturias",
  "Baleares",
  "Canarias",
  "Cantabria",
  "Castilla-La Mancha",
  "Castilla y Len",
  "Catalua",
  "Comunidad Valenciana",
  "Extremadura",
  "Galicia",
  "La Rioja",
  "Comunidad de Madrid",
  "Navarra",
  "Pas Vasco",
  "Regin de Murcia"
];

},{}],642:[function(require,module,exports){
module["exports"] = [
  "And",
  "Ara",
  "Ast",
  "Bal",
  "Can",
  "Cbr",
  "Man",
  "Leo",
  "Cat",
  "Com",
  "Ext",
  "Gal",
  "Rio",
  "Mad",
  "Nav",
  "Vas",
  "Mur"
];

},{}],643:[function(require,module,exports){
module["exports"] = [
  "#{street_name}#{building_number}",
  "#{street_name}#{building_number} #{secondary_address}"
];

},{}],644:[function(require,module,exports){
module["exports"] = [
  "#{street_suffix} #{Name.first_name}",
  "#{street_suffix} #{Name.first_name} #{Name.last_name}"
];

},{}],645:[function(require,module,exports){
module["exports"] = [
  "Aldea",
  "Apartamento",
  "Arrabal",
  "Arroyo",
  "Avenida",
  "Bajada",
  "Barranco",
  "Barrio",
  "Bloque",
  "Calle",
  "Calleja",
  "Camino",
  "Carretera",
  "Caserio",
  "Colegio",
  "Colonia",
  "Conjunto",
  "Cuesta",
  "Chalet",
  "Edificio",
  "Entrada",
  "Escalinata",
  "Explanada",
  "Extramuros",
  "Extrarradio",
  "Ferrocarril",
  "Glorieta",
  "Gran Subida",
  "Grupo",
  "Huerta",
  "Jardines",
  "Lado",
  "Lugar",
  "Manzana",
  "Masa",
  "Mercado",
  "Monte",
  "Muelle",
  "Municipio",
  "Parcela",
  "Parque",
  "Partida",
  "Pasaje",
  "Paseo",
  "Plaza",
  "Poblado",
  "Polgono",
  "Prolongacin",
  "Puente",
  "Puerta",
  "Quinta",
  "Ramal",
  "Rambla",
  "Rampa",
  "Riera",
  "Rincn",
  "Ronda",
  "Rua",
  "Salida",
  "Sector",
  "Seccin",
  "Senda",
  "Solar",
  "Subida",
  "Terrenos",
  "Torrente",
  "Travesa",
  "Urbanizacin",
  "Va",
  "Va Pblica"
];

},{}],646:[function(require,module,exports){
module["exports"] = [
  "Pacfico/Midway",
  "Pacfico/Pago_Pago",
  "Pacfico/Honolulu",
  "America/Juneau",
  "America/Los_Angeles",
  "America/Tijuana",
  "America/Denver",
  "America/Phoenix",
  "America/Chihuahua",
  "America/Mazatlan",
  "America/Chicago",
  "America/Regina",
  "America/Mexico_City",
  "America/Mexico_City",
  "America/Monterrey",
  "America/Guatemala",
  "America/New_York",
  "America/Indiana/Indianapolis",
  "America/Bogota",
  "America/Lima",
  "America/Lima",
  "America/Halifax",
  "America/Caracas",
  "America/La_Paz",
  "America/Santiago",
  "America/St_Johns",
  "America/Sao_Paulo",
  "America/Argentina/Buenos_Aires",
  "America/Guyana",
  "America/Godthab",
  "Atlantic/South_Georgia",
  "Atlantic/Azores",
  "Atlantic/Cape_Verde",
  "Europa/Dublin",
  "Europa/London",
  "Europa/Lisbon",
  "Europa/London",
  "Africa/Casablanca",
  "Africa/Monrovia",
  "Etc/UTC",
  "Europa/Belgrade",
  "Europa/Bratislava",
  "Europa/Budapest",
  "Europa/Ljubljana",
  "Europa/Prague",
  "Europa/Sarajevo",
  "Europa/Skopje",
  "Europa/Warsaw",
  "Europa/Zagreb",
  "Europa/Brussels",
  "Europa/Copenhagen",
  "Europa/Madrid",
  "Europa/Paris",
  "Europa/Amsterdam",
  "Europa/Berlin",
  "Europa/Berlin",
  "Europa/Rome",
  "Europa/Stockholm",
  "Europa/Vienna",
  "Africa/Algiers",
  "Europa/Bucharest",
  "Africa/Cairo",
  "Europa/Helsinki",
  "Europa/Kiev",
  "Europa/Riga",
  "Europa/Sofia",
  "Europa/Tallinn",
  "Europa/Vilnius",
  "Europa/Athens",
  "Europa/Istanbul",
  "Europa/Minsk",
  "Asia/Jerusalen",
  "Africa/Harare",
  "Africa/Johannesburg",
  "Europa/Mosc",
  "Europa/Mosc",
  "Europa/Mosc",
  "Asia/Kuwait",
  "Asia/Riyadh",
  "Africa/Nairobi",
  "Asia/Baghdad",
  "Asia/Tehran",
  "Asia/Muscat",
  "Asia/Muscat",
  "Asia/Baku",
  "Asia/Tbilisi",
  "Asia/Yerevan",
  "Asia/Kabul",
  "Asia/Yekaterinburg",
  "Asia/Karachi",
  "Asia/Karachi",
  "Asia/Tashkent",
  "Asia/Kolkata",
  "Asia/Kolkata",
  "Asia/Kolkata",
  "Asia/Kolkata",
  "Asia/Kathmandu",
  "Asia/Dhaka",
  "Asia/Dhaka",
  "Asia/Colombo",
  "Asia/Almaty",
  "Asia/Novosibirsk",
  "Asia/Rangoon",
  "Asia/Bangkok",
  "Asia/Bangkok",
  "Asia/Jakarta",
  "Asia/Krasnoyarsk",
  "Asia/Shanghai",
  "Asia/Chongqing",
  "Asia/Hong_Kong",
  "Asia/Urumqi",
  "Asia/Kuala_Lumpur",
  "Asia/Singapore",
  "Asia/Taipei",
  "Australia/Perth",
  "Asia/Irkutsk",
  "Asia/Ulaanbaatar",
  "Asia/Seoul",
  "Asia/Tokyo",
  "Asia/Tokyo",
  "Asia/Tokyo",
  "Asia/Yakutsk",
  "Australia/Darwin",
  "Australia/Adelaide",
  "Australia/Melbourne",
  "Australia/Melbourne",
  "Australia/Sydney",
  "Australia/Brisbane",
  "Australia/Hobart",
  "Asia/Vladivostok",
  "Pacfico/Guam",
  "Pacfico/Port_Moresby",
  "Asia/Magadan",
  "Asia/Magadan",
  "Pacfico/Noumea",
  "Pacfico/Fiji",
  "Asia/Kamchatka",
  "Pacfico/Majuro",
  "Pacfico/Auckland",
  "Pacfico/Auckland",
  "Pacfico/Tongatapu",
  "Pacfico/Fakaofo",
  "Pacfico/Apia"
];

},{}],647:[function(require,module,exports){
module["exports"] = [
  "6##-###-###",
  "6##.###.###",
  "6## ### ###",
  "6########"
];

},{}],648:[function(require,module,exports){
arguments[4][371][0].apply(exports,arguments)
},{"./formats":647,"dup":371}],649:[function(require,module,exports){
module["exports"] = [
  "Adaptativo",
  "Avanzado",
  "Asimilado",
  "Automatizado",
  "Equilibrado",
  "Centrado en el negocio",
  "Centralizado",
  "Clonado",
  "Compatible",
  "Configurable",
  "Multi grupo",
  "Multi plataforma",
  "Centrado en el usuario",
  "Configurable",
  "Descentralizado",
  "Digitalizado",
  "Distribuido",
  "Diverso",
  "Reducido",
  "Mejorado",
  "Para toda la empresa",
  "Ergonomico",
  "Exclusivo",
  "Expandido",
  "Extendido",
  "Cara a cara",
  "Enfocado",
  "Totalmente configurable",
  "Fundamental",
  "Orgenes",
  "Horizontal",
  "Implementado",
  "Innovador",
  "Integrado",
  "Intuitivo",
  "Inverso",
  "Gestionado",
  "Obligatorio",
  "Monitorizado",
  "Multi canal",
  "Multi lateral",
  "Multi capa",
  "En red",
  "Orientado a objetos",
  "Open-source",
  "Operativo",
  "Optimizado",
  "Opcional",
  "Organico",
  "Organizado",
  "Perseverando",
  "Persistente",
  "en fases",
  "Polarizado",
  "Pre-emptivo",
  "Proactivo",
  "Enfocado a benficios",
  "Profundo",
  "Programable",
  "Progresivo",
  "Public-key",
  "Enfocado en la calidad",
  "Reactivo",
  "Realineado",
  "Re-contextualizado",
  "Re-implementado",
  "Reducido",
  "Ingenieria inversa",
  "Robusto",
  "Fcil",
  "Seguro",
  "Auto proporciona",
  "Compartible",
  "Intercambiable",
  "Sincronizado",
  "Orientado a equipos",
  "Total",
  "Universal",
  "Mejorado",
  "Actualizable",
  "Centrado en el usuario",
  "Amigable",
  "Versatil",
  "Virtual",
  "Visionario"
];

},{}],650:[function(require,module,exports){
module["exports"] = [
  "24 horas",
  "24/7",
  "3rd generacin",
  "4th generacin",
  "5th generacin",
  "6th generacin",
  "analizada",
  "asimtrica",
  "asncrona",
  "monitorizada por red",
  "bidireccional",
  "bifurcada",
  "generada por el cliente",
  "cliente servidor",
  "coherente",
  "cohesiva",
  "compuesto",
  "sensible al contexto",
  "basado en el contexto",
  "basado en contenido",
  "dedicada",
  "generado por la demanda",
  "didactica",
  "direccional",
  "discreta",
  "dinmica",
  "potenciada",
  "acompasada",
  "ejecutiva",
  "explcita",
  "tolerante a fallos",
  "innovadora",
  "amplio banico",
  "global",
  "heurstica",
  "alto nivel",
  "holstica",
  "homognea",
  "hibrida",
  "incremental",
  "intangible",
  "interactiva",
  "intermedia",
  "local",
  "logstica",
  "maximizada",
  "metdica",
  "misin crtica",
  "mbil",
  "modular",
  "motivadora",
  "multimedia",
  "multiestado",
  "multitarea",
  "nacional",
  "basado en necesidades",
  "neutral",
  "nueva generacin",
  "no-voltil",
  "orientado a objetos",
  "ptima",
  "optimizada",
  "radical",
  "tiempo real",
  "recproca",
  "regional",
  "escalable",
  "secundaria",
  "orientada a soluciones",
  "estable",
  "estatica",
  "sistemtica",
  "sistmica",
  "tangible",
  "terciaria",
  "transicional",
  "uniforme",
  "valor aadido",
  "va web",
  "defectos cero",
  "tolerancia cero"
];

},{}],651:[function(require,module,exports){
var company = {};
module['exports'] = company;
company.suffix = require("./suffix");
company.noun = require("./noun");
company.descriptor = require("./descriptor");
company.adjective = require("./adjective");
company.name = require("./name");

},{"./adjective":649,"./descriptor":650,"./name":652,"./noun":653,"./suffix":654}],652:[function(require,module,exports){
module["exports"] = [
  "#{Name.last_name} #{suffix}",
  "#{Name.last_name} y #{Name.last_name}",
  "#{Name.last_name} #{Name.last_name} #{suffix}",
  "#{Name.last_name}, #{Name.last_name} y #{Name.last_name} Asociados"
];

},{}],653:[function(require,module,exports){
module["exports"] = [
  "habilidad",
  "acceso",
  "adaptador",
  "algoritmo",
  "alianza",
  "analista",
  "aplicacin",
  "enfoque",
  "arquitectura",
  "archivo",
  "inteligencia artificial",
  "array",
  "actitud",
  "medicin",
  "gestin presupuestaria",
  "capacidad",
  "desafo",
  "circuito",
  "colaboracin",
  "complejidad",
  "concepto",
  "conglomeracin",
  "contingencia",
  "ncleo",
  "fidelidad",
  "base de datos",
  "data-warehouse",
  "definicin",
  "emulacin",
  "codificar",
  "encriptar",
  "extranet",
  "firmware",
  "flexibilidad",
  "focus group",
  "previsin",
  "base de trabajo",
  "funcin",
  "funcionalidad",
  "Interfaz Grfica",
  "groupware",
  "Interfaz grfico de usuario",
  "hardware",
  "Soporte",
  "jerarqua",
  "conjunto",
  "implementacin",
  "infraestructura",
  "iniciativa",
  "instalacin",
  "conjunto de instrucciones",
  "interfaz",
  "intranet",
  "base del conocimiento",
  "red de area local",
  "aprovechar",
  "matrices",
  "metodologas",
  "middleware",
  "migracin",
  "modelo",
  "moderador",
  "monitorizar",
  "arquitectura abierta",
  "sistema abierto",
  "orquestar",
  "paradigma",
  "paralelismo",
  "poltica",
  "portal",
  "estructura de precios",
  "proceso de mejora",
  "producto",
  "productividad",
  "proyecto",
  "proyeccin",
  "protocolo",
  "lnea segura",
  "software",
  "solucin",
  "estandardizacin",
  "estrategia",
  "estructura",
  "xito",
  "superestructura",
  "soporte",
  "sinergia",
  "mediante",
  "marco de tiempo",
  "caja de herramientas",
  "utilizacin",
  "website",
  "fuerza de trabajo"
];

},{}],654:[function(require,module,exports){
module["exports"] = [
  "S.L.",
  "e Hijos",
  "S.A.",
  "Hermanos"
];

},{}],655:[function(require,module,exports){
var es = {};
module['exports'] = es;
es.title = "Spanish";
es.address = require("./address");
es.company = require("./company");
es.internet = require("./internet");
es.name = require("./name");
es.phone_number = require("./phone_number");
es.cell_phone = require("./cell_phone");

},{"./address":637,"./cell_phone":648,"./company":651,"./internet":658,"./name":660,"./phone_number":667}],656:[function(require,module,exports){
module["exports"] = [
  "com",
  "es",
  "info",
  "com.es",
  "org"
];

},{}],657:[function(require,module,exports){
arguments[4][378][0].apply(exports,arguments)
},{"dup":378}],658:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":656,"./free_email":657,"dup":302}],659:[function(require,module,exports){
module["exports"] = [
  "Adn",
  "Agustn",
  "Alberto",
  "Alejandro",
  "Alfonso",
  "Alfredo",
  "Andrs",
  "Antonio",
  "Armando",
  "Arturo",
  "Benito",
  "Benjamn",
  "Bernardo",
  "Carlos",
  "Csar",
  "Claudio",
  "Clemente",
  "Cristian",
  "Cristobal",
  "Daniel",
  "David",
  "Diego",
  "Eduardo",
  "Emilio",
  "Enrique",
  "Ernesto",
  "Esteban",
  "Federico",
  "Felipe",
  "Fernando",
  "Francisco",
  "Gabriel",
  "Gerardo",
  "Germn",
  "Gilberto",
  "Gonzalo",
  "Gregorio",
  "Guillermo",
  "Gustavo",
  "Hernn",
  "Homero",
  "Horacio",
  "Hugo",
  "Ignacio",
  "Jacobo",
  "Jaime",
  "Javier",
  "Jernimo",
  "Jess",
  "Joaqun",
  "Jorge",
  "Jorge Luis",
  "Jos",
  "Jos Eduardo",
  "Jos Emilio",
  "Jos Luis",
  "Jos Mara",
  "Juan",
  "Juan Carlos",
  "Julio",
  "Julio Csar",
  "Lorenzo",
  "Lucas",
  "Luis",
  "Luis Miguel",
  "Manuel",
  "Marco Antonio",
  "Marcos",
  "Mariano",
  "Mario",
  "Martn",
  "Mateo",
  "Miguel",
  "Miguel ngel",
  "Nicols",
  "Octavio",
  "scar",
  "Pablo",
  "Patricio",
  "Pedro",
  "Rafael",
  "Ramiro",
  "Ramn",
  "Ral",
  "Ricardo",
  "Roberto",
  "Rodrigo",
  "Rubn",
  "Salvador",
  "Samuel",
  "Sancho",
  "Santiago",
  "Sergio",
  "Teodoro",
  "Timoteo",
  "Toms",
  "Vicente",
  "Vctor",
  "Adela",
  "Adriana",
  "Alejandra",
  "Alicia",
  "Amalia",
  "Ana",
  "Ana Luisa",
  "Ana Mara",
  "Andrea",
  "Anita",
  "ngela",
  "Antonia",
  "Ariadna",
  "Barbara",
  "Beatriz",
  "Berta",
  "Blanca",
  "Caridad",
  "Carla",
  "Carlota",
  "Carmen",
  "Carolina",
  "Catalina",
  "Cecilia",
  "Clara",
  "Claudia",
  "Concepcin",
  "Conchita",
  "Cristina",
  "Daniela",
  "Dbora",
  "Diana",
  "Dolores",
  "Lola",
  "Dorotea",
  "Elena",
  "Elisa",
  "Eloisa",
  "Elsa",
  "Elvira",
  "Emilia",
  "Esperanza",
  "Estela",
  "Ester",
  "Eva",
  "Florencia",
  "Francisca",
  "Gabriela",
  "Gloria",
  "Graciela",
  "Guadalupe",
  "Guillermina",
  "Ins",
  "Irene",
  "Isabel",
  "Isabela",
  "Josefina",
  "Juana",
  "Julia",
  "Laura",
  "Leonor",
  "Leticia",
  "Lilia",
  "Lorena",
  "Lourdes",
  "Lucia",
  "Luisa",
  "Luz",
  "Magdalena",
  "Manuela",
  "Marcela",
  "Margarita",
  "Mara",
  "Mara del Carmen",
  "Mara Cristina",
  "Mara Elena",
  "Mara Eugenia",
  "Mara Jos",
  "Mara Luisa",
  "Mara Soledad",
  "Mara Teresa",
  "Mariana",
  "Maricarmen",
  "Marilu",
  "Marisol",
  "Marta",
  "Mayte",
  "Mercedes",
  "Micaela",
  "Mnica",
  "Natalia",
  "Norma",
  "Olivia",
  "Patricia",
  "Pilar",
  "Ramona",
  "Raquel",
  "Rebeca",
  "Reina",
  "Rocio",
  "Rosa",
  "Rosalia",
  "Rosario",
  "Sara",
  "Silvia",
  "Sofia",
  "Soledad",
  "Sonia",
  "Susana",
  "Teresa",
  "Vernica",
  "Victoria",
  "Virginia",
  "Yolanda"
];

},{}],660:[function(require,module,exports){
arguments[4][518][0].apply(exports,arguments)
},{"./first_name":659,"./last_name":661,"./name":662,"./prefix":663,"./suffix":664,"./title":665,"dup":518}],661:[function(require,module,exports){
module["exports"] = [
  "Abeyta",
  "Abrego",
  "Abreu",
  "Acevedo",
  "Acosta",
  "Acua",
  "Adame",
  "Adorno",
  "Agosto",
  "Aguayo",
  "guilar",
  "Aguilera",
  "Aguirre",
  "Alanis",
  "Alaniz",
  "Alarcn",
  "Alba",
  "Alcala",
  "Alcntar",
  "Alcaraz",
  "Alejandro",
  "Alemn",
  "Alfaro",
  "Alicea",
  "Almanza",
  "Almaraz",
  "Almonte",
  "Alonso",
  "Alonzo",
  "Altamirano",
  "Alva",
  "Alvarado",
  "Alvarez",
  "Amador",
  "Amaya",
  "Anaya",
  "Anguiano",
  "Angulo",
  "Aparicio",
  "Apodaca",
  "Aponte",
  "Aragn",
  "Araa",
  "Aranda",
  "Arce",
  "Archuleta",
  "Arellano",
  "Arenas",
  "Arevalo",
  "Arguello",
  "Arias",
  "Armas",
  "Armendriz",
  "Armenta",
  "Armijo",
  "Arredondo",
  "Arreola",
  "Arriaga",
  "Arroyo",
  "Arteaga",
  "Atencio",
  "valos",
  "vila",
  "Avils",
  "Ayala",
  "Baca",
  "Badillo",
  "Bez",
  "Baeza",
  "Bahena",
  "Balderas",
  "Ballesteros",
  "Banda",
  "Bauelos",
  "Barajas",
  "Barela",
  "Barragn",
  "Barraza",
  "Barrera",
  "Barreto",
  "Barrientos",
  "Barrios",
  "Batista",
  "Becerra",
  "Beltrn",
  "Benavides",
  "Benavdez",
  "Bentez",
  "Bermdez",
  "Bernal",
  "Berros",
  "Btancourt",
  "Blanco",
  "Bonilla",
  "Borrego",
  "Botello",
  "Bravo",
  "Briones",
  "Briseo",
  "Brito",
  "Bueno",
  "Burgos",
  "Bustamante",
  "Bustos",
  "Caballero",
  "Cabn",
  "Cabrera",
  "Cadena",
  "Caldera",
  "Caldern",
  "Calvillo",
  "Camacho",
  "Camarillo",
  "Campos",
  "Canales",
  "Candelaria",
  "Cano",
  "Cant",
  "Caraballo",
  "Carbajal",
  "Cardenas",
  "Cardona",
  "Carmona",
  "Carranza",
  "Carrasco",
  "Carrasquillo",
  "Carren",
  "Carrera",
  "Carrero",
  "Carrillo",
  "Carrion",
  "Carvajal",
  "Casanova",
  "Casares",
  "Casrez",
  "Casas",
  "Casillas",
  "Castaeda",
  "Castellanos",
  "Castillo",
  "Castro",
  "Cavazos",
  "Cazares",
  "Ceballos",
  "Cedillo",
  "Ceja",
  "Centeno",
  "Cepeda",
  "Cerda",
  "Cervantes",
  "Cervntez",
  "Chacn",
  "Chapa",
  "Chavarra",
  "Chvez",
  "Cintrn",
  "Cisneros",
  "Collado",
  "Collazo",
  "Coln",
  "Colunga",
  "Concepcin",
  "Contreras",
  "Cordero",
  "Crdova",
  "Cornejo",
  "Corona",
  "Coronado",
  "Corral",
  "Corrales",
  "Correa",
  "Corts",
  "Cortez",
  "Cotto",
  "Covarrubias",
  "Crespo",
  "Cruz",
  "Cuellar",
  "Curiel",
  "Dvila",
  "de Anda",
  "de Jess",
  "Delacrz",
  "Delafuente",
  "Delagarza",
  "Delao",
  "Delapaz",
  "Delarosa",
  "Delatorre",
  "Delen",
  "Delgadillo",
  "Delgado",
  "Delro",
  "Delvalle",
  "Daz",
  "Domnguez",
  "Domnquez",
  "Duarte",
  "Dueas",
  "Duran",
  "Echevarra",
  "Elizondo",
  "Enrquez",
  "Escalante",
  "Escamilla",
  "Escobar",
  "Escobedo",
  "Esparza",
  "Espinal",
  "Espino",
  "Espinosa",
  "Espinoza",
  "Esquibel",
  "Esquivel",
  "Estvez",
  "Estrada",
  "Fajardo",
  "Faras",
  "Feliciano",
  "Fernndez",
  "Ferrer",
  "Fierro",
  "Figueroa",
  "Flores",
  "Flrez",
  "Fonseca",
  "Franco",
  "Fras",
  "Fuentes",
  "Gaitn",
  "Galarza",
  "Galindo",
  "Gallardo",
  "Gallegos",
  "Galvn",
  "Glvez",
  "Gamboa",
  "Gamez",
  "Gaona",
  "Garay",
  "Garca",
  "Garibay",
  "Garica",
  "Garrido",
  "Garza",
  "Gastlum",
  "Gaytn",
  "Gil",
  "Girn",
  "Godnez",
  "Godoy",
  "Gmez",
  "Gonzales",
  "Gonzlez",
  "Gollum",
  "Gracia",
  "Granado",
  "Granados",
  "Griego",
  "Grijalva",
  "Guajardo",
  "Guardado",
  "Guerra",
  "Guerrero",
  "Guevara",
  "Guillen",
  "Gurule",
  "Gutirrez",
  "Guzmn",
  "Haro",
  "Henrquez",
  "Heredia",
  "Herndez",
  "Hernandes",
  "Hernndez",
  "Herrera",
  "Hidalgo",
  "Hinojosa",
  "Holgun",
  "Huerta",
  "Hurtado",
  "Ibarra",
  "Iglesias",
  "Irizarry",
  "Jaime",
  "Jaimes",
  "Jquez",
  "Jaramillo",
  "Jasso",
  "Jimnez",
  "Jimnez",
  "Jurez",
  "Jurado",
  "Laboy",
  "Lara",
  "Laureano",
  "Leal",
  "Lebrn",
  "Ledesma",
  "Leiva",
  "Lemus",
  "Len",
  "Lerma",
  "Leyva",
  "Limn",
  "Linares",
  "Lira",
  "Llamas",
  "Loera",
  "Lomeli",
  "Longoria",
  "Lpez",
  "Lovato",
  "Loya",
  "Lozada",
  "Lozano",
  "Lucero",
  "Lucio",
  "Luevano",
  "Lugo",
  "Luna",
  "Macas",
  "Madera",
  "Madrid",
  "Madrigal",
  "Maestas",
  "Magaa",
  "Malave",
  "Maldonado",
  "Manzanares",
  "Mares",
  "Marn",
  "Mrquez",
  "Marrero",
  "Marroqun",
  "Martnez",
  "Mascareas",
  "Mata",
  "Mateo",
  "Matas",
  "Matos",
  "Maya",
  "Mayorga",
  "Medina",
  "Medrano",
  "Meja",
  "Melndez",
  "Melgar",
  "Mena",
  "Menchaca",
  "Mndez",
  "Mendoza",
  "Menndez",
  "Meraz",
  "Mercado",
  "Merino",
  "Mesa",
  "Meza",
  "Miramontes",
  "Miranda",
  "Mireles",
  "Mojica",
  "Molina",
  "Mondragn",
  "Monroy",
  "Montalvo",
  "Montaez",
  "Montao",
  "Montemayor",
  "Montenegro",
  "Montero",
  "Montes",
  "Montez",
  "Montoya",
  "Mora",
  "Morales",
  "Moreno",
  "Mota",
  "Moya",
  "Mungua",
  "Muiz",
  "Muoz",
  "Murillo",
  "Muro",
  "Njera",
  "Naranjo",
  "Narvez",
  "Nava",
  "Navarrete",
  "Navarro",
  "Nazario",
  "Negrete",
  "Negrn",
  "Nevrez",
  "Nieto",
  "Nieves",
  "Nio",
  "Noriega",
  "Nez",
  "Ocampo",
  "Ocasio",
  "Ochoa",
  "Ojeda",
  "Olivares",
  "Olivrez",
  "Olivas",
  "Olivera",
  "Olivo",
  "Olmos",
  "Olvera",
  "Ontiveros",
  "Oquendo",
  "Ordez",
  "Orellana",
  "Ornelas",
  "Orosco",
  "Orozco",
  "Orta",
  "Ortega",
  "Ortiz",
  "Osorio",
  "Otero",
  "Ozuna",
  "Pabn",
  "Pacheco",
  "Padilla",
  "Padrn",
  "Pez",
  "Pagan",
  "Palacios",
  "Palomino",
  "Palomo",
  "Pantoja",
  "Paredes",
  "Parra",
  "Partida",
  "Patio",
  "Paz",
  "Pedraza",
  "Pedroza",
  "Pelayo",
  "Pea",
  "Perales",
  "Peralta",
  "Perea",
  "Peres",
  "Prez",
  "Pichardo",
  "Pia",
  "Pineda",
  "Pizarro",
  "Polanco",
  "Ponce",
  "Porras",
  "Portillo",
  "Posada",
  "Prado",
  "Preciado",
  "Prieto",
  "Puente",
  "Puga",
  "Pulido",
  "Quesada",
  "Quezada",
  "Quiones",
  "Quinez",
  "Quintana",
  "Quintanilla",
  "Quintero",
  "Quiroz",
  "Rael",
  "Ramrez",
  "Ramn",
  "Ramos",
  "Rangel",
  "Rascn",
  "Raya",
  "Razo",
  "Regalado",
  "Rendn",
  "Rentera",
  "Resndez",
  "Reyes",
  "Reyna",
  "Reynoso",
  "Rico",
  "Rincn",
  "Riojas",
  "Ros",
  "Rivas",
  "Rivera",
  "Rivero",
  "Robledo",
  "Robles",
  "Rocha",
  "Rodarte",
  "Rodrgez",
  "Rodrguez",
  "Rodrquez",
  "Rojas",
  "Rojo",
  "Roldn",
  "Roln",
  "Romero",
  "Romo",
  "Roque",
  "Rosado",
  "Rosales",
  "Rosario",
  "Rosas",
  "Roybal",
  "Rubio",
  "Ruelas",
  "Ruiz",
  "Saavedra",
  "Senz",
  "Saiz",
  "Salas",
  "Salazar",
  "Salcedo",
  "Salcido",
  "Saldaa",
  "Saldivar",
  "Salgado",
  "Salinas",
  "Samaniego",
  "Sanabria",
  "Sanches",
  "Snchez",
  "Sandoval",
  "Santacruz",
  "Santana",
  "Santiago",
  "Santilln",
  "Sarabia",
  "Sauceda",
  "Saucedo",
  "Sedillo",
  "Segovia",
  "Segura",
  "Seplveda",
  "Serna",
  "Serrano",
  "Serrato",
  "Sevilla",
  "Sierra",
  "Sisneros",
  "Solano",
  "Sols",
  "Soliz",
  "Solorio",
  "Solorzano",
  "Soria",
  "Sosa",
  "Sotelo",
  "Soto",
  "Surez",
  "Tafoya",
  "Tamayo",
  "Tamez",
  "Tapia",
  "Tejada",
  "Tejeda",
  "Tllez",
  "Tello",
  "Tern",
  "Terrazas",
  "Tijerina",
  "Tirado",
  "Toledo",
  "Toro",
  "Torres",
  "Trrez",
  "Tovar",
  "Trejo",
  "Trevio",
  "Trujillo",
  "Ulibarri",
  "Ulloa",
  "Urbina",
  "Urea",
  "Uras",
  "Uribe",
  "Urrutia",
  "Vaca",
  "Valadez",
  "Valds",
  "Valdez",
  "Valdivia",
  "Valencia",
  "Valentn",
  "Valenzuela",
  "Valladares",
  "Valle",
  "Vallejo",
  "Valles",
  "Valverde",
  "Vanegas",
  "Varela",
  "Vargas",
  "Vsquez",
  "Vzquez",
  "Vega",
  "Vela",
  "Velasco",
  "Velsquez",
  "Velzquez",
  "Vlez",
  "Vliz",
  "Venegas",
  "Vera",
  "Verdugo",
  "Verduzco",
  "Vergara",
  "Viera",
  "Vigil",
  "Villa",
  "Villagmez",
  "Villalobos",
  "Villalpando",
  "Villanueva",
  "Villareal",
  "Villarreal",
  "Villaseor",
  "Villegas",
  "Yez",
  "Ybarra",
  "Zambrano",
  "Zamora",
  "Zamudio",
  "Zapata",
  "Zaragoza",
  "Zarate",
  "Zavala",
  "Zayas",
  "Zelaya",
  "Zepeda",
  "Ziga"
];

},{}],662:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{first_name} #{last_name} #{last_name}",
  "#{first_name} #{last_name} #{last_name}",
  "#{first_name} #{last_name} #{last_name}",
  "#{first_name} #{last_name} #{last_name}",
  "#{first_name} #{last_name} #{last_name}"
];

},{}],663:[function(require,module,exports){
module["exports"] = [
  "Sr.",
  "Sra.",
  "Sta."
];

},{}],664:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"dup":522}],665:[function(require,module,exports){
module["exports"] = {
  "descriptor": [
    "Jefe",
    "Senior",
    "Directo",
    "Corporativo",
    "Dinnmico",
    "Futuro",
    "Producto",
    "Nacional",
    "Regional",
    "Distrito",
    "Central",
    "Global",
    "Cliente",
    "Inversor",
    "International",
    "Heredado",
    "Adelante",
    "Interno",
    "Humano",
    "Gerente",
    "Director"
  ],
  "level": [
    "Soluciones",
    "Programa",
    "Marca",
    "Seguridada",
    "Investigacin",
    "Marketing",
    "Normas",
    "Implementacin",
    "Integracin",
    "Funcionalidad",
    "Respuesta",
    "Paradigma",
    "Tcticas",
    "Identidad",
    "Mercados",
    "Grupo",
    "Divisin",
    "Aplicaciones",
    "Optimizacin",
    "Operaciones",
    "Infraestructura",
    "Intranet",
    "Comunicaciones",
    "Web",
    "Calidad",
    "Seguro",
    "Mobilidad",
    "Cuentas",
    "Datos",
    "Creativo",
    "Configuracin",
    "Contabilidad",
    "Interacciones",
    "Factores",
    "Usabilidad",
    "Mtricas"
  ],
  "job": [
    "Supervisor",
    "Asociado",
    "Ejecutivo",
    "Relacciones",
    "Oficial",
    "Gerente",
    "Ingeniero",
    "Especialista",
    "Director",
    "Coordinador",
    "Administrador",
    "Arquitecto",
    "Analista",
    "Diseador",
    "Planificador",
    "Tcnico",
    "Funcionario",
    "Desarrollador",
    "Productor",
    "Consultor",
    "Asistente",
    "Facilitador",
    "Agente",
    "Representante",
    "Estratega"
  ]
};

},{}],666:[function(require,module,exports){
module["exports"] = [
  "9##-###-###",
  "9##.###.###",
  "9## ### ###",
  "9########"
];

},{}],667:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":666,"dup":312}],668:[function(require,module,exports){
module["exports"] = [
  " s/n.",
  ", #",
  ", ##",
  " #",
  " ##",
  " ###",
  " ####"
];

},{}],669:[function(require,module,exports){
arguments[4][610][0].apply(exports,arguments)
},{"dup":610}],670:[function(require,module,exports){
module["exports"] = [
  "Aguascalientes",
  "Apodaca",
  "Buenavista",
  "Campeche",
  "Cancn",
  "Crdenas",
  "Celaya",
  "Chalco",
  "Chetumal",
  "Chicoloapan",
  "Chignahuapan",
  "Chihuahua",
  "Chilpancingo",
  "Chimalhuacn",
  "Ciudad Acua",
  "Ciudad de Mxico",
  "Ciudad del Carmen",
  "Ciudad Lpez Mateos",
  "Ciudad Madero",
  "Ciudad Obregn",
  "Ciudad Valles",
  "Ciudad Victoria",
  "Coatzacoalcos",
  "Colima-Villa de lvarez",
  "Comitn de Dominguez",
  "Crdoba",
  "Cuautitln Izcalli",
  "Cuautla",
  "Cuernavaca",
  "Culiacn",
  "Delicias",
  "Durango",
  "Ensenada",
  "Fresnillo",
  "General Escobedo",
  "Gmez Palacio",
  "Guadalajara",
  "Guadalupe",
  "Guanajuato",
  "Guaymas",
  "Hermosillo",
  "Hidalgo del Parral",
  "Iguala",
  "Irapuato",
  "Ixtapaluca",
  "Jiutepec",
  "Jurez",
  "La Laguna",
  "La Paz",
  "La Piedad-Pnjamo",
  "Len",
  "Los Cabos",
  "Los Mochis",
  "Manzanillo",
  "Matamoros",
  "Mazatln",
  "Mrida",
  "Mexicali",
  "Minatitln",
  "Miramar",
  "Monclova",
  "Monclova-Frontera",
  "Monterrey",
  "Morelia",
  "Naucalpan de Jurez",
  "Navojoa",
  "Nezahualcyotl",
  "Nogales",
  "Nuevo Laredo",
  "Oaxaca",
  "Ocotln",
  "Ojo de agua",
  "Orizaba",
  "Pachuca",
  "Piedras Negras",
  "Poza Rica",
  "Puebla",
  "Puerto Vallarta",
  "Quertaro",
  "Reynosa-Ro Bravo",
  "Rioverde-Ciudad Fernndez",
  "Salamanca",
  "Saltillo",
  "San Cristobal de las Casas",
  "San Francisco Coacalco",
  "San Francisco del Rincn",
  "San Juan Bautista Tuxtepec",
  "San Juan del Ro",
  "San Luis Potos-Soledad",
  "San Luis Ro Colorado",
  "San Nicols de los Garza",
  "San Pablo de las Salinas",
  "San Pedro Garza Garca",
  "Santa Catarina",
  "Soledad de Graciano Snchez",
  "Tampico-Pnuco",
  "Tapachula",
  "Tecomn",
  "Tehuacn",
  "Tehuacn",
  "Tehuantepec-Salina Cruz",
  "Tepexpan",
  "Tepic",
  "Tetela de Ocampo",
  "Texcoco de Mora",
  "Tijuana",
  "Tlalnepantla",
  "Tlaquepaque",
  "Tlaxcala-Apizaco",
  "Toluca",
  "Tonal",
  "Torren",
  "Tula",
  "Tulancingo",
  "Tulancingo de Bravo",
  "Tuxtla Gutirrez",
  "Uruapan",
  "Uruapan del Progreso",
  "Valle de Mxico",
  "Veracruz",
  "Villa de lvarez",
  "Villa Nicols Romero",
  "Villahermosa",
  "Xalapa",
  "Zacatecas-Guadalupe",
  "Zacatlan",
  "Zacatzingo",
  "Zamora-Jacona",
  "Zapopan",
  "Zitacuaro"
];

},{}],671:[function(require,module,exports){
arguments[4][441][0].apply(exports,arguments)
},{"dup":441}],672:[function(require,module,exports){
module["exports"] = [
  "Afganistn",
  "Albania",
  "Argelia",
  "Andorra",
  "Angola",
  "Argentina",
  "Armenia",
  "Aruba",
  "Australia",
  "Austria",
  "Azerbayn",
  "Bahamas",
  "Barein",
  "Bangladesh",
  "Barbados",
  "Bielorusia",
  "Blgica",
  "Belice",
  "Bermuda",
  "Butn",
  "Bolivia",
  "Bosnia Herzegovina",
  "Botswana",
  "Brasil",
  "Bulgaria",
  "Burkina Faso",
  "Burundi",
  "Camboya",
  "Camern",
  "Canada",
  "Cabo Verde",
  "Islas Caimn",
  "Chad",
  "Chile",
  "China",
  "Isla de Navidad",
  "Colombia",
  "Comodos",
  "Congo",
  "Costa Rica",
  "Costa de Marfil",
  "Croacia",
  "Cuba",
  "Chipre",
  "Repblica Checa",
  "Dinamarca",
  "Dominica",
  "Repblica Dominicana",
  "Ecuador",
  "Egipto",
  "El Salvador",
  "Guinea Ecuatorial",
  "Eritrea",
  "Estonia",
  "Etiopa",
  "Islas Faro",
  "Fiji",
  "Finlandia",
  "Francia",
  "Gabn",
  "Gambia",
  "Georgia",
  "Alemania",
  "Ghana",
  "Grecia",
  "Groenlandia",
  "Granada",
  "Guadalupe",
  "Guam",
  "Guatemala",
  "Guinea",
  "Guinea-Bisau",
  "Guayana",
  "Haiti",
  "Honduras",
  "Hong Kong",
  "Hungria",
  "Islandia",
  "India",
  "Indonesia",
  "Iran",
  "Irak",
  "Irlanda",
  "Italia",
  "Jamaica",
  "Japn",
  "Jordania",
  "Kazajistan",
  "Kenia",
  "Kiribati",
  "Corea",
  "Kuwait",
  "Letonia",
  "Lbano",
  "Liberia",
  "Liechtenstein",
  "Lituania",
  "Luxemburgo",
  "Macao",
  "Macedonia",
  "Madagascar",
  "Malawi",
  "Malasia",
  "Maldivas",
  "Mali",
  "Malta",
  "Martinica",
  "Mauritania",
  "Mxico",
  "Micronesia",
  "Moldavia",
  "Mnaco",
  "Mongolia",
  "Montenegro",
  "Montserrat",
  "Marruecos",
  "Mozambique",
  "Namibia",
  "Nauru",
  "Nepal",
  "Holanda",
  "Nueva Zelanda",
  "Nicaragua",
  "Niger",
  "Nigeria",
  "Noruega",
  "Omn",
  "Pakistan",
  "Panam",
  "Papa Nueva Guinea",
  "Paraguay",
  "Per",
  "Filipinas",
  "Poland",
  "Portugal",
  "Puerto Rico",
  "Rusia",
  "Ruanda",
  "Samoa",
  "San Marino",
  "Santo Tom y Principe",
  "Arabia Saud",
  "Senegal",
  "Serbia",
  "Seychelles",
  "Sierra Leona",
  "Singapur",
  "Eslovaquia",
  "Eslovenia",
  "Somalia",
  "Espaa",
  "Sri Lanka",
  "Sudn",
  "Suriname",
  "Suecia",
  "Suiza",
  "Siria",
  "Taiwan",
  "Tajikistan",
  "Tanzania",
  "Tailandia",
  "Timor-Leste",
  "Togo",
  "Tonga",
  "Trinidad y Tobago",
  "Tunez",
  "Turquia",
  "Uganda",
  "Ucrania",
  "Emiratos rabes Unidos",
  "Reino Unido",
  "Estados Unidos de Amrica",
  "Uruguay",
  "Uzbekistan",
  "Vanuatu",
  "Venezuela",
  "Vietnam",
  "Yemen",
  "Zambia",
  "Zimbabwe"
];

},{}],673:[function(require,module,exports){
module["exports"] = [
  "Mxico"
];

},{}],674:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.country = require("./country");
address.building_number = require("./building_number");
address.street_suffix = require("./street_suffix");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.time_zone = require("./time_zone");
address.city = require("./city");
address.street = require("./street");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");
},{"./building_number":668,"./city":669,"./city_prefix":670,"./city_suffix":671,"./country":672,"./default_country":673,"./postcode":675,"./secondary_address":676,"./state":677,"./state_abbr":678,"./street":679,"./street_address":680,"./street_name":681,"./street_suffix":682,"./time_zone":683}],675:[function(require,module,exports){
arguments[4][638][0].apply(exports,arguments)
},{"dup":638}],676:[function(require,module,exports){
module["exports"] = [
  "Esc. ###",
  "Puerta ###",
  "Edificio #"
];

},{}],677:[function(require,module,exports){
module["exports"] = [
  "Aguascalientes",
  "Baja California Norte",
  "Baja California Sur",
  'Estado de Mxico',
  "Campeche",
  "Chiapas",
  "Chihuahua",
  "Coahuila",
  "Colima",
  "Durango",
  "Guanajuato",
  "Guerrero",
  "Hidalgo",
  "Jalisco",
  "Michoacan",
  "Morelos",
  "Nayarit",
  'Nuevo Len',
  "Oaxaca",
  "Puebla",
  "Quertaro",
  "Quintana Roo",
  "San Luis Potos",
  "Sinaloa",
  "Sonora",
  "Tabasco",
  "Tamaulipas",
  "Tlaxcala",
  "Veracruz",
  "Yucatn",
  "Zacatecas"
];

},{}],678:[function(require,module,exports){
module["exports"] = [
  "AS",
  "BC",
  "BS",
  "CC",
  "CS",
  "CH",
  "CL",
  "CM",
  "DF",
  "DG",
  "GT",
  "GR",
  "HG",
  "JC",
  "MC",
  "MN",
  "MS",
  "NT",
  "NL",
  "OC",
  "PL",
  "QT",
  "QR",
  "SP",
  "SL",
  "SR",
  "TC",
  "TS",
  "TL",
  "VZ",
  "YN",
  "ZS"
];

},{}],679:[function(require,module,exports){
module["exports"] = [
	"20 de Noviembre",
	"Cinco de Mayo",
	"Cuahutemoc",
	"Manzanares",
	"Donceles",
	"Francisco I. Madero",
	"Jurez",
	"Repplica de Cuba",
	"Repplica de Chile",
	"Repplica de Argentina",
	"Repplica de Uruguay",
	"Isabel la Catlica",
	"Izazaga",
	"Eje Central",
	"Eje 6",
	"Eje 5",
	"La viga",
	"Aniceto Ortega",
	"Miguel ngel de Quevedo",
	"Amores",
	"Coyoacn",
	"Corua",
	"Batalla de Naco",
	"La otra banda",
	"Piedra del Comal",
	"Balcn de los edecanes",
	"Barrio la Lonja",
	"Jicolapa",
	"Zacatln",
	"Zapata",
	"Polotitlan",
	"Calimaya",
	"Flor Marina",
	"Flor Solvestre",
	"San Miguel",
	"Naranjo",
	"Cedro",
	"Jalisco",
	"Avena"
];
},{}],680:[function(require,module,exports){
arguments[4][643][0].apply(exports,arguments)
},{"dup":643}],681:[function(require,module,exports){
module["exports"] = [
  "#{street_suffix} #{Name.first_name}",
  "#{street_suffix} #{Name.first_name} #{Name.last_name}",
  "#{street_suffix} #{street}",
  "#{street_suffix} #{street}",
  "#{street_suffix} #{street}",
  "#{street_suffix} #{street}"

];

},{}],682:[function(require,module,exports){
arguments[4][645][0].apply(exports,arguments)
},{"dup":645}],683:[function(require,module,exports){
module["exports"] = [
  "Pacfico/Midway",
  "Pacfico/Pago_Pago",
  "Pacfico/Honolulu",
  "America/Juneau",
  "America/Los_Angeles",
  "America/Tijuana",
  "America/Denver",
  "America/Phoenix",
  "America/Chihuahua",
  "America/Mazatlan",
  "America/Chicago",
  "America/Regina",
  "America/Mexico_City",
  "America/Monterrey",
  "America/Guatemala",
  "America/New_York",
  "America/Indiana/Indianapolis",
  "America/Bogota",
  "America/Lima",
  "America/Lima",
  "America/Halifax",
  "America/Caracas",
  "America/La_Paz",
  "America/Santiago",
  "America/St_Johns",
  "America/Sao_Paulo",
  "America/Argentina/Buenos_Aires",
  "America/Guyana",
  "America/Godthab",
  "Atlantic/South_Georgia",
  "Atlantic/Azores",
  "Atlantic/Cape_Verde",
  "Europa/Dublin",
  "Europa/London",
  "Europa/Lisbon",
  "Europa/London",
  "Africa/Casablanca",
  "Africa/Monrovia",
  "Etc/UTC",
  "Europa/Belgrade",
  "Europa/Bratislava",
  "Europa/Budapest",
  "Europa/Ljubljana",
  "Europa/Prague",
  "Europa/Sarajevo",
  "Europa/Skopje",
  "Europa/Warsaw",
  "Europa/Zagreb",
  "Europa/Brussels",
  "Europa/Copenhagen",
  "Europa/Madrid",
  "Europa/Paris",
  "Europa/Amsterdam",
  "Europa/Berlin",
  "Europa/Berlin",
  "Europa/Rome",
  "Europa/Stockholm",
  "Europa/Vienna",
  "Africa/Algiers",
  "Europa/Bucharest",
  "Africa/Cairo",
  "Europa/Helsinki",
  "Europa/Kiev",
  "Europa/Riga",
  "Europa/Sofia",
  "Europa/Tallinn",
  "Europa/Vilnius",
  "Europa/Athens",
  "Europa/Istanbul",
  "Europa/Minsk",
  "Asia/Jerusalen",
  "Africa/Harare",
  "Africa/Johannesburg",
  "Europa/Mosc",
  "Europa/Mosc",
  "Europa/Mosc",
  "Asia/Kuwait",
  "Asia/Riyadh",
  "Africa/Nairobi",
  "Asia/Baghdad",
  "Asia/Tehran",
  "Asia/Muscat",
  "Asia/Muscat",
  "Asia/Baku",
  "Asia/Tbilisi",
  "Asia/Yerevan",
  "Asia/Kabul",
  "Asia/Yekaterinburg",
  "Asia/Karachi",
  "Asia/Karachi",
  "Asia/Tashkent",
  "Asia/Kolkata",
  "Asia/Kolkata",
  "Asia/Kolkata",
  "Asia/Kolkata",
  "Asia/Kathmandu",
  "Asia/Dhaka",
  "Asia/Dhaka",
  "Asia/Colombo",
  "Asia/Almaty",
  "Asia/Novosibirsk",
  "Asia/Rangoon",
  "Asia/Bangkok",
  "Asia/Bangkok",
  "Asia/Jakarta",
  "Asia/Krasnoyarsk",
  "Asia/Shanghai",
  "Asia/Chongqing",
  "Asia/Hong_Kong",
  "Asia/Urumqi",
  "Asia/Kuala_Lumpur",
  "Asia/Singapore",
  "Asia/Taipei",
  "Australia/Perth",
  "Asia/Irkutsk",
  "Asia/Ulaanbaatar",
  "Asia/Seoul",
  "Asia/Tokyo",
  "Asia/Tokyo",
  "Asia/Tokyo",
  "Asia/Yakutsk",
  "Australia/Darwin",
  "Australia/Adelaide",
  "Australia/Melbourne",
  "Australia/Melbourne",
  "Australia/Sydney",
  "Australia/Brisbane",
  "Australia/Hobart",
  "Asia/Vladivostok",
  "Pacfico/Guam",
  "Pacfico/Port_Moresby",
  "Asia/Magadan",
  "Asia/Magadan",
  "Pacfico/Noumea",
  "Pacfico/Fiji",
  "Asia/Kamchatka",
  "Pacfico/Majuro",
  "Pacfico/Auckland",
  "Pacfico/Auckland",
  "Pacfico/Tongatapu",
  "Pacfico/Fakaofo",
  "Pacfico/Apia"
];

},{}],684:[function(require,module,exports){
module["exports"] = [
  "5##-###-###",
  "5##.###.###",
  "5## ### ###",
  "5########"
];

},{}],685:[function(require,module,exports){
arguments[4][371][0].apply(exports,arguments)
},{"./formats":684,"dup":371}],686:[function(require,module,exports){
module["exports"] = [
   "rojo",
   "verde",
   "azul",
   "amarillo",
   "morado",
   "Menta verde",
   "teal",
   "blanco",
   "negro",
   "Naranja",
   "Rosa",
   "gris",
   "marrn",
   "violeta",
   "turquesa",
   "tan",
   "cielo azul",
   "salmn",
   "ciruela",
   "orqudea",
   "aceituna",
   "magenta",
   "Lima",
   "marfil",
   "ndigo",
   "oro",
   "fucsia",
   "cian",
   "azul",
   "lavanda",
   "plata"
];

},{}],687:[function(require,module,exports){
module["exports"] = [
   "Libros",
   "Pelculas",
   "Msica",
   "Juegos",
   "Electrnica",
   "Ordenadores",
   "Hogar",
   "Jardn",
   "Herramientas",
   "Ultramarinos",
   "Salud",
   "Belleza",
   "Juguetes",
   "Kids",
   "Baby",
   "Ropa",
   "Zapatos",
   "Joyera",
   "Deportes",
   "Aire libre",
   "Automocin",
   "Industrial"
];

},{}],688:[function(require,module,exports){
arguments[4][290][0].apply(exports,arguments)
},{"./color":686,"./department":687,"./product_name":689,"dup":290}],689:[function(require,module,exports){
module["exports"] = {
"adjective": [
     "Pequeo",
     "Ergonmico",
     "Rstico",
     "Inteligente",
     "Gorgeous",
     "Increble",
     "Fantstico",
     "Prctica",
     "Elegante",
     "Increble",
     "Genrica",
     "Artesanal",
     "Hecho a mano",
     "Licencia",
     "Refinado",
     "Sin marca",
     "Sabrosa"
   ],
"material": [
     "Acero",
     "Madera",
     "Hormign",
     "Plstico",
     "Cotton",
     "Granito",
     "Caucho",
     "Metal",
     "Soft",
     "Fresco",
     "Frozen"
   ],
"product": [
     "Presidente",
     "Auto",
     "Computadora",
     "Teclado",
     "Ratn",
     "Bike",
     "Pelota",
     "Guantes",
     "Pantalones",
     "Camisa",
     "Mesa",
     "Zapatos",
     "Sombrero",
     "Toallas",
     "Jabn",
     "Tuna",
     "Pollo",
     "Pescado",
     "Queso",
     "Tocino",
     "Pizza",
     "Ensalada",
     "Embutidos"
  ]
};

},{}],690:[function(require,module,exports){
arguments[4][649][0].apply(exports,arguments)
},{"dup":649}],691:[function(require,module,exports){
module["exports"] = [
  "Clics y mortero",
  "Valor aadido",
  "Vertical",
  "Proactivo",
  "Robusto",
  "Revolucionario",
  "Escalable",
  "De vanguardia",
  "Innovador",
  "Intuitivo",
  "Estratgico",
  "E-business",
  "Misin crtica",
  "Pegajosa",
  "Doce y cincuenta y nueve de la noche",
  "24/7",
  "De extremo a extremo",
  "Global",
  "B2B",
  "B2C",
  "Granular",
  "Friccin",
  "Virtual",
  "Viral",
  "Dinmico",
  "24/365",
  "Mejor de su clase",
  "Asesino",
  "Magntica",
  "Filo sangriento",
  "Habilitado web",
  "Interactiva",
  "Punto com",
  "Sexy",
  "Back-end",
  "Tiempo real",
  "Eficiente",
  "Frontal",
  "Distribuida",
  "Sin costura",
  "Extensible",
  "Llave en mano",
  "Clase mundial",
  "Cdigo abierto",
  "Multiplataforma",
  "Cross-media",
  "Sinrgico",
  "ladrillos y clics",
  "Fuera de la caja",
  "Empresa",
  "Integrado",
  "Impactante",
  "Inalmbrico",
  "Transparente",
  "Prxima generacin",
  "Innovador",
  "User-centric",
  "Visionario",
  "A medida",
  "Ubicua",
  "Enchufa y juega",
  "Colaboracin",
  "Convincente",
  "Holstico",
  "Ricos"
];

},{}],692:[function(require,module,exports){
module["exports"] = [
   "sinergias",
   "web-readiness",
   "paradigmas",
   "mercados",
   "asociaciones",
   "infraestructuras",
   "plataformas",
   "iniciativas",
   "canales",
   "ojos",
   "comunidades",
   "ROI",
   "soluciones",
   "minoristas electrnicos",
   "e-servicios",
   "elementos de accin",
   "portales",
   "nichos",
   "tecnologas",
   "contenido",
   "vortales",
   "cadenas de suministro",
   "convergencia",
   "relaciones",
   "arquitecturas",
   "interfaces",
   "mercados electrnicos",
   "e-commerce",
   "sistemas",
   "ancho de banda",
   "infomediarios",
   "modelos",
   "Mindshare",
   "entregables",
   "usuarios",
   "esquemas",
   "redes",
   "aplicaciones",
   "mtricas",
   "e-business",
   "funcionalidades",
   "experiencias",
   "servicios web",
   "metodologas"
];

},{}],693:[function(require,module,exports){
module["exports"] = [
   "poner en prctica",
   "utilizar",
   "integrar",
   "racionalizar",
   "optimizar",
   "evolucionar",
   "transformar",
   "abrazar",
   "habilitar",
   "orquestar",
   "apalancamiento",
   "reinventar",
   "agregado",
   "arquitecto",
   "mejorar",
   "incentivar",
   "transformarse",
   "empoderar",
   "Envisioneer",
   "monetizar",
   "arns",
   "facilitar",
   "aprovechar",
   "desintermediar",
   "sinergia",
   "estrategias",
   "desplegar",
   "marca",
   "crecer",
   "objetivo",
   "sindicato",
   "sintetizar",
   "entregue",
   "malla",
   "incubar",
   "enganchar",
   "maximizar",
   "punto de referencia",
   "acelerar",
   "reintermediate",
   "pizarra",
   "visualizar",
   "reutilizar",
   "innovar",
   "escala",
   "desatar",
   "conducir",
   "extender",
   "ingeniero",
   "revolucionar",
   "generar",
   "explotar",
   "transicin",
   "e-enable",
   "repetir",
   "cultivar",
   "matriz",
   "productize",
   "redefinir",
   "recontextualizar"
]

},{}],694:[function(require,module,exports){
arguments[4][650][0].apply(exports,arguments)
},{"dup":650}],695:[function(require,module,exports){
var company = {};
module['exports'] = company;
company.suffix = require("./suffix");
company.adjective = require("./adjective");
company.descriptor = require("./descriptor");
company.noun = require("./noun");
company.bs_verb = require("./bs_verb");
company.name = require("./name");
company.bs_adjective = require("./bs_adjective");
company.bs_noun = require("./bs_noun");

},{"./adjective":690,"./bs_adjective":691,"./bs_noun":692,"./bs_verb":693,"./descriptor":694,"./name":696,"./noun":697,"./suffix":698}],696:[function(require,module,exports){
arguments[4][652][0].apply(exports,arguments)
},{"dup":652}],697:[function(require,module,exports){
arguments[4][653][0].apply(exports,arguments)
},{"dup":653}],698:[function(require,module,exports){
arguments[4][654][0].apply(exports,arguments)
},{"dup":654}],699:[function(require,module,exports){
var es_MX = {};
module['exports'] = es_MX;
es_MX.title = "Spanish Mexico";
es_MX.separator = " & ";
es_MX.name = require("./name");
es_MX.address = require("./address");
es_MX.company = require("./company");
es_MX.internet = require("./internet");
es_MX.phone_number = require("./phone_number");
es_MX.cell_phone = require("./cell_phone");
es_MX.lorem = require("./lorem");
es_MX.commerce = require("./commerce");
es_MX.team = require("./team");
},{"./address":674,"./cell_phone":685,"./commerce":688,"./company":695,"./internet":702,"./lorem":703,"./name":707,"./phone_number":714,"./team":716}],700:[function(require,module,exports){
module["exports"] = [
  "com",
  "mx",
  "info",
  "com.mx",
  "org",
  "gob.mx"
];

},{}],701:[function(require,module,exports){
module["exports"] = [
  "gmail.com",
  "yahoo.com",
  "hotmail.com",
  "nearbpo.com",
  "corpfolder.com"
];

},{}],702:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":700,"./free_email":701,"dup":302}],703:[function(require,module,exports){
arguments[4][342][0].apply(exports,arguments)
},{"./supplemental":704,"./words":705,"dup":342}],704:[function(require,module,exports){
arguments[4][343][0].apply(exports,arguments)
},{"dup":343}],705:[function(require,module,exports){
module["exports"] = [
"Abacalero",
"Abacera",
"Abacero",
"Abacial",
"Abaco",
"Abacora",
"Abacorar",
"Abad",
"Abada",
"Abadejo",
"Abadengo",
"Abadernar",
"Abadesa",
"Abad",
"Abada",
"Abadiado",
"Abadiato",
"Abajadero",
"Abajamiento",
"Abajar",
"Abajeo",
"Abajera",
"Abajo",
"Abalada",
"Abalanzar",
"Abalar",
"Abalaustrado",
"Abaldonadamente",
"Abaldonamiento",
"Bastonada",
"Bastonazo",
"Bastoncillo",
"Bastonear",
"Bastonero",
"Bstulo",
"Basura",
"Basural",
"Basurear",
"Basurero",
"Bata",
"Batacazo",
"Batahola",
"Bataln",
"Batalla",
"Batallador",
"Batallar",
"Batallaroso",
"Batallola",
"Batalln",
"Batallona",
"Batalloso",
"Batn",
"Batanar",
"Batanear",
"Batanero",
"Batanga",
"Bataola",
"Batata",
"Batatazo",
"Batato",
"Batavia",
"Btavo",
"Batayola",
"Batazo",
"Bate",
"Batea",
"Bateador",
"Bateaguas",
"Cenagar",
"Cenagoso",
"Cenal",
"Cenaoscuras",
"Cear",
"Cenata",
"Cenca",
"Cencapa",
"Cencellada",
"Cenceada",
"Cenceo",
"Cencero",
"Cencerra",
"Cencerrada",
"Cencerrado",
"Cencerrear",
"Cencerreo",
"Cencerril",
"Cencerrillas",
"Cencerro",
"Cencerrn",
"Cencha",
"Cencido",
"Cenco",
"Cencivera",
"Cenco",
"Cencuate",
"Cendal",
"Cendal",
"Cndea",
"Cendolilla",
"Cendra",
"Cendrada",
"Cendradilla",
"Cendrado",
"Cendrar",
"Cendrazo",
"Cenefa",
"Cenegar",
"Ceneque",
"Cenero",
"Cenestesia",
"Desceir",
"Descensin",
"Descenso",
"Descentrado",
"Descentralizacin",
"Descentralizador",
"Descentralizar",
"Descentrar",
"Descepar",
"Descerar",
"Descercado",
"Descercador",
"Descercar",
"Descerco",
"Descerebracin",
"Descerebrado",
"Descerebrar",
"Descerezar",
"Descerrajado",
"Descerrajadura",
"Descerrajar",
"Descerrar",
"Descerrumarse",
"Descervigamiento",
"Descervigar",
"Deschapar",
"Descharchar",
"Deschavetado",
"Deschavetarse",
"Deschuponar",
"Descifrable",
"Descifrador",
"Desciframiento",
"Descifrar",
"Descifre",
"Descimbramiento",
"Descimbrar",
"Engarbarse",
"Engarberar",
"Engarbullar",
"Engarce",
"Engarfiar",
"Engargantadura",
"Engargantar",
"Engargante",
"Engargolado",
"Engargolar",
"Engaritar",
"Engarmarse",
"Engarnio",
"Engarrafador",
"Engarrafar",
"Engarrar",
"Engarro",
"Engarronar",
"Engarrotar",
"Engarzador",
"Engarzadura",
"Engarzar",
"Engasgarse",
"Engastador",
"Engastadura",
"Engastar",
"Engaste",
"Ficcin",
"Fice",
"Ficha",
"Fichaje",
"Fichar",
"Fichero",
"Ficoideo",
"Ficticio",
"Fidalgo",
"Fidecomiso",
"Fidedigno",
"Fideero",
"Fideicomisario",
"Fideicomiso",
"Fideicomitente",
"Fidesmo",
"Fidelidad",
"Fidelsimo",
"Fideo",
"Fido",
"Fiducia",
"Geminacin",
"Geminado",
"Geminar",
"Gminis",
"Gmino",
"Gemparo",
"Gemiquear",
"Gemiqueo",
"Gemir",
"Gemologa",
"Gemolgico",
"Gemlogo",
"Gemonias",
"Gemoso",
"Gemoterapia",
"Gen",
"Genciana",
"Gencianceo",
"Gencianeo",
"Gendarme",
"Gendarmera",
"Genealoga",
"Genealgico",
"Genealogista",
"Genearca",
"Genetico",
"Generable",
"Generacin",
"Generacional",
"Generador",
"General",
"Generala",
"Generalato",
"Generalidad",
"Generalsimo",
"Incordio",
"Incorporacin",
"Incorporal",
"Incorporalmente",
"Incorporar",
"Incorporeidad",
"Incorpreo",
"Incorporo",
"Incorreccin",
"Incorrectamente",
"Incorrecto",
"Incorregibilidad",
"Incorregible",
"Incorregiblemente",
"Incorrupcin",
"Incorruptamente",
"Incorruptibilidad",
"Incorruptible",
"Incorrupto",
"Incrasar",
"Increado",
"Incredibilidad",
"Incrdulamente",
"Incredulidad",
"Incrdulo",
"Increble",
"Increblemente",
"Incrementar",
"Incremento",
"Increpacin",
"Increpador",
"Increpar",
"Incriminacin",
"Incriminar",
"Incristalizable",
"Incruentamente",
"Incruento",
"Incrustacin"
];

},{}],706:[function(require,module,exports){
module["exports"] = [
"Aarn",
"Abraham",
"Adn",
"Agustn",
"Alan",
"Alberto",
"Alejandro",
"Alexander",
"Alexis",
"Alfonso",
"Alfredo",
"Andrs",
"ngel Daniel",
"ngel Gabriel",
"Antonio",
"Armando",
"Arturo",
"Axel",
"Benito",
"Benjamn",
"Bernardo",
"Brandon",
"Brayan",
"Carlos",
"Csar",
"Claudio",
"Clemente",
"Cristian",
"Cristobal",
"Damin",
"Daniel",
"David",
"Diego",
"Eduardo",
"Elas",
"Emiliano",
"Emilio",
"Emilio",
"Emmanuel",
"Enrique",
"Erick",
"Ernesto",
"Esteban",
"Federico",
"Felipe",
"Fernando",
"Fernando Javier",
"Francisco",
"Francisco Javier",
"Gabriel",
"Gael",
"Gerardo",
"Germn",
"Gilberto",
"Gonzalo",
"Gregorio",
"Guillermo",
"Gustavo",
"Hernn",
"Homero",
"Horacio",
"Hugo",
"Ignacio",
"Iker",
"Isaac",
"Isaias",
"Israel",
"Ivan",
"Jacobo",
"Jaime",
"Javier",
"Jernimo",
"Jess",
"Joaqun",
"Jorge",
"Jorge Luis",
"Jos",
"Jos Antonio",
"Jose Daniel",
"Jos Eduardo",
"Jos Emilio",
"Jos Luis",
"Jos Mara",
"Jos Miguel",
"Juan",
"Juan Carlos",
"Juan Manuel",
"Juan Pablo",
"Julio",
"Julio Csar",
"Kevin",
"Leonardo",
"Lorenzo",
"Lucas",
"Luis",
"Luis ngel",
"Luis Fernando",
"Luis Gabino",
"Luis Miguel",
"Manuel",
"Marco Antonio",
"Marcos",
"Mariano",
"Mario",
"Martn",
"Mateo",
"Matas",
"Mauricio",
"Maximiliano",
"Miguel",
"Miguel ngel",
"Nicols",
"Octavio",
"scar",
"Pablo",
"Patricio",
"Pedro",
"Rafael",
"Ramiro",
"Ramn",
"Ral",
"Ricardo",
"Roberto",
"Rodrigo",
"Rubn",
"Salvador",
"Samuel",
"Sancho",
"Santiago",
"Sal",
"Sebastian",
"Sergio",
"Tadeo",
"Teodoro",
"Timoteo",
"Toms",
"Uriel",
"Vicente",
"Vctor",
"Victor Manuel",
"Adriana",
"Alejandra",
"Alicia",
"Amalia",
"Ana",
"Ana Luisa",
"Ana Mara",
"Andrea",
"ngela",
"Anita",
"Antonia",
"Araceli",
"Ariadna",
"Barbara",
"Beatriz",
"Berta",
"Blanca",
"Caridad",
"Carla",
"Carlota",
"Carmen",
"Carolina",
"Catalina",
"Cecilia",
"Clara",
"Claudia",
"Concepcin",
"Conchita",
"Cristina",
"Daniela",
"Dbora",
"Diana",
"Dolores",
"Dorotea",
"Elena",
"Elisa",
"Elizabeth",
"Eloisa",
"Elsa",
"Elvira",
"Emilia",
"Esperanza",
"Estela",
"Ester",
"Eva",
"Florencia",
"Francisca",
"Gabriela",
"Gloria",
"Graciela",
"Guadalupe",
"Guillermina",
"Ins",
"Irene",
"Isabel",
"Isabela",
"Josefina",
"Juana",
"Julia",
"Laura",
"Leonor",
"Leticia",
"Lilia",
"Lola",
"Lorena",
"Lourdes",
"Lucia",
"Luisa",
"Luz",
"Magdalena",
"Manuela",
"Marcela",
"Margarita",
"Mara",
"Mara Cristina",
"Mara de Jess",
"Mara de los ngeles",
"Mara del Carmen",
"Mara Elena",
"Mara Eugenia",
"Mara Guadalupe",
"Mara Jos",
"Mara Luisa",
"Mara Soledad",
"Mara Teresa",
"Mariana",
"Maricarmen",
"Marilu",
"Marisol",
"Marta",
"Mayte",
"Mercedes",
"Micaela",
"Mnica",
"Natalia",
"Norma",
"Olivia",
"Patricia",
"Pilar",
"Ramona",
"Raquel",
"Rebeca",
"Reina",
"Rocio",
"Rosa",
"Rosa Mara",
"Rosalia",
"Rosario",
"Sara",
"Silvia",
"Sofia",
"Soledad",
"Sonia",
"Susana",
"Teresa",
"Vernica",
"Victoria",
"Virginia",
"Xochitl",
"Yolanda",
"Abigail",
"Abril",
"Adela",
"Alexa",
"Alondra Romina",
"Ana Sofa",
"Ana Victoria",
"Camila",
"Carolina",
"Daniela",
"Dulce Mara",
"Emily",
"Esmeralda",
"Estefana",
"Evelyn",
"Fatima",
"Ivanna",
"Jazmin",
"Jennifer",
"Jimena",
"Julieta",
"Kimberly",
"Liliana",
"Lizbeth",
"Mara Fernanda",
"Melany",
"Melissa",
"Miranda",
"Monserrat",
"Naomi",
"Natalia",
"Nicole",
"Paola",
"Paulina",
"Regina",
"Renata",
"Valentina",
"Valeria",
"Vanessa",
"Ximena",
"Ximena Guadalupe",
"Yamileth",
"Yaretzi",
"Zoe"
]
},{}],707:[function(require,module,exports){
arguments[4][518][0].apply(exports,arguments)
},{"./first_name":706,"./last_name":708,"./name":709,"./prefix":710,"./suffix":711,"./title":712,"dup":518}],708:[function(require,module,exports){
module["exports"] = [
  "Abeyta",
"Abrego",
"Abreu",
"Acevedo",
"Acosta",
"Acua",
"Adame",
"Adorno",
"Agosto",
"Aguayo",
"guilar",
"Aguilera",
"Aguirre",
"Alanis",
"Alaniz",
"Alarcn",
"Alba",
"Alcala",
"Alcntar",
"Alcaraz",
"Alejandro",
"Alemn",
"Alfaro",
"Alicea",
"Almanza",
"Almaraz",
"Almonte",
"Alonso",
"Alonzo",
"Altamirano",
"Alva",
"Alvarado",
"Alvarez",
"Amador",
"Amaya",
"Anaya",
"Anguiano",
"Angulo",
"Aparicio",
"Apodaca",
"Aponte",
"Aragn",
"Aranda",
"Araa",
"Arce",
"Archuleta",
"Arellano",
"Arenas",
"Arevalo",
"Arguello",
"Arias",
"Armas",
"Armendriz",
"Armenta",
"Armijo",
"Arredondo",
"Arreola",
"Arriaga",
"Arroyo",
"Arteaga",
"Atencio",
"valos",
"vila",
"Avils",
"Ayala",
"Baca",
"Badillo",
"Bez",
"Baeza",
"Bahena",
"Balderas",
"Ballesteros",
"Banda",
"Bauelos",
"Barajas",
"Barela",
"Barragn",
"Barraza",
"Barrera",
"Barreto",
"Barrientos",
"Barrios",
"Batista",
"Becerra",
"Beltrn",
"Benavides",
"Benavdez",
"Bentez",
"Bermdez",
"Bernal",
"Berros",
"Btancourt",
"Blanco",
"Bonilla",
"Borrego",
"Botello",
"Bravo",
"Briones",
"Briseo",
"Brito",
"Bueno",
"Burgos",
"Bustamante",
"Bustos",
"Caballero",
"Cabn",
"Cabrera",
"Cadena",
"Caldera",
"Caldern",
"Calvillo",
"Camacho",
"Camarillo",
"Campos",
"Canales",
"Candelaria",
"Cano",
"Cant",
"Caraballo",
"Carbajal",
"Cardenas",
"Cardona",
"Carmona",
"Carranza",
"Carrasco",
"Carrasquillo",
"Carren",
"Carrera",
"Carrero",
"Carrillo",
"Carrion",
"Carvajal",
"Casanova",
"Casares",
"Casrez",
"Casas",
"Casillas",
"Castaeda",
"Castellanos",
"Castillo",
"Castro",
"Cavazos",
"Cazares",
"Ceballos",
"Cedillo",
"Ceja",
"Centeno",
"Cepeda",
"Cerda",
"Cervantes",
"Cervntez",
"Chacn",
"Chapa",
"Chavarra",
"Chvez",
"Cintrn",
"Cisneros",
"Collado",
"Collazo",
"Coln",
"Colunga",
"Concepcin",
"Contreras",
"Cordero",
"Crdova",
"Cornejo",
"Corona",
"Coronado",
"Corral",
"Corrales",
"Correa",
"Corts",
"Cortez",
"Cotto",
"Covarrubias",
"Crespo",
"Cruz",
"Cuellar",
"Curiel",
"Dvila",
"de Anda",
"de Jess",
"Delacrz",
"Delafuente",
"Delagarza",
"Delao",
"Delapaz",
"Delarosa",
"Delatorre",
"Delen",
"Delgadillo",
"Delgado",
"Delro",
"Delvalle",
"Daz",
"Domnguez",
"Domnquez",
"Duarte",
"Dueas",
"Duran",
"Echevarra",
"Elizondo",
"Enrquez",
"Escalante",
"Escamilla",
"Escobar",
"Escobedo",
"Esparza",
"Espinal",
"Espino",
"Espinosa",
"Espinoza",
"Esquibel",
"Esquivel",
"Estvez",
"Estrada",
"Fajardo",
"Faras",
"Feliciano",
"Fernndez",
"Ferrer",
"Fierro",
"Figueroa",
"Flores",
"Flrez",
"Fonseca",
"Franco",
"Fras",
"Fuentes",
"Gaitn",
"Galarza",
"Galindo",
"Gallardo",
"Gallegos",
"Galvn",
"Glvez",
"Gamboa",
"Gamez",
"Gaona",
"Garay",
"Garca",
"Garibay",
"Garica",
"Garrido",
"Garza",
"Gastlum",
"Gaytn",
"Gil",
"Girn",
"Godnez",
"Godoy",
"Gollum",
"Gmez",
"Gonzales",
"Gonzlez",
"Gracia",
"Granado",
"Granados",
"Griego",
"Grijalva",
"Guajardo",
"Guardado",
"Guerra",
"Guerrero",
"Guevara",
"Guillen",
"Gurule",
"Gutirrez",
"Guzmn",
"Haro",
"Henrquez",
"Heredia",
"Herndez",
"Hernandes",
"Hernndez",
"Herrera",
"Hidalgo",
"Hinojosa",
"Holgun",
"Huerta",
"Huixtlacatl",
"Hurtado",
"Ibarra",
"Iglesias",
"Irizarry",
"Jaime",
"Jaimes",
"Jquez",
"Jaramillo",
"Jasso",
"Jimnez",
"Jimnez",
"Jurez",
"Jurado",
"Kadar rodriguez",
"Kamal",
"Kamat",
"Kanaria",
"Kanea",
"Kanimal",
"Kano",
"Kanzaki",
"Kaplan",
"Kara",
"Karam",
"Karan",
"Kardache soto",
"Karem",
"Karen",
"Khalid",
"Kindelan",
"Koenig",
"Korta",
"Korta hernandez",
"Kortajarena",
"Kranz sans",
"Krasnova",
"Krauel natera",
"Kuzmina",
"Kyra",
"Laboy",
"Lara",
"Laureano",
"Leal",
"Lebrn",
"Ledesma",
"Leiva",
"Lemus",
"Len",
"Lerma",
"Leyva",
"Limn",
"Linares",
"Lira",
"Llamas",
"Loera",
"Lomeli",
"Longoria",
"Lpez",
"Lovato",
"Loya",
"Lozada",
"Lozano",
"Lucero",
"Lucio",
"Luevano",
"Lugo",
"Luna",
"Macas",
"Madera",
"Madrid",
"Madrigal",
"Maestas",
"Magaa",
"Malave",
"Maldonado",
"Manzanares",
"Mares",
"Marn",
"Mrquez",
"Marrero",
"Marroqun",
"Martnez",
"Mascareas",
"Mata",
"Mateo",
"Matas",
"Matos",
"Maya",
"Mayorga",
"Medina",
"Medrano",
"Meja",
"Melndez",
"Melgar",
"Mena",
"Menchaca",
"Mndez",
"Mendoza",
"Menndez",
"Meraz",
"Mercado",
"Merino",
"Mesa",
"Meza",
"Miramontes",
"Miranda",
"Mireles",
"Mojica",
"Molina",
"Mondragn",
"Monroy",
"Montalvo",
"Montaez",
"Montao",
"Montemayor",
"Montenegro",
"Montero",
"Montes",
"Montez",
"Montoya",
"Mora",
"Morales",
"Moreno",
"Mota",
"Moya",
"Mungua",
"Muiz",
"Muoz",
"Murillo",
"Muro",
"Njera",
"Naranjo",
"Narvez",
"Nava",
"Navarrete",
"Navarro",
"Nazario",
"Negrete",
"Negrn",
"Nevrez",
"Nieto",
"Nieves",
"Nio",
"Noriega",
"Nez",
"aez",
"Ocampo",
"Ocasio",
"Ochoa",
"Ojeda",
"Olivares",
"Olivrez",
"Olivas",
"Olivera",
"Olivo",
"Olmos",
"Olvera",
"Ontiveros",
"Oquendo",
"Ordez",
"Orellana",
"Ornelas",
"Orosco",
"Orozco",
"Orta",
"Ortega",
"Ortiz",
"Osorio",
"Otero",
"Ozuna",
"Pabn",
"Pacheco",
"Padilla",
"Padrn",
"Pez",
"Pagan",
"Palacios",
"Palomino",
"Palomo",
"Pantoja",
"Paredes",
"Parra",
"Partida",
"Patio",
"Paz",
"Pedraza",
"Pedroza",
"Pelayo",
"Pea",
"Perales",
"Peralta",
"Perea",
"Peres",
"Prez",
"Pichardo",
"Pineda",
"Pia",
"Pizarro",
"Polanco",
"Ponce",
"Porras",
"Portillo",
"Posada",
"Prado",
"Preciado",
"Prieto",
"Puente",
"Puga",
"Pulido",
"Quesada",
"Quevedo",
"Quezada",
"Quinta",
"Quintairos",
"Quintana",
"Quintanilla",
"Quintero",
"Quintero cruz",
"Quintero de la cruz",
"Quiones",
"Quinez",
"Quiros",
"Quiroz",
"Rael",
"Ramrez",
"Ramn",
"Ramos",
"Rangel",
"Rascn",
"Raya",
"Razo",
"Regalado",
"Rendn",
"Rentera",
"Resndez",
"Reyes",
"Reyna",
"Reynoso",
"Rico",
"Rincn",
"Riojas",
"Ros",
"Rivas",
"Rivera",
"Rivero",
"Robledo",
"Robles",
"Rocha",
"Rodarte",
"Rodrgez",
"Rodrguez",
"Rodrquez",
"Rojas",
"Rojo",
"Roldn",
"Roln",
"Romero",
"Romo",
"Roque",
"Rosado",
"Rosales",
"Rosario",
"Rosas",
"Roybal",
"Rubio",
"Ruelas",
"Ruiz",
"Saavedra",
"Senz",
"Saiz",
"Salas",
"Salazar",
"Salcedo",
"Salcido",
"Saldaa",
"Saldivar",
"Salgado",
"Salinas",
"Samaniego",
"Sanabria",
"Sanches",
"Snchez",
"Sandoval",
"Santacruz",
"Santana",
"Santiago",
"Santilln",
"Sarabia",
"Sauceda",
"Saucedo",
"Sedillo",
"Segovia",
"Segura",
"Seplveda",
"Serna",
"Serrano",
"Serrato",
"Sevilla",
"Sierra",
"Sisneros",
"Solano",
"Sols",
"Soliz",
"Solorio",
"Solorzano",
"Soria",
"Sosa",
"Sotelo",
"Soto",
"Surez",
"Tafoya",
"Tamayo",
"Tamez",
"Tapia",
"Tejada",
"Tejeda",
"Tllez",
"Tello",
"Tern",
"Terrazas",
"Tijerina",
"Tirado",
"Toledo",
"Toro",
"Torres",
"Trrez",
"Tovar",
"Trejo",
"Trevio",
"Trujillo",
"Ulibarri",
"Ulloa",
"Urbina",
"Urea",
"Uras",
"Uribe",
"Urrutia",
"Vaca",
"Valadez",
"Valds",
"Valdez",
"Valdivia",
"Valencia",
"Valentn",
"Valenzuela",
"Valladares",
"Valle",
"Vallejo",
"Valles",
"Valverde",
"Vanegas",
"Varela",
"Vargas",
"Vsquez",
"Vzquez",
"Vega",
"Vela",
"Velasco",
"Velsquez",
"Velzquez",
"Vlez",
"Vliz",
"Venegas",
"Vera",
"Verdugo",
"Verduzco",
"Vergara",
"Viera",
"Vigil",
"Villa",
"Villagmez",
"Villalobos",
"Villalpando",
"Villanueva",
"Villareal",
"Villarreal",
"Villaseor",
"Villegas",
"Xacon",
"Xairo Belmonte",
"Xana",
"Xenia",
"Xiana",
"Xicoy",
"Yago",
"Yami",
"Yanes",
"Yez",
"Ybarra",
"Yebra",
"Yunta",
"Zabaleta",
"Zamarreno",
"Zamarripa",
"Zambrana",
"Zambrano",
"Zamora",
"Zamudio",
"Zapata",
"Zaragoza",
"Zarate",
"Zavala",
"Zayas",
"Zelaya",
"Zepeda",
"Ziga"
];

},{}],709:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{first_name} #{last_name} #{last_name}",
  "#{first_name} #{last_name} de #{last_name}",
  "#{suffix} #{first_name} #{last_name} #{last_name}",
  "#{first_name} #{last_name} #{last_name}",
  "#{first_name} #{last_name} #{last_name}"
];

},{}],710:[function(require,module,exports){
arguments[4][663][0].apply(exports,arguments)
},{"dup":663}],711:[function(require,module,exports){
module["exports"] = [
  "Jr.",
  "Sr.",
  "I",
  "II",
  "III",
  "IV",
  "V",
  "MD",
  "DDS",
  "PhD",
  "DVM",
  "Ing.",
  "Lic.",
  "Dr.",
  "Mtro."
];

},{}],712:[function(require,module,exports){
 module["exports"] = {
  "descriptor": [
    "Jefe",
    "Senior",
    "Directo",
    "Corporativo",
    "Dinnmico",
    "Futuro",
    "Producto",
    "Nacional",
    "Regional",
    "Distrito",
    "Central",
    "Global",
    "Cliente",
    "Inversor",
    "International",
    "Heredado",
    "Adelante",
    "Interno",
    "Humano",
    "Gerente",
    "SubGerente",
    "Director"
  ],
  "level": [
    "Soluciones",
    "Programa",
    "Marca",
    "Seguridad",
    "Investigacin",
    "Marketing",
    "Normas",
    "Implementacin",
    "Integracin",
    "Funcionalidad",
    "Respuesta",
    "Paradigma",
    "Tcticas",
    "Identidad",
    "Mercados",
    "Grupo",
    "Divisin",
    "Aplicaciones",
    "Optimizacin",
    "Operaciones",
    "Infraestructura",
    "Intranet",
    "Comunicaciones",
    "Web",
    "Calidad",
    "Seguro",
    "Mobilidad",
    "Cuentas",
    "Datos",
    "Creativo",
    "Configuracin",
    "Contabilidad",
    "Interacciones",
    "Factores",
    "Usabilidad",
    "Mtricas",
  ],
  "job": [
    "Supervisor",
    "Asociado",
    "Ejecutivo",
    "Relacciones",
    "Oficial",
    "Gerente",
    "Ingeniero",
    "Especialista",
    "Director",
    "Coordinador",
    "Administrador",
    "Arquitecto",
    "Analista",
    "Diseador",
    "Planificador",
    "Tcnico",
    "Funcionario",
    "Desarrollador",
    "Productor",
    "Consultor",
    "Asistente",
    "Facilitador",
    "Agente",
    "Representante",
    "Estratega",
    "Scrum Master",
    "Scrum Owner",
    "Product Owner",
    "Scrum Developer"
  ]
};

},{}],713:[function(require,module,exports){
module["exports"] = [
  "5###-###-###",
  "5##.###.###",
  "5## ### ###",
  "5########"
];

},{}],714:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":713,"dup":312}],715:[function(require,module,exports){
module["exports"] = [
  "hormigas",
   "murcilagos",
   "osos",
   "abejas",
   "pjaros",
   "bfalo",
   "gatos",
   "pollos",
   "ganado",
   "perros",
   "delfines",
   "patos",
   "elefantes",
   "peces",
   "zorros",
   "ranas",
   "gansos",
   "cabras",
   "caballos",
   "canguros",
   "leones",
   "monos",
   "bhos",
   "bueyes",
   "pinginos",
   "pueblo",
   "cerdos",
   "conejos",
   "ovejas",
   "tigres",
   "ballenas",
   "lobos",
   "cebras",
   "almas en pena",
   "cuervos",
   "gatos negros",
   "quimeras",
   "fantasmas",
   "conspiradores",
   "dragones",
   "enanos",
   "duendes",
   "encantadores",
   "exorcistas",
   "hijos",
   "enemigos",
   "gigantes",
   "gnomos",
   "duendes",
   "gansos",
   "grifos",
   "licntropos",
   "nmesis",
   "ogros",
   "orculos",
   "profetas",
   "hechiceros",
   "araas",
   "espritus",
   "vampiros",
   "brujos",
   "zorras",
   "hombres lobo",
   "brujas",
   "adoradores",
   "zombies",
   "druidas"
];

},{}],716:[function(require,module,exports){
arguments[4][529][0].apply(exports,arguments)
},{"./creature":715,"./name":717,"dup":529}],717:[function(require,module,exports){
arguments[4][530][0].apply(exports,arguments)
},{"dup":530}],718:[function(require,module,exports){
var fa = {};
module['exports'] = fa;
fa.title = "Farsi";
fa.name = require("./name");

},{"./name":720}],719:[function(require,module,exports){
module["exports"] = [
  " ",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " (  )",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  " ",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  " ",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  " ",
  " ",
  "",
  " ",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  " ",
  "",
  "",
  " ",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  " ",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "(  )",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " (  )",
  "",
  "",
  "",
  "",
  ""
];

},{}],720:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.last_name = require("./last_name");
name.prefix = require("./prefix");

},{"./first_name":719,"./last_name":721,"./prefix":722}],721:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ( )",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],722:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  ""
];

},{}],723:[function(require,module,exports){
module["exports"] = [
  "####",
  "###",
  "##",
  "#"
];

},{}],724:[function(require,module,exports){
arguments[4][314][0].apply(exports,arguments)
},{"dup":314}],725:[function(require,module,exports){
module["exports"] = [
  "Paris",
  "Marseille",
  "Lyon",
  "Toulouse",
  "Nice",
  "Nantes",
  "Strasbourg",
  "Montpellier",
  "Bordeaux",
  "Lille13",
  "Rennes",
  "Reims",
  "Le Havre",
  "Saint-tienne",
  "Toulon",
  "Grenoble",
  "Dijon",
  "Angers",
  "Saint-Denis",
  "Villeurbanne",
  "Le Mans",
  "Aix-en-Provence",
  "Brest",
  "Nmes",
  "Limoges",
  "Clermont-Ferrand",
  "Tours",
  "Amiens",
  "Metz",
  "Perpignan",
  "Besanon",
  "Orlans",
  "Boulogne-Billancourt",
  "Mulhouse",
  "Rouen",
  "Caen",
  "Nancy",
  "Saint-Denis",
  "Saint-Paul",
  "Montreuil",
  "Argenteuil",
  "Roubaix",
  "Dunkerque14",
  "Tourcoing",
  "Nanterre",
  "Avignon",
  "Crteil",
  "Poitiers",
  "Fort-de-France",
  "Courbevoie",
  "Versailles",
  "Vitry-sur-Seine",
  "Colombes",
  "Pau",
  "Aulnay-sous-Bois",
  "Asnires-sur-Seine",
  "Rueil-Malmaison",
  "Saint-Pierre",
  "Antibes",
  "Saint-Maur-des-Fosss",
  "Champigny-sur-Marne",
  "La Rochelle",
  "Aubervilliers",
  "Calais",
  "Cannes",
  "Le Tampon",
  "Bziers",
  "Colmar",
  "Bourges",
  "Drancy",
  "Mrignac",
  "Saint-Nazaire",
  "Valence",
  "Ajaccio",
  "Issy-les-Moulineaux",
  "Villeneuve-d'Ascq",
  "Levallois-Perret",
  "Noisy-le-Grand",
  "Quimper",
  "La Seyne-sur-Mer",
  "Antony",
  "Troyes",
  "Neuilly-sur-Seine",
  "Sarcelles",
  "Les Abymes",
  "Vnissieux",
  "Clichy",
  "Lorient",
  "Pessac",
  "Ivry-sur-Seine",
  "Cergy",
  "Cayenne",
  "Niort",
  "Chambry",
  "Montauban",
  "Saint-Quentin",
  "Villejuif",
  "Hyres",
  "Beauvais",
  "Cholet"
];

},{}],726:[function(require,module,exports){
module["exports"] = [
  "France"
];

},{}],727:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.building_number = require("./building_number");
address.street_prefix = require("./street_prefix");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.state = require("./state");
address.city_name = require("./city_name");
address.city = require("./city");
address.street_suffix = require("./street_suffix");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":723,"./city":724,"./city_name":725,"./default_country":726,"./postcode":728,"./secondary_address":729,"./state":730,"./street_address":731,"./street_name":732,"./street_prefix":733,"./street_suffix":734}],728:[function(require,module,exports){
arguments[4][638][0].apply(exports,arguments)
},{"dup":638}],729:[function(require,module,exports){
module["exports"] = [
  "Apt. ###",
  "# tage"
];

},{}],730:[function(require,module,exports){
module["exports"] = [
  "Alsace",
  "Aquitaine",
  "Auvergne",
  "Basse-Normandie",
  "Bourgogne",
  "Bretagne",
  "Centre",
  "Champagne-Ardenne",
  "Corse",
  "Franche-Comt",
  "Haute-Normandie",
  "le-de-France",
  "Languedoc-Roussillon",
  "Limousin",
  "Lorraine",
  "Midi-Pyrnes",
  "Nord-Pas-de-Calais",
  "Pays de la Loire",
  "Picardie",
  "Poitou-Charentes",
  "Provence-Alpes-Cte d'Azur",
  "Rhne-Alpes"
];

},{}],731:[function(require,module,exports){
arguments[4][452][0].apply(exports,arguments)
},{"dup":452}],732:[function(require,module,exports){
module["exports"] = [
  "#{street_prefix} #{street_suffix}"
];

},{}],733:[function(require,module,exports){
module["exports"] = [
  "Alle, Voie",
  "Rue",
  "Avenue",
  "Boulevard",
  "Quai",
  "Passage",
  "Impasse",
  "Place"
];

},{}],734:[function(require,module,exports){
module["exports"] = [
  "de l'Abbaye",
  "Adolphe Mille",
  "d'Alsia",
  "d'Argenteuil",
  "d'Assas",
  "du Bac",
  "de Paris",
  "La Botie",
  "Bonaparte",
  "de la Bcherie",
  "de Caumartin",
  "Charlemagne",
  "du Chat-qui-Pche",
  "de la Chausse-d'Antin",
  "du Dahomey",
  "Dauphine",
  "Delesseux",
  "du Faubourg Saint-Honor",
  "du Faubourg-Saint-Denis",
  "de la Ferronnerie",
  "des Francs-Bourgeois",
  "des Grands Augustins",
  "de la Harpe",
  "du Havre",
  "de la Huchette",
  "Joubert",
  "Laffitte",
  "Lepic",
  "des Lombards",
  "Marcadet",
  "Molire",
  "Monsieur-le-Prince",
  "de Montmorency",
  "Montorgueil",
  "Mouffetard",
  "de Nesle",
  "Oberkampf",
  "de l'Odon",
  "d'Orsel",
  "de la Paix",
  "des Panoramas",
  "Pastourelle",
  "Pierre Charron",
  "de la Pompe",
  "de Presbourg",
  "de Provence",
  "de Richelieu",
  "de Rivoli",
  "des Rosiers",
  "Royale",
  "d'Abbeville",
  "Saint-Honor",
  "Saint-Bernard",
  "Saint-Denis",
  "Saint-Dominique",
  "Saint-Jacques",
  "Saint-Sverin",
  "des Saussaies",
  "de Seine",
  "de Solfrino",
  "Du Sommerard",
  "de Tilsitt",
  "Vaneau",
  "de Vaugirard",
  "de la Victoire",
  "Zadkine"
];

},{}],735:[function(require,module,exports){
arguments[4][327][0].apply(exports,arguments)
},{"dup":327}],736:[function(require,module,exports){
arguments[4][471][0].apply(exports,arguments)
},{"dup":471}],737:[function(require,module,exports){
arguments[4][472][0].apply(exports,arguments)
},{"dup":472}],738:[function(require,module,exports){
arguments[4][329][0].apply(exports,arguments)
},{"dup":329}],739:[function(require,module,exports){
arguments[4][330][0].apply(exports,arguments)
},{"dup":330}],740:[function(require,module,exports){
arguments[4][475][0].apply(exports,arguments)
},{"./adjective":735,"./bs_adjective":736,"./bs_noun":737,"./bs_verb":738,"./descriptor":739,"./name":741,"./noun":742,"./suffix":743,"dup":475}],741:[function(require,module,exports){
module["exports"] = [
  "#{Name.last_name} #{suffix}",
  "#{Name.last_name} et #{Name.last_name}"
];

},{}],742:[function(require,module,exports){
arguments[4][333][0].apply(exports,arguments)
},{"dup":333}],743:[function(require,module,exports){
module["exports"] = [
  "SARL",
  "SA",
  "EURL",
  "SAS",
  "SEM",
  "SCOP",
  "GIE",
  "EI"
];

},{}],744:[function(require,module,exports){
var fr = {};
module['exports'] = fr;
fr.title = "French";
fr.address = require("./address");
fr.company = require("./company");
fr.internet = require("./internet");
fr.lorem = require("./lorem");
fr.name = require("./name");
fr.phone_number = require("./phone_number");

},{"./address":727,"./company":740,"./internet":747,"./lorem":748,"./name":752,"./phone_number":758}],745:[function(require,module,exports){
module["exports"] = [
  "com",
  "fr",
  "eu",
  "info",
  "name",
  "net",
  "org"
];

},{}],746:[function(require,module,exports){
module["exports"] = [
  "gmail.com",
  "yahoo.fr",
  "hotmail.fr"
];

},{}],747:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":745,"./free_email":746,"dup":302}],748:[function(require,module,exports){
arguments[4][342][0].apply(exports,arguments)
},{"./supplemental":749,"./words":750,"dup":342}],749:[function(require,module,exports){
arguments[4][343][0].apply(exports,arguments)
},{"dup":343}],750:[function(require,module,exports){
arguments[4][344][0].apply(exports,arguments)
},{"dup":344}],751:[function(require,module,exports){
module["exports"] = [
  "Enzo",
  "Lucas",
  "Mathis",
  "Nathan",
  "Thomas",
  "Hugo",
  "Tho",
  "Tom",
  "Louis",
  "Raphal",
  "Clment",
  "Lo",
  "Matho",
  "Maxime",
  "Alexandre",
  "Antoine",
  "Yanis",
  "Paul",
  "Baptiste",
  "Alexis",
  "Gabriel",
  "Arthur",
  "Jules",
  "Ethan",
  "Noah",
  "Quentin",
  "Axel",
  "Evan",
  "Matto",
  "Romain",
  "Valentin",
  "Maxence",
  "Noa",
  "Adam",
  "Nicolas",
  "Julien",
  "Mael",
  "Pierre",
  "Rayan",
  "Victor",
  "Mohamed",
  "Adrien",
  "Kylian",
  "Sacha",
  "Benjamin",
  "La",
  "Clara",
  "Manon",
  "Chlo",
  "Camille",
  "Ines",
  "Sarah",
  "Jade",
  "Lola",
  "Anas",
  "Lucie",
  "Ocane",
  "Lilou",
  "Marie",
  "Eva",
  "Romane",
  "Lisa",
  "Zoe",
  "Julie",
  "Mathilde",
  "Louise",
  "Juliette",
  "Clmence",
  "Clia",
  "Laura",
  "Lena",
  "Malys",
  "Charlotte",
  "Ambre",
  "Maeva",
  "Pauline",
  "Lina",
  "Jeanne",
  "Lou",
  "Nomie",
  "Justine",
  "Louna",
  "Elisa",
  "Alice",
  "Emilie",
  "Carla",
  "Malle",
  "Alicia",
  "Mlissa"
];

},{}],752:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.last_name = require("./last_name");
name.prefix = require("./prefix");
name.title = require("./title");
name.name = require("./name");

},{"./first_name":751,"./last_name":753,"./name":754,"./prefix":755,"./title":756}],753:[function(require,module,exports){
module["exports"] = [
  "Martin",
  "Bernard",
  "Dubois",
  "Thomas",
  "Robert",
  "Richard",
  "Petit",
  "Durand",
  "Leroy",
  "Moreau",
  "Simon",
  "Laurent",
  "Lefebvre",
  "Michel",
  "Garcia",
  "David",
  "Bertrand",
  "Roux",
  "Vincent",
  "Fournier",
  "Morel",
  "Girard",
  "Andre",
  "Lefevre",
  "Mercier",
  "Dupont",
  "Lambert",
  "Bonnet",
  "Francois",
  "Martinez",
  "Legrand",
  "Garnier",
  "Faure",
  "Rousseau",
  "Blanc",
  "Guerin",
  "Muller",
  "Henry",
  "Roussel",
  "Nicolas",
  "Perrin",
  "Morin",
  "Mathieu",
  "Clement",
  "Gauthier",
  "Dumont",
  "Lopez",
  "Fontaine",
  "Chevalier",
  "Robin",
  "Masson",
  "Sanchez",
  "Gerard",
  "Nguyen",
  "Boyer",
  "Denis",
  "Lemaire",
  "Duval",
  "Joly",
  "Gautier",
  "Roger",
  "Roche",
  "Roy",
  "Noel",
  "Meyer",
  "Lucas",
  "Meunier",
  "Jean",
  "Perez",
  "Marchand",
  "Dufour",
  "Blanchard",
  "Marie",
  "Barbier",
  "Brun",
  "Dumas",
  "Brunet",
  "Schmitt",
  "Leroux",
  "Colin",
  "Fernandez",
  "Pierre",
  "Renard",
  "Arnaud",
  "Rolland",
  "Caron",
  "Aubert",
  "Giraud",
  "Leclerc",
  "Vidal",
  "Bourgeois",
  "Renaud",
  "Lemoine",
  "Picard",
  "Gaillard",
  "Philippe",
  "Leclercq",
  "Lacroix",
  "Fabre",
  "Dupuis",
  "Olivier",
  "Rodriguez",
  "Da silva",
  "Hubert",
  "Louis",
  "Charles",
  "Guillot",
  "Riviere",
  "Le gall",
  "Guillaume",
  "Adam",
  "Rey",
  "Moulin",
  "Gonzalez",
  "Berger",
  "Lecomte",
  "Menard",
  "Fleury",
  "Deschamps",
  "Carpentier",
  "Julien",
  "Benoit",
  "Paris",
  "Maillard",
  "Marchal",
  "Aubry",
  "Vasseur",
  "Le roux",
  "Renault",
  "Jacquet",
  "Collet",
  "Prevost",
  "Poirier",
  "Charpentier",
  "Royer",
  "Huet",
  "Baron",
  "Dupuy",
  "Pons",
  "Paul",
  "Laine",
  "Carre",
  "Breton",
  "Remy",
  "Schneider",
  "Perrot",
  "Guyot",
  "Barre",
  "Marty",
  "Cousin"
];

},{}],754:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{last_name} #{first_name}"
];

},{}],755:[function(require,module,exports){
module["exports"] = [
  "M",
  "Mme",
  "Mlle",
  "Dr",
  "Prof"
];

},{}],756:[function(require,module,exports){
module["exports"] = {
  "job": [
    "Superviseur",
    "Executif",
    "Manager",
    "Ingenieur",
    "Specialiste",
    "Directeur",
    "Coordinateur",
    "Administrateur",
    "Architecte",
    "Analyste",
    "Designer",
    "Technicien",
    "Developpeur",
    "Producteur",
    "Consultant",
    "Assistant",
    "Agent",
    "Stagiaire"
  ]
};

},{}],757:[function(require,module,exports){
module["exports"] = [
  "01########",
  "02########",
  "03########",
  "04########",
  "05########",
  "06########",
  "07########",
  "+33 1########",
  "+33 2########",
  "+33 3########",
  "+33 4########",
  "+33 5########",
  "+33 6########",
  "+33 7########"
];

},{}],758:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":757,"dup":312}],759:[function(require,module,exports){
arguments[4][551][0].apply(exports,arguments)
},{"dup":551}],760:[function(require,module,exports){
arguments[4][585][0].apply(exports,arguments)
},{"./default_country":759,"./postcode":761,"./state":762,"./state_abbr":763,"dup":585}],761:[function(require,module,exports){
arguments[4][553][0].apply(exports,arguments)
},{"dup":553}],762:[function(require,module,exports){
module["exports"] = [
  "Alberta",
  "Colombie-Britannique",
  "Manitoba",
  "Nouveau-Brunswick",
  "Terre-Neuve-et-Labrador",
  "Nouvelle-cosse",
  "Territoires du Nord-Ouest",
  "Nunavut",
  "Ontario",
  "le-du-Prince-douard",
  "Qubec",
  "Saskatchewan",
  "Yukon"
];

},{}],763:[function(require,module,exports){
module["exports"] = [
  "AB",
  "BC",
  "MB",
  "NB",
  "NL",
  "NS",
  "NU",
  "NT",
  "ON",
  "PE",
  "QC",
  "SK",
  "YK"
];

},{}],764:[function(require,module,exports){
var fr_CA = {};
module['exports'] = fr_CA;
fr_CA.title = "Canada (French)";
fr_CA.address = require("./address");
fr_CA.internet = require("./internet");
fr_CA.phone_number = require("./phone_number");

},{"./address":760,"./internet":767,"./phone_number":769}],765:[function(require,module,exports){
module["exports"] = [
  "qc.ca",
  "ca",
  "com",
  "biz",
  "info",
  "name",
  "net",
  "org"
];

},{}],766:[function(require,module,exports){
arguments[4][558][0].apply(exports,arguments)
},{"dup":558}],767:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":765,"./free_email":766,"dup":302}],768:[function(require,module,exports){
module["exports"] = [
  "### ###-####",
  "1 ### ###-####",
  "### ###-####, poste ###"
];

},{}],769:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":768,"dup":312}],770:[function(require,module,exports){
module["exports"] = [
  "###",
  "##",
  "#"
];

},{}],771:[function(require,module,exports){
module["exports"] = [
  "#{city_prefix} #{Name.first_name}#{city_suffix}",
  "#{city_prefix} #{Name.first_name}",
  "#{Name.first_name}#{city_suffix}",
  "#{Name.first_name}#{city_suffix}",
  "#{Name.last_name}#{city_suffix}",
  "#{Name.last_name}#{city_suffix}"
];

},{}],772:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],773:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  ""
];

},{}],774:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  ""
];

},{}],775:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "  --",
  "  ",
  " ",
  "  ",
  "",
  "",
  "",
  "",
  "  ",
  " ",
  "  ",
  "  ",
  "",
  "",
  "  ",
  "",
  "",
  " ",
  ". ",
  " ",
  " ",
  "",
  "-  ",
  " ",
  " ",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "  ",
  "",
  "",
  "  ",
  "  ",
  "   ",
  "",
  "",
  " ",
  "-",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "-",
  "",
  "",
  "",
  "",
  " .",
  " ",
  "",
  "",
  " ",
  " ",
  " ",
  "",
  " ",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  " ",
  " ",
  "",
  "",
  "",
  "  ",
  "",
  "   ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "-",
  " ",
  "",
  "",
  "",
  " ",
  " ",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  " ",
  "  ",
  " ",
  " ",
  "-",
  "-",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  " ",
  "  ",
  "",
  "",
  "",
  "",
  "  ",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  " ()",
  "",
  "",
  "- ",
  "",
  "",
  " ",
  "",
  "",
  "- ",
  "-",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  ". ",
  " ",
  " ",
  "  ",
  " ",
  "     ",
  " ",
  "-",
  "-  ",
  " ",
  "",
  " ",
  " ",
  "",
  "   ",
  " ",
  "-",
  "-",
  "-  ",
  "",
  "-  ",
  "-  ",
  "-",
  "",
  "",
  "",
  "",
  "-",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "   ",
  "",
  "",
  "",
  " ",
  "  ",
  "",
  "",
  "",
  "",
  "",
  "",
  "  ",
  "",
  " ",
  "",
  "",
  "",
  " ",
  "",
  " ",
  "",
  " ",
  "",
  "",
  "",
  "",
  " ",
  "-",
  "",
  "",
  "  ",
  "",
  "",
  "",
  ". ",
  " ",
  "  ",
  " ",
  " ",
  "  ",
  " ",
  "  ",
  "",
  " ",
  "  ",
  "",
  "",
  "",
  "",
  "",
  "   ",
  "",
  ""
];

},{}],776:[function(require,module,exports){
module["exports"] = [
  ""
];

},{}],777:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.city = require("./city");
address.country = require("./country");
address.building_number = require("./building_number");
address.street_suffix = require("./street_suffix");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.city_name = require("./city_name");
address.street_title = require("./street_title");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":770,"./city":771,"./city_name":772,"./city_prefix":773,"./city_suffix":774,"./country":775,"./default_country":776,"./postcode":778,"./secondary_address":779,"./street_address":780,"./street_name":781,"./street_suffix":782,"./street_title":783}],778:[function(require,module,exports){
module["exports"] = [
  "01##"
];

},{}],779:[function(require,module,exports){
module["exports"] = [
  ". ##",
  " ###"
];

},{}],780:[function(require,module,exports){
arguments[4][324][0].apply(exports,arguments)
},{"dup":324}],781:[function(require,module,exports){
module["exports"] = [
  "#{street_title} #{street_suffix}"
];

},{}],782:[function(require,module,exports){
module["exports"] = [
  ".",
  "",
  ".",
  "",
  "",
  ""
];

},{}],783:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],784:[function(require,module,exports){
module["exports"] = [
  "(+995 32) 2-##-##-##",
  "032-2-##-##-##",
  "032-2-######",
  "032-2-###-###",
  "032 2 ## ## ##",
  "032 2 ######",
  "2 ## ## ##",
  "2######",
  "2 ### ###"
];

},{}],785:[function(require,module,exports){
arguments[4][371][0].apply(exports,arguments)
},{"./formats":784,"dup":371}],786:[function(require,module,exports){
arguments[4][292][0].apply(exports,arguments)
},{"./name":787,"./prefix":788,"./suffix":789,"dup":292}],787:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{Name.first_name}",
  "#{prefix} #{Name.last_name}",
  "#{prefix} #{Name.last_name} #{suffix}",
  "#{prefix} #{Name.first_name} #{suffix}",
  "#{prefix} #{Name.last_name}-#{Name.last_name}"
];

},{}],788:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  ""
];

},{}],789:[function(require,module,exports){
module["exports"] = [
  "",
  " ",
  "",
  ""
];

},{}],790:[function(require,module,exports){
var ge = {};
module['exports'] = ge;
ge.title = "Georgian";
ge.separator = "  ";
ge.name = require("./name");
ge.address = require("./address");
ge.internet = require("./internet");
ge.company = require("./company");
ge.phone_number = require("./phone_number");
ge.cell_phone = require("./cell_phone");

},{"./address":777,"./cell_phone":785,"./company":786,"./internet":793,"./name":795,"./phone_number":801}],791:[function(require,module,exports){
module["exports"] = [
  "ge",
  "com",
  "net",
  "org",
  "com.ge",
  "org.ge"
];

},{}],792:[function(require,module,exports){
module["exports"] = [
  "gmail.com",
  "yahoo.com",
  "posta.ge"
];

},{}],793:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":791,"./free_email":792,"dup":302}],794:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],795:[function(require,module,exports){
arguments[4][752][0].apply(exports,arguments)
},{"./first_name":794,"./last_name":796,"./name":797,"./prefix":798,"./title":799,"dup":752}],796:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],797:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}"
];

},{}],798:[function(require,module,exports){
module["exports"] = [
  "-",
  "",
  "-",
  ""
];

},{}],799:[function(require,module,exports){
module["exports"] = {
  "descriptor": [
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  "level": [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  "job": [
    "",
    "",
    "",
    "",
    "",
    " ",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};

},{}],800:[function(require,module,exports){
module["exports"] = [
  "5##-###-###",
  "5########",
  "5## ## ## ##",
  "5## ######",
  "5## ### ###",
  "995 5##-###-###",
  "995 5########",
  "995 5## ## ## ##",
  "995 5## ######",
  "995 5## ### ###",
  "+995 5##-###-###",
  "+995 5########",
  "+995 5## ## ## ##",
  "+995 5## ######",
  "+995 5## ### ###",
  "(+995) 5##-###-###",
  "(+995) 5########",
  "(+995) 5## ## ## ##",
  "(+995) 5## ######",
  "(+995) 5## ### ###"
];

},{}],801:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":800,"dup":312}],802:[function(require,module,exports){
module["exports"] = [  
  "##",
  "#"
];

},{}],803:[function(require,module,exports){
arguments[4][314][0].apply(exports,arguments)
},{"dup":314}],804:[function(require,module,exports){
module["exports"] = [
  "Airmadidi",
  "Ampana",
  "Amurang",
  "Andolo",
  "Banggai",
  "Bantaeng",
  "Barru",
  "Bau-Bau",
  "Benteng",
  "Bitung",
  "Bolaang Uki",
  "Boroko",
  "Bulukumba",
  "Bungku",
  "Buol",
  "Buranga",
  "Donggala",
  "Enrekang",
  "Gorontalo",
  "Jeneponto",
  "Kawangkoan",
  "Kendari",
  "Kolaka",
  "Kotamobagu",
  "Kota Raha",
  "Kwandang",
  "Lasusua",
  "Luwuk",
  "Majene",
  "Makale",
  "Makassar",
  "Malili",
  "Mamasa",
  "Mamuju",
  "Manado",
  "Marisa",
  "Maros",
  "Masamba",
  "Melonguane",
  "Ondong Siau",
  "Palopo",
  "Palu",
  "Pangkajene",
  "Pare-Pare",
  "Parigi",
  "Pasangkayu",
  "Pinrang",
  "Polewali",
  "Poso",
  "Rantepao",
  "Ratahan",
  "Rumbia",
  "Sengkang",
  "Sidenreng",
  "Sigi Biromaru",
  "Sinjai",
  "Sunggu Minasa",
  "Suwawa",
  "Tahuna",
  "Takalar",
  "Tilamuta",
  "Toli Toli",
  "Tomohon",
  "Tondano",
  "Tutuyan",
  "Unaaha",
  "Wangi Wangi",
  "Wanggudu",
  "Watampone",
  "Watan Soppeng",
  "Ambarawa",
  "Anyer",
  "Bandung",
  "Bangil",
  "Banjar (Jawa Barat)",
  "Banjarnegara",
  "Bangkalan",
  "Bantul",
  "Banyumas",
  "Banyuwangi",
  "Batang",
  "Batu",
  "Bekasi",
  "Blitar",
  "Blora",
  "Bogor",
  "Bojonegoro",
  "Bondowoso",
  "Boyolali",
  "Bumiayu",
  "Brebes",
  "Caruban",
  "Cianjur",
  "Ciamis",
  "Cibinong",
  "Cikampek",
  "Cikarang",
  "Cilacap",
  "Cilegon",
  "Cirebon",
  "Demak",
  "Depok",
  "Garut",
  "Gresik",
  "Indramayu",
  "Jakarta",
  "Jember",
  "Jepara",
  "Jombang",
  "Kajen",
  "Karanganyar",
  "Kebumen",
  "Kediri",
  "Kendal",
  "Kepanjen",
  "Klaten",
  "Pelabuhan Ratu",
  "Kraksaan",
  "Kudus",
  "Kuningan",
  "Lamongan",
  "Lumajang",
  "Madiun",
  "Magelang",
  "Magetan",
  "Majalengka",
  "Malang",
  "Mojokerto",
  "Mojosari",
  "Mungkid",
  "Ngamprah",
  "Nganjuk",
  "Ngawi",
  "Pacitan",
  "Pamekasan",
  "Pandeglang",
  "Pare",
  "Pati",
  "Pasuruan",
  "Pekalongan",
  "Pemalang",
  "Ponorogo",
  "Probolinggo",
  "Purbalingga",
  "Purwakarta",
  "Purwodadi",
  "Purwokerto",
  "Purworejo",
  "Rangkasbitung",
  "Rembang",
  "Salatiga",
  "Sampang",
  "Semarang",
  "Serang",
  "Sidayu",
  "Sidoarjo",
  "Singaparna",
  "Situbondo",
  "Slawi",
  "Sleman",
  "Soreang",
  "Sragen",
  "Subang",
  "Sukabumi",
  "Sukoharjo",
  "Sumber",
  "Sumedang",
  "Sumenep",
  "Surabaya",
  "Surakarta",
  "Tasikmalaya",
  "Tangerang",
  "Tangerang Selatan",
  "Tegal",
  "Temanggung",
  "Tigaraksa",
  "Trenggalek",
  "Tuban",
  "Tulungagung",
  "Ungaran",
  "Wates",
  "Wlingi",
  "Wonogiri",
  "Wonosari",
  "Wonosobo",
  "Yogyakarta",
  "Atambua",
  "Baa",
  "Badung",
  "Bajawa",
  "Bangli",
  "Bima",
  "Denpasar",
  "Dompu",
  "Ende",
  "Gianyar",
  "Kalabahi",
  "Karangasem",
  "Kefamenanu",
  "Klungkung",
  "Kupang",
  "Labuhan Bajo",
  "Larantuka",
  "Lewoleba",
  "Maumere",
  "Mataram",
  "Mbay",
  "Negara",
  "Praya",
  "Raba",
  "Ruteng",
  "Selong",
  "Singaraja",
  "Soe",
  "Sumbawa Besar",
  "Tabanan",
  "Taliwang",
  "Tambolaka",
  "Tanjung",
  "Waibakul",
  "Waikabubak",
  "Waingapu",
  "Denpasar",
  "Negara,Bali",
  "Singaraja",
  "Tabanan",
  "Bangli"
];
},{}],805:[function(require,module,exports){
module["exports"] = [
  "Indonesia"
];

},{}],806:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.building_number = require("./building_number");
address.postcode = require("./postcode");
address.state = require("./state");
address.city_name = require("./city_name");
address.city = require("./city");
address.street_prefix = require("./street_prefix");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":802,"./city":803,"./city_name":804,"./default_country":805,"./postcode":807,"./state":808,"./street_address":809,"./street_name":810,"./street_prefix":811}],807:[function(require,module,exports){
module["exports"] = [
  "#####"
];
},{}],808:[function(require,module,exports){
module["exports"] = [
  "Aceh",
  "Sumatera Utara",
  "Sumatera Barat",
  "Jambi",
  "Bangka Belitung",
  "Riau",
  "Kepulauan Riau",
  "Bengkulu",
  "Sumatera Selatan",
  "Lampung",
  "Banten",
  "DKI Jakarta",
  "Jawa Barat",
  "Jawa Tengah",
  "Jawa Timur",
  "Nusa Tenggara Timur",
  "DI Yogyakarta",
  "Bali",
  "Nusa Tenggara Barat",
  "Kalimantan Barat",
  "Kalimantan Tengah",
  "Kalimantan Selatan",
  "Kalimantan Timur",
  "Kalimantan Utara",
  "Sulawesi Selatan",
  "Sulawesi Utara",
  "Gorontalo",
  "Sulawesi Tengah",
  "Sulawesi Barat",
  "Sulawesi Tenggara",
  "Maluku",
  "Maluku Utara",
  "Papua Barat",
  "Papua"
];
},{}],809:[function(require,module,exports){
module["exports"] = [
  "#{street_name} no #{building_number}"
];
},{}],810:[function(require,module,exports){
module["exports"] = [
  "#{street_prefix} #{Name.first_name}",
  "#{street_prefix} #{Name.last_name}"
];
},{}],811:[function(require,module,exports){
module["exports"] = [
  "Ds.",
  "Dk.",
  "Gg.",
  "Jln.",
  "Jr.",
  "Kpg.",
  "Ki.",
  "Psr."
];
},{}],812:[function(require,module,exports){
arguments[4][292][0].apply(exports,arguments)
},{"./name":813,"./prefix":814,"./suffix":815,"dup":292}],813:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{Name.last_name}",
  "#{Name.last_name} #{suffix}",
  "#{prefix} #{Name.last_name} #{suffix}"
];

},{}],814:[function(require,module,exports){
module["exports"] = [
  "PT",
  "CV",
  "UD",
  "PD",
  "Perum"
];
},{}],815:[function(require,module,exports){
module["exports"] = [
  "(Persero) Tbk",
  "Tbk"
];
},{}],816:[function(require,module,exports){
arguments[4][296][0].apply(exports,arguments)
},{"./month":817,"./weekday":818,"dup":296}],817:[function(require,module,exports){
module["exports"] = {
  wide: [
    "Januari",
    "Februari",
    "Maret",
    "April",
    "Mei",
    "Juni",
    "Juli",
    "Agustus",
    "September",
    "Oktober",
    "November",
    "Desember"
  ],
  wide_context: [
    "Januari",
    "Februari",
    "Maret",
    "April",
    "Mei",
    "Juni",
    "Juli",
    "Agustus",
    "September",
    "Oktober",
    "November",
    "Desember"
  ],
  abbr: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "Mei",
    "Jun",
    "Jul",
    "Ags",
    "Sep",
    "Okt",
    "Nov",
    "Des"
  ],
  abbr_context: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "Mei",
    "Jun",
    "Jul",
    "Ags",
    "Sep",
    "Okt",
    "Nov",
    "Des"
  ]
};

},{}],818:[function(require,module,exports){
module["exports"] = {
  wide: [
    "Minggu",
    "Senin",
    "Selasa",
    "Rabu",
    "Kamis",
    "Jumat",
    "Sabtu"
  ],
  wide_context: [
    "Minggu",
    "Senin",
    "Selasa",
    "Rabu",
    "Kamis",
    "Jumat",
    "Sabtu"
  ],
  abbr: [
    "Min",
    "Sen",
    "Sel",
    "Rab",
    "Kam",
    "Jum",
    "Sab"
  ],
  abbr_context: [
    "Min",
    "Sen",
    "Sel",
    "Rab",
    "Kam",
    "Jum",
    "Sab"
  ]
};

},{}],819:[function(require,module,exports){
var id = {};
module['exports'] = id;
id.title = "Indonesia";
id.address = require("./address");
id.company = require("./company");
id.internet = require("./internet");
id.date = require("./date");
id.name = require("./name");
id.phone_number = require("./phone_number");

},{"./address":806,"./company":812,"./date":816,"./internet":822,"./name":825,"./phone_number":832}],820:[function(require,module,exports){
module["exports"] = [
  "com",
  "net",
  "org",
  "asia",
  "tv",
  "biz",
  "info",
  "in",
  "name",
  "co",
  "ac.id",
  "sch.id",
  "go.id",
  "mil.id",
  "co.id",
  "or.id",
  "web.id",
  "my.id",
  "biz.id",
  "desa.id"
];
},{}],821:[function(require,module,exports){
module["exports"] = [
  'gmail.com',
  'yahoo.com',
  'gmail.co.id',
  'yahoo.co.id'
];
},{}],822:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":820,"./free_email":821,"dup":302}],823:[function(require,module,exports){
module["exports"] = [
  "Ade",
  "Agnes",
  "Ajeng",
  "Amalia",
  "Anita",
  "Ayu",
  "Aisyah",
  "Ana",
  "Ami",
  "Ani",
  "Azalea",
  "Aurora",
  "Alika",
  "Anastasia",
  "Amelia",
  "Almira",
  "Bella",
  "Betania",
  "Belinda",
  "Citra",
  "Cindy",
  "Chelsea",
  "Clara",
  "Cornelia",
  "Cinta",
  "Cinthia",
  "Ciaobella",
  "Cici",
  "Carla",
  "Calista",
  "Devi",
  "Dewi","Dian",
  "Diah",
  "Diana",
  "Dina",
  "Dinda",
  "Dalima",
  "Eka",
  "Eva",
  "Endah",
  "Elisa",
  "Eli",
  "Ella",
  "Ellis",
  "Elma",
  "Elvina",
  "Fitria",
  "Fitriani",
  "Febi",
  "Faizah",
  "Farah",
  "Farhunnisa",
  "Fathonah",
  "Gabriella",
  "Gasti",
  "Gawati",
  "Genta",
  "Ghaliyati",
  "Gina",
  "Gilda",
  "Halima",
  "Hesti",
  "Hilda",
  "Hafshah",
  "Hamima",
  "Hana",
  "Hani",
  "Hasna",
  "Humaira",
  "Ika",
  "Indah",
  "Intan",
  "Irma",
  "Icha",
  "Ida",
  "Ifa",
  "Ilsa",
  "Ina",
  "Ira",
  "Iriana",
  "Jamalia",
  "Janet",
  "Jane",
  "Julia",
  "Juli",
  "Jessica",
  "Jasmin",
  "Jelita",
  "Kamaria",
  "Kamila",
  "Kani",
  "Karen",
  "Karimah",
  "Kartika",
  "Kasiyah",
  "Keisha",
  "Kezia",
  "Kiandra",
  "Kayla",
  "Kania",
  "Lala",
  "Lalita",
  "Latika",
  "Laila",
  "Laras",
  "Lidya",
  "Lili",
  "Lintang",
  "Maria",
  "Mala",
  "Maya",
  "Maida",
  "Maimunah",
  "Melinda",
  "Mila",
  "Mutia",
  "Michelle",
  "Malika",
  "Nadia",
  "Nadine",
  "Nabila",
  "Natalia",
  "Novi",
  "Nova",
  "Nurul",
  "Nilam",
  "Najwa",
  "Olivia",
  "Ophelia",
  "Oni",
  "Oliva",
  "Padma",
  "Putri",
  "Paramita",
  "Paris",
  "Patricia",
  "Paulin",
  "Puput",
  "Puji",
  "Pia",
  "Puspa",
  "Puti",
  "Putri",
  "Padmi",
  "Qori",
  "Queen",
  "Ratih",
  "Ratna",
  "Restu",
  "Rini",
  "Rika",
  "Rina",
  "Rahayu",
  "Rahmi",
  "Rachel",
  "Rahmi",
  "Raisa",
  "Raina",
  "Sarah",
  "Sari",
  "Siti",
  "Siska",
  "Suci",
  "Syahrini",
  "Septi",
  "Sadina",
  "Safina",
  "Sakura",
  "Salimah",
  "Salwa",
  "Salsabila",
  "Samiah",
  "Shania",
  "Sabrina",
  "Silvia",
  "Shakila",
  "Talia",
  "Tami",
  "Tira",
  "Tiara",
  "Titin",
  "Tania",
  "Tina",
  "Tantri",
  "Tari",
  "Titi",
  "Uchita",
  "Unjani",
  "Ulya",
  "Uli",
  "Ulva",
  "Umi",
  "Usyi",
  "Vanya",
  "Vanesa",
  "Vivi",
  "Vera",
  "Vicky",
  "Victoria",
  "Violet",
  "Winda",
  "Widya",
  "Wulan",
  "Wirda",
  "Wani",
  "Yani",
  "Yessi",
  "Yulia",
  "Yuliana",
  "Yuni",
  "Yunita",
  "Yance",
  "Zahra",
  "Zalindra",
  "Zaenab",
  "Zulfa",
  "Zizi",
  "Zulaikha",
  "Zamira",
  "Zelda",
  "Zelaya"
];
},{}],824:[function(require,module,exports){
module["exports"] = [
  "Agustina",
  "Andriani",
  "Anggraini",
  "Aryani",
  "Astuti",
  "Fujiati",
  "Farida",
  "Handayani",
  "Hassanah",
  "Hartati",
  "Hasanah",
  "Haryanti",
  "Hariyah",
  "Hastuti",
  "Halimah",
  "Kusmawati",
  "Kuswandari",
  "Laksmiwati",
  "Laksita",
  "Lestari",
  "Lailasari",
  "Mandasari",
  "Mardhiyah",
  "Mayasari",
  "Melani",
  "Mulyani",
  "Maryati",
  "Nurdiyanti",
  "Novitasari",
  "Nuraini",
  "Nasyidah",
  "Nasyiah",
  "Namaga",
  "Palastri",
  "Pudjiastuti",
  "Puspasari",
  "Puspita",
  "Purwanti",
  "Pratiwi",
  "Purnawati",
  "Pertiwi",
  "Permata",
  "Prastuti",
  "Padmasari",
  "Rahmawati",
  "Rahayu",
  "Riyanti",
  "Rahimah",
  "Suartini",
  "Sudiati",
  "Suryatmi",
  "Susanti",
  "Safitri",
  "Oktaviani",
  "Utami",
  "Usamah",
  "Usada",
  "Uyainah",
  "Yuniar",
  "Yuliarti",
  "Yulianti",
  "Yolanda",
  "Wahyuni",
  "Wijayanti",
  "Widiastuti",
  "Winarsih",
  "Wulandari",
  "Wastuti",
  "Zulaika"
];
},{}],825:[function(require,module,exports){
arguments[4][305][0].apply(exports,arguments)
},{"./female_first_name":823,"./female_last_name":824,"./male_first_name":826,"./male_last_name":827,"./name":828,"./prefix":829,"./suffix":830,"dup":305}],826:[function(require,module,exports){
module["exports"] = [
  "Abyasa",
  "Ade",
  "Adhiarja",
  "Adiarja",
  "Adika",
  "Adikara",
  "Adinata",
  "Aditya",
  "Agus",
  "Ajiman",
  "Ajimat",
  "Ajimin",
  "Ajiono",
  "Akarsana",
  "Alambana",
  "Among",
  "Anggabaya",
  "Anom",
  "Argono",
  "Aris",
  "Arta",
  "Artanto",
  "Artawan",
  "Arsipatra",
  "Asirwada",
  "Asirwanda",
  "Aslijan",
  "Asmadi",
  "Asman",
  "Asmianto",
  "Asmuni",
  "Aswani",
  "Atma",
  "Atmaja",
  "Bagas",
  "Bagiya",
  "Bagus",
  "Bagya",
  "Bahuraksa",
  "Bahuwarna",
  "Bahuwirya",
  "Bajragin",
  "Bakda",
  "Bakiadi",
  "Bakianto",
  "Bakidin",
  "Bakijan",
  "Bakiman",
  "Bakiono",
  "Bakti",
  "Baktiadi",
  "Baktianto",
  "Baktiono",
  "Bala",
  "Balamantri",
  "Balangga",
  "Balapati",
  "Balidin",
  "Balijan",
  "Bambang",
  "Banara",
  "Banawa",
  "Banawi",
  "Bancar",
  "Budi",
  "Cagak",
  "Cager",
  "Cahyadi",
  "Cahyanto",
  "Cahya",
  "Cahyo",
  "Cahyono",
  "Caket",
  "Cakrabirawa",
  "Cakrabuana",
  "Cakrajiya",
  "Cakrawala",
  "Cakrawangsa",
  "Candra",
  "Chandra",
  "Candrakanta",
  "Capa",
  "Caraka",
  "Carub",
  "Catur",
  "Caturangga",
  "Cawisadi",
  "Cawisono",
  "Cawuk",
  "Cayadi",
  "Cecep",
  "Cemani",
  "Cemeti",
  "Cemplunk",
  "Cengkal",
  "Cengkir",
  "Dacin",
  "Dadap",
  "Dadi",
  "Dagel",
  "Daliman",
  "Dalimin",
  "Daliono",
  "Damar",
  "Damu",
  "Danang",
  "Daniswara",
  "Danu",
  "Danuja",
  "Dariati",
  "Darijan",
  "Darimin",
  "Darmaji",
  "Darman",
  "Darmana",
  "Darmanto",
  "Darsirah",
  "Dartono",
  "Daru",
  "Daruna",
  "Daryani",
  "Dasa",
  "Digdaya",
  "Dimas",
  "Dimaz",
  "Dipa",
  "Dirja",
  "Drajat",
  "Dwi",
  "Dono",
  "Dodo",
  "Edi",
  "Eka",
  "Elon",
  "Eluh",
  "Eman",
  "Emas",
  "Embuh",
  "Emong",
  "Empluk",
  "Endra",
  "Enteng",
  "Estiawan",
  "Estiono",
  "Eko",
  "Edi",
  "Edison",
  "Edward",
  "Elvin",
  "Erik",
  "Emil",
  "Ega",
  "Emin",
  "Eja",
  "Gada",
  "Gadang",
  "Gaduh",
  "Gaiman",
  "Galak",
  "Galang",
  "Galar",
  "Galih",
  "Galiono",
  "Galuh",
  "Galur",
  "Gaman",
  "Gamani",
  "Gamanto",
  "Gambira",
  "Gamblang",
  "Ganda",
  "Gandewa",
  "Gandi",
  "Gandi",
  "Ganep",
  "Gangsa",
  "Gangsar",
  "Ganjaran",
  "Gantar",
  "Gara",
  "Garan",
  "Garang",
  "Garda",
  "Gatot",
  "Gatra",
  "Gilang",
  "Galih",
  "Ghani",
  "Gading",
  "Hairyanto",
  "Hardana",
  "Hardi",
  "Harimurti",
  "Harja",
  "Harjasa",
  "Harjaya",
  "Harjo",
  "Harsana",
  "Harsanto",
  "Harsaya",
  "Hartaka",
  "Hartana",
  "Harto",
  "Hasta",
  "Heru",
  "Himawan",
  "Hadi",
  "Halim",
  "Hasim",
  "Hasan",
  "Hendra",
  "Hendri",
  "Heryanto",
  "Hamzah",
  "Hari",
  "Imam",
  "Indra",
  "Irwan",
  "Irsad",
  "Ikhsan",
  "Irfan",
  "Ian",
  "Ibrahim",
  "Ibrani",
  "Ismail",
  "Irnanto",
  "Ilyas",
  "Ibun",
  "Ivan",
  "Ikin",
  "Ihsan",
  "Jabal",
  "Jaeman",
  "Jaga",
  "Jagapati",
  "Jagaraga",
  "Jail",
  "Jaiman",
  "Jaka",
  "Jarwa",
  "Jarwadi",
  "Jarwi",
  "Jasmani",
  "Jaswadi",
  "Jati",
  "Jatmiko",
  "Jaya",
  "Jayadi",
  "Jayeng",
  "Jinawi",
  "Jindra",
  "Joko",
  "Jumadi",
  "Jumari",
  "Jamal",
  "Jamil",
  "Jais",
  "Jefri",
  "Johan",
  "Jono",
  "Kacung",
  "Kajen",
  "Kambali",
  "Kamidin",
  "Kariman",
  "Karja",
  "Karma",
  "Karman",
  "Karna",
  "Karsa",
  "Karsana",
  "Karta",
  "Kasiran",
  "Kasusra",
  "Kawaca",
  "Kawaya",
  "Kayun",
  "Kemba",
  "Kenari",
  "Kenes",
  "Kuncara",
  "Kunthara",
  "Kusuma",
  "Kadir",
  "Kala",
  "Kalim",
  "Kurnia",
  "Kanda",
  "Kardi",
  "Karya",
  "Kasim",
  "Kairav",
  "Kenzie",
  "Kemal",
  "Kamal",
  "Koko",
  "Labuh",
  "Laksana",
  "Lamar",
  "Lanang",
  "Langgeng",
  "Lanjar",
  "Lantar",
  "Lega",
  "Legawa",
  "Lembah",
  "Liman",
  "Limar",
  "Luhung",
  "Lukita",
  "Luluh",
  "Lulut",
  "Lurhur",
  "Luwar",
  "Luwes",
  "Latif",
  "Lasmanto",
  "Lukman",
  "Luthfi",
  "Leo",
  "Luis",
  "Lutfan",
  "Lasmono",
  "Laswi",
  "Mahesa",
  "Makara",
  "Makuta",
  "Manah",
  "Maras",
  "Margana",
  "Mariadi",
  "Marsudi",
  "Martaka",
  "Martana",
  "Martani",
  "Marwata",
  "Maryadi",
  "Maryanto",
  "Mitra",
  "Mujur",
  "Mulya",
  "Mulyanto",
  "Mulyono",
  "Mumpuni",
  "Muni",
  "Mursita",
  "Murti",
  "Mustika",
  "Maman",
  "Mahmud",
  "Mahdi",
  "Mahfud",
  "Malik",
  "Muhammad",
  "Mustofa",
  "Marsito",
  "Mursinin",
  "Nalar",
  "Naradi",
  "Nardi",
  "Niyaga",
  "Nrima",
  "Nugraha",
  "Nyana",
  "Narji",
  "Nasab",
  "Nasrullah",
  "Nasim",
  "Najib",
  "Najam",
  "Nyoman",
  "Olga",
  "Ozy",
  "Omar",
  "Opan",
  "Oskar",
  "Oman",
  "Okto",
  "Okta",
  "Opung",
  "Paiman",
  "Panca",
  "Pangeran",
  "Pangestu",
  "Pardi",
  "Parman",
  "Perkasa",
  "Praba",
  "Prabu",
  "Prabawa",
  "Prabowo",
  "Prakosa",
  "Pranata",
  "Pranawa",
  "Prasetya",
  "Prasetyo",
  "Prayitna",
  "Prayoga",
  "Prayogo",
  "Purwadi",
  "Purwa",
  "Purwanto",
  "Panji",
  "Pandu",
  "Paiman",
  "Prima",
  "Putu",
  "Raden",
  "Raditya",
  "Raharja",
  "Rama",
  "Rangga",
  "Reksa",
  "Respati",
  "Rusman",
  "Rosman",
  "Rahmat",
  "Rahman",
  "Rendy",
  "Reza",
  "Rizki",
  "Ridwan",
  "Rudi",
  "Raden",
  "Radit",
  "Radika",
  "Rafi",
  "Rafid",
  "Raihan",
  "Salman",
  "Saadat",
  "Saiful",
  "Surya",
  "Slamet",
  "Samsul",
  "Soleh",
  "Simon",
  "Sabar",
  "Sabri",
  "Sidiq",
  "Satya",
  "Setya",
  "Saka",
  "Sakti",
  "Taswir",
  "Tedi",
  "Teddy",
  "Taufan",
  "Taufik",
  "Tomi",
  "Tasnim",
  "Teguh",
  "Tasdik",
  "Timbul",
  "Tirta",
  "Tirtayasa",
  "Tri",
  "Tugiman",
  "Umar",
  "Usman",
  "Uda",
  "Umay",
  "Unggul",
  "Utama",
  "Umaya",
  "Upik",
  "Viktor",
  "Vino",
  "Vinsen",
  "Vero",
  "Vega",
  "Viman",
  "Virman",
  "Wahyu",
  "Wira",
  "Wisnu",
  "Wadi",
  "Wardi",
  "Warji",
  "Waluyo",
  "Wakiman",
  "Wage",
  "Wardaya",
  "Warsa",
  "Warsita",
  "Warta",
  "Wasis",
  "Wawan",
  "Xanana",
  "Yahya",
  "Yusuf",
  "Yosef",
  "Yono",
  "Yoga"
];
},{}],827:[function(require,module,exports){
module["exports"] = [
  "Adriansyah",
  "Ardianto",
  "Anggriawan",
  "Budiman",
  "Budiyanto",
  "Damanik",
  "Dongoran",
  "Dabukke",
  "Firmansyah",
  "Firgantoro",
  "Gunarto",
  "Gunawan",
  "Hardiansyah",
  "Habibi",
  "Hakim",
  "Halim",
  "Haryanto",
  "Hidayat",
  "Hidayanto",
  "Hutagalung",
  "Hutapea",
  "Hutasoit",
  "Irawan",
  "Iswahyudi",
  "Kuswoyo",
  "Januar",
  "Jailani",
  "Kurniawan",
  "Kusumo",
  "Latupono",
  "Lazuardi",
  "Maheswara",
  "Mahendra",
  "Mustofa",
  "Mansur",
  "Mandala",
  "Megantara",
  "Maulana",
  "Maryadi",
  "Mangunsong",
  "Manullang",
  "Marpaung",
  "Marbun",
  "Narpati",
  "Natsir",
  "Nugroho",
  "Najmudin",
  "Nashiruddin",
  "Nainggolan",
  "Nababan",
  "Napitupulu",
  "Pangestu",
  "Putra",
  "Pranowo",
  "Prabowo",
  "Pratama",
  "Prasetya",
  "Prasetyo",
  "Pradana",
  "Pradipta",
  "Prakasa",
  "Permadi",
  "Prasasta",
  "Prayoga",
  "Ramadan",
  "Rajasa",
  "Rajata",
  "Saptono",
  "Santoso",
  "Saputra",
  "Saefullah",
  "Setiawan",
  "Suryono",
  "Suwarno",
  "Siregar",
  "Sihombing",
  "Salahudin",
  "Sihombing",
  "Samosir",
  "Saragih",
  "Sihotang",
  "Simanjuntak",
  "Sinaga",
  "Simbolon",
  "Sitompul",
  "Sitorus",
  "Sirait",
  "Siregar",
  "Situmorang",
  "Tampubolon",
  "Thamrin",
  "Tamba",
  "Tarihoran",
  "Utama",
  "Uwais",
  "Wahyudin",
  "Waluyo",
  "Wibowo",
  "Winarno",
  "Wibisono",
  "Wijaya",
  "Widodo",
  "Wacana",
  "Waskita",
  "Wasita",
  "Zulkarnain"
];
},{}],828:[function(require,module,exports){
module["exports"] = [
  "#{male_first_name} #{male_last_name}",
  "#{male_last_name} #{male_first_name}",
  "#{male_first_name} #{male_first_name} #{male_last_name}",
  "#{female_first_name} #{female_last_name}",
  "#{female_first_name} #{male_last_name}",
  "#{female_last_name} #{female_first_name}",
  "#{female_first_name} #{female_first_name} #{female_last_name}"
];

},{}],829:[function(require,module,exports){
module["exports"] = [];
},{}],830:[function(require,module,exports){
module["exports"] = [
  "S.Ked",
  "S.Gz",
  "S.Pt",
  "S.IP",
  "S.E.I",
  "S.E.",
  "S.Kom",
  "S.H.",
  "S.T.",
  "S.Pd",
  "S.Psi",
  "S.I.Kom",
  "S.Sos",
  "S.Farm",
  "M.M.",
  "M.Kom.",
  "M.TI.",
  "M.Pd",
  "M.Farm",
  "M.Ak"
];
},{}],831:[function(require,module,exports){
module["exports"] = [
  "02# #### ###",
  "02## #### ###",
  "03## #### ###",
  "04## #### ###",
  "05## #### ###",
  "06## #### ###",
  "07## #### ###",
  "09## #### ###",
  "02# #### ####",
  "02## #### ####",
  "03## #### ####",
  "04## #### ####",
  "05## #### ####",
  "06## #### ####",
  "07## #### ####",
  "09## #### ####",
  "08## ### ###",
  "08## #### ###",
  "08## #### ####",
  "(+62) 8## ### ###",
  "(+62) 2# #### ###",
  "(+62) 2## #### ###",
  "(+62) 3## #### ###",
  "(+62) 4## #### ###",
  "(+62) 5## #### ###",
  "(+62) 6## #### ###",
  "(+62) 7## #### ###",
  "(+62) 8## #### ###",
  "(+62) 9## #### ###",
  "(+62) 2# #### ####",
  "(+62) 2## #### ####",
  "(+62) 3## #### ####",
  "(+62) 4## #### ####",
  "(+62) 5## #### ####",
  "(+62) 6## #### ####",
  "(+62) 7## #### ####",
  "(+62) 8## #### ####",
  "(+62) 9## #### ####"
];
},{}],832:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":831,"dup":312}],833:[function(require,module,exports){
arguments[4][770][0].apply(exports,arguments)
},{"dup":770}],834:[function(require,module,exports){
module["exports"] = [
  "#{city_prefix} #{Name.first_name} #{city_suffix}",
  "#{city_prefix} #{Name.first_name}",
  "#{Name.first_name} #{city_suffix}",
  "#{Name.last_name} #{city_suffix}"
];

},{}],835:[function(require,module,exports){
module["exports"] = [
  "San",
  "Borgo",
  "Sesto",
  "Quarto",
  "Settimo"
];

},{}],836:[function(require,module,exports){
module["exports"] = [
  "a mare",
  "lido",
  "ligure",
  "del friuli",
  "salentino",
  "calabro",
  "veneto",
  "nell'emilia",
  "umbro",
  "laziale",
  "terme",
  "sardo"
];

},{}],837:[function(require,module,exports){
module["exports"] = [
  "Afghanistan",
  "Albania",
  "Algeria",
  "American Samoa",
  "Andorra",
  "Angola",
  "Anguilla",
  "Antartide (territori a sud del 60 parallelo)",
  "Antigua e Barbuda",
  "Argentina",
  "Armenia",
  "Aruba",
  "Australia",
  "Austria",
  "Azerbaijan",
  "Bahamas",
  "Bahrain",
  "Bangladesh",
  "Barbados",
  "Bielorussia",
  "Belgio",
  "Belize",
  "Benin",
  "Bermuda",
  "Bhutan",
  "Bolivia",
  "Bosnia e Herzegovina",
  "Botswana",
  "Bouvet Island (Bouvetoya)",
  "Brasile",
  "Territorio dell'arcipelago indiano",
  "Isole Vergini Britanniche",
  "Brunei Darussalam",
  "Bulgaria",
  "Burkina Faso",
  "Burundi",
  "Cambogia",
  "Cameroon",
  "Canada",
  "Capo Verde",
  "Isole Cayman",
  "Repubblica Centrale Africana",
  "Chad",
  "Cile",
  "Cina",
  "Isola di Pasqua",
  "Isola di Cocos (Keeling)",
  "Colombia",
  "Comoros",
  "Congo",
  "Isole Cook",
  "Costa Rica",
  "Costa d'Avorio",
  "Croazia",
  "Cuba",
  "Cipro",
  "Repubblica Ceca",
  "Danimarca",
  "Gibuti",
  "Repubblica Dominicana",
  "Equador",
  "Egitto",
  "El Salvador",
  "Guinea Equatoriale",
  "Eritrea",
  "Estonia",
  "Etiopia",
  "Isole Faroe",
  "Isole Falkland (Malvinas)",
  "Fiji",
  "Finlandia",
  "Francia",
  "Guyana Francese",
  "Polinesia Francese",
  "Territori Francesi del sud",
  "Gabon",
  "Gambia",
  "Georgia",
  "Germania",
  "Ghana",
  "Gibilterra",
  "Grecia",
  "Groenlandia",
  "Grenada",
  "Guadalupa",
  "Guam",
  "Guatemala",
  "Guernsey",
  "Guinea",
  "Guinea-Bissau",
  "Guyana",
  "Haiti",
  "Heard Island and McDonald Islands",
  "Citt del Vaticano",
  "Honduras",
  "Hong Kong",
  "Ungheria",
  "Islanda",
  "India",
  "Indonesia",
  "Iran",
  "Iraq",
  "Irlanda",
  "Isola di Man",
  "Israele",
  "Italia",
  "Giamaica",
  "Giappone",
  "Jersey",
  "Giordania",
  "Kazakhstan",
  "Kenya",
  "Kiribati",
  "Korea",
  "Kuwait",
  "Republicca Kirgiza",
  "Repubblica del Laos",
  "Latvia",
  "Libano",
  "Lesotho",
  "Liberia",
  "Libyan Arab Jamahiriya",
  "Liechtenstein",
  "Lituania",
  "Lussemburgo",
  "Macao",
  "Macedonia",
  "Madagascar",
  "Malawi",
  "Malesia",
  "Maldive",
  "Mali",
  "Malta",
  "Isole Marshall",
  "Martinica",
  "Mauritania",
  "Mauritius",
  "Mayotte",
  "Messico",
  "Micronesia",
  "Moldova",
  "Principato di Monaco",
  "Mongolia",
  "Montenegro",
  "Montserrat",
  "Marocco",
  "Mozambico",
  "Myanmar",
  "Namibia",
  "Nauru",
  "Nepal",
  "Antille Olandesi",
  "Olanda",
  "Nuova Caledonia",
  "Nuova Zelanda",
  "Nicaragua",
  "Niger",
  "Nigeria",
  "Niue",
  "Isole Norfolk",
  "Northern Mariana Islands",
  "Norvegia",
  "Oman",
  "Pakistan",
  "Palau",
  "Palestina",
  "Panama",
  "Papua Nuova Guinea",
  "Paraguay",
  "Peru",
  "Filippine",
  "Pitcairn Islands",
  "Polonia",
  "Portogallo",
  "Porto Rico",
  "Qatar",
  "Reunion",
  "Romania",
  "Russia",
  "Rwanda",
  "San Bartolomeo",
  "Sant'Elena",
  "Saint Kitts and Nevis",
  "Saint Lucia",
  "Saint Martin",
  "Saint Pierre and Miquelon",
  "Saint Vincent and the Grenadines",
  "Samoa",
  "San Marino",
  "Sao Tome and Principe",
  "Arabia Saudita",
  "Senegal",
  "Serbia",
  "Seychelles",
  "Sierra Leone",
  "Singapore",
  "Slovenia",
  "Isole Solomon",
  "Somalia",
  "Sud Africa",
  "Georgia del sud e South Sandwich Islands",
  "Spagna",
  "Sri Lanka",
  "Sudan",
  "Suriname",
  "Svalbard & Jan Mayen Islands",
  "Swaziland",
  "Svezia",
  "Svizzera",
  "Siria",
  "Taiwan",
  "Tajikistan",
  "Tanzania",
  "Tailandia",
  "Timor-Leste",
  "Togo",
  "Tokelau",
  "Tonga",
  "Trinidad e Tobago",
  "Tunisia",
  "Turchia",
  "Turkmenistan",
  "Isole di Turks and Caicos",
  "Tuvalu",
  "Uganda",
  "Ucraina",
  "Emirati Arabi Uniti",
  "Regno Unito",
  "Stati Uniti d'America",
  "United States Minor Outlying Islands",
  "Isole Vergini Statunitensi",
  "Uruguay",
  "Uzbekistan",
  "Vanuatu",
  "Venezuela",
  "Vietnam",
  "Wallis and Futuna",
  "Western Sahara",
  "Yemen",
  "Zambia",
  "Zimbabwe"
];

},{}],838:[function(require,module,exports){
module["exports"] = [
  "Italia"
];

},{}],839:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.country = require("./country");
address.building_number = require("./building_number");
address.street_suffix = require("./street_suffix");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.city = require("./city");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":833,"./city":834,"./city_prefix":835,"./city_suffix":836,"./country":837,"./default_country":838,"./postcode":840,"./secondary_address":841,"./state":842,"./state_abbr":843,"./street_address":844,"./street_name":845,"./street_suffix":846}],840:[function(require,module,exports){
arguments[4][638][0].apply(exports,arguments)
},{"dup":638}],841:[function(require,module,exports){
module["exports"] = [
  "Appartamento ##",
  "Piano #"
];

},{}],842:[function(require,module,exports){
module["exports"] = [
  "Agrigento",
  "Alessandria",
  "Ancona",
  "Aosta",
  "Arezzo",
  "Ascoli Piceno",
  "Asti",
  "Avellino",
  "Bari",
  "Barletta-Andria-Trani",
  "Belluno",
  "Benevento",
  "Bergamo",
  "Biella",
  "Bologna",
  "Bolzano",
  "Brescia",
  "Brindisi",
  "Cagliari",
  "Caltanissetta",
  "Campobasso",
  "Carbonia-Iglesias",
  "Caserta",
  "Catania",
  "Catanzaro",
  "Chieti",
  "Como",
  "Cosenza",
  "Cremona",
  "Crotone",
  "Cuneo",
  "Enna",
  "Fermo",
  "Ferrara",
  "Firenze",
  "Foggia",
  "Forl-Cesena",
  "Frosinone",
  "Genova",
  "Gorizia",
  "Grosseto",
  "Imperia",
  "Isernia",
  "La Spezia",
  "L'Aquila",
  "Latina",
  "Lecce",
  "Lecco",
  "Livorno",
  "Lodi",
  "Lucca",
  "Macerata",
  "Mantova",
  "Massa-Carrara",
  "Matera",
  "Messina",
  "Milano",
  "Modena",
  "Monza e della Brianza",
  "Napoli",
  "Novara",
  "Nuoro",
  "Olbia-Tempio",
  "Oristano",
  "Padova",
  "Palermo",
  "Parma",
  "Pavia",
  "Perugia",
  "Pesaro e Urbino",
  "Pescara",
  "Piacenza",
  "Pisa",
  "Pistoia",
  "Pordenone",
  "Potenza",
  "Prato",
  "Ragusa",
  "Ravenna",
  "Reggio Calabria",
  "Reggio Emilia",
  "Rieti",
  "Rimini",
  "Roma",
  "Rovigo",
  "Salerno",
  "Medio Campidano",
  "Sassari",
  "Savona",
  "Siena",
  "Siracusa",
  "Sondrio",
  "Taranto",
  "Teramo",
  "Terni",
  "Torino",
  "Ogliastra",
  "Trapani",
  "Trento",
  "Treviso",
  "Trieste",
  "Udine",
  "Varese",
  "Venezia",
  "Verbano-Cusio-Ossola",
  "Vercelli",
  "Verona",
  "Vibo Valentia",
  "Vicenza",
  "Viterbo"
];

},{}],843:[function(require,module,exports){
module["exports"] = [
  "AG",
  "AL",
  "AN",
  "AO",
  "AR",
  "AP",
  "AT",
  "AV",
  "BA",
  "BT",
  "BL",
  "BN",
  "BG",
  "BI",
  "BO",
  "BZ",
  "BS",
  "BR",
  "CA",
  "CL",
  "CB",
  "CI",
  "CE",
  "CT",
  "CZ",
  "CH",
  "CO",
  "CS",
  "CR",
  "KR",
  "CN",
  "EN",
  "FM",
  "FE",
  "FI",
  "FG",
  "FC",
  "FR",
  "GE",
  "GO",
  "GR",
  "IM",
  "IS",
  "SP",
  "AQ",
  "LT",
  "LE",
  "LC",
  "LI",
  "LO",
  "LU",
  "MC",
  "MN",
  "MS",
  "MT",
  "ME",
  "MI",
  "MO",
  "MB",
  "NA",
  "NO",
  "NU",
  "OT",
  "OR",
  "PD",
  "PA",
  "PR",
  "PV",
  "PG",
  "PU",
  "PE",
  "PC",
  "PI",
  "PT",
  "PN",
  "PZ",
  "PO",
  "RG",
  "RA",
  "RC",
  "RE",
  "RI",
  "RN",
  "RM",
  "RO",
  "SA",
  "VS",
  "SS",
  "SV",
  "SI",
  "SR",
  "SO",
  "TA",
  "TE",
  "TR",
  "TO",
  "OG",
  "TP",
  "TN",
  "TV",
  "TS",
  "UD",
  "VA",
  "VE",
  "VB",
  "VC",
  "VR",
  "VV",
  "VI",
  "VT"
];

},{}],844:[function(require,module,exports){
module["exports"] = [
  "#{street_name} #{building_number}",
  "#{street_name} #{building_number}, #{secondary_address}"
];

},{}],845:[function(require,module,exports){
module["exports"] = [
  "#{street_suffix} #{Name.first_name}",
  "#{street_suffix} #{Name.last_name}"
];

},{}],846:[function(require,module,exports){
module["exports"] = [
  "Piazza",
  "Strada",
  "Via",
  "Borgo",
  "Contrada",
  "Rotonda",
  "Incrocio"
];

},{}],847:[function(require,module,exports){
module["exports"] = [
  "24 ore",
  "24/7",
  "terza generazione",
  "quarta generazione",
  "quinta generazione",
  "sesta generazione",
  "asimmetrica",
  "asincrona",
  "background",
  "bi-direzionale",
  "biforcata",
  "bottom-line",
  "coerente",
  "coesiva",
  "composita",
  "sensibile al contesto",
  "basta sul contesto",
  "basata sul contenuto",
  "dedicata",
  "didattica",
  "direzionale",
  "discreta",
  "dinamica",
  "eco-centrica",
  "esecutiva",
  "esplicita",
  "full-range",
  "globale",
  "euristica",
  "alto livello",
  "olistica",
  "omogenea",
  "ibrida",
  "impattante",
  "incrementale",
  "intangibile",
  "interattiva",
  "intermediaria",
  "locale",
  "logistica",
  "massimizzata",
  "metodica",
  "mission-critical",
  "mobile",
  "modulare",
  "motivazionale",
  "multimedia",
  "multi-tasking",
  "nazionale",
  "neutrale",
  "nextgeneration",
  "non-volatile",
  "object-oriented",
  "ottima",
  "ottimizzante",
  "radicale",
  "real-time",
  "reciproca",
  "regionale",
  "responsiva",
  "scalabile",
  "secondaria",
  "stabile",
  "statica",
  "sistematica",
  "sistemica",
  "tangibile",
  "terziaria",
  "uniforme",
  "valore aggiunto"
];

},{}],848:[function(require,module,exports){
module["exports"] = [
  "valore aggiunto",
  "verticalizzate",
  "proattive",
  "forti",
  "rivoluzionari",
  "scalabili",
  "innovativi",
  "intuitivi",
  "strategici",
  "e-business",
  "mission-critical",
  "24/7",
  "globali",
  "B2B",
  "B2C",
  "granulari",
  "virtuali",
  "virali",
  "dinamiche",
  "magnetiche",
  "web",
  "interattive",
  "sexy",
  "back-end",
  "real-time",
  "efficienti",
  "front-end",
  "distributivi",
  "estensibili",
  "mondiali",
  "open-source",
  "cross-platform",
  "sinergiche",
  "out-of-the-box",
  "enterprise",
  "integrate",
  "di impatto",
  "wireless",
  "trasparenti",
  "next-generation",
  "cutting-edge",
  "visionari",
  "plug-and-play",
  "collaborative",
  "olistiche",
  "ricche"
];

},{}],849:[function(require,module,exports){
module["exports"] = [
  "partnerships",
  "comunit",
  "ROI",
  "soluzioni",
  "e-services",
  "nicchie",
  "tecnologie",
  "contenuti",
  "supply-chains",
  "convergenze",
  "relazioni",
  "architetture",
  "interfacce",
  "mercati",
  "e-commerce",
  "sistemi",
  "modelli",
  "schemi",
  "reti",
  "applicazioni",
  "metriche",
  "e-business",
  "funzionalit",
  "esperienze",
  "webservices",
  "metodologie"
];

},{}],850:[function(require,module,exports){
module["exports"] = [
  "implementate",
  "utilizzo",
  "integrate",
  "ottimali",
  "evolutive",
  "abilitate",
  "reinventate",
  "aggregate",
  "migliorate",
  "incentivate",
  "monetizzate",
  "sinergizzate",
  "strategiche",
  "deploy",
  "marchi",
  "accrescitive",
  "target",
  "sintetizzate",
  "spedizioni",
  "massimizzate",
  "innovazione",
  "guida",
  "estensioni",
  "generate",
  "exploit",
  "transizionali",
  "matrici",
  "ricontestualizzate"
];

},{}],851:[function(require,module,exports){
module["exports"] = [
  "adattiva",
  "avanzata",
  "migliorata",
  "assimilata",
  "automatizzata",
  "bilanciata",
  "centralizzata",
  "compatibile",
  "configurabile",
  "cross-platform",
  "decentralizzata",
  "digitalizzata",
  "distribuita",
  "piccola",
  "ergonomica",
  "esclusiva",
  "espansa",
  "estesa",
  "configurabile",
  "fondamentale",
  "orizzontale",
  "implementata",
  "innovativa",
  "integrata",
  "intuitiva",
  "inversa",
  "gestita",
  "obbligatoria",
  "monitorata",
  "multi-canale",
  "multi-laterale",
  "open-source",
  "operativa",
  "ottimizzata",
  "organica",
  "persistente",
  "polarizzata",
  "proattiva",
  "programmabile",
  "progressiva",
  "reattiva",
  "riallineata",
  "ricontestualizzata",
  "ridotta",
  "robusta",
  "sicura",
  "condivisibile",
  "stand-alone",
  "switchabile",
  "sincronizzata",
  "sinergica",
  "totale",
  "universale",
  "user-friendly",
  "versatile",
  "virtuale",
  "visionaria"
];

},{}],852:[function(require,module,exports){
var company = {};
module['exports'] = company;
company.suffix = require("./suffix");
company.noun = require("./noun");
company.descriptor = require("./descriptor");
company.adjective = require("./adjective");
company.bs_noun = require("./bs_noun");
company.bs_verb = require("./bs_verb");
company.bs_adjective = require("./bs_adjective");
company.name = require("./name");

},{"./adjective":847,"./bs_adjective":848,"./bs_noun":849,"./bs_verb":850,"./descriptor":851,"./name":853,"./noun":854,"./suffix":855}],853:[function(require,module,exports){
module["exports"] = [
  "#{Name.last_name} #{suffix}",
  "#{Name.last_name}-#{Name.last_name} #{suffix}",
  "#{Name.last_name}, #{Name.last_name} e #{Name.last_name} #{suffix}"
];

},{}],854:[function(require,module,exports){
module["exports"] = [
  "Abilit",
  "Access",
  "Adattatore",
  "Algoritmo",
  "Alleanza",
  "Analizzatore",
  "Applicazione",
  "Approccio",
  "Architettura",
  "Archivio",
  "Intelligenza artificiale",
  "Array",
  "Attitudine",
  "Benchmark",
  "Capacit",
  "Sfida",
  "Circuito",
  "Collaborazione",
  "Complessit",
  "Concetto",
  "Conglomerato",
  "Contingenza",
  "Core",
  "Database",
  "Data-warehouse",
  "Definizione",
  "Emulazione",
  "Codifica",
  "Criptazione",
  "Firmware",
  "Flessibilit",
  "Previsione",
  "Frame",
  "framework",
  "Funzione",
  "Funzionalit",
  "Interfaccia grafica",
  "Hardware",
  "Help-desk",
  "Gerarchia",
  "Hub",
  "Implementazione",
  "Infrastruttura",
  "Iniziativa",
  "Installazione",
  "Set di istruzioni",
  "Interfaccia",
  "Soluzione internet",
  "Intranet",
  "Conoscenza base",
  "Matrici",
  "Matrice",
  "Metodologia",
  "Middleware",
  "Migrazione",
  "Modello",
  "Moderazione",
  "Monitoraggio",
  "Moratoria",
  "Rete",
  "Architettura aperta",
  "Sistema aperto",
  "Orchestrazione",
  "Paradigma",
  "Parallelismo",
  "Policy",
  "Portale",
  "Struttura di prezzo",
  "Prodotto",
  "Produttivit",
  "Progetto",
  "Proiezione",
  "Protocollo",
  "Servizio clienti",
  "Software",
  "Soluzione",
  "Standardizzazione",
  "Strategia",
  "Struttura",
  "Successo",
  "Sovrastruttura",
  "Supporto",
  "Sinergia",
  "Task-force",
  "Finestra temporale",
  "Strumenti",
  "Utilizzazione",
  "Sito web",
  "Forza lavoro"
];

},{}],855:[function(require,module,exports){
module["exports"] = [
  "SPA",
  "e figli",
  "Group",
  "s.r.l."
];

},{}],856:[function(require,module,exports){
var it = {};
module['exports'] = it;
it.title = "Italian";
it.address = require("./address");
it.company = require("./company");
it.internet = require("./internet");
it.name = require("./name");
it.phone_number = require("./phone_number");

},{"./address":839,"./company":852,"./internet":859,"./name":861,"./phone_number":867}],857:[function(require,module,exports){
module["exports"] = [
  "com",
  "com",
  "com",
  "net",
  "org",
  "it",
  "it",
  "it"
];

},{}],858:[function(require,module,exports){
module["exports"] = [
  "gmail.com",
  "yahoo.com",
  "hotmail.com",
  "email.it",
  "libero.it",
  "yahoo.it"
];

},{}],859:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":857,"./free_email":858,"dup":302}],860:[function(require,module,exports){
module["exports"] = [
  "Aaron",
  "Akira",
  "Alberto",
  "Alessandro",
  "Alighieri",
  "Amedeo",
  "Amos",
  "Anselmo",
  "Antonino",
  "Arcibaldo",
  "Armando",
  "Artes",
  "Audenico",
  "Ausonio",
  "Bacchisio",
  "Battista",
  "Bernardo",
  "Boris",
  "Caio",
  "Carlo",
  "Cecco",
  "Cirino",
  "Cleros",
  "Costantino",
  "Damiano",
  "Danny",
  "Davide",
  "Demian",
  "Dimitri",
  "Domingo",
  "Dylan",
  "Edilio",
  "Egidio",
  "Elio",
  "Emanuel",
  "Enrico",
  "Ercole",
  "Ermes",
  "Ethan",
  "Eusebio",
  "Evangelista",
  "Fabiano",
  "Ferdinando",
  "Fiorentino",
  "Flavio",
  "Fulvio",
  "Gabriele",
  "Gastone",
  "Germano",
  "Giacinto",
  "Gianantonio",
  "Gianleonardo",
  "Gianmarco",
  "Gianriccardo",
  "Gioacchino",
  "Giordano",
  "Giuliano",
  "Graziano",
  "Guido",
  "Harry",
  "Iacopo",
  "Ilario",
  "Ione",
  "Italo",
  "Jack",
  "Jari",
  "Joey",
  "Joseph",
  "Kai",
  "Kociss",
  "Laerte",
  "Lauro",
  "Leonardo",
  "Liborio",
  "Lorenzo",
  "Ludovico",
  "Maggiore",
  "Manuele",
  "Mariano",
  "Marvin",
  "Matteo",
  "Mauro",
  "Michael",
  "Mirco",
  "Modesto",
  "Muzio",
  "Nabil",
  "Nathan",
  "Nick",
  "Noah",
  "Odino",
  "Olo",
  "Oreste",
  "Osea",
  "Pablo",
  "Patrizio",
  "Piererminio",
  "Pierfrancesco",
  "Piersilvio",
  "Priamo",
  "Quarto",
  "Quirino",
  "Radames",
  "Raniero",
  "Renato",
  "Rocco",
  "Romeo",
  "Rosalino",
  "Rudy",
  "Sabatino",
  "Samuel",
  "Santo",
  "Sebastian",
  "Serse",
  "Silvano",
  "Sirio",
  "Tancredi",
  "Terzo",
  "Timoteo",
  "Tolomeo",
  "Trevis",
  "Ubaldo",
  "Ulrico",
  "Valdo",
  "Neri",
  "Vinicio",
  "Walter",
  "Xavier",
  "Yago",
  "Zaccaria",
  "Abramo",
  "Adriano",
  "Alan",
  "Albino",
  "Alessio",
  "Alighiero",
  "Amerigo",
  "Anastasio",
  "Antimo",
  "Antonio",
  "Arduino",
  "Aroldo",
  "Arturo",
  "Augusto",
  "Avide",
  "Baldassarre",
  "Bettino",
  "Bortolo",
  "Caligola",
  "Carmelo",
  "Celeste",
  "Ciro",
  "Costanzo",
  "Dante",
  "Danthon",
  "Davis",
  "Demis",
  "Dindo",
  "Domiziano",
  "Edipo",
  "Egisto",
  "Eliziario",
  "Emidio",
  "Enzo",
  "Eriberto",
  "Erminio",
  "Ettore",
  "Eustachio",
  "Fabio",
  "Fernando",
  "Fiorenzo",
  "Folco",
  "Furio",
  "Gaetano",
  "Gavino",
  "Gerlando",
  "Giacobbe",
  "Giancarlo",
  "Gianmaria",
  "Giobbe",
  "Giorgio",
  "Giulio",
  "Gregorio",
  "Hector",
  "Ian",
  "Ippolito",
  "Ivano",
  "Jacopo",
  "Jarno",
  "Joannes",
  "Joshua",
  "Karim",
  "Kris",
  "Lamberto",
  "Lazzaro",
  "Leone",
  "Lino",
  "Loris",
  "Luigi",
  "Manfredi",
  "Marco",
  "Marino",
  "Marzio",
  "Mattia",
  "Max",
  "Michele",
  "Mirko",
  "Moreno",
  "Nadir",
  "Nazzareno",
  "Nestore",
  "Nico",
  "Noel",
  "Odone",
  "Omar",
  "Orfeo",
  "Osvaldo",
  "Pacifico",
  "Pericle",
  "Pietro",
  "Primo",
  "Quasimodo",
  "Radio",
  "Raoul",
  "Renzo",
  "Rodolfo",
  "Romolo",
  "Rosolino",
  "Rufo",
  "Sabino",
  "Sandro",
  "Sasha",
  "Secondo",
  "Sesto",
  "Silverio",
  "Siro",
  "Tazio",
  "Teseo",
  "Timothy",
  "Tommaso",
  "Tristano",
  "Umberto",
  "Ariel",
  "Artemide",
  "Assia",
  "Azue",
  "Benedetta",
  "Bibiana",
  "Brigitta",
  "Carmela",
  "Cassiopea",
  "Cesidia",
  "Cira",
  "Clea",
  "Cleopatra",
  "Clodovea",
  "Concetta",
  "Cosetta",
  "Cristyn",
  "Damiana",
  "Danuta",
  "Deborah",
  "Demi",
  "Diamante",
  "Diana",
  "Donatella",
  "Doriana",
  "Edvige",
  "Elda",
  "Elga",
  "Elsa",
  "Emilia",
  "Enrica",
  "Erminia",
  "Eufemia",
  "Evita",
  "Fatima",
  "Felicia",
  "Filomena",
  "Flaviana",
  "Fortunata",
  "Gelsomina",
  "Genziana",
  "Giacinta",
  "Gilda",
  "Giovanna",
  "Giulietta",
  "Grazia",
  "Guendalina",
  "Helga",
  "Ileana",
  "Ingrid",
  "Irene",
  "Isabel",
  "Isira",
  "Ivonne",
  "Jelena",
  "Jole",
  "Claudia",
  "Kayla",
  "Kristel",
  "Laura",
  "Lucia",
  "Lia",
  "Lidia",
  "Lisa",
  "Loredana",
  "Loretta",
  "Luce",
  "Lucrezia",
  "Luna",
  "Maika",
  "Marcella",
  "Maria",
  "Mariagiulia",
  "Marianita",
  "Mariapia",
  "Marieva",
  "Marina",
  "Maristella",
  "Maruska",
  "Matilde",
  "Mecren",
  "Mercedes",
  "Mietta",
  "Miriana",
  "Miriam",
  "Monia",
  "Morgana",
  "Naomi",
  "Nayade",
  "Nicoletta",
  "Ninfa",
  "Noemi",
  "Nunzia",
  "Olimpia",
  "Oretta",
  "Ortensia",
  "Penelope",
  "Piccarda",
  "Prisca",
  "Rebecca",
  "Rita",
  "Rosalba",
  "Rosaria",
  "Rosita",
  "Ruth",
  "Samira",
  "Sarita",
  "Selvaggia",
  "Shaira",
  "Sibilla",
  "Soriana",
  "Thea",
  "Tosca",
  "Ursula",
  "Vania",
  "Vera",
  "Vienna",
  "Violante",
  "Vitalba",
  "Zelida"
];

},{}],861:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.last_name = require("./last_name");
name.prefix = require("./prefix");
name.suffix = require("./suffix");
name.name = require("./name");

},{"./first_name":860,"./last_name":862,"./name":863,"./prefix":864,"./suffix":865}],862:[function(require,module,exports){
module["exports"] = [
  "Amato",
  "Barbieri",
  "Barone",
  "Basile",
  "Battaglia",
  "Bellini",
  "Benedetti",
  "Bernardi",
  "Bianc",
  "Bianchi",
  "Bruno",
  "Caputo",
  "Carbon",
  "Caruso",
  "Cattaneo",
  "Colombo",
  "Cont",
  "Conte",
  "Coppola",
  "Costa",
  "Costantin",
  "D'amico",
  "D'angelo",
  "Damico",
  "De Angelis",
  "De luca",
  "De rosa",
  "De Santis",
  "Donati",
  "Esposito",
  "Fabbri",
  "Farin",
  "Ferrara",
  "Ferrari",
  "Ferraro",
  "Ferretti",
  "Ferri",
  "Fior",
  "Fontana",
  "Galli",
  "Gallo",
  "Gatti",
  "Gentile",
  "Giordano",
  "Giuliani",
  "Grassi",
  "Grasso",
  "Greco",
  "Guerra",
  "Leone",
  "Lombardi",
  "Lombardo",
  "Longo",
  "Mancini",
  "Marchetti",
  "Marian",
  "Marini",
  "Marino",
  "Martinelli",
  "Martini",
  "Martino",
  "Mazza",
  "Messina",
  "Milani",
  "Montanari",
  "Monti",
  "Morelli",
  "Moretti",
  "Negri",
  "Neri",
  "Orlando",
  "Pagano",
  "Palmieri",
  "Palumbo",
  "Parisi",
  "Pellegrini",
  "Pellegrino",
  "Piras",
  "Ricci",
  "Rinaldi",
  "Riva",
  "Rizzi",
  "Rizzo",
  "Romano",
  "Ross",
  "Rossetti",
  "Ruggiero",
  "Russo",
  "Sala",
  "Sanna",
  "Santoro",
  "Sartori",
  "Serr",
  "Silvestri",
  "Sorrentino",
  "Testa",
  "Valentini",
  "Villa",
  "Vitale",
  "Vitali"
];

},{}],863:[function(require,module,exports){
arguments[4][797][0].apply(exports,arguments)
},{"dup":797}],864:[function(require,module,exports){
module["exports"] = [
  "Sig.",
  "Dott.",
  "Dr.",
  "Ing."
];

},{}],865:[function(require,module,exports){
arguments[4][309][0].apply(exports,arguments)
},{"dup":309}],866:[function(require,module,exports){
module["exports"] = [
  "+## ### ## ## ####",
  "+## ## #######",
  "+## ## ########",
  "+## ### #######",
  "+## ### ########",
  "+## #### #######",
  "+## #### ########",
  "0## ### ####",
  "+39 0## ### ###",
  "3## ### ###",
  "+39 3## ### ###"
];

},{}],867:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":866,"dup":312}],868:[function(require,module,exports){
module["exports"] = [
  "#{city_prefix}#{Name.first_name}#{city_suffix}",
  "#{Name.first_name}#{city_suffix}",
  "#{city_prefix}#{Name.last_name}#{city_suffix}",
  "#{Name.last_name}#{city_suffix}"
];

},{}],869:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],870:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  ""
];

},{}],871:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.city = require("./city");
address.street_name = require("./street_name");

},{"./city":868,"./city_prefix":869,"./city_suffix":870,"./postcode":872,"./state":873,"./state_abbr":874,"./street_name":875}],872:[function(require,module,exports){
module["exports"] = [
  "###-####"
];

},{}],873:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],874:[function(require,module,exports){
module["exports"] = [
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47"
];

},{}],875:[function(require,module,exports){
module["exports"] = [
  "#{Name.first_name}#{street_suffix}",
  "#{Name.last_name}#{street_suffix}"
];

},{}],876:[function(require,module,exports){
module["exports"] = [
  "090-####-####",
  "080-####-####",
  "070-####-####"
];

},{}],877:[function(require,module,exports){
arguments[4][371][0].apply(exports,arguments)
},{"./formats":876,"dup":371}],878:[function(require,module,exports){
var ja = {};
module['exports'] = ja;
ja.title = "Japanese";
ja.address = require("./address");
ja.phone_number = require("./phone_number");
ja.cell_phone = require("./cell_phone");
ja.name = require("./name");

},{"./address":871,"./cell_phone":877,"./name":880,"./phone_number":884}],879:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],880:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.last_name = require("./last_name");
name.first_name = require("./first_name");
name.name = require("./name");

},{"./first_name":879,"./last_name":881,"./name":882}],881:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],882:[function(require,module,exports){
module["exports"] = [
  "#{last_name} #{first_name}"
];

},{}],883:[function(require,module,exports){
module["exports"] = [
  "0####-#-####",
  "0###-##-####",
  "0##-###-####",
  "0#-####-####"
];

},{}],884:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":883,"dup":312}],885:[function(require,module,exports){
module["exports"] = [
  "#{city_name}#{city_suffix}"
];

},{}],886:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],887:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  ""
];

},{}],888:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.city_suffix = require("./city_suffix");
address.city_name = require("./city_name");
address.city = require("./city");
address.street_root = require("./street_root");
address.street_suffix = require("./street_suffix");
address.street_name = require("./street_name");

},{"./city":885,"./city_name":886,"./city_suffix":887,"./postcode":889,"./state":890,"./state_abbr":891,"./street_name":892,"./street_root":893,"./street_suffix":894}],889:[function(require,module,exports){
module["exports"] = [
  "###-###"
];

},{}],890:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],891:[function(require,module,exports){
arguments[4][890][0].apply(exports,arguments)
},{"dup":890}],892:[function(require,module,exports){
module["exports"] = [
  "#{street_root}#{street_suffix}"
];

},{}],893:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],894:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  ""
];

},{}],895:[function(require,module,exports){
var company = {};
module['exports'] = company;
company.suffix = require("./suffix");
company.prefix = require("./prefix");
company.name = require("./name");

},{"./name":896,"./prefix":897,"./suffix":898}],896:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{Name.first_name}",
  "#{Name.first_name} #{suffix}"
];

},{}],897:[function(require,module,exports){
module["exports"] = [
  "",
  ""
];

},{}],898:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],899:[function(require,module,exports){
var ko = {};
module['exports'] = ko;
ko.title = "Korean";
ko.address = require("./address");
ko.phone_number = require("./phone_number");
ko.company = require("./company");
ko.internet = require("./internet");
ko.lorem = require("./lorem");
ko.name = require("./name");

},{"./address":888,"./company":895,"./internet":902,"./lorem":903,"./name":906,"./phone_number":910}],900:[function(require,module,exports){
module["exports"] = [
  "co.kr",
  "com",
  "biz",
  "info",
  "ne.kr",
  "net",
  "or.kr",
  "org"
];

},{}],901:[function(require,module,exports){
module["exports"] = [
  "gmail.com",
  "yahoo.co.kr",
  "hanmail.net",
  "naver.com"
];

},{}],902:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":900,"./free_email":901,"dup":302}],903:[function(require,module,exports){
arguments[4][380][0].apply(exports,arguments)
},{"./words":904,"dup":380}],904:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ".",
  "",
  "",
  "",
  "",
  ".",
  "",
  "",
  "",
  "",
  "",
  "",
  ".",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ".",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ".",
  ",",
  "",
  "",
  "",
  "3",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ".",
  "",
  "",
  "",
  "",
  ".",
  "",
  "",
  "",
  "",
  "",
  "",
  ".",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ",",
  "",
  "",
  "",
  "",
  "",
  ".",
  "",
  "",
  "",
  ".",
  "",
  "",
  "",
  "",
  "",
  "",
  ".",
  "",
  "",
  ".",
  "",
  "",
  "",
  "",
  ".",
  "",
  "",
  "",
  "",
  "",
  ".",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "."
];

},{}],905:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],906:[function(require,module,exports){
arguments[4][880][0].apply(exports,arguments)
},{"./first_name":905,"./last_name":907,"./name":908,"dup":880}],907:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],908:[function(require,module,exports){
arguments[4][882][0].apply(exports,arguments)
},{"dup":882}],909:[function(require,module,exports){
module["exports"] = [
  "0#-#####-####",
  "0##-###-####",
  "0##-####-####"
];

},{}],910:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":909,"dup":312}],911:[function(require,module,exports){
module["exports"] = [
  "#",
  "##"
];

},{}],912:[function(require,module,exports){
module["exports"] = [
  "#{city_root}#{city_suffix}"
];

},{}],913:[function(require,module,exports){
module["exports"] = [
  "Fet",
  "Gjes",
  "Hy",
  "Inn",
  "Fager",
  "Lille",
  "Lo",
  "Mal",
  "Nord",
  "Nr",
  "Sand",
  "Sme",
  "Stav",
  "Stor",
  "Tand",
  "Ut",
  "Vest"
];

},{}],914:[function(require,module,exports){
module["exports"] = [
  "berg",
  "borg",
  "by",
  "b",
  "dal",
  "eid",
  "fjell",
  "fjord",
  "foss",
  "grunn",
  "hamn",
  "havn",
  "helle",
  "mark",
  "nes",
  "odden",
  "sand",
  "sjen",
  "stad",
  "strand",
  "strm",
  "sund",
  "vik",
  "vr",
  "vg",
  "",
  "y",
  "s"
];

},{}],915:[function(require,module,exports){
module["exports"] = [
  "sgate",
  "svei",
  "s Gate",
  "s Vei",
  "gata",
  "veien"
];

},{}],916:[function(require,module,exports){
module["exports"] = [
  "Norge"
];

},{}],917:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city_root = require("./city_root");
address.city_suffix = require("./city_suffix");
address.street_prefix = require("./street_prefix");
address.street_root = require("./street_root");
address.street_suffix = require("./street_suffix");
address.common_street_suffix = require("./common_street_suffix");
address.building_number = require("./building_number");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.state = require("./state");
address.city = require("./city");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":911,"./city":912,"./city_root":913,"./city_suffix":914,"./common_street_suffix":915,"./default_country":916,"./postcode":918,"./secondary_address":919,"./state":920,"./street_address":921,"./street_name":922,"./street_prefix":923,"./street_root":924,"./street_suffix":925}],918:[function(require,module,exports){
module["exports"] = [
  "####",
  "####",
  "####",
  "0###"
];

},{}],919:[function(require,module,exports){
module["exports"] = [
  "Leil. ###",
  "Oppgang A",
  "Oppgang B"
];

},{}],920:[function(require,module,exports){
module["exports"] = [
  ""
];

},{}],921:[function(require,module,exports){
arguments[4][324][0].apply(exports,arguments)
},{"dup":324}],922:[function(require,module,exports){
module["exports"] = [
  "#{street_root}#{street_suffix}",
  "#{street_prefix} #{street_root}#{street_suffix}",
  "#{Name.first_name}#{common_street_suffix}",
  "#{Name.last_name}#{common_street_suffix}"
];

},{}],923:[function(require,module,exports){
module["exports"] = [
  "vre",
  "Nedre",
  "Sndre",
  "Gamle",
  "stre",
  "Vestre"
];

},{}],924:[function(require,module,exports){
module["exports"] = [
  "Eike",
  "Bjrke",
  "Gran",
  "Vass",
  "Furu",
  "Litj",
  "Lille",
  "Hy",
  "Fosse",
  "Elve",
  "Ku",
  "Konvall",
  "Soldugg",
  "Hestemyr",
  "Granitt",
  "Hegge",
  "Rogne",
  "Fiol",
  "Sol",
  "Ting",
  "Malm",
  "Klokker",
  "Preste",
  "Dam",
  "Geiterygg",
  "Bekke",
  "Berg",
  "Kirke",
  "Kors",
  "Bru",
  "Blveis",
  "Torg",
  "Sj"
];

},{}],925:[function(require,module,exports){
module["exports"] = [
  "allen",
  "bakken",
  "berget",
  "brten",
  "eggen",
  "engen",
  "ekra",
  "faret",
  "flata",
  "gata",
  "gjerdet",
  "grenda",
  "gropa",
  "hagen",
  "haugen",
  "havna",
  "holtet",
  "hgda",
  "jordet",
  "kollen",
  "kroken",
  "lia",
  "lunden",
  "lyngen",
  "lkka",
  "marka",
  "moen",
  "myra",
  "plassen",
  "ringen",
  "roa",
  "ra",
  "skogen",
  "skrenten",
  "spranget",
  "stien",
  "stranda",
  "stubben",
  "stykket",
  "svingen",
  "tjernet",
  "toppen",
  "tunet",
  "vollen",
  "vika",
  "sen"
];

},{}],926:[function(require,module,exports){
arguments[4][425][0].apply(exports,arguments)
},{"./name":927,"./suffix":928,"dup":425}],927:[function(require,module,exports){
module["exports"] = [
  "#{Name.last_name} #{suffix}",
  "#{Name.last_name}-#{Name.last_name}",
  "#{Name.last_name}, #{Name.last_name} og #{Name.last_name}"
];

},{}],928:[function(require,module,exports){
module["exports"] = [
  "Gruppen",
  "AS",
  "ASA",
  "BA",
  "RFH",
  "og Snner"
];

},{}],929:[function(require,module,exports){
var nb_NO = {};
module['exports'] = nb_NO;
nb_NO.title = "Norwegian";
nb_NO.address = require("./address");
nb_NO.company = require("./company");
nb_NO.internet = require("./internet");
nb_NO.name = require("./name");
nb_NO.phone_number = require("./phone_number");

},{"./address":917,"./company":926,"./internet":931,"./name":934,"./phone_number":941}],930:[function(require,module,exports){
module["exports"] = [
  "no",
  "com",
  "net",
  "org"
];

},{}],931:[function(require,module,exports){
arguments[4][430][0].apply(exports,arguments)
},{"./domain_suffix":930,"dup":430}],932:[function(require,module,exports){
module["exports"] = [
  "Emma",
  "Sara",
  "Thea",
  "Ida",
  "Julie",
  "Nora",
  "Emilie",
  "Ingrid",
  "Hanna",
  "Maria",
  "Sofie",
  "Anna",
  "Malin",
  "Amalie",
  "Vilde",
  "Frida",
  "Andrea",
  "Tuva",
  "Victoria",
  "Mia",
  "Karoline",
  "Mathilde",
  "Martine",
  "Linnea",
  "Marte",
  "Hedda",
  "Marie",
  "Helene",
  "Silje",
  "Leah",
  "Maja",
  "Elise",
  "Oda",
  "Kristine",
  "Aurora",
  "Kaja",
  "Camilla",
  "Mari",
  "Maren",
  "Mina",
  "Selma",
  "Jenny",
  "Celine",
  "Eline",
  "Sunniva",
  "Natalie",
  "Tiril",
  "Synne",
  "Sandra",
  "Madeleine"
];

},{}],933:[function(require,module,exports){
module["exports"] = [
  "Emma",
  "Sara",
  "Thea",
  "Ida",
  "Julie",
  "Nora",
  "Emilie",
  "Ingrid",
  "Hanna",
  "Maria",
  "Sofie",
  "Anna",
  "Malin",
  "Amalie",
  "Vilde",
  "Frida",
  "Andrea",
  "Tuva",
  "Victoria",
  "Mia",
  "Karoline",
  "Mathilde",
  "Martine",
  "Linnea",
  "Marte",
  "Hedda",
  "Marie",
  "Helene",
  "Silje",
  "Leah",
  "Maja",
  "Elise",
  "Oda",
  "Kristine",
  "Aurora",
  "Kaja",
  "Camilla",
  "Mari",
  "Maren",
  "Mina",
  "Selma",
  "Jenny",
  "Celine",
  "Eline",
  "Sunniva",
  "Natalie",
  "Tiril",
  "Synne",
  "Sandra",
  "Madeleine",
  "Markus",
  "Mathias",
  "Kristian",
  "Jonas",
  "Andreas",
  "Alexander",
  "Martin",
  "Sander",
  "Daniel",
  "Magnus",
  "Henrik",
  "Tobias",
  "Kristoffer",
  "Emil",
  "Adrian",
  "Sebastian",
  "Marius",
  "Elias",
  "Fredrik",
  "Thomas",
  "Sondre",
  "Benjamin",
  "Jakob",
  "Oliver",
  "Lucas",
  "Oskar",
  "Nikolai",
  "Filip",
  "Mats",
  "William",
  "Erik",
  "Simen",
  "Ole",
  "Eirik",
  "Isak",
  "Kasper",
  "Noah",
  "Lars",
  "Joakim",
  "Johannes",
  "Hkon",
  "Sindre",
  "Jrgen",
  "Herman",
  "Anders",
  "Jonathan",
  "Even",
  "Theodor",
  "Mikkel",
  "Aksel"
];

},{}],934:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.feminine_name = require("./feminine_name");
name.masculine_name = require("./masculine_name");
name.last_name = require("./last_name");
name.prefix = require("./prefix");
name.suffix = require("./suffix");
name.name = require("./name");

},{"./feminine_name":932,"./first_name":933,"./last_name":935,"./masculine_name":936,"./name":937,"./prefix":938,"./suffix":939}],935:[function(require,module,exports){
module["exports"] = [
  "Johansen",
  "Hansen",
  "Andersen",
  "Kristiansen",
  "Larsen",
  "Olsen",
  "Solberg",
  "Andresen",
  "Pedersen",
  "Nilsen",
  "Berg",
  "Halvorsen",
  "Karlsen",
  "Svendsen",
  "Jensen",
  "Haugen",
  "Martinsen",
  "Eriksen",
  "Srensen",
  "Johnsen",
  "Myhrer",
  "Johannessen",
  "Nielsen",
  "Hagen",
  "Pettersen",
  "Bakke",
  "Skuterud",
  "Lken",
  "Gundersen",
  "Strand",
  "Jrgensen",
  "Kvarme",
  "Red",
  "Sther",
  "Stensrud",
  "Moe",
  "Kristoffersen",
  "Jakobsen",
  "Holm",
  "Aas",
  "Lie",
  "Moen",
  "Andreassen",
  "Vedvik",
  "Nguyen",
  "Jacobsen",
  "Torgersen",
  "Ruud",
  "Krogh",
  "Christiansen",
  "Bjerke",
  "Aalerud",
  "Borge",
  "Srlie",
  "Berge",
  "stli",
  "degrd",
  "Torp",
  "Henriksen",
  "Haukelidster",
  "Fjeld",
  "Danielsen",
  "Aasen",
  "Fredriksen",
  "Dahl",
  "Berntsen",
  "Arnesen",
  "Wold",
  "Thoresen",
  "Solheim",
  "Skoglund",
  "Bakken",
  "Amundsen",
  "Solli",
  "Smogeli",
  "Kristensen",
  "Glosli",
  "Fossum",
  "Evensen",
  "Eide",
  "Carlsen",
  "stby",
  "Vegge",
  "Tangen",
  "Smedsrud",
  "Olstad",
  "Lunde",
  "Kleven",
  "Huseby",
  "Bjrnstad",
  "Ryan",
  "Rasmussen",
  "Nygrd",
  "Nordskaug",
  "Nordby",
  "Mathisen",
  "Hopland",
  "Gran",
  "Finstad",
  "Edvardsen"
];

},{}],936:[function(require,module,exports){
module["exports"] = [
  "Markus",
  "Mathias",
  "Kristian",
  "Jonas",
  "Andreas",
  "Alexander",
  "Martin",
  "Sander",
  "Daniel",
  "Magnus",
  "Henrik",
  "Tobias",
  "Kristoffer",
  "Emil",
  "Adrian",
  "Sebastian",
  "Marius",
  "Elias",
  "Fredrik",
  "Thomas",
  "Sondre",
  "Benjamin",
  "Jakob",
  "Oliver",
  "Lucas",
  "Oskar",
  "Nikolai",
  "Filip",
  "Mats",
  "William",
  "Erik",
  "Simen",
  "Ole",
  "Eirik",
  "Isak",
  "Kasper",
  "Noah",
  "Lars",
  "Joakim",
  "Johannes",
  "Hkon",
  "Sindre",
  "Jrgen",
  "Herman",
  "Anders",
  "Jonathan",
  "Even",
  "Theodor",
  "Mikkel",
  "Aksel"
];

},{}],937:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{first_name} #{last_name}",
  "#{first_name} #{last_name} #{suffix}",
  "#{feminine_name} #{feminine_name} #{last_name}",
  "#{masculine_name} #{masculine_name} #{last_name}",
  "#{first_name} #{last_name} #{last_name}",
  "#{first_name} #{last_name}"
];

},{}],938:[function(require,module,exports){
module["exports"] = [
  "Dr.",
  "Prof."
];

},{}],939:[function(require,module,exports){
module["exports"] = [
  "Jr.",
  "Sr.",
  "I",
  "II",
  "III",
  "IV",
  "V"
];

},{}],940:[function(require,module,exports){
module["exports"] = [
  "########",
  "## ## ## ##",
  "### ## ###",
  "+47 ## ## ## ##"
];

},{}],941:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":940,"dup":312}],942:[function(require,module,exports){
module["exports"] = [
  "Bhaktapur",
  "Biratnagar",
  "Birendranagar",
  "Birgunj",
  "Butwal",
  "Damak",
  "Dharan",
  "Gaur",
  "Gorkha",
  "Hetauda",
  "Itahari",
  "Janakpur",
  "Kathmandu",
  "Lahan",
  "Nepalgunj",
  "Pokhara"
];

},{}],943:[function(require,module,exports){
module["exports"] = [
  "Nepal"
];

},{}],944:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.postcode = require("./postcode");
address.state = require("./state");
address.city = require("./city");
address.default_country = require("./default_country");

},{"./city":942,"./default_country":943,"./postcode":945,"./state":946}],945:[function(require,module,exports){
module["exports"] = [
  0
];

},{}],946:[function(require,module,exports){
module["exports"] = [
  "Baglung",
  "Banke",
  "Bara",
  "Bardiya",
  "Bhaktapur",
  "Bhojupu",
  "Chitwan",
  "Dailekh",
  "Dang",
  "Dhading",
  "Dhankuta",
  "Dhanusa",
  "Dolakha",
  "Dolpha",
  "Gorkha",
  "Gulmi",
  "Humla",
  "Ilam",
  "Jajarkot",
  "Jhapa",
  "Jumla",
  "Kabhrepalanchok",
  "Kalikot",
  "Kapilvastu",
  "Kaski",
  "Kathmandu",
  "Lalitpur",
  "Lamjung",
  "Manang",
  "Mohottari",
  "Morang",
  "Mugu",
  "Mustang",
  "Myagdi",
  "Nawalparasi",
  "Nuwakot",
  "Palpa",
  "Parbat",
  "Parsa",
  "Ramechhap",
  "Rauswa",
  "Rautahat",
  "Rolpa",
  "Rupandehi",
  "Sankhuwasabha",
  "Sarlahi",
  "Sindhuli",
  "Sindhupalchok",
  "Sunsari",
  "Surket",
  "Syangja",
  "Tanahu",
  "Terhathum"
];

},{}],947:[function(require,module,exports){
arguments[4][538][0].apply(exports,arguments)
},{"./suffix":948,"dup":538}],948:[function(require,module,exports){
module["exports"] = [
  "Pvt Ltd",
  "Group",
  "Ltd",
  "Limited"
];

},{}],949:[function(require,module,exports){
var nep = {};
module['exports'] = nep;
nep.title = "Nepalese";
nep.name = require("./name");
nep.address = require("./address");
nep.internet = require("./internet");
nep.company = require("./company");
nep.phone_number = require("./phone_number");

},{"./address":944,"./company":947,"./internet":952,"./name":954,"./phone_number":957}],950:[function(require,module,exports){
module["exports"] = [
  "np",
  "com",
  "info",
  "net",
  "org"
];

},{}],951:[function(require,module,exports){
module["exports"] = [
  "worldlink.com.np",
  "gmail.com",
  "yahoo.com",
  "hotmail.com"
];

},{}],952:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":950,"./free_email":951,"dup":302}],953:[function(require,module,exports){
module["exports"] = [
  "Aarav",
  "Ajita",
  "Amit",
  "Amita",
  "Amrit",
  "Arijit",
  "Ashmi",
  "Asmita",
  "Bibek",
  "Bijay",
  "Bikash",
  "Bina",
  "Bishal",
  "Bishnu",
  "Buddha",
  "Deepika",
  "Dipendra",
  "Gagan",
  "Ganesh",
  "Khem",
  "Krishna",
  "Laxmi",
  "Manisha",
  "Nabin",
  "Nikita",
  "Niraj",
  "Nischal",
  "Padam",
  "Pooja",
  "Prabin",
  "Prakash",
  "Prashant",
  "Prem",
  "Purna",
  "Rajendra",
  "Rajina",
  "Raju",
  "Rakesh",
  "Ranjan",
  "Ratna",
  "Sagar",
  "Sandeep",
  "Sanjay",
  "Santosh",
  "Sarita",
  "Shilpa",
  "Shirisha",
  "Shristi",
  "Siddhartha",
  "Subash",
  "Sumeet",
  "Sunita",
  "Suraj",
  "Susan",
  "Sushant"
];

},{}],954:[function(require,module,exports){
arguments[4][544][0].apply(exports,arguments)
},{"./first_name":953,"./last_name":955,"dup":544}],955:[function(require,module,exports){
module["exports"] = [
  "Adhikari",
  "Aryal",
  "Baral",
  "Basnet",
  "Bastola",
  "Basynat",
  "Bhandari",
  "Bhattarai",
  "Chettri",
  "Devkota",
  "Dhakal",
  "Dongol",
  "Ghale",
  "Gurung",
  "Gyawali",
  "Hamal",
  "Jung",
  "KC",
  "Kafle",
  "Karki",
  "Khadka",
  "Koirala",
  "Lama",
  "Limbu",
  "Magar",
  "Maharjan",
  "Niroula",
  "Pandey",
  "Pradhan",
  "Rana",
  "Raut",
  "Sai",
  "Shai",
  "Shakya",
  "Sherpa",
  "Shrestha",
  "Subedi",
  "Tamang",
  "Thapa"
];

},{}],956:[function(require,module,exports){
module["exports"] = [
  "##-#######",
  "+977-#-#######",
  "+977########"
];

},{}],957:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":956,"dup":312}],958:[function(require,module,exports){
module["exports"] = [
  "#",
  "##",
  "###",
  "###a",
  "###b",
  "###c",
  "### I",
  "### II",
  "### III"
];

},{}],959:[function(require,module,exports){
module["exports"] = [
  "#{city_prefix}#{city_suffix}",
  "#{city_prefix}"
];

},{}],960:[function(require,module,exports){
module["exports"] = [
  "Aagte",
  "Aal",
  "Aalden",
  "Aals",
  "Aalst",
  "Aalsum",
  "Aanschot",
  "Aarden",
  "Aarle",
  "Abbe",
  "Abbegea",
  "Abben",
  "Abbestede",
  "Abcoven",
  "Absdale",
  "Abts",
  "Acht",
  "Achter",
  "Achterste",
  "Achtmaal",
  "Achttien",
  "Acquoy",
  "Aduard",
  "Aduarder",
  "Aekinga",
  "Aerde",
  "Aerden",
  "Aerdt",
  "Afferden",
  "Aijen",
  "Akersloot",
  "Akker",
  "Akkerput",
  "Akkrun",
  "Akmarijp",
  "Aldeboarn",
  "Aldegae",
  "Aldtsjerk",
  "Aling",
  "Alkmaar",
  "Allersma",
  "Allinga",
  "Almere",
  "Alphen",
  "Altena",
  "Alteveer",
  "Alting",
  "Altweert",
  "Alverna",
  "Ameide",
  "Amerika",
  "Amerongen",
  "Ammerstol",
  "Ams",
  "Amster",
  "Andel",
  "Angeren",
  "Anholt",
  "Anjum",
  "Anke",
  "Ankum",
  "Anna",
  "Annendaal",
  "Anneville",
  "Anreep",
  "Ansen",
  "Apeldoorn",
  "Apen",
  "Appel",
  "Appen",
  "Arcen",
  "Archem",
  "Arendnest",
  "Arensge",
  "Arkens",
  "Armweide",
  "Arnhem",
  "Arnoud",
  "Arrin",
  "Arrir",
  "Arum",
  "Arwerd",
  "Asch",
  "Asenray",
  "Asperen",
  "Asschat",
  "Assel",
  "Asselt",
  "Assen",
  "Asten",
  "Atze",
  "Augs",
  "Averlo",
  "Avest",
  "Azelo",
  "Azewijn",
  "Ba",
  "Baaium",
  "Baak",
  "Baaks",
  "Baal",
  "Baamsum",
  "Baan",
  "Baard",
  "Baarder",
  "Baarle",
  "Baarlo",
  "Baars",
  "Baarschot",
  "Baexem",
  "Baflo",
  "Bahr",
  "Bakel",
  "Bakelse",
  "Bakertand",
  "Bakke",
  "Bakkerom",
  "Balgoij",
  "Balinge",
  "Ballast",
  "Balleman",
  "Ballum",
  "Balma",
  "Bane",
  "Bankert",
  "Bantega",
  "Bare",
  "Bargebek",
  "Barlage",
  "Barlaque",
  "Barlo",
  "Barnflair",
  "Barrier",
  "Bars",
  "Basse",
  "Basser",
  "Baten",
  "Bath",
  "Bathmen",
  "Bavinkel",
  "Bazuin",
  "Bears",
  "Beckum",
  "Bedaf",
  "Bedum",
  "Beekb",
  "Beekkant",
  "Beemdkant",
  "Beemte",
  "Beertsen",
  "Beerze",
  "Beerzer",
  "Beesd",
  "Beetgum",
  "Beetgumer",
  "Behelp",
  "Beilen",
  "Beinum",
  "Beke",
  "Beldert",
  "Belgen",
  "Belgeren",
  "Belt",
  "Belvert",
  "Bemmel",
  "Bemmer",
  "Benderse",
  "Beneden",
  "Benne",
  "Bennekom",
  "Bent",
  "Bente",
  "Benthem",
  "Berg",
  "Bergakker",
  "Bergen",
  "Bergens",
  "Bergerden",
  "Bergharen",
  "Berghem",
  "Berghum",
  "Bergstoep",
  "Berik",
  "Beringe",
  "Berk",
  "Berke",
  "Berken",
  "Berkt",
  "Berlicum",
  "Bern",
  "Besse",
  "Besthmen",
  "Beswerd",
  "Bethlehem",
  "Beugt",
  "Beuke",
  "Beun",
  "Beusb",
  "Beusichem",
  "Bever",
  "Bidding",
  "Biert",
  "Bierum",
  "Biessum",
  "Biest",
  "Biezen",
  "Bigge",
  "Bijster",
  "Bijsteren",
  "Billing",
  "Bilt",
  "Bingerden",
  "Bisselt",
  "Bissen",
  "Blaker",
  "Blaricum",
  "Blauhs",
  "Blauw",
  "Blauwe",
  "Blauwen",
  "Bleijen",
  "Bleijs",
  "Blekslage",
  "Blenkert",
  "Blerick",
  "Blessum",
  "Blije",
  "Blijham",
  "Blijnse",
  "Blok",
  "Blokken",
  "Blokum",
  "Boazum",
  "Boberden",
  "Bocholtz",
  "Bocht",
  "Boeiink",
  "Boek",
  "Boekel",
  "Boekelo",
  "Boekelte",
  "Boekend",
  "Boer",
  "Boerakker",
  "Boerelaan",
  "Boeren",
  "Boerengat",
  "Boerenhol",
  "Boerhaar",
  "Boijl",
  "Boks",
  "Boksum",
  "Bokt",
  "Bollinga",
  "Bols",
  "Bolst",
  "Bolt",
  "Bommerig",
  "Bong",
  "Bonkwert",
  "Bonner",
  "Bonrepas",
  "Bontebok",
  "Boomen",
  "Boord",
  "Borger",
  "Borgharen",
  "Borgs",
  "Borgweg",
  "Borkel",
  "Borkeld",
  "Born",
  "Borne",
  "Borneo",
  "Bornwird",
  "Bos",
  "Boschkens",
  "Bosje",
  "Bosjes",
  "Boskamp",
  "Boskant",
  "Boskoop",
  "Boslust",
  "Bosschen",
  "Bosscher",
  "Bosven",
  "Boter",
  "Botshoofd",
  "Boukoul",
  "Bourtange",
  "Boven",
  "Bovenstad",
  "Boxtel",
  "Braak",
  "Braamt",
  "Brabander",
  "Brakel",
  "Brand",
  "Brande",
  "Brandt",
  "Brantgum",
  "Breda",
  "Brede",
  "Bree",
  "Breede",
  "Breedeweg",
  "Breehees",
  "Breezand",
  "Brem",
  "Breskens",
  "Breugel",
  "Breukele",
  "Breyvin",
  "Brielle",
  "Brigdamme",
  "Brij",
  "Brillerij",
  "Briltil",
  "Brinkmans",
  "Britsum",
  "Britswert",
  "Broek",
  "Broekens",
  "Broekkant",
  "Brommelen",
  "Brons",
  "Bruchem",
  "Bruggen",
  "Brugger",
  "Bruil",
  "Bruinisse",
  "Bruister",
  "Brumhold",
  "Brunssum",
  "Brunsting",
  "Bruntinge",
  "Buchten",
  "Buggenum",
  "Buis",
  "Buiten",
  "Bulkenaar",
  "Bult",
  "Bultinge",
  "Bunne",
  "Bunnik",
  "Burdaard",
  "Burger",
  "Burgh",
  "Burgt",
  "Burgum",
  "Burgwerd",
  "Burstum",
  "Burum",
  "Bussel",
  "Busselte",
  "Busser",
  "Buttinge",
  "Buurtje",
  "Cadier",
  "Cadzand",
  "Calfven",
  "Calslagen",
  "Caluna",
  "Camerig",
  "Capelle",
  "Carnisse",
  "Cartils",
  "Castelr",
  "Castenray",
  "Castert",
  "Castricum",
  "Catsop",
  "Chaam",
  "Clinge",
  "Coevorden",
  "Colmont",
  "Cornjum",
  "Cornwerd",
  "Cottessen",
  "Crapoel",
  "Crau",
  "Crix",
  "Crob",
  "Croy",
  "Culemborg",
  "Daarle",
  "Dale",
  "Dalem",
  "Dalen",
  "Daler",
  "Dalerend",
  "Dalerpeel",
  "Dallinge",
  "Damwld",
  "Daniken",
  "Darp",
  "Dassemus",
  "Dearsum",
  "Dedgum",
  "Deelen",
  "Deelse",
  "Deelshurk",
  "Deense",
  "Deest",
  "Deil",
  "Deinum",
  "Dekes",
  "Dekkers",
  "Del",
  "Delden",
  "Delf",
  "Delft",
  "Dellen",
  "Delwijnen",
  "Demen",
  "Den ",
  "Deursen",
  "Deuteren",
  "Deventer",
  "Dieden",
  "Diemen",
  "Diepen",
  "Diependal",
  "Diepswal",
  "Diermen",
  "Dieskant",
  "Dieteren",
  "Diever",
  "Dijken",
  "Dijker",
  "Dijkster",
  "Dijkwel",
  "Dintelsas",
  "Dinther",
  "Dintherse",
  "Diphoorn",
  "Dirkshorn",
  "Dis",
  "Diunt",
  "Doenrade",
  "Does",
  "Doeveren",
  "Doezum",
  "Doijum",
  "Dokkum",
  "Doldersum",
  "Dom",
  "Dommelen",
  "Donderen",
  "Dongen",
  "Donia",
  "Doniaga",
  "Donzel",
  "Dood",
  "Doodstil",
  "Doon",
  "Doorn",
  "Doornen",
  "Doornik",
  "Doorning",
  "Doorwerth",
  "Doosje",
  "Dorkwerd",
  "Dorst",
  "Dorther",
  "Douverge",
  "Douwen",
  "Draai",
  "Drachten",
  "Dreischor",
  "Drie",
  "Drieboere",
  "Driehuis",
  "Driene",
  "Dries",
  "Driewegen",
  "Driezum",
  "Drien",
  "Drijber",
  "Drimmelen",
  "Drogeham",
  "Drogt",
  "Dronrijp",
  "Dronten",
  "Druif",
  "Drunen",
  "Druten",
  "Drylts",
  "Duifhuis",
  "Duinen",
  "Duiven",
  "Duizel",
  "Duizend",
  "Dulder",
  "Dunsborg",
  "Dussen",
  "Duur",
  "Duurends",
  "Eagum",
  "Earnewld",
  "Easterein",
  "Eastermar",
  "Easthim",
  "Echt",
  "Echten",
  "Echtener",
  "Echter",
  "Eder",
  "Eede",
  "Eefsele",
  "Eekt",
  "Eekwerd",
  "Eelde",
  "Eelen",
  "Eems",
  "Eemster",
  "Eemten",
  "Een",
  "Eenigen",
  "Eenrum",
  "Eenum",
  "Eerde",
  "Eersel",
  "Eerste",
  "Ees",
  "Eesterga",
  "Effen",
  "Egchel",
  "Egede",
  "Egmond",
  "Egypte",
  "Eikelen",
  "Eikelhof",
  "Eimeren",
  "Eindewege",
  "Eindje",
  "Ekamp",
  "Elde",
  "Elden",
  "Eldik",
  "Eldrik",
  "Elft",
  "Elkerzee",
  "Ellemeet",
  "Eller",
  "Ellerhei",
  "Ellersing",
  "Elsen",
  "Elshof",
  "Elspeet",
  "Elst",
  "Elsteren",
  "Elzet",
  "Emmeloord",
  "Emmen",
  "Empel",
  "Endepoel",
  "Eng",
  "Enge",
  "Engel",
  "Engelbert",
  "Engelen",
  "Engelum",
  "Englum",
  "Engwegen",
  "Engwierum",
  "Enk",
  "Ensched",
  "Enspijk",
  "Enumatil",
  "Enzelens",
  "Eper",
  "Eppen",
  "Erichem",
  "Erlecom",
  "Ermelo",
  "Ermer",
  "Escharen",
  "Eschoten",
  "Espelo",
  "Essen",
  "Etenaken",
  "Etzenrade",
  "Eursing",
  "Eursinge",
  "Euverem",
  "Ever",
  "Everd",
  "Everlo",
  "Everse",
  "Ewer",
  "Ewinkel",
  "Exmorra",
  "Eygels",
  "Eyser",
  "Ezinge",
  "Ezuma",
  "Faan",
  "Falom",
  "Farmsum",
  "Fatum",
  "Feerwerd",
  "Fel",
  "Ferwert",
  "Fiemel",
  "Fijfhs",
  "Finke",
  "Finkum",
  "Flieren",
  "Flnsum",
  "Fokkers",
  "Follega",
  "Folsgeare",
  "Formerum",
  "Fort",
  "Fortmond",
  "Foudgum",
  "Fraamklap",
  "Frankhuis",
  "Frankrijk",
  "Fransum",
  "Friens",
  "Frytum",
  "Fns",
  "Gaag",
  "Gaanderen",
  "Gaar",
  "Gaast",
  "Gaasten",
  "Gaastmar",
  "Gaete",
  "Gagel",
  "Galder",
  "Gameren",
  "Gammelke",
  "Ganzert",
  "Gapinge",
  "Garminge",
  "Garnwerd",
  "Garre",
  "Garrels",
  "Garst",
  "Garyp",
  "Gassel",
  "Gasthuis",
  "Gawege",
  "Gebergte",
  "Geefs",
  "Geen",
  "Geer",
  "Gees",
  "Geeuwen",
  "Geffen",
  "Gelders",
  "Gelderse",
  "Geleen",
  "Gelkenes",
  "Gellicum",
  "Gemaal",
  "Gement",
  "Gemert",
  "Gemonde",
  "Gendt",
  "Geneijgen",
  "Genen",
  "Gening",
  "Genne",
  "Gennep",
  "Genooi",
  "Gerheggen",
  "Gerner",
  "Gersloot",
  "Gerven",
  "Gerwen",
  "Geulhem",
  "Gever",
  "Geverik",
  "Gewande",
  "Giers",
  "Giessen",
  "Gietelo",
  "Giethmen",
  "Giethoorn",
  "Gijbe",
  "Gijsselte",
  "Gijzel",
  "Gilze",
  "Ginkel",
  "Ginnum",
  "Glaner",
  "Goaingea",
  "Godlinze",
  "Goes",
  "Goilberd",
  "Goirle",
  "Goldhoorn",
  "Gooium",
  "Goor",
  "Gorinchem",
  "Gorp",
  "Gortel",
  "Gouda",
  "Gouderak",
  "Goudseweg",
  "Gonga",
  "Graaf",
  "Graauw",
  "Gracht",
  "Graet",
  "Graf",
  "Grafwegen",
  "Gras",
  "Graspeel",
  "Graszode",
  "Grathem",
  "Grauwe",
  "Grave",
  "Grazen",
  "Greonterp",
  "Greup",
  "Griete",
  "Grijps",
  "Grits",
  "Groe",
  "Groede",
  "Groen",
  "Groenekan",
  "Groeneweg",
  "Groenlo",
  "Groep",
  "Groes",
  "Groessen",
  "Groet",
  "Groeve",
  "Groeze",
  "Gron",
  "Groot",
  "Groote",
  "Grote",
  "Grotel",
  "Grou",
  "Gytsjerk",
  "Haaften",
  "Haag",
  "Haagje",
  "Haaks",
  "Haakswold",
  "Haalderen",
  "Haalweide",
  "Haamstede",
  "Haandrik",
  "Haar",
  "Haarlem",
  "Haarsteeg",
  "Haart",
  "Haelen",
  "Haerst",
  "Hagestein",
  "Haiink",
  "Halder",
  "Haler",
  "Half",
  "Halfmijl",
  "Halfweg",
  "Halle",
  "Haller",
  "Hallum",
  "Halte",
  "Halvink",
  "Hamrik",
  "Hamshorn",
  "Handel",
  "Hane",
  "Hank",
  "Hankate",
  "Hansweert",
  "Hantum",
  "Hantumer",
  "Harculo",
  "Harde",
  "Hardinx",
  "Haren",
  "Harener",
  "Haring",
  "Harke",
  "Harkema",
  "Harl",
  "Harles",
  "Harpel",
  "Harre",
  "Harse",
  "Harskamp",
  "Harssens",
  "Hartwerd",
  "Haspel",
  "Hasselt",
  "Hasselter",
  "Hatte",
  "Hattem",
  "Hauwert",
  "Havelt",
  "Havelte",
  "Hayum",
  "Haze",
  "Hazenhurk",
  "Hazennest",
  "Heaburgen",
  "Hedel",
  "Hedik",
  "Heech",
  "Heegher",
  "Heek",
  "Heelsum",
  "Heems",
  "Heemstede",
  "Heenweg",
  "Heer",
  "Heerde",
  "Heere",
  "Heeren",
  "Heers",
  "Hees",
  "Heesakker",
  "Heesbeen",
  "Heesboom",
  "Heesch",
  "Heesselt",
  "Heet",
  "Heezeren",
  "Hefswal",
  "Hegge",
  "Hei",
  "Heiakker",
  "Heibloem",
  "Heid",
  "Heide",
  "Heidekant",
  "Heiden",
  "Heier",
  "Heihoefke",
  "Heij",
  "Heijen",
  "Heikant",
  "Heikantse",
  "Heille",
  "Heine",
  "Heioord",
  "Heister",
  "Heitrak",
  "Hekel",
  "Hekkum",
  "Hel",
  "Helden",
  "Helkant",
  "Hell",
  "Helle",
  "Hellegat",
  "Hellen",
  "Hellevoet",
  "Helling",
  "Hellouw",
  "Helwerd",
  "Hemert",
  "Hemrik",
  "Hendrik",
  "Henge",
  "Herfte",
  "Herike",
  "Herk",
  "Herken",
  "Hermalen",
  "Hernen",
  "Herpen",
  "Herpt",
  "Hersel",
  "Hersend",
  "Hert",
  "Herten",
  "Hertme",
  "Herveld",
  "Herwen",
  "Herwijnen",
  "Herxen",
  "Hesens",
  "Hespe",
  "Hessum",
  "Heugde",
  "Heukelom",
  "Heukelum",
  "Heult",
  "Heumen",
  "Heure",
  "Heurne",
  "Heusden",
  "Heuvel",
  "Heuvels",
  "Heuveltje",
  "Hexel",
  "Heze",
  "Hiaure",
  "Hichtum",
  "Hidaard",
  "Hien",
  "Hierden",
  "Hieslum",
  "Hijken",
  "Hijum",
  "Hilaard",
  "Hilakker",
  "Hild",
  "Hill",
  "Hilte",
  "Hilversum",
  "Hinnaard",
  "Hintham",
  "Hitsertse",
  "Hodenpijl",
  "Hoef",
  "Hoefkens",
  "Hoek",
  "Hoekdries",
  "Hoekelum",
  "Hoekens",
  "Hoekje",
  "Hoeks",
  "Hoekske",
  "Hoetmans",
  "Hoeve",
  "Hoeven",
  "Hoeves",
  "Hoge",
  "Hogert",
  "Hogeweg",
  "Holker",
  "Hollum",
  "Holm",
  "Holset",
  "Holsloot",
  "Holst",
  "Holt",
  "Holte",
  "Holten",
  "Holter",
  "Holthe",
  "Holtien",
  "Holtinge",
  "Holtum",
  "Holwerd",
  "Holwierde",
  "Holwinde",
  "Hommelse",
  "Hommert",
  "Hommerts",
  "Honderd",
  "Honds",
  "Hondsrug",
  "Hongerige",
  "Honthem",
  "Hoog",
  "Hoogcruts",
  "Hooge",
  "Hoogehaar",
  "Hoogen",
  "Hoogeweg",
  "Hooghalen",
  "Hoogmade",
  "Hoogmeien",
  "Hoogwatum",
  "Hool",
  "Hoon",
  "Hoonte",
  "Hoorn",
  "Hoornder",
  "Hoptille",
  "Horck",
  "Horick",
  "Horn",
  "Horssen",
  "Horsten",
  "Horzik",
  "Hout",
  "Houterd",
  "Houtgoor",
  "Houthei",
  "Houthem",
  "Houw",
  "Houwer",
  "Hugten",
  "Huij",
  "Huinen",
  "Huinerwal",
  "Huis",
  "Huissen",
  "Huize",
  "Huizinge",
  "Hul",
  "Huls",
  "Hulsen",
  "Hulst",
  "Hulten",
  "Hultje",
  "Humcoven",
  "Hunnecum",
  "Hunsel",
  "Hupsel",
  "Hurkske",
  "Hurpesch",
  "Hutten",
  "Huurne",
  "Hchte",
  "Hfke",
  "Hns",
  "Idaerd",
  "Idserda",
  "Idsken",
  "Idzegea",
  "Iens",
  "IJmuiden",
  "IJpe",
  "IJpelo",
  "IJsselham",
  "IJzen",
  "IJzeren",
  "IJzerlo",
  "Illik",
  "Indoornik",
  "Ingwert",
  "Inia",
  "Itens",
  "Itteren",
  "Jaars",
  "Jammer",
  "Jannum",
  "Jellum",
  "Jelsum",
  "Jeth",
  "Jipsing",
  "Jirnsum",
  "Jislum",
  "Jisp",
  "Jistrum",
  "Jonas",
  "Jonen",
  "Jonkers",
  "Jorwert",
  "Joure",
  "Jous",
  "Jousterp",
  "Jouswerd",
  "Jouwer",
  "Jubbega",
  "Jukwerd",
  "Junne",
  "Jutryp",
  "Kaag",
  "Kaakhorn",
  "Kaard",
  "Kaarschot",
  "Kaat",
  "Kade",
  "Kadoelen",
  "Kalis",
  "Kalteren",
  "Kameren",
  "Kamp",
  "Kampen",
  "Kamper",
  "Kamperei",
  "Kampers",
  "Kamperzee",
  "Kantens",
  "Kantje",
  "Kapel",
  "Kapelle",
  "Kapolder",
  "Kappert",
  "Karre",
  "Kasen",
  "Kasteren",
  "Kater",
  "Katerveer",
  "Kathagen",
  "Katlijk",
  "Kats",
  "Katwijk",
  "Kaumes",
  "Kavel",
  "Kaweide",
  "Kedichem",
  "Keegen",
  "Keent",
  "Keersop",
  "Keinsmer",
  "Keizers",
  "Kekerdom",
  "Kelmond",
  "Kelpen",
  "Kempkens",
  "Kerk",
  "Kerken",
  "Kerkhof",
  "Kerkrade",
  "Kerkwerve",
  "Keske",
  "Kessel",
  "Kesseleik",
  "Ketting",
  "Keulse",
  "Keunen",
  "Keup",
  "Keuter",
  "Kibbel",
  "Kiel",
  "Kiester",
  "Kievit",
  "Kijf",
  "Kijfwaard",
  "Kijkuit",
  "Kilder",
  "Kille",
  "Kimswerd",
  "Kinderbos",
  "Kink",
  "Kinnum",
  "Kipper",
  "Klaaswaal",
  "Kladde",
  "Klaren",
  "Klatering",
  "Klef",
  "Klei",
  "Klein",
  "Kleinder",
  "Kleine",
  "Kleinge",
  "Klem",
  "Kletter",
  "Klevers",
  "Klispoel",
  "Klomp",
  "Klooster",
  "Klosse",
  "Klsse",
  "Knaphof",
  "Knegsel",
  "Knipe",
  "Knol",
  "Knolle",
  "Knuiters",
  "Koedood",
  "Koehool",
  "Koekange",
  "Koekanger",
  "Koekoek",
  "Koel",
  "Koevering",
  "Kokkelert",
  "Kolder",
  "Kolhol",
  "Kolhorn",
  "Kolk",
  "Kollum",
  "Kolonie",
  "Kommer",
  "Konings",
  "Koog",
  "Kooi",
  "Kooldert",
  "Kopaf",
  "Korhorn",
  "Korn",
  "Kornhorn",
  "Kort",
  "Korte",
  "Korteraar",
  "Korteven",
  "Kortgene",
  "Kostvlies",
  "Koude",
  "Kouden",
  "Koudhoorn",
  "Koulen",
  "Kraan",
  "Kraanven",
  "Kraats",
  "Krabben",
  "Krachtig",
  "Kranen",
  "Krassum",
  "Kreek",
  "Kreielt",
  "Kreijel",
  "Kreijl",
  "Krewerd",
  "Krim",
  "Krimpen",
  "Krol",
  "Kruin",
  "Kruishaar",
  "Kruispunt",
  "Kruisweg",
  "Kuikhorne",
  "Kuiks",
  "Kuinre",
  "Kuitaart",
  "Kuivezand",
  "Kulert",
  "Kulsdom",
  "Kunrade",
  "Kutt",
  "Kuundert",
  "Kuzemer",
  "Kwaal",
  "Kwakel",
  "Kwakkel",
  "Kwartier",
  "Kkherne",
  "Laag",
  "Laaghalen",
  "Laaghaler",
  "Laak",
  "Laaksum",
  "Laan",
  "Lage",
  "Lagekant",
  "Lageweg",
  "Lakei",
  "Laker",
  "Lalle",
  "Lammer",
  "Lammerweg",
  "Lamperen",
  "Landerum",
  "Landsrade",
  "Lang",
  "Lange",
  "Langeraar",
  "Langerak",
  "Langereit",
  "Lank",
  "Lankes",
  "Laren",
  "Laskwerd",
  "Lattrop",
  "Laude",
  "Lauwer",
  "Ledeacker",
  "Leeg",
  "Leegte",
  "Leek",
  "Leem",
  "Leen",
  "Leens",
  "Leensel",
  "Leermens",
  "Leersum",
  "Leeuw",
  "Leeuwerik",
  "Leeuwte",
  "Lege",
  "Legert",
  "Leiden",
  "Leimuiden",
  "Leker",
  "Lekker",
  "Lelystad",
  "Lemel",
  "Lemele",
  "Lemmer",
  "Lemselo",
  "Lengel",
  "Lent",
  "Lenthe",
  "Leons",
  "Lerop",
  "Lethe",
  "Lettele",
  "Leuke",
  "Leunen",
  "Leur",
  "Leusden",
  "Leutes",
  "Leuth",
  "Leuven",
  "Leuvenum",
  "Leveroy",
  "Lexmond",
  "Lhee",
  "Lichtaard",
  "Lichtmis",
  "Liefkens",
  "Liempde",
  "Lienden",
  "Lier",
  "Lieren",
  "Lierop",
  "Lies",
  "Lievelde",
  "Lieving",
  "Lijnden",
  "Limbricht",
  "Limmen",
  "Linde",
  "Lingsfort",
  "Lintelo",
  "Lintvelde",
  "Lioessens",
  "Lippen",
  "Lith",
  "Lithoijen",
  "Lobith",
  "Loc",
  "Locht",
  "Loenen",
  "Loer",
  "Loete",
  "Logt",
  "Loil",
  "Lollum",
  "Lomm",
  "Lonneker",
  "Loo",
  "Loobrink",
  "Loofaert",
  "Looi",
  "Looien",
  "Look",
  "Loon",
  "Loons",
  "Loonse",
  "Looveer",
  "Loppersum",
  "Lovendaal",
  "Loveren",
  "Longa",
  "Lubbinge",
  "Luchen",
  "Luchten",
  "Luissel",
  "Luitert",
  "Lula",
  "Lunen",
  "Lunteren",
  "Lunters",
  "Lutjegast",
  "Lutjerijp",
  "Lutke",
  "Lutkepost",
  "Lutten",
  "Lutter",
  "Lytse",
  "Lytshuzen",
  "Maagd",
  "Maaijkant",
  "Maalb",
  "Maaldrift",
  "Maalstede",
  "Maar",
  "Maarn",
  "Maars",
  "Maarssen",
  "Maasband",
  "Maasbree",
  "Maaskant",
  "Maat",
  "Maatsehei",
  "Macharen",
  "Made",
  "Magele",
  "Magrette",
  "Makkum",
  "Mal",
  "Malden",
  "Mallem",
  "Mamelis",
  "Manen",
  "Mantgum",
  "Mantinge",
  "Maren",
  "Maria",
  "Maris",
  "Mark",
  "Markvelde",
  "Marle",
  "Marrum",
  "Mars",
  "Marssum",
  "Marsum",
  "Martens",
  "Marum",
  "Mataram",
  "Maten",
  "Mathijs",
  "Maurik",
  "Maxet",
  "Medemblik",
  "Medevoort",
  "Medler",
  "Meed",
  "Meeden",
  "Meele",
  "Meemortel",
  "Meene",
  "Meer",
  "Meeren",
  "Meern",
  "Meerten",
  "Meerven",
  "Meerwijck",
  "Megelsum",
  "Megen",
  "Meije",
  "Meijel",
  "Melick",
  "Melis",
  "Melissant",
  "Menaldum",
  "Mensinge",
  "Menzel",
  "Meppen",
  "Merkel",
  "Merm",
  "Merselo",
  "Merum",
  "Mesch",
  "Meteren",
  "Metsla",
  "Midbuul",
  "Midde",
  "Middel",
  "Middelijk",
  "Midden",
  "Middenhof",
  "Midlaren",
  "Midlum",
  "Mids",
  "Midwolde",
  "Miedum",
  "Mildert",
  "Milheeze",
  "Mill",
  "Mils",
  "Milschot",
  "Minkeloos",
  "Mispel",
  "Moddergat",
  "Moer",
  "Moeren",
  "Moerslag",
  "Moespot",
  "Molembaix",
  "Molenbaan",
  "Molenbelt",
  "Molengat",
  "Molenhof",
  "Molenperk",
  "Molenrij",
  "Molenstad",
  "Molkwar",
  "Monster",
  "Montfort",
  "Mook",
  "Moord",
  "Moorsel",
  "Morige",
  "Morra",
  "Mortel",
  "Mosbulten",
  "Mosik",
  "Moskou",
  "Mosse",
  "Mossel",
  "Most",
  "Muggenhol",
  "Muis",
  "Muizenhol",
  "Mulderij",
  "Mullegen",
  "Munneke",
  "Munnekens",
  "Munniken",
  "Munte",
  "Murns",
  "Mussel",
  "Mnein",
  "Naarder",
  "Nabbegat",
  "Nagel",
  "Nansum",
  "Napels",
  "Natten",
  "Neder",
  "Nederbiel",
  "Neer",
  "Neerijnen",
  "Neeritter",
  "Neerloon",
  "Neerst",
  "Negen",
  "Nekke",
  "Nergena",
  "Nia",
  "Nie",
  "Niebert",
  "Niehove",
  "Nier",
  "Niersen",
  "Niesoord",
  "Nieuw",
  "Nieuwaal",
  "Nieuwe",
  "Nieuwer",
  "Nieuwklap",
  "Nieuwkoop",
  "Nieuwolda",
  "Nieuwstad",
  "Niftrik",
  "Nijega",
  "Nijehaske",
  "Nijesyl",
  "Nijken",
  "Nijkerker",
  "Nijln",
  "Nijmegen",
  "Nijnsel",
  "Nijrees",
  "Nijstad",
  "Nijve",
  "Nispense",
  "Noardein",
  "Noenes",
  "Nolde",
  "Noord",
  "Noorden",
  "Noorder",
  "Noordhorn",
  "Noordink",
  "Noordkant",
  "Noordse",
  "Notendaal",
  "Notsel",
  "Noukoop",
  "Nuenen",
  "Nuijen",
  "Nuil",
  "Nuis",
  "Nunhem",
  "Nunspeet",
  "Nuth",
  "Obbicht",
  "Ock",
  "Oegst",
  "Oekel",
  "Oeken",
  "Oele",
  "Oensel",
  "Oentsjerk",
  "Oerle",
  "Oete",
  "Oever",
  "Offinga",
  "Ofwegen",
  "Oh;",
  "Oijen",
  "Oirlo",
  "Oirs",
  "Okswerd",
  "Olde",
  "Oldehove",
  "Oldemarkt",
  "Olden",
  "Oldeneel",
  "Oldenhave",
  "Oldeouwer",
  "Oldrp",
  "Olen",
  "Oler",
  "Oling",
  "Olterterp",
  "Ommel",
  "Ommen",
  "Ommeren",
  "Onder",
  "Onna",
  "Onsenoort",
  "Onstwedde",
  "Ooij",
  "Ooijen",
  "Oost",
  "Oostappen",
  "Ooste",
  "Ooster",
  "Oosterend",
  "Oosterens",
  "Oosterhof",
  "Oosterik",
  "Oosternie",
  "Oosternij",
  "Oosterse",
  "Oosterzee",
  "Oosthem",
  "Oostindi",
  "Oostrum",
  "Oostum",
  "Oostwold",
  "Oostzaan",
  "Op",
  "Opende",
  "Ophemert",
  "Ophuis",
  "Opijnen",
  "Opmeeden",
  "Opper",
  "Opperdoes",
  "Opperduit",
  "Opwetten",
  "Opwierde",
  "Oranje",
  "Orvelte",
  "Osen",
  "Oshaar",
  "Ospel",
  "Ossen",
  "Ossenisse",
  "Ostaaijen",
  "Osterbos",
  "Othene",
  "Otterlo",
  "Ottersum",
  "Ou",
  "OuBildt",
  "Oude",
  "Oudega",
  "Oudehaske",
  "Oudehorne",
  "Ouden",
  "Oudenrijn",
  "Ouder",
  "Oudeschip",
  "Oudleusen",
  "Oukoop",
  "OuLeede",
  "OuLeije",
  "OuPolder",
  "OuSchouw",
  "OuStaten",
  "OuStee",
  "OuStoof",
  "OuStrumpt",
  "OuWaranda",
  "Ouwer",
  "OuWillem",
  "Ouwster",
  "Oventje",
  "Over",
  "Overa",
  "Overakker",
  "Overbiel",
  "Overeys",
  "Overgeul",
  "Overheek",
  "Overschot",
  "Overval",
  "Overwater",
  "Paal",
  "Paarde",
  "Paarlo",
  "Paauwen",
  "Paddepoel",
  "Padhuis",
  "Paesens",
  "Palestina",
  "Pallert",
  "Pandgat",
  "Panheel",
  "Pann",
  "Pannerden",
  "Papen",
  "Papenveer",
  "Park",
  "Parrega",
  "Partij",
  "Pasop",
  "Patrijzen",
  "Peebos",
  "Peelkant",
  "Peij",
  "Peizerweg",
  "Pelikaan",
  "Pepinus",
  "Pernis",
  "Pers",
  "Pesaken",
  "Peters",
  "Petten",
  "Piaam",
  "Pieperij",
  "Piepert",
  "Piershil",
  "Pieter",
  "Pikesyl",
  "Piksen",
  "Pingjum",
  "Pinkeveer",
  "Pitteperk",
  "Plaat",
  "Plaats",
  "Plak",
  "Plantage",
  "Plas",
  "Plat",
  "Plein",
  "Poffert",
  "Polen",
  "Polle",
  "Pollen",
  "Ponte",
  "Poonhaven",
  "Poppen",
  "Posterenk",
  "Posthoorn",
  "Pot",
  "Praets",
  "Prickart",
  "Puiflijk",
  "Punt",
  "Purmer",
  "Purmerend",
  "Puth",
  "Putse",
  "Putten",
  "Putters",
  "Pyramide",
  "Raai",
  "Raak",
  "Raam",
  "Raar",
  "Raard",
  "Raayen",
  "Raerd",
  "Rakens",
  "Rakt",
  "Rand",
  "Rande",
  "Randen",
  "Ranum",
  "Raren",
  "Rasquert",
  "Ratte",
  "Ravensgat",
  "Reahs",
  "Rechteren",
  "Rectum",
  "Reduzum",
  "Reeth",
  "Reidswal",
  "Reitsum",
  "Remswerd",
  "Renesse",
  "Renkum",
  "Renneborg",
  "Rens",
  "Respel",
  "Ressen",
  "Reters",
  "Reth",
  "Reuth",
  "Reutje",
  "Reuzen",
  "Rewert",
  "Rhaan",
  "Rheder",
  "Rhee",
  "Rhenoy",
  "Rhoon",
  "Ridder",
  "Riel",
  "Rien",
  "Riet",
  "Rietven",
  "Rijckholt",
  "Rijen",
  "Rijke",
  "Rijkel",
  "Rijker",
  "Rijlst",
  "Rijnsater",
  "Rijsb",
  "Rijsoord",
  "Rijt",
  "Rijtjes",
  "Ril",
  "Rimpelt",
  "Rink",
  "Rips",
  "Rith",
  "Ritsuma",
  "Roeke",
  "Roekel",
  "Roelage",
  "Roels",
  "Roermond",
  "Roeven",
  "Roggel",
  "Rohel",
  "Rolaf",
  "Roligt",
  "Rollecate",
  "Rolpaal",
  "Rome",
  "Rond",
  "Ronduite",
  "Rood",
  "Roodehaan",
  "Rooden",
  "Roond",
  "Roosteren",
  "Rooth",
  "Ropta",
  "Roskam",
  "Rothem",
  "Rott",
  "Rotte",
  "Rotter",
  "Rotting",
  "Rottum",
  "Rozendaal",
  "Rucphen",
  "Ruif",
  "Ruigen",
  "Ruigezand",
  "Ruimel",
  "Ruinen",
  "Ruischer",
  "Ruiten",
  "Rukven",
  "Rullen",
  "Rumpt",
  "Rund",
  "Rusven",
  "Rut",
  "Ryptsjerk",
  "Rytseterp",
  "Saaksum",
  "Saaxum",
  "Salverd",
  "Sandebuur",
  "Santfort",
  "Santpoort",
  "Sasput",
  "Sauwerd",
  "Schaa",
  "Schaaphok",
  "Schaaps",
  "Schadron",
  "Schafelt",
  "Schaft",
  "Schagen",
  "Schager",
  "Schandelo",
  "Schans",
  "Schapers",
  "Scharen",
  "Scharne",
  "Scharster",
  "Schatkuil",
  "Schaveren",
  "Scheemder",
  "Schelf",
  "Schellach",
  "Schelm",
  "Schettens",
  "Schey",
  "Schieven",
  "Schijf",
  "Schijndel",
  "Schillers",
  "Schimmert",
  "Schin",
  "Schinnen",
  "Schippers",
  "School",
  "Schoon",
  "Schoonen",
  "Schoor",
  "Schoorl",
  "Schoot",
  "Schore",
  "Schoter",
  "Schotters",
  "Schouw",
  "Schouwen",
  "Schouwer",
  "Schraard",
  "Schrap",
  "Schuilen",
  "Schuring",
  "Schuwacht",
  "Sebalde",
  "Seerijp",
  "Sell",
  "Selmien",
  "Selwerd",
  "Seroos",
  "Seters",
  "Sibbe",
  "Siberi",
  "Siegers",
  "Simpel",
  "Sinouts",
  "Sinsel",
  "Sint",
  "Sion",
  "Sittard",
  "Sjunga",
  "Skarl",
  "Skillaerd",
  "Skou",
  "Skrins",
  "Skyldum",
  "Slee",
  "Sleen",
  "Slegge",
  "Slek",
  "Slichten",
  "Sliffert",
  "Slijkwell",
  "Slikken",
  "Sloot",
  "Sluis",
  "Smakt",
  "Smal",
  "Smalle",
  "Smeerling",
  "Smelbrge",
  "Smele",
  "Smilde",
  "Smits",
  "Sneek",
  "Sneiders",
  "Snelle",
  "Sneps",
  "Snikzwaag",
  "Snipperij",
  "Snoden",
  "Soeter",
  "Solwerd",
  "Someren",
  "Sopsum",
  "Spaanrijt",
  "Spaanse",
  "Spaken",
  "Spannen",
  "Spannum",
  "Spears",
  "Spek",
  "Spekklef",
  "Spekt",
  "Speuld",
  "Speurgt",
  "Spier",
  "Spijk",
  "Spik",
  "Spits",
  "Spoolde",
  "Spoor",
  "Sprang",
  "Sprundel",
  "Spurkt",
  "Stad",
  "Stadterij",
  "Starten",
  "Stations",
  "Staverden",
  "Stedum",
  "Steeg",
  "Steegh",
  "Steel",
  "Steen",
  "Steenkamp",
  "Steenoven",
  "Steenpaal",
  "Steensel",
  "Steenvak",
  "Stegen",
  "Steger",
  "Stegeren",
  "Stein",
  "Sterken",
  "Sterre",
  "Steurgat",
  "Stevens",
  "Stevert",
  "Stiem",
  "Stiens",
  "Stitswerd",
  "Stobben",
  "Stokhem",
  "Stokkelen",
  "Stokkum",
  "Stokske",
  "Stokt",
  "Stolpen",
  "Stomme",
  "Stoof",
  "Stork",
  "Stouten",
  "Stox",
  "Strand",
  "Straten",
  "Strateris",
  "Streek",
  "Strepen",
  "Streukel",
  "Strij",
  "Strijen",
  "Strijp",
  "Stroet",
  "Stroo",
  "Stroopuit",
  "Strubben",
  "Strucht",
  "Strype",
  "Stuw",
  "Sumar",
  "Sumarre",
  "Surhuizum",
  "Susteren",
  "Suttum",
  "Suwld",
  "Swaenwert",
  "Swalmen",
  "Sweik",
  "Syt",
  "Snfurd",
  "Taarlo",
  "Teeffelen",
  "Teije",
  "Teijl",
  "Telgt",
  "Tempel",
  "Ter",
  "Terband",
  "Terblijt",
  "Terdiek",
  "Tereyken",
  "Tergft",
  "Terhagen",
  "Terheijl",
  "Terherne",
  "Terkaple",
  "Terlet",
  "Terlinden",
  "Termaar",
  "Termoors",
  "Termunten",
  "Termunter",
  "Ternaard",
  "Teroele",
  "Terover",
  "Tersoal",
  "Tervaten",
  "Tervoorst",
  "Tervoort",
  "Terwispel",
  "Terwolde",
  "Terziet",
  "Teuge",
  "Theetuin",
  "Themaat",
  "Tholen",
  "Thull",
  "Thuserhof",
  "Tibma",
  "Tiel",
  "Tielse",
  "Tiggelt",
  "Tijnje",
  "Tike",
  "Til",
  "Timmer",
  "Tippe",
  "Tjaard",
  "Tjams",
  "Tjerkwerd",
  "Tjoene",
  "Tolbert",
  "Tolkamer",
  "Tommel",
  "Tongeren",
  "Tongerlo",
  "Tonsel",
  "Toom",
  "Toornwerd",
  "Top",
  "Toren",
  "Toterfout",
  "Toven",
  "Tragel",
  "Tranendal",
  "Trege",
  "Trent",
  "Tricht",
  "Triemen",
  "Trimpert",
  "Trintelen",
  "Tritzum",
  "Tronde",
  "Trophorne",
  "Trutjes",
  "Tuil",
  "Tull",
  "Tungelroy",
  "Turns",
  "Tusschen",
  "Tuut",
  "Tuuthees",
  "Twee",
  "Tweedeweg",
  "TweeTol",
  "Twekkelo",
  "Twello",
  "Twijzel",
  "Twijzeler",
  "Twisk",
  "Tynaarlo",
  "Tytsjerk",
  "Ubach",
  "Ubbena",
  "Ubber",
  "Uddel",
  "Uffelsen",
  "Uffelte",
  "Uit",
  "Uiter",
  "Uithoorn",
  "Uitwierde",
  "Ulfter",
  "Ulicoten",
  "Ulrum",
  "Ulsda",
  "Ulvend",
  "Unga",
  "Uppel",
  "Usquert",
  "Usselo",
  "Vaals",
  "Vaar",
  "Vaarle",
  "Vaart",
  "Vaesrade",
  "Valk",
  "Valken",
  "Valom",
  "Valsteeg",
  "Varik",
  "Varsen",
  "Varssel",
  "Vebenabos",
  "Vecht",
  "Veecaten",
  "Veele",
  "Veeler",
  "Veen",
  "Veenhof",
  "Veenhoop",
  "Veenhuis",
  "Veere",
  "Veessen",
  "Veghel",
  "Veld",
  "Veldbraak",
  "Velde",
  "Velden",
  "Veldhuis",
  "Veldzicht",
  "Velp",
  "Velsen",
  "Veluwe",
  "Vemde",
  "Ven",
  "Venbe",
  "Vene",
  "Venekoten",
  "Venlo",
  "Venne",
  "Venray",
  "Venweg",
  "Vergelt",
  "Verloren",
  "Vessem",
  "Vestjens",
  "Vet",
  "Vetterik",
  "Veulen",
  "Vianen",
  "Viel",
  "Vier",
  "Vierhuis",
  "Vijcie",
  "Vijf",
  "Vilgert",
  "Vilsteren",
  "Vilt",
  "Vink",
  "Vinkel",
  "Vinken",
  "Vinkepas",
  "Vis",
  "Visschers",
  "Vissers",
  "Vlaas",
  "Vlake",
  "Vlas",
  "Vledder",
  "Vleet",
  "Vleuten",
  "Vlie",
  "Vliegert",
  "Vlieghuis",
  "Vlijmen",
  "Vliss",
  "Vlist",
  "Vlodrop",
  "Vloei",
  "Vloet",
  "Vlootkant",
  "Vogelfort",
  "Volthe",
  "Voor",
  "Voorne",
  "Voorrijp",
  "Voorst",
  "Voorstad",
  "Voorste",
  "Voorster",
  "Voort",
  "Voortje",
  "Voorweg",
  "Vorchten",
  "Vorst",
  "Vorsten",
  "Voske",
  "Voskuil",
  "Vosse",
  "Vossebelt",
  "Vosselen",
  "Vossen",
  "Voulwames",
  "Vrachelen",
  "Vragender",
  "Vredepeel",
  "Vree",
  "Vries",
  "Vriezen",
  "Vrij",
  "Vrijhoeve",
  "Vrilk",
  "Vroe",
  "Vroelen",
  "Vuile",
  "Vuilpan",
  "Vuren",
  "Waaksens",
  "Waal",
  "Waar",
  "Waard",
  "Waarde",
  "Waarden",
  "Waarder",
  "Waatskamp",
  "Wachtum",
  "Waddinx",
  "Wadway",
  "Wadwerd",
  "Wagen",
  "Waije",
  "Walder",
  "Walik",
  "Walsert",
  "Wammert",
  "Wanneper",
  "Wanroij",
  "Wapen",
  "Wapse",
  "Wapser",
  "Warf",
  "Warffum",
  "Warfster",
  "Warmen",
  "Warmond",
  "Warnia",
  "Warstiens",
  "Warten",
  "Waspik",
  "Water",
  "Wateren",
  "Waterkant",
  "Waterop",
  "Waterval",
  "Waver",
  "Weakens",
  "Wedde",
  "Wedder",
  "Wee",
  "Weeg",
  "Weende",
  "Weerd",
  "Weerdinge",
  "Weere",
  "Weert",
  "Weerwille",
  "Wehe",
  "Wehl",
  "Weidum",
  "Weij",
  "Weijer",
  "Weijpoort",
  "Weilens",
  "Weimeren",
  "Weipoort",
  "Weite",
  "Weitemans",
  "Weiwerd",
  "Wekerom",
  "Wele",
  "Wells",
  "Welsum",
  "Wely",
  "Wenum",
  "Weper",
  "Wercheren",
  "Weren",
  "Wergea",
  "Werk",
  "Wernhouts",
  "Wesch",
  "Wessing",
  "Wessinge",
  "West",
  "Westeneng",
  "Wester",
  "Westerein",
  "Westerlee",
  "Westernie",
  "Westerse",
  "Westhim",
  "Westlaren",
  "Westmaas",
  "Westrik",
  "Wetering",
  "Wetsens",
  "Weurt",
  "Wevers",
  "Weverslo",
  "Wezel",
  "Wezep",
  "Wezup",
  "Wezuper",
  "Wielder",
  "Wieler",
  "Wielse",
  "Wiene",
  "Wierren",
  "Wierum",
  "Wiesel",
  "Wieuwens",
  "Wijchen",
  "Wijnaldum",
  "Wijnb",
  "Wijnje",
  "Wijster",
  "Wijthmen",
  "Wijzend",
  "Wilderhof",
  "Wildert",
  "Wilgen",
  "Wilp",
  "Wils",
  "Wilsum",
  "Winde",
  "Windraak",
  "Winkel",
  "Winkels",
  "Winssen",
  "Winsum",
  "Wintelre",
  "Winthagen",
  "Wirdum",
  "Wisse",
  "Wissel",
  "Wissen",
  "Witharen",
  "Withuis",
  "Witman",
  "Witmarsum",
  "Witrijt",
  "Witte",
  "Wittelte",
  "Witten",
  "Wiuwert",
  "Wjelsryp",
  "Woerd",
  "Woerdense",
  "Woezik",
  "Wognum",
  "Wolfers",
  "Wolfhaag",
  "Wolfhagen",
  "Wolfheze",
  "Wolfs",
  "Wolfshuis",
  "Wolling",
  "Wolsum",
  "Wommels",
  "Wonne",
  "Wons",
  "Woord",
  "Wopereis",
  "Wordragen",
  "Wormer",
  "Worsum",
  "Woubrugge",
  "Wouwse",
  "Wulpenbek",
  "Wyns",
  "Wytgaard",
  "Wldsein",
  "Wnswert",
  "Yerseke",
  "Yndyk",
  "Zaamslag",
  "Zaarvlaas",
  "Zalk",
  "Zand",
  "Zande",
  "Zandfort",
  "Zandkant",
  "Zandoerle",
  "Zandplaat",
  "Zandpol",
  "Zandput",
  "Zandvoort",
  "Zee",
  "Zeegat",
  "Zeegse",
  "Zeerijp",
  "Zeesse",
  "Zegge",
  "Zeijen",
  "Zeijer",
  "Zeist",
  "Zelder",
  "Zelen",
  "Zelt",
  "Zenderen",
  "Zethuis",
  "Zeven",
  "Zevenhuis",
  "Zierikzee",
  "Zieuwent",
  "Zijder",
  "Zijdewind",
  "Zijp",
  "Zijper",
  "Zijtaart",
  "Zilven",
  "Zinkweg",
  "Zittard",
  "Zoeke",
  "Zoelen",
  "Zoelmond",
  "Zoerte",
  "Zoeter",
  "Zoggel",
  "Zomerven",
  "Zond",
  "Zorgvlied",
  "Zoutkamp",
  "Zuid",
  "Zuider",
  "Zuidhorn",
  "Zuidlaren",
  "Zuidwolde",
  "Zuidzande",
  "Zuidzijde",
  "Zuilichem",
  "Zundert",
  "Zurich",
  "Zutphen",
  "Zuuk",
  "Zwaag",
  "Zwager",
  "Zwanegat",
  "Zwart",
  "Zwarte",
  "Zweek",
  "Zwiggelte",
  "Zwijn",
  "Zwinderen",
  "Zwolle"
];

},{}],961:[function(require,module,exports){
module["exports"] = [
  " aan de IJssel",
  " aan de Rijn",
  "ambacht",
  "beek",
  "berg",
  "bergen",
  "bosch",
  "broek",
  "brug",
  "buren",
  "burg",
  "buurt",
  "dam",
  "dijk",
  "dijke",
  "donk",
  "dorp",
  "eind",
  "enmaes",
  "gat",
  "geest",
  "heide",
  "hoek",
  "horst",
  "hout",
  "hoven",
  "huizen",
  "ingen",
  "kerk",
  "laar",
  "land",
  "meer",
  "recht",
  "schoten",
  "sluis",
  "stroom",
  "swaerd",
  "veen",
  "veld",
  "vliet",
  "weer",
  "wier",
  "wijk",
  "woud",
  "woude",
  "zijl",
  ""
];

},{}],962:[function(require,module,exports){
module["exports"] = [
  "Afghanistan",
  "Akrotiri",
  "Albani",
  "Algerije",
  "Amerikaanse Maagdeneilanden",
  "Amerikaans-Samoa",
  "Andorra",
  "Angola",
  "Anguilla",
  "Antarctica",
  "Antigua en Barbuda",
  "Arctic Ocean",
  "Argentini",
  "Armeni",
  "Aruba",
  "Ashmore and Cartier Islands",
  "Atlantic Ocean",
  "Australi",
  "Azerbeidzjan",
  "Bahama's",
  "Bahrein",
  "Bangladesh",
  "Barbados",
  "Belarus",
  "Belgi",
  "Belize",
  "Benin",
  "Bermuda",
  "Bhutan",
  "Bolivi",
  "Bosni-Herzegovina",
  "Botswana",
  "Bouvet Island",
  "Brazili",
  "British Indian Ocean Territory",
  "Britse Maagdeneilanden",
  "Brunei",
  "Bulgarije",
  "Burkina Faso",
  "Burundi",
  "Cambodja",
  "Canada",
  "Caymaneilanden",
  "Centraal-Afrikaanse Republiek",
  "Chili",
  "China",
  "Christmas Island",
  "Clipperton Island",
  "Cocos (Keeling) Islands",
  "Colombia",
  "Comoren (Unie)",
  "Congo (Democratische Republiek)",
  "Congo (Volksrepubliek)",
  "Cook",
  "Coral Sea Islands",
  "Costa Rica",
  "Cuba",
  "Cyprus",
  "Denemarken",
  "Dhekelia",
  "Djibouti",
  "Dominica",
  "Dominicaanse Republiek",
  "Duitsland",
  "Ecuador",
  "Egypte",
  "El Salvador",
  "Equatoriaal-Guinea",
  "Eritrea",
  "Estland",
  "Ethiopi",
  "European Union",
  "Falkland",
  "Faroe Islands",
  "Fiji",
  "Filipijnen",
  "Finland",
  "Frankrijk",
  "Frans-Polynesi",
  "French Southern and Antarctic Lands",
  "Gabon",
  "Gambia",
  "Gaza Strip",
  "Georgi",
  "Ghana",
  "Gibraltar",
  "Grenada",
  "Griekenland",
  "Groenland",
  "Guam",
  "Guatemala",
  "Guernsey",
  "Guinea",
  "Guinee-Bissau",
  "Guyana",
  "Hati",
  "Heard Island and McDonald Islands",
  "Heilige Stoel",
  "Honduras",
  "Hongarije",
  "Hongkong",
  "Ierland",
  "IJsland",
  "India",
  "Indian Ocean",
  "Indonesi",
  "Irak",
  "Iran",
  "Isle of Man",
  "Isral",
  "Itali",
  "Ivoorkust",
  "Jamaica",
  "Jan Mayen",
  "Japan",
  "Jemen",
  "Jersey",
  "Jordani",
  "Kaapverdi",
  "Kameroen",
  "Kazachstan",
  "Kenia",
  "Kirgizstan",
  "Kiribati",
  "Koeweit",
  "Kroati",
  "Laos",
  "Lesotho",
  "Letland",
  "Libanon",
  "Liberia",
  "Libi",
  "Liechtenstein",
  "Litouwen",
  "Luxemburg",
  "Macao",
  "Macedoni",
  "Madagaskar",
  "Malawi",
  "Maldiven",
  "Maleisi",
  "Mali",
  "Malta",
  "Marokko",
  "Marshall Islands",
  "Mauritani",
  "Mauritius",
  "Mayotte",
  "Mexico",
  "Micronesia, Federated States of",
  "Moldavi",
  "Monaco",
  "Mongoli",
  "Montenegro",
  "Montserrat",
  "Mozambique",
  "Myanmar",
  "Namibi",
  "Nauru",
  "Navassa Island",
  "Nederland",
  "Nederlandse Antillen",
  "Nepal",
  "Ngwane",
  "Nicaragua",
  "Nieuw-Caledoni",
  "Nieuw-Zeeland",
  "Niger",
  "Nigeria",
  "Niue",
  "Noordelijke Marianen",
  "Noord-Korea",
  "Noorwegen",
  "Norfolk Island",
  "Oekrane",
  "Oezbekistan",
  "Oman",
  "Oostenrijk",
  "Pacific Ocean",
  "Pakistan",
  "Palau",
  "Panama",
  "Papoea-Nieuw-Guinea",
  "Paracel Islands",
  "Paraguay",
  "Peru",
  "Pitcairn",
  "Polen",
  "Portugal",
  "Puerto Rico",
  "Qatar",
  "Roemeni",
  "Rusland",
  "Rwanda",
  "Saint Helena",
  "Saint Lucia",
  "Saint Vincent en de Grenadines",
  "Saint-Pierre en Miquelon",
  "Salomon",
  "Samoa",
  "San Marino",
  "So Tom en Principe",
  "Saudi-Arabi",
  "Senegal",
  "Servi",
  "Seychellen",
  "Sierra Leone",
  "Singapore",
  "Sint-Kitts en Nevis",
  "Sloveni",
  "Slowakije",
  "Soedan",
  "Somali",
  "South Georgia and the South Sandwich Islands",
  "Southern Ocean",
  "Spanje",
  "Spratly Islands",
  "Sri Lanka",
  "Suriname",
  "Svalbard",
  "Syri",
  "Tadzjikistan",
  "Taiwan",
  "Tanzania",
  "Thailand",
  "Timor Leste",
  "Togo",
  "Tokelau",
  "Tonga",
  "Trinidad en Tobago",
  "Tsjaad",
  "Tsjechi",
  "Tunesi",
  "Turkije",
  "Turkmenistan",
  "Turks-en Caicoseilanden",
  "Tuvalu",
  "Uganda",
  "Uruguay",
  "Vanuatu",
  "Venezuela",
  "Verenigd Koninkrijk",
  "Verenigde Arabische Emiraten",
  "Verenigde Staten van Amerika",
  "Vietnam",
  "Wake Island",
  "Wallis en Futuna",
  "Wereld",
  "West Bank",
  "Westelijke Sahara",
  "Zambia",
  "Zimbabwe",
  "Zuid-Afrika",
  "Zuid-Korea",
  "Zweden",
  "Zwitserland"
];

},{}],963:[function(require,module,exports){
module["exports"] = [
  "Nederland"
];

},{}],964:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.city = require("./city");
address.country = require("./country");
address.building_number = require("./building_number");
address.street_suffix = require("./street_suffix");
address.secondary_address = require("./secondary_address");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.postcode = require("./postcode");
address.state = require("./state");
address.default_country = require("./default_country");

},{"./building_number":958,"./city":959,"./city_prefix":960,"./city_suffix":961,"./country":962,"./default_country":963,"./postcode":965,"./secondary_address":966,"./state":967,"./street_address":968,"./street_name":969,"./street_suffix":970}],965:[function(require,module,exports){
module["exports"] = [
  "#### ??"
];

},{}],966:[function(require,module,exports){
module["exports"] = [
  "1 hoog",
  "2 hoog",
  "3 hoog"
];

},{}],967:[function(require,module,exports){
module["exports"] = [
  "Noord-Holland",
  "Zuid-Holland",
  "Utrecht",
  "Zeeland",
  "Overijssel",
  "Gelderland",
  "Drenthe",
  "Friesland",
  "Groningen",
  "Noord-Brabant",
  "Limburg",
  "Flevoland"
];

},{}],968:[function(require,module,exports){
arguments[4][324][0].apply(exports,arguments)
},{"dup":324}],969:[function(require,module,exports){
arguments[4][875][0].apply(exports,arguments)
},{"dup":875}],970:[function(require,module,exports){
module["exports"] = [
  "straat",
  "laan",
  "weg",
  "plantsoen",
  "park"
];

},{}],971:[function(require,module,exports){
arguments[4][538][0].apply(exports,arguments)
},{"./suffix":972,"dup":538}],972:[function(require,module,exports){
module["exports"] = [
  "BV",
  "V.O.F.",
  "Group",
  "en Zonen"
];

},{}],973:[function(require,module,exports){
var nl = {};
module['exports'] = nl;
nl.title = "Dutch";
nl.address = require("./address");
nl.company = require("./company");
nl.internet = require("./internet");
nl.lorem = require("./lorem");
nl.name = require("./name");
nl.phone_number = require("./phone_number");

},{"./address":964,"./company":971,"./internet":976,"./lorem":977,"./name":981,"./phone_number":988}],974:[function(require,module,exports){
module["exports"] = [
  "nl",
  "com",
  "net",
  "org"
];

},{}],975:[function(require,module,exports){
arguments[4][378][0].apply(exports,arguments)
},{"dup":378}],976:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":974,"./free_email":975,"dup":302}],977:[function(require,module,exports){
arguments[4][342][0].apply(exports,arguments)
},{"./supplemental":978,"./words":979,"dup":342}],978:[function(require,module,exports){
arguments[4][343][0].apply(exports,arguments)
},{"dup":343}],979:[function(require,module,exports){
arguments[4][344][0].apply(exports,arguments)
},{"dup":344}],980:[function(require,module,exports){
module["exports"] = [
  "Amber",
  "Anna",
  "Anne",
  "Anouk",
  "Bas",
  "Bram",
  "Britt",
  "Daan",
  "Emma",
  "Eva",
  "Femke",
  "Finn",
  "Fleur",
  "Iris",
  "Isa",
  "Jan",
  "Jasper",
  "Jayden",
  "Jesse",
  "Johannes",
  "Julia",
  "Julian",
  "Kevin",
  "Lars",
  "Lieke",
  "Lisa",
  "Lotte",
  "Lucas",
  "Luuk",
  "Maud",
  "Max",
  "Mike",
  "Milan",
  "Nick",
  "Niels",
  "Noa",
  "Rick",
  "Roos",
  "Ruben",
  "Sander",
  "Sanne",
  "Sem",
  "Sophie",
  "Stijn",
  "Sven",
  "Thijs",
  "Thijs",
  "Thomas",
  "Tim",
  "Tom"
];

},{}],981:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.tussenvoegsel = require("./tussenvoegsel");
name.last_name = require("./last_name");
name.prefix = require("./prefix");
name.suffix = require("./suffix");
name.name = require("./name");

},{"./first_name":980,"./last_name":982,"./name":983,"./prefix":984,"./suffix":985,"./tussenvoegsel":986}],982:[function(require,module,exports){
module["exports"] = [
  "Bakker",
  "Beek",
  "Berg",
  "Boer",
  "Bos",
  "Bosch",
  "Brink",
  "Broek",
  "Brouwer",
  "Bruin",
  "Dam",
  "Dekker",
  "Dijk",
  "Dijkstra",
  "Graaf",
  "Groot",
  "Haan",
  "Hendriks",
  "Heuvel",
  "Hoek",
  "Jacobs",
  "Jansen",
  "Janssen",
  "Jong",
  "Klein",
  "Kok",
  "Koning",
  "Koster",
  "Leeuwen",
  "Linden",
  "Maas",
  "Meer",
  "Meijer",
  "Mulder",
  "Peters",
  "Ruiter",
  "Schouten",
  "Smit",
  "Smits",
  "Stichting",
  "Veen",
  "Ven",
  "Vermeulen",
  "Visser",
  "Vliet",
  "Vos",
  "Vries",
  "Wal",
  "Willems",
  "Wit"
];

},{}],983:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{first_name} #{last_name}",
  "#{first_name} #{last_name} #{suffix}",
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name}",
  "#{first_name} #{tussenvoegsel} #{last_name}",
  "#{first_name} #{tussenvoegsel} #{last_name}"
];

},{}],984:[function(require,module,exports){
module["exports"] = [
  "Dhr.",
  "Mevr. Dr.",
  "Bsc",
  "Msc",
  "Prof."
];

},{}],985:[function(require,module,exports){
arguments[4][939][0].apply(exports,arguments)
},{"dup":939}],986:[function(require,module,exports){
module["exports"] = [
  "van",
  "van de",
  "van den",
  "van 't",
  "van het",
  "de",
  "den"
];

},{}],987:[function(require,module,exports){
module["exports"] = [
  "(####) ######",
  "##########",
  "06########",
  "06 #### ####"
];

},{}],988:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":987,"dup":312}],989:[function(require,module,exports){
arguments[4][438][0].apply(exports,arguments)
},{"dup":438}],990:[function(require,module,exports){
arguments[4][314][0].apply(exports,arguments)
},{"dup":314}],991:[function(require,module,exports){
module["exports"] = [
  "Aleksandrw Kujawski",
  "Aleksandrw dzki",
  "Alwernia",
  "Andrychw",
  "Annopol",
  "Augustw",
  "Babimost",
  "Baborw",
  "Baranw Sandomierski",
  "Barcin",
  "Barczewo",
  "Bardo",
  "Barlinek",
  "Bartoszyce",
  "Barwice",
  "Bechatw",
  "Beyce",
  "Bdzin",
  "Biaa",
  "Biaa Piska",
  "Biaa Podlaska",
  "Biaa Rawska",
  "Biaobrzegi",
  "Biaogard",
  "Biay Br",
  "Biaystok",
  "Biecz",
  "Bielawa",
  "Bielsk Podlaski",
  "Bielsko-Biaa",
  "Bieru",
  "Bierutw",
  "Bieu",
  "Bigoraj",
  "Biskupiec",
  "Bisztynek",
  "Blachownia",
  "Baszki",
  "Baowa",
  "Bonie",
  "Bobolice",
  "Bobowa",
  "Bochnia",
  "Bodzentyn",
  "Bogatynia",
  "Boguchwaa",
  "Boguszw-Gorce",
  "Bojanowo",
  "Bolesawiec",
  "Bolkw",
  "Borek Wielkopolski",
  "Borne Sulinowo",
  "Braniewo",
  "Brask",
  "Brodnica",
  "Brok",
  "Brusy",
  "Brwinw",
  "Brzeg",
  "Brzeg Dolny",
  "Brzesko",
  "Brzeszcze",
  "Brze Kujawski",
  "Brzeziny",
  "Brzostek",
  "Brzozw",
  "Buk",
  "Bukowno",
  "Busko-Zdrj",
  "Bychawa",
  "Byczyna",
  "Bydgoszcz",
  "Bystrzyca Kodzka",
  "Bytom",
  "Bytom Odrzaski",
  "Bytw",
  "Cedynia",
  "Chem",
  "Chemek",
  "Chemno",
  "Chema",
  "Chciny",
  "Chmielnik",
  "Chocianw",
  "Chociwel",
  "Chodecz",
  "Chodzie",
  "Chojna",
  "Chojnice",
  "Chojnw",
  "Choroszcz",
  "Chorzele",
  "Chorzw",
  "Choszczno",
  "Chrzanw",
  "Ciechanowiec",
  "Ciechanw",
  "Ciechocinek",
  "Cieszanw",
  "Cieszyn",
  "Cikowice",
  "Cybinka",
  "Czaplinek",
  "Czarna Biaostocka",
  "Czarna Woda",
  "Czarne",
  "Czarnkw",
  "Czchw",
  "Czechowice-Dziedzice",
  "Czelad",
  "Czempi",
  "Czerniejewo",
  "Czersk",
  "Czerwiesk",
  "Czerwionka-Leszczyny",
  "Czstochowa",
  "Czopa",
  "Czuchw",
  "Czyew",
  "mielw",
  "Daleszyce",
  "Darowo",
  "Dbie",
  "Dbrowa Biaostocka",
  "Dbrowa Grnicza",
  "Dbrowa Tarnowska",
  "Debrzno",
  "Dbica",
  "Dblin",
  "Dbno",
  "Dobczyce",
  "Dobiegniew",
  "Dobra (powiat obeski)",
  "Dobra (powiat turecki)",
  "Dobre Miasto",
  "Dobrodzie",
  "Dobrzany",
  "Dobrzy nad Wis",
  "Dolsk",
  "Drawno",
  "Drawsko Pomorskie",
  "Drezdenko",
  "Drobin",
  "Drohiczyn",
  "Drzewica",
  "Dukla",
  "Duszniki-Zdrj",
  "Dynw",
  "Dziadowo",
  "Dziaoszyce",
  "Dziaoszyn",
  "Dzierzgo",
  "Dzieroniw",
  "Dziwnw",
  "Elblg",
  "Ek",
  "Frampol",
  "Frombork",
  "Garwolin",
  "Gbin",
  "Gdask",
  "Gdynia",
  "Giycko",
  "Glinojeck",
  "Gliwice",
  "Gogw",
  "Gogw Maopolski",
  "Gogwek",
  "Gowno",
  "Gubczyce",
  "Guchoazy",
  "Guszyca",
  "Gniew",
  "Gniewkowo",
  "Gniezno",
  "Gogolin",
  "Golczewo",
  "Goleniw",
  "Golina",
  "Golub-Dobrzy",
  "Goacz",
  "Godap",
  "Gonidz",
  "Gorlice",
  "Gorzw lski",
  "Gorzw Wielkopolski",
  "Gostynin",
  "Gosty",
  "Gocino",
  "Gozdnica",
  "Gra",
  "Gra Kalwaria",
  "Growo Iaweckie",
  "Grzno",
  "Grabw nad Prosn",
  "Grajewo",
  "Grodkw",
  "Grodzisk Mazowiecki",
  "Grodzisk Wielkopolski",
  "Grjec",
  "Grudzidz",
  "Grybw",
  "Gryfice",
  "Gryfino",
  "Gryfw lski",
  "Gubin",
  "Hajnwka",
  "Halinw",
  "Hel",
  "Hrubieszw",
  "Iawa",
  "Iowa",
  "Ia",
  "Imielin",
  "Inowrocaw",
  "Isko",
  "Iwonicz-Zdrj",
  "Izbica Kujawska",
  "Jabonowo Pomorskie",
  "Janikowo",
  "Janowiec Wielkopolski",
  "Janw Lubelski",
  "Jarocin",
  "Jarosaw",
  "Jasie",
  "Jaso",
  "Jastarnia",
  "Jastrowie",
  "Jastrzbie-Zdrj",
  "Jawor",
  "Jaworzno",
  "Jaworzyna lska",
  "Jedlicze",
  "Jedlina-Zdrj",
  "Jedwabne",
  "Jelcz-Laskowice",
  "Jelenia Gra",
  "Jeziorany",
  "Jdrzejw",
  "Jordanw",
  "Jzefw (powiat bigorajski)",
  "Jzefw (powiat otwocki)",
  "Jutrosin",
  "Kalety",
  "Kalisz",
  "Kalisz Pomorski",
  "Kalwaria Zebrzydowska",
  "Kauszyn",
  "Kamienna Gra",
  "Kamie Krajeski",
  "Kamie Pomorski",
  "Kamiesk",
  "Kaczuga",
  "Karczew",
  "Kargowa",
  "Karlino",
  "Karpacz",
  "Kartuzy",
  "Katowice",
  "Kazimierz Dolny",
  "Kazimierza Wielka",
  "Kty Wrocawskie",
  "Kcynia",
  "Kdzierzyn-Kole",
  "Kpice",
  "Kpno",
  "Ktrzyn",
  "Kty",
  "Kielce",
  "Kietrz",
  "Kisielice",
  "Kleczew",
  "Kleszczele",
  "Kluczbork",
  "Kecko",
  "Kobuck",
  "Kodawa",
  "Kodzko",
  "Knurw",
  "Knyszyn",
  "Kobylin",
  "Kobyka",
  "Kock",
  "Kolbuszowa",
  "Kolno",
  "Kolonowskie",
  "Koluszki",
  "Koaczyce",
  "Koo",
  "Koobrzeg",
  "Koniecpol",
  "Konin",
  "Konstancin-Jeziorna",
  "Konstantynw dzki",
  "Koskie",
  "Koprzywnica",
  "Korfantw",
  "Koronowo",
  "Korsze",
  "Kosw Lacki",
  "Kostrzyn",
  "Kostrzyn nad Odr",
  "Koszalin",
  "Kocian",
  "Kocierzyna",
  "Kowal",
  "Kowalewo Pomorskie",
  "Kowary",
  "Koziegowy",
  "Kozienice",
  "Komin Wielkopolski",
  "Kouchw",
  "Krnik",
  "Krajenka",
  "Krakw",
  "Krapkowice",
  "Krasnobrd",
  "Krasnystaw",
  "Kranik",
  "Krobia",
  "Krosno",
  "Krosno Odrzaskie",
  "Kroniewice",
  "Krotoszyn",
  "Kruszwica",
  "Krynica Morska",
  "Krynica-Zdrj",
  "Krynki",
  "Krzanowice",
  "Krzepice",
  "Krzeszowice",
  "Krzywi",
  "Krzy Wielkopolski",
  "Ksi Wielkopolski",
  "Kudowa-Zdrj",
  "Kunw",
  "Kutno",
  "Kunia Raciborska",
  "Kwidzyn",
  "Ldek-Zdrj",
  "Legionowo",
  "Legnica",
  "Lesko",
  "Leszno",
  "Lena",
  "Lenica",
  "Lewin Brzeski",
  "Leajsk",
  "Lbork",
  "Ldziny",
  "Libi",
  "Lidzbark",
  "Lidzbark Warmiski",
  "Limanowa",
  "Lipiany",
  "Lipno",
  "Lipsk",
  "Lipsko",
  "Lubaczw",
  "Luba",
  "Lubartw",
  "Lubawa",
  "Lubawka",
  "Lubie Kujawski",
  "Lubin",
  "Lublin",
  "Lubliniec",
  "Lubniewice",
  "Lubomierz",
  "Lubo",
  "Lubraniec",
  "Lubsko",
  "Lwwek",
  "Lwwek lski",
  "abiszyn",
  "acut",
  "apy",
  "asin",
  "ask",
  "askarzew",
  "aszczw",
  "aziska Grne",
  "azy",
  "eba",
  "czna",
  "czyca",
  "knica",
  "obez",
  "obenica",
  "ochw",
  "omianki",
  "oma",
  "osice",
  "owicz",
  "d",
  "ukw",
  "Makw Mazowiecki",
  "Makw Podhalaski",
  "Malbork",
  "Maogoszcz",
  "Maomice",
  "Margonin",
  "Marki",
  "Maszewo",
  "Miasteczko lskie",
  "Miastko",
  "Michaowo",
  "Miechw",
  "Miejska Grka",
  "Mielec",
  "Mieroszw",
  "Mieszkowice",
  "Midzybrz",
  "Midzychd",
  "Midzylesie",
  "Midzyrzec Podlaski",
  "Midzyrzecz",
  "Midzyzdroje",
  "Mikoajki",
  "Mikow",
  "Mikstat",
  "Milanwek",
  "Milicz",
  "Miakowo",
  "Miomyn",
  "Miosaw",
  "Misk Mazowiecki",
  "Mirosawiec",
  "Mirsk",
  "Mawa",
  "Mynary",
  "Mogielnica",
  "Mogilno",
  "Moki",
  "Morg",
  "Mordy",
  "Mory",
  "Mosina",
  "Mrgowo",
  "Mrocza",
  "Mszana Dolna",
  "Mszczonw",
  "Murowana Golina",
  "Muszyna",
  "Mysowice",
  "Myszkw",
  "Myszyniec",
  "Mylenice",
  "Mylibrz",
  "Nako nad Noteci",
  "Naczw",
  "Namysw",
  "Narol",
  "Nasielsk",
  "Nekla",
  "Nidzica",
  "Niemcza",
  "Niemodlin",
  "Niepoomice",
  "Nieszawa",
  "Nisko",
  "Nowa Dba",
  "Nowa Ruda",
  "Nowa Sarzyna",
  "Nowa Sl",
  "Nowe",
  "Nowe Brzesko",
  "Nowe Miasteczko",
  "Nowe Miasto Lubawskie",
  "Nowe Miasto nad Pilic",
  "Nowe Skalmierzyce",
  "Nowe Warpno",
  "Nowogard",
  "Nowogrodziec",
  "Nowogrd",
  "Nowogrd Bobrzaski",
  "Nowy Dwr Gdaski",
  "Nowy Dwr Mazowiecki",
  "Nowy Scz",
  "Nowy Staw",
  "Nowy Targ",
  "Nowy Tomyl",
  "Nowy Winicz",
  "Nysa",
  "Oborniki",
  "Oborniki lskie",
  "Obrzycko",
  "Odolanw",
  "Ogrodzieniec",
  "Okonek",
  "Olecko",
  "Olesno",
  "Oleszyce",
  "Olenica",
  "Olkusz",
  "Olsztyn",
  "Olsztynek",
  "Olszyna",
  "Oawa",
  "Opalenica",
  "Opatw",
  "Opoczno",
  "Opole",
  "Opole Lubelskie",
  "Orneta",
  "Orzesze",
  "Orzysz",
  "Osieczna",
  "Osiek",
  "Ostroka",
  "Ostrorg",
  "Ostrowiec witokrzyski",
  "Ostrda",
  "Ostrw Lubelski",
  "Ostrw Mazowiecka",
  "Ostrw Wielkopolski",
  "Ostrzeszw",
  "Ono Lubuskie",
  "Owicim",
  "Otmuchw",
  "Otwock",
  "Ozimek",
  "Ozorkw",
  "Oarw",
  "Oarw Mazowiecki",
  "Pabianice",
  "Paczkw",
  "Pajczno",
  "Pako",
  "Parczew",
  "Pask",
  "Pasym",
  "Pelplin",
  "Peczyce",
  "Piaseczno",
  "Piaski",
  "Piastw",
  "Piechowice",
  "Piekary lskie",
  "Pienino",
  "Piesk",
  "Pieszyce",
  "Pilawa",
  "Pilica",
  "Pilzno",
  "Pia",
  "Piawa Grna",
  "Piczw",
  "Pionki",
  "Piotrkw Kujawski",
  "Piotrkw Trybunalski",
  "Pisz",
  "Piwniczna-Zdrj",
  "Pleszew",
  "Pock",
  "Posk",
  "Poty",
  "Pniewy",
  "Pobiedziska",
  "Poddbice",
  "Podkowa Lena",
  "Pogorzela",
  "Polanica-Zdrj",
  "Polanw",
  "Police",
  "Polkowice",
  "Poaniec",
  "Poczyn-Zdrj",
  "Poniatowa",
  "Poniec",
  "Porba",
  "Pozna",
  "Prabuty",
  "Praszka",
  "Prochowice",
  "Proszowice",
  "Prszkw",
  "Pruchnik",
  "Prudnik",
  "Prusice",
  "Pruszcz Gdaski",
  "Pruszkw",
  "Przasnysz",
  "Przecaw",
  "Przedbrz",
  "Przedecz",
  "Przemkw",
  "Przemyl",
  "Przeworsk",
  "Przysucha",
  "Pszczyna",
  "Pszw",
  "Puck",
  "Puawy",
  "Putusk",
  "Puszczykowo",
  "Pyrzyce",
  "Pyskowice",
  "Pyzdry",
  "Rabka-Zdrj",
  "Raci",
  "Racibrz",
  "Radkw",
  "Radlin",
  "Radw",
  "Radom",
  "Radomsko",
  "Radomyl Wielki",
  "Radymno",
  "Radziejw",
  "Radzionkw",
  "Radzymin",
  "Radzy Chemiski",
  "Radzy Podlaski",
  "Rajgrd",
  "Rakoniewice",
  "Raszkw",
  "Rawa Mazowiecka",
  "Rawicz",
  "Recz",
  "Reda",
  "Rejowiec Fabryczny",
  "Resko",
  "Reszel",
  "Rogono",
  "Ropczyce",
  "Ran",
  "Ruciane-Nida",
  "Ruda lska",
  "Rudnik nad Sanem",
  "Rumia",
  "Rybnik",
  "Rychwa",
  "Rydutowy",
  "Rydzyna",
  "Ryglice",
  "Ryki",
  "Rymanw",
  "Ryn",
  "Rypin",
  "Rzepin",
  "Rzeszw",
  "Rzgw",
  "Sandomierz",
  "Sanok",
  "Sejny",
  "Serock",
  "Sdziszw",
  "Sdziszw Maopolski",
  "Spopol",
  "Splno Krajeskie",
  "Sianw",
  "Siechnice",
  "Siedlce",
  "Siemianowice lskie",
  "Siemiatycze",
  "Sieniawa",
  "Sieradz",
  "Sierakw",
  "Sierpc",
  "Siewierz",
  "Skalbmierz",
  "Skaa",
  "Skarszewy",
  "Skaryszew",
  "Skarysko-Kamienna",
  "Skawina",
  "Skpe",
  "Skierniewice",
  "Skoczw",
  "Skoki",
  "Skrcz",
  "Skwierzyna",
  "Sawa",
  "Sawkw",
  "Sawno",
  "Somniki",
  "Subice",
  "Supca",
  "Supsk",
  "Sobtka",
  "Sochaczew",
  "Sokow Maopolski",
  "Sokow Podlaski",
  "Sokka",
  "Solec Kujawski",
  "Sompolno",
  "Sopot",
  "Sosnowiec",
  "Sonicowice",
  "Stalowa Wola",
  "Starachowice",
  "Stargard Szczeciski",
  "Starogard Gdaski",
  "Stary Scz",
  "Staszw",
  "Stawiski",
  "Stawiszyn",
  "Stporkw",
  "Stszew",
  "Stoczek ukowski",
  "Stronie lskie",
  "Strumie",
  "Strykw",
  "Strzegom",
  "Strzelce Krajeskie",
  "Strzelce Opolskie",
  "Strzelin",
  "Strzelno",
  "Strzyw",
  "Sucha Beskidzka",
  "Sucha",
  "Suchedniw",
  "Suchowola",
  "Sulechw",
  "Sulejw",
  "Sulejwek",
  "Sulcin",
  "Sulmierzyce",
  "Sukowice",
  "Supral",
  "Sura",
  "Susz",
  "Suwaki",
  "Swarzdz",
  "Sycw",
  "Szadek",
  "Szamocin",
  "Szamotuy",
  "Szczawnica",
  "Szczawno-Zdrj",
  "Szczebrzeszyn",
  "Szczecin",
  "Szczecinek",
  "Szczekociny",
  "Szczucin",
  "Szczuczyn",
  "Szczyrk",
  "Szczytna",
  "Szczytno",
  "Szepietowo",
  "Szklarska Porba",
  "Szlichtyngowa",
  "Szprotawa",
  "Sztum",
  "Szubin",
  "Szydowiec",
  "cinawa",
  "lesin",
  "migiel",
  "rem",
  "roda lska",
  "roda Wielkopolska",
  "witniki Grne",
  "widnica",
  "widnik",
  "widwin",
  "wiebodzice",
  "wiebodzin",
  "wiecie",
  "wieradw-Zdrj",
  "wierzawa",
  "witochowice",
  "winoujcie",
  "Tarczyn",
  "Tarnobrzeg",
  "Tarnogrd",
  "Tarnowskie Gry",
  "Tarnw",
  "Tczew",
  "Terespol",
  "Tuszcz",
  "Tolkmicko",
  "Tomaszw Lubelski",
  "Tomaszw Mazowiecki",
  "Toru",
  "Torzym",
  "Toszek",
  "Trzcianka",
  "Trzciel",
  "Trzcisko-Zdrj",
  "Trzebiatw",
  "Trzebinia",
  "Trzebnica",
  "Trzemeszno",
  "Tuchola",
  "Tuchw",
  "Tuczno",
  "Tuliszkw",
  "Turek",
  "Tuszyn",
  "Twardogra",
  "Tychowo",
  "Tychy",
  "Tyczyn",
  "Tykocin",
  "Tyszowce",
  "Ujazd",
  "Ujcie",
  "Ulanw",
  "Uniejw",
  "Ustka",
  "Ustro",
  "Ustrzyki Dolne",
  "Wadowice",
  "Wabrzych",
  "Wacz",
  "Warka",
  "Warszawa",
  "Warta",
  "Wasilkw",
  "Wbrzeno",
  "Wchock",
  "Wgrowiec",
  "Wsosz",
  "Wejherowo",
  "Wgliniec",
  "Wgorzewo",
  "Wgorzyno",
  "Wgrw",
  "Wizw",
  "Wiele",
  "Wielichowo",
  "Wieliczka",
  "Wielu",
  "Wieruszw",
  "Wicbork",
  "Wilamowice",
  "Wisa",
  "Witkowo",
  "Witnica",
  "Wle",
  "Wadysawowo",
  "Wocawek",
  "Wodawa",
  "Woszczowa",
  "Wodzisaw lski",
  "Wojcieszw",
  "Wojkowice",
  "Wojnicz",
  "Wolbrz",
  "Wolbrom",
  "Wolin",
  "Wolsztyn",
  "Woczyn",
  "Woomin",
  "Wow",
  "Woniki",
  "Wrocaw",
  "Wronki",
  "Wrzenia",
  "Wschowa",
  "Wyrzysk",
  "Wysoka",
  "Wysokie Mazowieckie",
  "Wyszkw",
  "Wyszogrd",
  "Wymierzyce",
  "Zabudw",
  "Zabrze",
  "Zagrw",
  "Zagrz",
  "Zakliczyn",
  "Zakopane",
  "Zakroczym",
  "Zalewo",
  "Zambrw",
  "Zamo",
  "Zator",
  "Zawadzkie",
  "Zawichost",
  "Zawidw",
  "Zawiercie",
  "Zbki",
  "Zbkowice lskie",
  "Zbszynek",
  "Zbszy",
  "Zduny",
  "Zduska Wola",
  "Zdzieszowice",
  "Zelw",
  "Zgierz",
  "Zgorzelec",
  "Zielona Gra",
  "Zielonka",
  "Zibice",
  "Zocieniec",
  "Zoczew",
  "Zotoryja",
  "Zotw",
  "Zoty Stok",
  "Zwierzyniec",
  "Zwole",
  "abno",
  "aga",
  "arki",
  "arw",
  "ary",
  "elechw",
  "erkw",
  "migrd",
  "nin",
  "ory",
  "ukowo",
  "uromin",
  "ychlin",
  "yrardw",
  "ywiec"
];

},{}],992:[function(require,module,exports){
module["exports"] = [
  "Afganistan",
  "Albania",
  "Algieria",
  "Andora",
  "Angola",
  "Antigua i Barbuda",
  "Arabia Saudyjska",
  "Argentyna",
  "Armenia",
  "Australia",
  "Austria",
  "Azerbejdan",
  "Bahamy",
  "Bahrajn",
  "Bangladesz",
  "Barbados",
  "Belgia",
  "Belize",
  "Benin",
  "Bhutan",
  "Biaoru",
  "Birma",
  "Boliwia",
  "Sucre",
  "Bonia i Hercegowina",
  "Botswana",
  "Brazylia",
  "Brunei",
  "Bugaria",
  "Burkina Faso",
  "Burundi",
  "Chile",
  "Chiny",
  "Chorwacja",
  "Cypr",
  "Czad",
  "Czarnogra",
  "Czechy",
  "Dania",
  "Demokratyczna Republika Konga",
  "Dominika",
  "Dominikana",
  "Dibuti",
  "Egipt",
  "Ekwador",
  "Erytrea",
  "Estonia",
  "Etiopia",
  "Fidi",
  "Filipiny",
  "Finlandia",
  "Francja",
  "Gabon",
  "Gambia",
  "Ghana",
  "Grecja",
  "Grenada",
  "Gruzja",
  "Gujana",
  "Gwatemala",
  "Gwinea",
  "Gwinea Bissau",
  "Gwinea Rwnikowa",
  "Haiti",
  "Hiszpania",
  "Holandia",
  "Haga",
  "Honduras",
  "Indie",
  "Indonezja",
  "Irak",
  "Iran",
  "Irlandia",
  "Islandia",
  "Izrael",
  "Jamajka",
  "Japonia",
  "Jemen",
  "Jordania",
  "Kamboda",
  "Kamerun",
  "Kanada",
  "Katar",
  "Kazachstan",
  "Kenia",
  "Kirgistan",
  "Kiribati",
  "Kolumbia",
  "Komory",
  "Kongo",
  "Korea Poudniowa",
  "Korea Pnocna",
  "Kostaryka",
  "Kuba",
  "Kuwejt",
  "Laos",
  "Lesotho",
  "Liban",
  "Liberia",
  "Libia",
  "Liechtenstein",
  "Litwa",
  "Luksemburg",
  "otwa",
  "Macedonia",
  "Madagaskar",
  "Malawi",
  "Malediwy",
  "Malezja",
  "Mali",
  "Malta",
  "Maroko",
  "Mauretania",
  "Mauritius",
  "Meksyk",
  "Mikronezja",
  "Modawia",
  "Monako",
  "Mongolia",
  "Mozambik",
  "Namibia",
  "Nauru",
  "Nepal",
  "Niemcy",
  "Niger",
  "Nigeria",
  "Nikaragua",
  "Norwegia",
  "Nowa Zelandia",
  "Oman",
  "Pakistan",
  "Palau",
  "Panama",
  "Papua-Nowa Gwinea",
  "Paragwaj",
  "Peru",
  "Polska",
  "322 575",
  "Portugalia",
  "Republika Poudniowej Afryki",
  "Republika rodkowoafrykaska",
  "Republika Zielonego Przyldka",
  "Rosja",
  "Rumunia",
  "Rwanda",
  "Saint Kitts i Nevis",
  "Saint Lucia",
  "Saint Vincent i Grenadyny",
  "Salwador",
  "Samoa",
  "San Marino",
  "Senegal",
  "Serbia",
  "Seszele",
  "Sierra Leone",
  "Singapur",
  "Sowacja",
  "Sowenia",
  "Somalia",
  "Sri Lanka",
  "Stany Zjednoczone",
  "Suazi",
  "Sudan",
  "Sudan Poudniowy",
  "Surinam",
  "Syria",
  "Szwajcaria",
  "Szwecja",
  "Tadykistan",
  "Tajlandia",
  "Tanzania",
  "Timor Wschodni",
  "Togo",
  "Tonga",
  "Trynidad i Tobago",
  "Tunezja",
  "Turcja",
  "Turkmenistan",
  "Tuvalu",
  "Funafuti",
  "Uganda",
  "Ukraina",
  "Urugwaj",
  2008,
  "Uzbekistan",
  "Vanuatu",
  "Watykan",
  "Wenezuela",
  "Wgry",
  "Wielka Brytania",
  "Wietnam",
  "Wochy",
  "Wybrzee Koci Soniowej",
  "Wyspy Marshalla",
  "Wyspy Salomona",
  "Wyspy witego Tomasza i Ksica",
  "Zambia",
  "Zimbabwe",
  "Zjednoczone Emiraty Arabskie"
];

},{}],993:[function(require,module,exports){
module["exports"] = [
  "Polska"
];

},{}],994:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.country = require("./country");
address.building_number = require("./building_number");
address.street_prefix = require("./street_prefix");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.city_name = require("./city_name");
address.city = require("./city");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":989,"./city":990,"./city_name":991,"./country":992,"./default_country":993,"./postcode":995,"./secondary_address":996,"./state":997,"./state_abbr":998,"./street_address":999,"./street_name":1000,"./street_prefix":1001}],995:[function(require,module,exports){
module["exports"] = [
  "##-###"
];

},{}],996:[function(require,module,exports){
arguments[4][320][0].apply(exports,arguments)
},{"dup":320}],997:[function(require,module,exports){
module["exports"] = [
  "Dolnolskie",
  "Kujawsko-pomorskie",
  "Lubelskie",
  "Lubuskie",
  "dzkie",
  "Maopolskie",
  "Mazowieckie",
  "Opolskie",
  "Podkarpackie",
  "Podlaskie",
  "Pomorskie",
  "lskie",
  "witokrzyskie",
  "Warmisko-mazurskie",
  "Wielkopolskie",
  "Zachodniopomorskie"
];

},{}],998:[function(require,module,exports){
module["exports"] = [
  "D",
  "KP",
  "LB",
  "LS",
  "D",
  "MP",
  "MZ",
  "OP",
  "PK",
  "PL",
  "PM",
  "L",
  "K",
  "WM",
  "WP",
  "ZP"
];

},{}],999:[function(require,module,exports){
arguments[4][324][0].apply(exports,arguments)
},{"dup":324}],1000:[function(require,module,exports){
module["exports"] = [
  "#{street_prefix} #{Name.last_name}"
];

},{}],1001:[function(require,module,exports){
module["exports"] = [
  "ul.",
  "al."
];

},{}],1002:[function(require,module,exports){
module["exports"] = [
  "50-###-##-##",
  "51-###-##-##",
  "53-###-##-##",
  "57-###-##-##",
  "60-###-##-##",
  "66-###-##-##",
  "69-###-##-##",
  "72-###-##-##",
  "73-###-##-##",
  "78-###-##-##",
  "79-###-##-##",
  "88-###-##-##"
];

},{}],1003:[function(require,module,exports){
arguments[4][371][0].apply(exports,arguments)
},{"./formats":1002,"dup":371}],1004:[function(require,module,exports){
arguments[4][327][0].apply(exports,arguments)
},{"dup":327}],1005:[function(require,module,exports){
arguments[4][471][0].apply(exports,arguments)
},{"dup":471}],1006:[function(require,module,exports){
arguments[4][472][0].apply(exports,arguments)
},{"dup":472}],1007:[function(require,module,exports){
arguments[4][329][0].apply(exports,arguments)
},{"dup":329}],1008:[function(require,module,exports){
arguments[4][330][0].apply(exports,arguments)
},{"dup":330}],1009:[function(require,module,exports){
var company = {};
module['exports'] = company;
company.suffix = require("./suffix");
company.adjetive = require("./adjetive");
company.descriptor = require("./descriptor");
company.noun = require("./noun");
company.bs_verb = require("./bs_verb");
company.bs_adjective = require("./bs_adjective");
company.bs_noun = require("./bs_noun");
company.name = require("./name");

},{"./adjetive":1004,"./bs_adjective":1005,"./bs_noun":1006,"./bs_verb":1007,"./descriptor":1008,"./name":1010,"./noun":1011,"./suffix":1012}],1010:[function(require,module,exports){
arguments[4][476][0].apply(exports,arguments)
},{"dup":476}],1011:[function(require,module,exports){
arguments[4][333][0].apply(exports,arguments)
},{"dup":333}],1012:[function(require,module,exports){
arguments[4][478][0].apply(exports,arguments)
},{"dup":478}],1013:[function(require,module,exports){
var pl = {};
module['exports'] = pl;
pl.title = "Polish";
pl.name = require("./name");
pl.address = require("./address");
pl.company = require("./company");
pl.internet = require("./internet");
pl.lorem = require("./lorem");
pl.phone_number = require("./phone_number");
pl.cell_phone = require("./cell_phone");

},{"./address":994,"./cell_phone":1003,"./company":1009,"./internet":1016,"./lorem":1017,"./name":1021,"./phone_number":1027}],1014:[function(require,module,exports){
module["exports"] = [
  "com",
  "pl",
  "com.pl",
  "net",
  "org"
];

},{}],1015:[function(require,module,exports){
arguments[4][378][0].apply(exports,arguments)
},{"dup":378}],1016:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":1014,"./free_email":1015,"dup":302}],1017:[function(require,module,exports){
arguments[4][342][0].apply(exports,arguments)
},{"./supplemental":1018,"./words":1019,"dup":342}],1018:[function(require,module,exports){
arguments[4][343][0].apply(exports,arguments)
},{"dup":343}],1019:[function(require,module,exports){
arguments[4][344][0].apply(exports,arguments)
},{"dup":344}],1020:[function(require,module,exports){
module["exports"] = [
  "Aaron",
  "Abraham",
  "Adam",
  "Adrian",
  "Atanazy",
  "Agaton",
  "Alan",
  "Albert",
  "Aleksander",
  "Aleksy",
  "Alfred",
  "Alwar",
  "Ambroy",
  "Anatol",
  "Andrzej",
  "Antoni",
  "Apollinary",
  "Apollo",
  "Arkady",
  "Arkadiusz",
  "Archibald",
  "Arystarch",
  "Arnold",
  "Arseniusz",
  "Artur",
  "August",
  "Baldwin",
  "Bazyli",
  "Benedykt",
  "Beniamin",
  "Bernard",
  "Bertrand",
  "Bertram",
  "Borys",
  "Brajan",
  "Bruno",
  "Cezary",
  "Cecyliusz",
  "Karol",
  "Krystian",
  "Krzysztof",
  "Klarencjusz",
  "Klaudiusz",
  "Klemens",
  "Konrad",
  "Konstanty",
  "Konstantyn",
  "Kornel",
  "Korneliusz",
  "Korneli",
  "Cyryl",
  "Cyrus",
  "Damian",
  "Daniel",
  "Dariusz",
  "Dawid",
  "Dionizy",
  "Demetriusz",
  "Dominik",
  "Donald",
  "Dorian",
  "Edgar",
  "Edmund",
  "Edward",
  "Edwin",
  "Efrem",
  "Efraim",
  "Eliasz",
  "Eleazar",
  "Emil",
  "Emanuel",
  "Erast",
  "Ernest",
  "Eugeniusz",
  "Eustracjusz",
  "Fabian",
  "Feliks",
  "Florian",
  "Franciszek",
  "Fryderyk",
  "Gabriel",
  "Gedeon",
  "Galfryd",
  "Jerzy",
  "Gerald",
  "Gerazym",
  "Gilbert",
  "Gonsalwy",
  "Grzegorz",
  "Gwido",
  "Harald",
  "Henryk",
  "Herbert",
  "Herman",
  "Hilary",
  "Horacy",
  "Hubert",
  "Hugo",
  "Ignacy",
  "Igor",
  "Hilarion",
  "Innocenty",
  "Hipolit",
  "Ireneusz",
  "Erwin",
  "Izaak",
  "Izajasz",
  "Izydor",
  "Jakub",
  "Jeremi",
  "Jeremiasz",
  "Hieronim",
  "Gerald",
  "Joachim",
  "Jan",
  "Janusz",
  "Jonatan",
  "Jzef",
  "Jozue",
  "Julian",
  "Juliusz",
  "Justyn",
  "Kalistrat",
  "Kazimierz",
  "Wawrzyniec",
  "Laurenty",
  "Laurencjusz",
  "azarz",
  "Leon",
  "Leonard",
  "Leonid",
  "Leon",
  "Ludwik",
  "ukasz",
  "Lucjan",
  "Magnus",
  "Makary",
  "Marceli",
  "Marek",
  "Marcin",
  "Mateusz",
  "Maurycy",
  "Maksym",
  "Maksymilian",
  "Micha",
  "Miron",
  "Modest",
  "Mojesz",
  "Natan",
  "Natanael",
  "Nazariusz",
  "Nazary",
  "Nestor",
  "Mikoaj",
  "Nikodem",
  "Olaf",
  "Oleg",
  "Oliwier",
  "Onufry",
  "Orestes",
  "Oskar",
  "Ansgary",
  "Osmund",
  "Pankracy",
  "Pantaleon",
  "Patryk",
  "Patrycjusz",
  "Patrycy",
  "Pawe",
  "Piotr",
  "Filemon",
  "Filip",
  "Platon",
  "Polikarp",
  "Porfiry",
  "Porfiriusz",
  "Prokles",
  "Prokul",
  "Prokop",
  "Kwintyn",
  "Randolf",
  "Rafa",
  "Rajmund",
  "Reginald",
  "Rajnold",
  "Ryszard",
  "Robert",
  "Roderyk",
  "Roger",
  "Roland",
  "Roman",
  "Romeo",
  "Reginald",
  "Rudolf",
  "Samson",
  "Samuel",
  "Salwator",
  "Sebastian",
  "Serafin",
  "Sergiusz",
  "Seweryn",
  "Zygmunt",
  "Sylwester",
  "Szymon",
  "Salomon",
  "Spirydion",
  "Stanisaw",
  "Szczepan",
  "Stefan",
  "Terencjusz",
  "Teodor",
  "Tomasz",
  "Tymoteusz",
  "Tobiasz",
  "Walenty",
  "Walentyn",
  "Walerian",
  "Walery",
  "Wiktor",
  "Wincenty",
  "Witalis",
  "Wodzimierz",
  "Wadysaw",
  "Baej",
  "Walter",
  "Walgierz",
  "Wacaw",
  "Wilfryd",
  "Wilhelm",
  "Ksawery",
  "Ksenofont",
  "Jerzy",
  "Zachariasz",
  "Zachary",
  "Ada",
  "Adelajda",
  "Agata",
  "Agnieszka",
  "Agrypina",
  "Aida",
  "Aleksandra",
  "Alicja",
  "Alina",
  "Amanda",
  "Anastazja",
  "Angela",
  "Andelika",
  "Angelina",
  "Anna",
  "Hanna",
  "",
  "Antonina",
  "Ariadna",
  "Aurora",
  "Barbara",
  "Beatrycze",
  "Berta",
  "Brygida",
  "Kamila",
  "Karolina",
  "Karolina",
  "Kornelia",
  "Katarzyna",
  "Cecylia",
  "Karolina",
  "Chloe",
  "Krystyna",
  "Klara",
  "Klaudia",
  "Klementyna",
  "Konstancja",
  "Koralia",
  "Daria",
  "Diana",
  "Dina",
  "Dorota",
  "Edyta",
  "Eleonora",
  "Eliza",
  "Elbieta",
  "Izabela",
  "Elwira",
  "Emilia",
  "Estera",
  "Eudoksja",
  "Eudokia",
  "Eugenia",
  "Ewa",
  "Ewelina",
  "Ferdynanda",
  "Florencja",
  "Franciszka",
  "Gabriela",
  "Gertruda",
  "Gloria",
  "Gracja",
  "Jadwiga",
  "Helena",
  "Henryka",
  "Nadzieja",
  "Ida",
  "Ilona",
  "Helena",
  "Irena",
  "Irma",
  "Izabela",
  "Izolda",
  "Jakubina",
  "Joanna",
  "Janina",
  "aneta",
  "Joanna",
  "Ginewra",
  "Jzefina",
  "Judyta",
  "Julia",
  "Julia",
  "Julita",
  "Justyna",
  "Kira",
  "Cyra",
  "Kleopatra",
  "Larysa",
  "Laura",
  "Laurencja",
  "Laurentyna",
  "Lea",
  "Leila",
  "Eleonora",
  "Liliana",
  "Lilianna",
  "Lilia",
  "Lilla",
  "Liza",
  "Eliza",
  "Laura",
  "Ludwika",
  "Luiza",
  "ucja",
  "Lucja",
  "Lidia",
  "Amabela",
  "Magdalena",
  "Malwina",
  "Magorzata",
  "Greta",
  "Marianna",
  "Maryna",
  "Marta",
  "Martyna",
  "Maria",
  "Matylda",
  "Maja",
  "Maja",
  "Melania",
  "Michalina",
  "Monika",
  "Nadzieja",
  "Noemi",
  "Natalia",
  "Nikola",
  "Nina",
  "Olga",
  "Olimpia",
  "Oliwia",
  "Ofelia",
  "Patrycja",
  "Paula",
  "Pelagia",
  "Penelopa",
  "Filipa",
  "Paulina",
  "Rachela",
  "Rebeka",
  "Regina",
  "Renata",
  "Rozalia",
  "Ra",
  "Roksana",
  "Rufina",
  "Ruta",
  "Sabina",
  "Sara",
  "Serafina",
  "Sybilla",
  "Sylwia",
  "Zofia",
  "Stella",
  "Stefania",
  "Zuzanna",
  "Tamara",
  "Tacjana",
  "Tekla",
  "Teodora",
  "Teresa",
  "Walentyna",
  "Waleria",
  "Wanesa",
  "Wiara",
  "Weronika",
  "Wiktoria",
  "Wirginia",
  "Bibiana",
  "Bibianna",
  "Wanda",
  "Wilhelmina",
  "Ksawera",
  "Ksenia",
  "Zoe"
];

},{}],1021:[function(require,module,exports){
arguments[4][752][0].apply(exports,arguments)
},{"./first_name":1020,"./last_name":1022,"./name":1023,"./prefix":1024,"./title":1025,"dup":752}],1022:[function(require,module,exports){
module["exports"] = [
  "Adamczak",
  "Adamczyk",
  "Adamek",
  "Adamiak",
  "Adamiec",
  "Adamowicz",
  "Adamski",
  "Adamus",
  "Aleksandrowicz",
  "Andrzejczak",
  "Andrzejewski",
  "Antczak",
  "Augustyn",
  "Augustyniak",
  "Bagiski",
  "Balcerzak",
  "Banach",
  "Banasiak",
  "Banasik",
  "Bana",
  "Baran",
  "Baranowski",
  "Baraski",
  "Bartczak",
  "Bartkowiak",
  "Bartnik",
  "Bartosik",
  "Bednarczyk",
  "Bednarek",
  "Bednarski",
  "Bednarz",
  "Biaas",
  "Biaek",
  "Biakowski",
  "Bielak",
  "Bielawski",
  "Bielecki",
  "Bielski",
  "Bieniek",
  "Biernacki",
  "Biernat",
  "Biekowski",
  "Bilski",
  "Bober",
  "Bochenek",
  "Bogucki",
  "Bogusz",
  "Borek",
  "Borkowski",
  "Borowiec",
  "Borowski",
  "Boek",
  "Broda",
  "Brzeziski",
  "Brzozowski",
  "Buczek",
  "Buczkowski",
  "Buczyski",
  "Budziski",
  "Budzyski",
  "Bujak",
  "Bukowski",
  "Burzyski",
  "Bk",
  "Bkowski",
  "Baszczak",
  "Baszczyk",
  "Cebula",
  "Chmiel",
  "Chmielewski",
  "Chmura",
  "Chojnacki",
  "Chojnowski",
  "Cholewa",
  "Chrzanowski",
  "Chudzik",
  "Cichocki",
  "Cicho",
  "Cichy",
  "Ciesielski",
  "Ciela",
  "Cielak",
  "Cielik",
  "Ciszewski",
  "Cybulski",
  "Cygan",
  "Czaja",
  "Czajka",
  "Czajkowski",
  "Czapla",
  "Czarnecki",
  "Czech",
  "Czechowski",
  "Czekaj",
  "Czerniak",
  "Czerwiski",
  "Czy",
  "Czyewski",
  "Dec",
  "Dobosz",
  "Dobrowolski",
  "Dobrzyski",
  "Domagaa",
  "Domaski",
  "Dominiak",
  "Drabik",
  "Drozd",
  "Drozdowski",
  "Drzewiecki",
  "Drd",
  "Dubiel",
  "Duda",
  "Dudek",
  "Dudziak",
  "Dudzik",
  "Dudziski",
  "Duszyski",
  "Dziedzic",
  "Dziuba",
  "Dbek",
  "Dbkowski",
  "Dbrowski",
  "Dbowski",
  "Dbski",
  "Dugosz",
  "Falkowski",
  "Fijakowski",
  "Filipek",
  "Filipiak",
  "Filipowicz",
  "Flak",
  "Flis",
  "Florczak",
  "Florek",
  "Frankowski",
  "Frckowiak",
  "Frczek",
  "Frtczak",
  "Furman",
  "Gadomski",
  "Gajda",
  "Gajewski",
  "Gawe",
  "Gawlik",
  "Gawron",
  "Gawroski",
  "Gaka",
  "Gazka",
  "Gil",
  "Godlewski",
  "Golec",
  "Gob",
  "Gobiewski",
  "Gobiowski",
  "Grabowski",
  "Graczyk",
  "Grochowski",
  "Grudzie",
  "Gruszczyski",
  "Gruszka",
  "Grzegorczyk",
  "Grzelak",
  "Grzesiak",
  "Grzesik",
  "Grzekowiak",
  "Grzyb",
  "Grzybowski",
  "Grzywacz",
  "Gutowski",
  "Guzik",
  "Gwd",
  "Gra",
  "Gral",
  "Grecki",
  "Grka",
  "Grniak",
  "Grny",
  "Grski",
  "Gsior",
  "Gsiorowski",
  "Gogowski",
  "Gowacki",
  "Gb",
  "Hajduk",
  "Herman",
  "Iwaski",
  "Izdebski",
  "Jaboski",
  "Jackowski",
  "Jagielski",
  "Jagieo",
  "Jagodziski",
  "Jakubiak",
  "Jakubowski",
  "Janas",
  "Janiak",
  "Janicki",
  "Janik",
  "Janiszewski",
  "Jankowiak",
  "Jankowski",
  "Janowski",
  "Janus",
  "Janusz",
  "Januszewski",
  "Jaros",
  "Jarosz",
  "Jarzbek",
  "Jasiski",
  "Jastrzbski",
  "Jaworski",
  "Jakiewicz",
  "Jezierski",
  "Jurek",
  "Jurkiewicz",
  "Jurkowski",
  "Juszczak",
  "Jwiak",
  "Jwik",
  "Jdrzejczak",
  "Jdrzejczyk",
  "Jdrzejewski",
  "Kacprzak",
  "Kaczmarczyk",
  "Kaczmarek",
  "Kaczmarski",
  "Kaczor",
  "Kaczorowski",
  "Kaczyski",
  "Kaleta",
  "Kalinowski",
  "Kalisz",
  "Kamiski",
  "Kania",
  "Kaniewski",
  "Kapusta",
  "Kara",
  "Karczewski",
  "Karpiski",
  "Karwowski",
  "Kasperek",
  "Kasprzak",
  "Kasprzyk",
  "Kaszuba",
  "Kawa",
  "Kawecki",
  "Kaua",
  "Kamierczak",
  "Kiebasa",
  "Kisiel",
  "Kita",
  "Klimczak",
  "Klimek",
  "Kmiecik",
  "Kmie",
  "Knapik",
  "Kobus",
  "Kogut",
  "Kolasa",
  "Komorowski",
  "Konieczna",
  "Konieczny",
  "Konopka",
  "Kopczyski",
  "Koper",
  "Kope",
  "Korzeniowski",
  "Kos",
  "Kosiski",
  "Kosowski",
  "Kostecki",
  "Kostrzewa",
  "Kot",
  "Kotowski",
  "Kowal",
  "Kowalczuk",
  "Kowalczyk",
  "Kowalewski",
  "Kowalik",
  "Kowalski",
  "Koza",
  "Kozak",
  "Kozie",
  "Kozio",
  "Kozowski",
  "Koakowski",
  "Koodziej",
  "Koodziejczyk",
  "Koodziejski",
  "Krajewski",
  "Krakowiak",
  "Krawczyk",
  "Krawiec",
  "Kruk",
  "Krukowski",
  "Krupa",
  "Krupiski",
  "Kruszewski",
  "Krysiak",
  "Krzemiski",
  "Krzyanowski",
  "Krl",
  "Krlikowski",
  "Ksiek",
  "Kubacki",
  "Kubiak",
  "Kubica",
  "Kubicki",
  "Kubik",
  "Kuc",
  "Kucharczyk",
  "Kucharski",
  "Kuchta",
  "Kuciski",
  "Kuczyski",
  "Kujawa",
  "Kujawski",
  "Kula",
  "Kulesza",
  "Kulig",
  "Kulik",
  "Kuliski",
  "Kurek",
  "Kurowski",
  "Ku",
  "Kwaniewski",
  "Kwiatkowski",
  "Kwiecie",
  "Kwieciski",
  "Kdzierski",
  "Kdziora",
  "Kpa",
  "Kos",
  "Kosowski",
  "Lach",
  "Laskowski",
  "Lasota",
  "Lech",
  "Lenart",
  "Lesiak",
  "Leszczyski",
  "Lewandowski",
  "Lewicki",
  "Leniak",
  "Leniewski",
  "Lipiski",
  "Lipka",
  "Lipski",
  "Lis",
  "Lisiecki",
  "Lisowski",
  "Maciejewski",
  "Macig",
  "Mackiewicz",
  "Madej",
  "Maj",
  "Majcher",
  "Majchrzak",
  "Majewski",
  "Majka",
  "Makowski",
  "Malec",
  "Malicki",
  "Malinowski",
  "Maliszewski",
  "Marchewka",
  "Marciniak",
  "Marcinkowski",
  "Marczak",
  "Marek",
  "Markiewicz",
  "Markowski",
  "Marszaek",
  "Marzec",
  "Masowski",
  "Matusiak",
  "Matuszak",
  "Matuszewski",
  "Matysiak",
  "Mazur",
  "Mazurek",
  "Mazurkiewicz",
  "Makowiak",
  "Maecki",
  "Maek",
  "Malanka",
  "Michalak",
  "Michalczyk",
  "Michalik",
  "Michalski",
  "Michaek",
  "Michaowski",
  "Mielczarek",
  "Mierzejewski",
  "Mika",
  "Mikoajczak",
  "Mikoajczyk",
  "Mikulski",
  "Milczarek",
  "Milewski",
  "Miller",
  "Misiak",
  "Misztal",
  "Mikiewicz",
  "Modzelewski",
  "Molenda",
  "Morawski",
  "Motyka",
  "Mroczek",
  "Mroczkowski",
  "Mrozek",
  "Mrz",
  "Mucha",
  "Murawski",
  "Musia",
  "Muszyski",
  "Mynarczyk",
  "Napieraa",
  "Nawrocki",
  "Nawrot",
  "Niedziela",
  "Niedzielski",
  "Niedwiecki",
  "Niemczyk",
  "Niemiec",
  "Niewiadomski",
  "Noga",
  "Nowacki",
  "Nowaczyk",
  "Nowak",
  "Nowakowski",
  "Nowicki",
  "Nowiski",
  "Olczak",
  "Olejniczak",
  "Olejnik",
  "Olszewski",
  "Orzechowski",
  "Orowski",
  "Osiski",
  "Ossowski",
  "Ostrowski",
  "Owczarek",
  "Paczkowski",
  "Pajk",
  "Pakua",
  "Paluch",
  "Panek",
  "Partyka",
  "Pasternak",
  "Paszkowski",
  "Pawelec",
  "Pawlak",
  "Pawlicki",
  "Pawlik",
  "Pawlikowski",
  "Pawowski",
  "Paka",
  "Piasecki",
  "Piechota",
  "Piekarski",
  "Pietras",
  "Pietruszka",
  "Pietrzak",
  "Pietrzyk",
  "Pilarski",
  "Pilch",
  "Piotrowicz",
  "Piotrowski",
  "Piwowarczyk",
  "Pirkowski",
  "Pitek",
  "Pitkowski",
  "Piat",
  "Pluta",
  "Podgrski",
  "Polak",
  "Popawski",
  "Porbski",
  "Prokop",
  "Prus",
  "Przybylski",
  "Przybysz",
  "Przyby",
  "Przybya",
  "Ptak",
  "Puchalski",
  "Pytel",
  "Ponka",
  "Raczyski",
  "Radecki",
  "Radomski",
  "Rak",
  "Rakowski",
  "Ratajczak",
  "Robak",
  "Rogala",
  "Rogalski",
  "Rogowski",
  "Rojek",
  "Romanowski",
  "Rosa",
  "Rosiak",
  "Rosiski",
  "Ruciski",
  "Rudnicki",
  "Rudziski",
  "Rudzki",
  "Rusin",
  "Rutkowski",
  "Rybak",
  "Rybarczyk",
  "Rybicki",
  "Rzepka",
  "Raski",
  "Rycki",
  "Sadowski",
  "Sawicki",
  "Serafin",
  "Siedlecki",
  "Sienkiewicz",
  "Sieradzki",
  "Sikora",
  "Sikorski",
  "Sitek",
  "Siwek",
  "Skalski",
  "Skiba",
  "Skibiski",
  "Skoczylas",
  "Skowron",
  "Skowronek",
  "Skowroski",
  "Skrzypczak",
  "Skrzypek",
  "Skra",
  "Smoliski",
  "Sobczak",
  "Sobczyk",
  "Sobieraj",
  "Sobolewski",
  "Socha",
  "Sochacki",
  "Sokoowski",
  "Sok",
  "Sosnowski",
  "Sowa",
  "Sowiski",
  "Sotys",
  "Sotysiak",
  "Sroka",
  "Stachowiak",
  "Stachowicz",
  "Stachura",
  "Stachurski",
  "Stanek",
  "Staniszewski",
  "Stanisawski",
  "Stankiewicz",
  "Stasiak",
  "Staszewski",
  "Stawicki",
  "Stec",
  "Stefaniak",
  "Stefaski",
  "Stelmach",
  "Stolarczyk",
  "Stolarski",
  "Strzelczyk",
  "Strzelecki",
  "Stpie",
  "Stpniak",
  "Surma",
  "Suski",
  "Szafraski",
  "Szatkowski",
  "Szczepaniak",
  "Szczepanik",
  "Szczepaski",
  "Szczerba",
  "Szczeniak",
  "Szczygie",
  "Szczsna",
  "Szczsny",
  "Szelg",
  "Szewczyk",
  "Szostak",
  "Szulc",
  "Szwarc",
  "Szwed",
  "Szydowski",
  "Szymaski",
  "Szymczak",
  "Szymczyk",
  "Szymkowiak",
  "Szyszka",
  "Sawiski",
  "Sowik",
  "Sowiski",
  "Tarnowski",
  "Tkaczyk",
  "Tokarski",
  "Tomala",
  "Tomaszewski",
  "Tomczak",
  "Tomczyk",
  "Tracz",
  "Trojanowski",
  "Trzciski",
  "Trzeciak",
  "Turek",
  "Twardowski",
  "Urban",
  "Urbanek",
  "Urbaniak",
  "Urbanowicz",
  "Urbaczyk",
  "Urbaski",
  "Walczak",
  "Walkowiak",
  "Warcho",
  "Wasiak",
  "Wasilewski",
  "Wawrzyniak",
  "Wesoowski",
  "Wieczorek",
  "Wierzbicki",
  "Wilczek",
  "Wilczyski",
  "Wilk",
  "Winiarski",
  "Witczak",
  "Witek",
  "Witkowski",
  "Wicek",
  "Wicek",
  "Wickowski",
  "Winiewski",
  "Wnuk",
  "Wojciechowski",
  "Wojtas",
  "Wojtasik",
  "Wojtczak",
  "Wojtkowiak",
  "Wolak",
  "Woliski",
  "Wolny",
  "Wolski",
  "Wo",
  "Woniak",
  "Wrona",
  "Wroski",
  "Wrbel",
  "Wrblewski",
  "Wypych",
  "Wysocki",
  "Wyszyski",
  "Wjcicki",
  "Wjcik",
  "Wjtowicz",
  "Wsik",
  "Wgrzyn",
  "Wodarczyk",
  "Wodarski",
  "Zaborowski",
  "Zabocki",
  "Zagrski",
  "Zajc",
  "Zajczkowski",
  "Zakrzewski",
  "Zalewski",
  "Zaremba",
  "Zarzycki",
  "Zarba",
  "Zawada",
  "Zawadzki",
  "Zdunek",
  "Zieliski",
  "Zielonka",
  "Zikowski",
  "Ziba",
  "Zitek",
  "Zwoliski",
  "Zych",
  "Zygmunt",
  "apiski",
  "uczak",
  "ukasiewicz",
  "ukasik",
  "ukaszewski",
  "liwa",
  "liwiski",
  "lusarczyk",
  "widerski",
  "wierczyski",
  "witek",
  "ak",
  "ebrowski",
  "muda",
  "uk",
  "ukowski",
  "urawski",
  "urek",
  "ya"
];

},{}],1023:[function(require,module,exports){
arguments[4][797][0].apply(exports,arguments)
},{"dup":797}],1024:[function(require,module,exports){
module["exports"] = [
  "Pan",
  "Pani"
];

},{}],1025:[function(require,module,exports){
arguments[4][523][0].apply(exports,arguments)
},{"dup":523}],1026:[function(require,module,exports){
module["exports"] = [
  "12-###-##-##",
  "13-###-##-##",
  "14-###-##-##",
  "15-###-##-##",
  "16-###-##-##",
  "17-###-##-##",
  "18-###-##-##",
  "22-###-##-##",
  "23-###-##-##",
  "24-###-##-##",
  "25-###-##-##",
  "29-###-##-##",
  "32-###-##-##",
  "33-###-##-##",
  "34-###-##-##",
  "41-###-##-##",
  "42-###-##-##",
  "43-###-##-##",
  "44-###-##-##",
  "46-###-##-##",
  "48-###-##-##",
  "52-###-##-##",
  "54-###-##-##",
  "55-###-##-##",
  "56-###-##-##",
  "58-###-##-##",
  "59-###-##-##",
  "61-###-##-##",
  "62-###-##-##",
  "63-###-##-##",
  "65-###-##-##",
  "67-###-##-##",
  "68-###-##-##",
  "71-###-##-##",
  "74-###-##-##",
  "75-###-##-##",
  "76-###-##-##",
  "77-###-##-##",
  "81-###-##-##",
  "82-###-##-##",
  "83-###-##-##",
  "84-###-##-##",
  "85-###-##-##",
  "86-###-##-##",
  "87-###-##-##",
  "89-###-##-##",
  "91-###-##-##",
  "94-###-##-##",
  "95-###-##-##"
];

},{}],1027:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":1026,"dup":312}],1028:[function(require,module,exports){
arguments[4][438][0].apply(exports,arguments)
},{"dup":438}],1029:[function(require,module,exports){
module["exports"] = [
  "Nova",
  "Velha",
  "Grande",
  "Vila",
  "Municpio de"
];

},{}],1030:[function(require,module,exports){
module["exports"] = [
  "do Descoberto",
  "de Nossa Senhora",
  "do Norte",
  "do Sul"
];

},{}],1031:[function(require,module,exports){
module["exports"] = [
  "Afeganisto",
  "Albnia",
  "Algria",
  "Samoa",
  "Andorra",
  "Angola",
  "Anguilla",
  "Antigua and Barbada",
  "Argentina",
  "Armnia",
  "Aruba",
  "Austrlia",
  "ustria",
  "Alzerbajo",
  "Bahamas",
  "Barm",
  "Bangladesh",
  "Barbado",
  "Belgrado",
  "Blgica",
  "Belize",
  "Benin",
  "Bermuda",
  "Bhutan",
  "Bolvia",
  "Bsnia",
  "Botuasuna",
  "Bouvetoia",
  "Brasil",
  "Arquiplago de Chagos",
  "Ilhas Virgens",
  "Brunei",
  "Bulgria",
  "Burkina Faso",
  "Burundi",
  "Cambjia",
  "Camares",
  "Canad",
  "Cabo Verde",
  "Ilhas Caiman",
  "Repblica da frica Central",
  "Chad",
  "Chile",
  "China",
  "Ilhas Natal",
  "Ilhas Cocos",
  "Colmbia",
  "Comoros",
  "Congo",
  "Ilhas Cook",
  "Costa Rica",
  "Costa do Marfim",
  "Crocia",
  "Cuba",
  "Cyprus",
  "Repblica Tcheca",
  "Dinamarca",
  "Djibouti",
  "Dominica",
  "Repblica Dominicana",
  "Equador",
  "Egito",
  "El Salvador",
  "Guin Equatorial",
  "Eritrea",
  "Estnia",
  "Etipia",
  "Ilhas Faroe",
  "Malvinas",
  "Fiji",
  "Finlndia",
  "Frana",
  "Guin Francesa",
  "Polinsia Francesa",
  "Gabo",
  "Gmbia",
  "Georgia",
  "Alemanha",
  "Gana",
  "Gibraltar",
  "Grcia",
  "Groelndia",
  "Granada",
  "Guadalupe",
  "Guano",
  "Guatemala",
  "Guernsey",
  "Guin",
  "Guin-Bissau",
  "Guiana",
  "Haiti",
  "Heard Island and McDonald Islands",
  "Vaticano",
  "Honduras",
  "Hong Kong",
  "Hungria",
  "Iceland",
  "ndia",
  "Indonsia",
  "Ir",
  "Iraque",
  "Irlanda",
  "Ilha de Man",
  "Israel",
  "Itlia",
  "Jamaica",
  "Japo",
  "Jersey",
  "Jordnia",
  "Cazaquisto",
  "Qunia",
  "Kiribati",
  "Coreia do Norte",
  "Coreia do Sul",
  "Kuwait",
  "Kyrgyz Republic",
  "Repblica Democrtica de Lao People",
  "Latvia",
  "Lbano",
  "Lesotho",
  "Libria",
  "Libyan Arab Jamahiriya",
  "Liechtenstein",
  "Litunia",
  "Luxemburgo",
  "Macao",
  "Macednia",
  "Madagascar",
  "Malawi",
  "Malsia",
  "Maldives",
  "Mali",
  "Malta",
  "Ilhas Marshall",
  "Martinica",
  "Mauritnia",
  "Mauritius",
  "Mayotte",
  "Mxico",
  "Micronsia",
  "Moldova",
  "Mnaco",
  "Monglia",
  "Montenegro",
  "Montserrat",
  "Marrocos",
  "Moambique",
  "Myanmar",
  "Namibia",
  "Nauru",
  "Nepal",
  "Antilhas Holandesas",
  "Holanda",
  "Nova Caledonia",
  "Nova Zelndia",
  "Nicargua",
  "Nigria",
  "Niue",
  "Ilha Norfolk",
  "Northern Mariana Islands",
  "Noruega",
  "Oman",
  "Paquisto",
  "Palau",
  "Territrio da Palestina",
  "Panam",
  "Nova Guin Papua",
  "Paraguai",
  "Peru",
  "Filipinas",
  "Polnia",
  "Portugal",
  "Puerto Rico",
  "Qatar",
  "Romnia",
  "Rssia",
  "Ruanda",
  "So Bartolomeu",
  "Santa Helena",
  "Santa Lcia",
  "Saint Martin",
  "Saint Pierre and Miquelon",
  "Saint Vincent and the Grenadines",
  "Samoa",
  "San Marino",
  "Sao Tom e Prncipe",
  "Arbia Saudita",
  "Senegal",
  "Srvia",
  "Seychelles",
  "Serra Leoa",
  "Singapura",
  "Eslovquia",
  "Eslovnia",
  "Ilhas Salomo",
  "Somlia",
  "frica do Sul",
  "South Georgia and the South Sandwich Islands",
  "Spanha",
  "Sri Lanka",
  "Sudo",
  "Suriname",
  "Svalbard & Jan Mayen Islands",
  "Swaziland",
  "Sucia",
  "Sua",
  "Sria",
  "Taiwan",
  "Tajiquisto",
  "Tanznia",
  "Tailndia",
  "Timor-Leste",
  "Togo",
  "Tokelau",
  "Tonga",
  "Trinid e Tobago",
  "Tunsia",
  "Turquia",
  "Turcomenisto",
  "Turks and Caicos Islands",
  "Tuvalu",
  "Uganda",
  "Ucrnia",
  "Emirados rabes Unidos",
  "Reino Unido",
  "Estados Unidos da Amrica",
  "Estados Unidos das Ilhas Virgens",
  "Uruguai",
  "Uzbequisto",
  "Vanuatu",
  "Venezuela",
  "Vietn",
  "Wallis and Futuna",
  "Sahara",
  "Yemen",
  "Zmbia",
  "Zimbbue"
];

},{}],1032:[function(require,module,exports){
module["exports"] = [
  "Brasil"
];

},{}],1033:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.country = require("./country");
address.building_number = require("./building_number");
address.street_suffix = require("./street_suffix");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.default_country = require("./default_country");

},{"./building_number":1028,"./city_prefix":1029,"./city_suffix":1030,"./country":1031,"./default_country":1032,"./postcode":1034,"./secondary_address":1035,"./state":1036,"./state_abbr":1037,"./street_suffix":1038}],1034:[function(require,module,exports){
module["exports"] = [
  "#####",
  "#####-###"
];

},{}],1035:[function(require,module,exports){
module["exports"] = [
  "Apto. ###",
  "Sobrado ##",
  "Casa #",
  "Lote ##",
  "Quadra ##"
];

},{}],1036:[function(require,module,exports){
module["exports"] = [
  "Acre",
  "Alagoas",
  "Amap",
  "Amazonas",
  "Bahia",
  "Cear",
  "Distrito Federal",
  "Esprito Santo",
  "Gois",
  "Maranho",
  "Mato Grosso",
  "Mato Grosso do Sul",
  "Minas Gerais",
  "Par",
  "Paraba",
  "Paran",
  "Pernambuco",
  "Piau",
  "Rio de Janeiro",
  "Rio Grande do Norte",
  "Rio Grande do Sul",
  "Rondnia",
  "Roraima",
  "Santa Catarina",
  "So Paulo",
  "Sergipe",
  "Tocantins"
];

},{}],1037:[function(require,module,exports){
module["exports"] = [
  "AC",
  "AL",
  "AP",
  "AM",
  "BA",
  "CE",
  "DF",
  "ES",
  "GO",
  "MA",
  "MT",
  "MS",
  "PA",
  "PB",
  "PR",
  "PE",
  "PI",
  "RJ",
  "RN",
  "RS",
  "RO",
  "RR",
  "SC",
  "SP"
];

},{}],1038:[function(require,module,exports){
module["exports"] = [
  "Rua",
  "Avenida",
  "Travessa",
  "Ponte",
  "Alameda",
  "Marginal",
  "Viela",
  "Rodovia"
];

},{}],1039:[function(require,module,exports){
arguments[4][425][0].apply(exports,arguments)
},{"./name":1040,"./suffix":1041,"dup":425}],1040:[function(require,module,exports){
module["exports"] = [
  "#{Name.last_name} #{suffix}",
  "#{Name.last_name}-#{Name.last_name}",
  "#{Name.last_name}, #{Name.last_name} e #{Name.last_name}"
];

},{}],1041:[function(require,module,exports){
module["exports"] = [
  "S.A.",
  "LTDA",
  "e Associados",
  "Comrcio"
];

},{}],1042:[function(require,module,exports){
var pt_BR = {};
module['exports'] = pt_BR;
pt_BR.title = "Portuguese (Brazil)";
pt_BR.address = require("./address");
pt_BR.company = require("./company");
pt_BR.internet = require("./internet");
pt_BR.lorem = require("./lorem");
pt_BR.name = require("./name");
pt_BR.phone_number = require("./phone_number");

},{"./address":1033,"./company":1039,"./internet":1045,"./lorem":1046,"./name":1049,"./phone_number":1054}],1043:[function(require,module,exports){
module["exports"] = [
  "br",
  "com",
  "biz",
  "info",
  "name",
  "net",
  "org"
];

},{}],1044:[function(require,module,exports){
module["exports"] = [
  "gmail.com",
  "yahoo.com",
  "hotmail.com",
  "live.com",
  "bol.com.br"
];

},{}],1045:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":1043,"./free_email":1044,"dup":302}],1046:[function(require,module,exports){
arguments[4][380][0].apply(exports,arguments)
},{"./words":1047,"dup":380}],1047:[function(require,module,exports){
arguments[4][344][0].apply(exports,arguments)
},{"dup":344}],1048:[function(require,module,exports){
module["exports"] = [
  "Alessandro",
  "Alessandra",
  "Alexandre",
  "Aline",
  "Antnio",
  "Breno",
  "Bruna",
  "Carlos",
  "Carla",
  "Clia",
  "Ceclia",
  "Csar",
  "Danilo",
  "Dalila",
  "Deneval",
  "Eduardo",
  "Eduarda",
  "Esther",
  "Elsio",
  "Fbio",
  "Fabrcio",
  "Fabrcia",
  "Flix",
  "Felcia",
  "Feliciano",
  "Frederico",
  "Fabiano",
  "Gustavo",
  "Guilherme",
  "Gbio",
  "Heitor",
  "Hlio",
  "Hugo",
  "Isabel",
  "Isabela",
  "gor",
  "Joo",
  "Joana",
  "Jlio Csar",
  "Jlio",
  "Jlia",
  "Janana",
  "Karla",
  "Klber",
  "Lucas",
  "Lorena",
  "Lorraine",
  "Larissa",
  "Ladislau",
  "Marcos",
  "Meire",
  "Marcelo",
  "Marcela",
  "Margarida",
  "Mrcia",
  "Mrcia",
  "Marli",
  "Morgana",
  "Maria",
  "Norberto",
  "Natlia",
  "Nataniel",
  "Nbia",
  "Oflia",
  "Paulo",
  "Paula",
  "Pablo",
  "Pedro",
  "Raul",
  "Rafael",
  "Rafaela",
  "Ricardo",
  "Roberto",
  "Roberta",
  "Slvia",
  "Slvia",
  "Silas",
  "Sulen",
  "Sara",
  "Salvador",
  "Sirineu",
  "Talita",
  "Tertuliano",
  "Vicente",
  "Vctor",
  "Vitria",
  "Yango",
  "Yago",
  "Yuri",
  "Washington",
  "Warley"
];

},{}],1049:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.last_name = require("./last_name");
name.prefix = require("./prefix");
name.suffix = require("./suffix");

},{"./first_name":1048,"./last_name":1050,"./prefix":1051,"./suffix":1052}],1050:[function(require,module,exports){
module["exports"] = [
  "Silva",
  "Souza",
  "Carvalho",
  "Santos",
  "Reis",
  "Xavier",
  "Franco",
  "Braga",
  "Macedo",
  "Batista",
  "Barros",
  "Moraes",
  "Costa",
  "Pereira",
  "Carvalho",
  "Melo",
  "Saraiva",
  "Nogueira",
  "Oliveira",
  "Martins",
  "Moreira",
  "Albuquerque"
];

},{}],1051:[function(require,module,exports){
module["exports"] = [
  "Sr.",
  "Sra.",
  "Srta.",
  "Dr."
];

},{}],1052:[function(require,module,exports){
module["exports"] = [
  "Jr.",
  "Neto",
  "Filho"
];

},{}],1053:[function(require,module,exports){
module["exports"] = [
  "(##) ####-####",
  "+55 (##) ####-####",
  "(##) #####-####"
];

},{}],1054:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":1053,"dup":312}],1055:[function(require,module,exports){
arguments[4][275][0].apply(exports,arguments)
},{"dup":275}],1056:[function(require,module,exports){
arguments[4][276][0].apply(exports,arguments)
},{"dup":276}],1057:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "-",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "--",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "m ",
  "",
  "",
  "",
  "",
  ""
];

},{}],1058:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "  ( )",
  "",
  "",
  "",
  " ( )",
  "  ",
  "  ( )",
  " ( )",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "  ",
  "",
  "",
  "",
  "-",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  " ( )",
  "",
  " ( )",
  "",
  "-",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "-",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  " ",
  " ()",
  " ()",
  "",
  "-",
  "-'",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "  ",
  "",
  "",
  "",
  "",
  "   ",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "-",
  "-  ",
  " ",
  "",
  " ",
  "",
  "-  ",
  "-  ",
  "-",
  "",
  "",
  "",
  "",
  "",
  "  ",
  " ",
  "",
  "",
  "",
  "-",
  "",
  "",
  " ( )",
  "- ( )",
  "",
  "   ( )",
  "",
  " ( )",
  "",
  "  ",
  "",
  "",
  "    ( )",
  "",
  "",
  "",
  "",
  "",
  "",
  "  ( )",
  "",
  "",
  "",
  "",
  "  ( )",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "-",
  "",
  " ",
  "",
  "",
  "",
  "- ",
  "",
  ""
];

},{}],1059:[function(require,module,exports){
module["exports"] = [
  ""
];

},{}],1060:[function(require,module,exports){
arguments[4][280][0].apply(exports,arguments)
},{"./building_number":1055,"./city":1056,"./city_name":1057,"./country":1058,"./default_country":1059,"./postcode":1061,"./secondary_address":1062,"./state":1063,"./street_address":1064,"./street_name":1065,"./street_suffix":1066,"./street_title":1067,"dup":280}],1061:[function(require,module,exports){
module["exports"] = [
  "######"
];

},{}],1062:[function(require,module,exports){
module["exports"] = [
  ". ###"
];

},{}],1063:[function(require,module,exports){
module["exports"] = [
  " ",
  " ",
  " ",
  "   ",
  " ",
  "- ",
  " ",
  " -",
  " ",
  " ",
  "  ",
  " ",
  "  ()",
  "  -",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  "  ",
  "  . ",
  "-  ",
  "  ",
  "  ",
  " (-)  ",
  "-   ",
  "-  ",
  "  ",
  "  ",
  "-  ",
  " "
];

},{}],1064:[function(require,module,exports){
arguments[4][284][0].apply(exports,arguments)
},{"dup":284}],1065:[function(require,module,exports){
arguments[4][285][0].apply(exports,arguments)
},{"dup":285}],1066:[function(require,module,exports){
module["exports"] = [
  ".",
  "",
  "",
  ".",
  "",
  "."
];

},{}],1067:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "8 ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "40  ",
  ""
];

},{}],1068:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "-",
  "",
  "",
  "",
  "",
  "",
  "-",
  "",
  "",
  "-",
  " ",
  "-",
  "-",
  "",
  "",
  "",
  "",
  "",
  "-",
  "",
  "-",
  "",
  "",
  "",
  ""
];

},{}],1069:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1070:[function(require,module,exports){
arguments[4][290][0].apply(exports,arguments)
},{"./color":1068,"./department":1069,"./product_name":1071,"dup":290}],1071:[function(require,module,exports){
module["exports"] = {
  "adjective": [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  "material": [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  "product": [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};

},{}],1072:[function(require,module,exports){
arguments[4][292][0].apply(exports,arguments)
},{"./name":1073,"./prefix":1074,"./suffix":1075,"dup":292}],1073:[function(require,module,exports){
arguments[4][293][0].apply(exports,arguments)
},{"dup":293}],1074:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1075:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  ""
];

},{}],1076:[function(require,module,exports){
arguments[4][296][0].apply(exports,arguments)
},{"./month":1077,"./weekday":1078,"dup":296}],1077:[function(require,module,exports){
// source: http://unicode.org/cldr/trac/browser/tags/release-27/common/main/ru.xml#L1734
module["exports"] = {
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide_context: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  abbr: [
    ".",
    ".",
    "",
    ".",
    "",
    "",
    "",
    ".",
    ".",
    ".",
    ".",
    "."
  ],
  abbr_context: [
    ".",
    ".",
    "",
    ".",
    "",
    "",
    "",
    ".",
    ".",
    ".",
    ".",
    "."
  ]
};

},{}],1078:[function(require,module,exports){
// source: http://unicode.org/cldr/trac/browser/tags/release-27/common/main/ru.xml#L1825
module["exports"] = {
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide_context: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  abbr: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  abbr_context: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};

},{}],1079:[function(require,module,exports){
var ru = {};
module['exports'] = ru;
ru.title = "Russian";
ru.separator = "  ";
ru.address = require("./address");
ru.internet = require("./internet");
ru.name = require("./name");
ru.phone_number = require("./phone_number");
ru.commerce = require("./commerce");
ru.company = require("./company");
ru.date = require("./date");

},{"./address":1060,"./commerce":1070,"./company":1072,"./date":1076,"./internet":1082,"./name":1086,"./phone_number":1094}],1080:[function(require,module,exports){
module["exports"] = [
  "com",
  "ru",
  "info",
  "",
  "net",
  "org"
];

},{}],1081:[function(require,module,exports){
module["exports"] = [
  "yandex.ru",
  "ya.ru",
  "mail.ru",
  "gmail.com",
  "yahoo.com",
  "hotmail.com"
];

},{}],1082:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":1080,"./free_email":1081,"dup":302}],1083:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1084:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1085:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1086:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.male_first_name = require("./male_first_name");
name.male_middle_name = require("./male_middle_name");
name.male_last_name = require("./male_last_name");
name.female_first_name = require("./female_first_name");
name.female_middle_name = require("./female_middle_name");
name.female_last_name = require("./female_last_name");
name.prefix = require("./prefix");
name.suffix = require("./suffix");
name.name = require("./name");

},{"./female_first_name":1083,"./female_last_name":1084,"./female_middle_name":1085,"./male_first_name":1087,"./male_last_name":1088,"./male_middle_name":1089,"./name":1090,"./prefix":1091,"./suffix":1092}],1087:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1088:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1089:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1090:[function(require,module,exports){
module["exports"] = [
  "#{male_first_name} #{male_last_name}",
  "#{male_last_name} #{male_first_name}",
  "#{male_first_name} #{male_middle_name} #{male_last_name}",
  "#{male_last_name} #{male_first_name} #{male_middle_name}",
  "#{female_first_name} #{female_last_name}",
  "#{female_last_name} #{female_first_name}",
  "#{female_first_name} #{female_middle_name} #{female_last_name}",
  "#{female_last_name} #{female_first_name} #{female_middle_name}"
];

},{}],1091:[function(require,module,exports){
arguments[4][309][0].apply(exports,arguments)
},{"dup":309}],1092:[function(require,module,exports){
arguments[4][309][0].apply(exports,arguments)
},{"dup":309}],1093:[function(require,module,exports){
arguments[4][311][0].apply(exports,arguments)
},{"dup":311}],1094:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":1093,"dup":312}],1095:[function(require,module,exports){
arguments[4][313][0].apply(exports,arguments)
},{"dup":313}],1096:[function(require,module,exports){
arguments[4][314][0].apply(exports,arguments)
},{"dup":314}],1097:[function(require,module,exports){
module["exports"] = [
  "Bnovce nad Bebravou",
  "Bansk Bystrica",
  "Bansk tiavnica",
  "Bardejov",
  "Bratislava I",
  "Bratislava II",
  "Bratislava III",
  "Bratislava IV",
  "Bratislava V",
  "Brezno",
  "Byta",
  "adca",
  "Detva",
  "Doln Kubn",
  "Dunajsk Streda",
  "Galanta",
  "Gelnica",
  "Hlohovec",
  "Humenn",
  "Ilava",
  "Kemarok",
  "Komrno",
  "Koice I",
  "Koice II",
  "Koice III",
  "Koice IV",
  "Koice-okolie",
  "Krupina",
  "Kysuck Nov Mesto",
  "Levice",
  "Levoa",
  "Liptovsk Mikul",
  "Luenec",
  "Malacky",
  "Martin",
  "Medzilaborce",
  "Michalovce",
  "Myjava",
  "Nmestovo",
  "Nitra",
  "Nov Mesto n.Vhom",
  "Nov Zmky",
  "Partiznske",
  "Pezinok",
  "Pieany",
  "Poltr",
  "Poprad",
  "Povask Bystrica",
  "Preov",
  "Prievidza",
  "Pchov",
  "Revca",
  "Rimavsk Sobota",
  "Roava",
  "Ruomberok",
  "Sabinov",
  "aa",
  "Senec",
  "Senica",
  "Skalica",
  "Snina",
  "Sobrance",
  "Spisk Nov Ves",
  "Star ubova",
  "Stropkov",
  "Svidnk",
  "Topoany",
  "Trebiov",
  "Trenn",
  "Trnava",
  "Turianske Teplice",
  "Tvrdon",
  "Vek Krt",
  "Vranov nad Topou",
  "arnovica",
  "iar nad Hronom",
  "ilina",
  "Zlat Moravce",
  "Zvolen"
];

},{}],1098:[function(require,module,exports){
arguments[4][440][0].apply(exports,arguments)
},{"dup":440}],1099:[function(require,module,exports){
arguments[4][441][0].apply(exports,arguments)
},{"dup":441}],1100:[function(require,module,exports){
module["exports"] = [
  "Afganistan",
  "Afgnsky islamsk tt",
  "Albnsko",
  "Albnska republika",
  "Alrsko",
  "Alrska demokratick udov republika",
  "Andorra",
  "Andorrsk knieatsvo",
  "Angola",
  "Angolsk republika",
  "Antigua a Barbuda",
  "Antigua a Barbuda",
  "Argentna",
  "Argentnska republika",
  "Armnsko",
  "Armnska republika",
  "Austrlia",
  "Austrlsky zvz",
  "Azerbajdan",
  "Azerbajdansk republika",
  "Bahamy",
  "Bahamsk spoloenstvo",
  "Bahrajn",
  "Bahrajnsk krovstvo",
  "Banglad",
  "Bangladska udov republika",
  "Barbados",
  "Barbados",
  "Belgicko",
  "Belgick krovstvo",
  "Belize",
  "Belize",
  "Benin",
  "Beninsk republika",
  "Bhutn",
  "Bhutnske krovstvo",
  "Bielorusko",
  "Bielorusk republika",
  "Bolvia",
  "Bolvijsk republika",
  "Bosna a Hercegovina",
  "Republika Bosny a Hercegoviny",
  "Botswana",
  "Botswansk republika",
  "Brazlia",
  "Brazlska federatvna republika",
  "Brunej",
  "Brunejsk sultant",
  "Bulharsko",
  "Bulharsk republika",
  "Burkina Faso",
  "Burkina Faso",
  "Burundi",
  "Burundsk republika",
  "Cyprus",
  "Cypersk republika",
  "ad",
  "Republika ad",
  "esko",
  "esk republika",
  "na",
  "nska udov republika",
  "Dnsko",
  "Dnsko krovstvo",
  "Dominika",
  "Spoloenstvo Dominika",
  "Dominiknska republika",
  "Dominiknska republika",
  "Dibutsko",
  "Dibutsk republika",
  "Egypt",
  "Egyptsk arabsk republika",
  "Ekvdor",
  "Ekvdorsk republika",
  "Eritrea",
  "Eritrejsk tt",
  "Estnsko",
  "Estnska republika",
  "Etipia",
  "Etipska federatvna demokratick republika",
  "Fidi",
  "Republika ostrovy Fidi",
  "Filipny",
  "Filipnska republika",
  "Fnsko",
  "Fnska republika",
  "Franczsko",
  "Franczska republika",
  "Gabon",
  "Gabonsk republika",
  "Gambia",
  "Gambijsk republika",
  "Ghana",
  "Ghansk republika",
  "Grcko",
  "Helnska republika",
  "Grenada",
  "Grenada",
  "Gruznsko",
  "Gruznsko",
  "Guatemala",
  "Guatemalsk republika",
  "Guinea",
  "Guinejsk republika",
  "Guinea-Bissau",
  "Republika Guinea-Bissau",
  "Guayana",
  "Guayansk republika",
  "Haiti",
  "Republika Haiti",
  "Holandsko",
  "Holandsk krovstvo",
  "Honduras",
  "Hondurask republika",
  "Chile",
  "lska republika",
  "Chorvtsko",
  "Chorvtska republika",
  "India",
  "Indick republika",
  "Indonzia",
  "Indonzska republika",
  "Irak",
  "Irack republika",
  "Irn",
  "Irnska islamsk republika",
  "Island",
  "Islandsk republika",
  "Izrael",
  "tt Izrael",
  "rsko",
  "rska republika",
  "Jamajka",
  "Jamajka",
  "Japonsko",
  "Japonsko",
  "Jemen",
  "Jemensk republika",
  "Jordnsko",
  "Jordnske himovsk krovstvo",
  "Jun Afrika",
  "Juhoafrick republika",
  "Kamboda",
  "Kambodsk krovstvo",
  "Kamerun",
  "Kamerunsk republika",
  "Kanada",
  "Kanada",
  "Kapverdy",
  "Kapverdsk republika",
  "Katar",
  "tt Katar",
  "Kazachstan",
  "Kazask republika",
  "Kea",
  "Kensk republika",
  "Kirgizsko",
  "Kirgizsk republika",
  "Kiribati",
  "Kiribatsk republika",
  "Kolumbia",
  "Kolumbijsk republika",
  "Komory",
  "Komorsk nia",
  "Kongo",
  "Konsk demokratick republika",
  "Kongo (\"Brazzaville\")",
  "Konsk republika",
  "Krea (\"Jun\")",
  "Krejsk republika",
  "Krea (\"Severn\")",
  "Krejsk udovodemokratick republika",
  "Kostarika",
  "Kostarick republika",
  "Kuba",
  "Kubnska republika",
  "Kuvajt",
  "Kuvajtsk tt",
  "Laos",
  "Laosk udovodemokratick republika",
  "Lesotho",
  "Lesothsk krovstvo",
  "Libanon",
  "Libanonsk republika",
  "Libria",
  "Librijsk republika",
  "Lbya",
  "Lbyjsk arabsk udov socialistick damhrija",
  "Lichtentajnsko",
  "Lichtentajnsk knieatstvo",
  "Litva",
  "Litovsk republika",
  "Lotysko",
  "Lotysk republika",
  "Luxembursko",
  "Luxembursk vekovojvodstvo",
  "Macednsko",
  "Macednska republika",
  "Madagaskar",
  "Madagaskarsk republika",
  "Maarsko",
  "Maarsk republika",
  "Malajzia",
  "Malajzia",
  "Malawi",
  "Malawijsk republika",
  "Maldivy",
  "Maldivsk republika",
  "Mali",
  "Malijsk republika",
  "Malta",
  "Malta",
  "Maroko",
  "Marock krovstvo",
  "Marshallove ostrovy",
  "Republika Marshallovch ostrovy",
  "Mauritnia",
  "Mauritnska islamsk republika",
  "Maurcius",
  "Maurcijsk republika",
  "Mexiko",
  "Spojen tty mexick",
  "Mikronzia",
  "Mikronzske federatvne tty",
  "Mjanmarsko",
  "Mjanmarsk zvz",
  "Moldavsko",
  "Moldavsk republika",
  "Monako",
  "Monack knieatstvo",
  "Mongolsko",
  "Mongolsko",
  "Mozambik",
  "Mozambick republika",
  "Nambia",
  "Nambijsk republika",
  "Nauru",
  "Naursk republika",
  "Nemecko",
  "Nemeck spolkov republika",
  "Nepl",
  "Neplske krovstvo",
  "Niger",
  "Nigersk republika",
  "Nigria",
  "Nigrijsk federatvna republika",
  "Nikaragua",
  "Nikaragujsk republika",
  "Nov Zland",
  "Nov Zland",
  "Nrsko",
  "Nrske krovstvo",
  "Omn",
  "Omnsky sultant",
  "Pakistan",
  "Pakistansk islamsk republika",
  "Palau",
  "Palausk republika",
  "Panama",
  "Panamsk republika",
  "Papua-Nov Guinea",
  "Nezvisl tt Papua-Nov Guinea",
  "Paraguaj",
  "Paraguajsk republika",
  "Peru",
  "Perunska republika",
  "Pobreie Slonoviny",
  "Republika Pobreie Slonoviny",
  "Posko",
  "Posk republika",
  "Portugalsko",
  "Portugalsk republika",
  "Raksko",
  "Rakska republika",
  "Rovnkov Guinea",
  "Republika Rovnkov Guinea",
  "Rumunsko",
  "Rumunsko",
  "Rusko",
  "Rusk federcia",
  "Rwanda",
  "Rwandsk republika",
  "Salvdor",
  "Salvdorsk republika",
  "Samoa",
  "Nezvisl tt Samoa",
  "San Marno",
  "Sanmarnska republika",
  "Saudsk Arbia",
  "Krovstvo Saudskej Arbie",
  "Senegal",
  "Senegalsk republika",
  "Seychely",
  "Seychelsk republika",
  "Sierra Leone",
  "Republika Sierra Leone",
  "Singapur",
  "Singapurska republika",
  "Slovensko",
  "Slovensk republika",
  "Slovinsko",
  "Slovinsk republika",
  "Somlsko",
  "Somlska demokratick republika",
  "Spojen arabsk emirty",
  "Spojen arabsk emirty",
  "Spojen tty americk",
  "Spojen tty americk",
  "Srbsko a ierna Hora",
  "Srbsko a ierna Hora",
  "Sr Lanka",
  "Demokratick socialistick republika Sr Lanka",
  "Stredoafrick republika",
  "Stredoafrick republika",
  "Sudn",
  "Sudnska republika",
  "Surinam",
  "Surinamsk republika",
  "Svazijsko",
  "Svazijsk krovstvo",
  "Svt Lucia",
  "Svt Lucia",
  "Svt Kritof a Nevis",
  "Federcia Svt Kritof a Nevis",
  "Sv. Tom a Princov Ostrov",
  "Demokratick republika Svt Tom a Princov Ostrov",
  "Sv. Vincent a Grenadny",
  "Svt Vincent a Grenadny",
  "Sria",
  "Srska arabsk republika",
  "alamnove ostrovy",
  "alamnove ostrovy",
  "panielsko",
  "panielske krovstvo",
  "vajiarsko",
  "vajiarska konfedercia",
  "vdsko",
  "vdske krovstvo",
  "Tadikistan",
  "Tadick republika",
  "Taliansko",
  "Talianska republika",
  "Tanznia",
  "Tanznijsk zjednoten republika",
  "Thajsko",
  "Thajsk krovstvo",
  "Togo",
  "Tosk republika",
  "Tonga",
  "Tonsk krovstvo",
  "Trinidad a Tobago",
  "Republika Trinidad a Tobago",
  "Tunisko",
  "Tunisk republika",
  "Turecko",
  "Tureck republika",
  "Turkmnsko",
  "Turkmnsko",
  "Tuvalu",
  "Tuvalu",
  "Uganda",
  "Ugandsk republika",
  "Ukrajina",
  "Uruguaj",
  "Uruguajsk vchodn republika",
  "Uzbekistan",
  "Vanuatu",
  "Vanuatsk republika",
  "Vatikn",
  "Svt Stolica",
  "Vek Britnia",
  "Spojen krovstvo Vekej Britnie a Severnho rska",
  "Venezuela",
  "Venezuelsk bolvarovsk republika",
  "Vietnam",
  "Vietnamsk socialistick republika",
  "Vchodn Timor",
  "Demokratick republika Vchodn Timor",
  "Zambia",
  "Zambijsk republika",
  "Zimbabwe",
  "Zimbabwianska republika"
];

},{}],1101:[function(require,module,exports){
module["exports"] = [
  "Slovensko"
];

},{}],1102:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.country = require("./country");
address.building_number = require("./building_number");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.time_zone = require("./time_zone");
address.city_name = require("./city_name");
address.city = require("./city");
address.street = require("./street");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":1095,"./city":1096,"./city_name":1097,"./city_prefix":1098,"./city_suffix":1099,"./country":1100,"./default_country":1101,"./postcode":1103,"./secondary_address":1104,"./state":1105,"./state_abbr":1106,"./street":1107,"./street_address":1108,"./street_name":1109,"./time_zone":1110}],1103:[function(require,module,exports){
module["exports"] = [
  "#####",
  "### ##",
  "## ###"
];

},{}],1104:[function(require,module,exports){
arguments[4][320][0].apply(exports,arguments)
},{"dup":320}],1105:[function(require,module,exports){
arguments[4][309][0].apply(exports,arguments)
},{"dup":309}],1106:[function(require,module,exports){
arguments[4][309][0].apply(exports,arguments)
},{"dup":309}],1107:[function(require,module,exports){
module["exports"] = [
  "Admiho",
  "Ahoj",
  "Albna Brunovskho",
  "Albrechtova",
  "Alejov",
  "Aleova",
  "Alibernetov",
  "Albetnska",
  "Albety Gwerkovej",
  "Ambroseho",
  "Ambruova",
  "Americk",
  "Americk nmestie",
  "Americk nmestie",
  "Andreja Mrza",
  "Andreja Plvku",
  "Andrusovova",
  "Anensk",
  "Anensk",
  "Antolsk",
  "Astronomick",
  "Astrov",
  "Azalkov",
  "Azovsk",
  "Babukova",
  "Bachova",
  "Bajkalsk",
  "Bajkalsk",
  "Bajkalsk",
  "Bajkalsk",
  "Bajkalsk",
  "Bajkalsk",
  "Bajzova",
  "Banckovej",
  "Bancka",
  "Bankova",
  "Banskobystrick",
  "Banelova",
  "Bardejovsk",
  "Bartkova",
  "Bartoova",
  "Bartokova",
  "Batov",
  "Bazov",
  "Baantia",
  "Beblavho",
  "Beckovsk",
  "Bedov",
  "Belnikov",
  "Belehradsk",
  "Belinskho",
  "Belopotockho",
  "Beadick",
  "Bencrova",
  "Benediktiho",
  "Beniakova",
  "Bernolkova",
  "Beskydsk",
  "Betliarska",
  "Bezruova",
  "Biela",
  "Bielkova",
  "Bjrnsonova",
  "Blagoevova",
  "Blatnick",
  "Blumentlska",
  "Blyskov",
  "Bon",
  "Bohrova",
  "Bohova",
  "Bojnick",
  "Borodova",
  "Borsk",
  "Boskova",
  "Botanick",
  "Bottova",
  "Boeny Nmcovej",
  "Brik",
  "Bradova",
  "Bradlianska",
  "Bransk",
  "Bratsk",
  "Brestov",
  "Brezovsk",
  "Brieky",
  "Brnianska",
  "Brodn",
  "Brodsk",
  "Broskyov",
  "Beclavsk",
  "Budatnska",
  "Budatnska",
  "Budatnska",
  "Bdkova  cesta",
  "Budovatesk",
  "Budynska",
  "Budynska",
  "Bukov",
  "Bukuretsk",
  "Bulharsk",
  "Bulkova",
  "Bystrho",
  "Bzovcka",
  "Cablkova",
  "Cesta na erven most",
  "Cesta na erven most",
  "Cesta na Senec",
  "Cikkerova",
  "Cintornska",
  "Cintulova",
  "Cukrov",
  "Cyrilova",
  "ajakova",
  "ajkovskho",
  "aklovsk",
  "alovsk",
  "apajevova",
  "apkova",
  "rskeho",
  "avojskho",
  "einov",
  "elakovskho",
  "ereov",
  "ernyevskho",
  "erveova",
  "esk",
  "eskoslovenskch par",
  "ipkrska",
  "melkova",
  "meovec",
  "ulenova",
  "Daliborovo nmestie",
  "Dankovskho",
  "Dargovsk",
  "atelinov",
  "Daxnerovo nmestie",
  "Devnska cesta",
  "Dlh diely I.",
  "Dlh diely II.",
  "Dlh diely III.",
  "Dobroviova",
  "Dobroviova",
  "Dobrovskho",
  "Dobinskho",
  "Dohnalova",
  "Dohnnyho",
  "Dolealova",
  "Doln",
  "Dolnozemsk cesta",
  "Domkrska",
  "Domov role",
  "Donnerova",
  "Donovalova",
  "Dostojevskho rad",
  "Dr. Vladimra Clemen",
  "Dreven",
  "Drieov",
  "Drieov",
  "Drieov",
  "Drotrska cesta",
  "Drotrska cesta",
  "Drotrska cesta",
  "Druicov",
  "Drustevn",
  "Dubnick",
  "Dubov",
  "Dbravsk cesta",
  "Dudova",
  "Dulovo nmestie",
  "Dulovo nmestie",
  "Dunajsk",
  "Dvokovo nbreie",
  "Edisonova",
  "Einsteinova",
  "Elektrrensk",
  "Exnrova",
  "F. Kostku",
  "Fadruszova",
  "Fajnorovo nbreie",
  "Fndlyho",
  "Farebn",
  "Farsk",
  "Farskho",
  "Fazuov",
  "Fedinova",
  "Ferienkova",
  "Fialkov dolie",
  "Fibichova",
  "Fililne ndraie",
  "Flglova",
  "Florinske nmestie",
  "Fraa Kra",
  "Francisciho",
  "Franczskych partiz",
  "Frantiknska",
  "Frantiknske nmest",
  "Furdekova",
  "Furdekova",
  "Gabkova",
  "Gagarinova",
  "Gagarinova",
  "Gagarinova",
  "Gajova",
  "Galaktick",
  "Galandova",
  "Gallova",
  "Galvaniho",
  "Gaparkova",
  "Gatanov",
  "Gavloviova",
  "Gemersk",
  "Gercenova",
  "Gessayova",
  "Gettingov",
  "Godrova",
  "Gogoova",
  "Golova",
  "Gondova",
  "Goralsk",
  "Gorazdova",
  "Gorkho",
  "Gregorovej",
  "Grsslingova",
  "Gruznska",
  "Gunduliova",
  "Gusevova",
  "Haanova",
  "Habursk",
  "Halaova",
  "Hlkova",
  "Hlova",
  "Hamuliakova",
  "Hancka",
  "Handlovsk",
  "Hany Melikovej",
  "Harmaneck",
  "Hasisk",
  "Hattalova",
  "Havlkova",
  "Havrania",
  "Haydnova",
  "Herlianska",
  "Herlianska",
  "Heydukova",
  "Hlavikova",
  "Hlavatho",
  "Hlavn nmestie",
  "Hlbok cesta",
  "Hlbok cesta",
  "Hlivov",
  "Hlunska",
  "Hodlova",
  "Hodovo nmestie",
  "Holekova",
  "Holska",
  "Hollho",
  "Holubyho",
  "Hontianska",
  "Horrska",
  "Horn idiny",
  "Horsk",
  "Horsk",
  "Hrad",
  "Hradn dolie",
  "Hrachov",
  "Hranin",
  "Hrebendova",
  "Hrbov",
  "Hriovsk",
  "Hrobkova",
  "Hrobrska",
  "Hroboova",
  "Hudecova",
  "Humensk nmestie",
  "Hummelova",
  "Hurbanovo nmestie",
  "Hurbanovo nmestie",
  "Hviezdoslavovo nmes",
  "Hroova",
  "Chalupkova",
  "Chemick",
  "Chlumeckho",
  "Chorvtska",
  "Chorvtska",
  "Ijuinova",
  "Ilkoviova",
  "Inoveck",
  "Inoveck",
  "Iskernkov",
  "Ivana Horvtha",
  "Ivnska cesta",
  "J.C.Hronskho",
  "Jabloov",
  "Jadrov",
  "Jakabova",
  "Jakubovo nmestie",
  "Jamnickho",
  "Jna Stanislava",
  "Jankova",
  "Janova",
  "Jankove role",
  "Jankolova",
  "Jnokova",
  "Jnokova",
  "Janotova",
  "Jnska",
  "Jantrov cesta",
  "Jarabinkov",
  "Jarn",
  "Jaroslavova",
  "Jaroova",
  "Jaseov",
  "Jasn",
  "Jasovsk",
  "Jastrabia",
  "Jakova",
  "Javorinsk",
  "Javorov",
  "Jazdeck",
  "Jedlkova",
  "Jgho",
  "Jelaiova",
  "Jelenia",
  "Jesenn",
  "Jesenskho",
  "Jirskova",
  "Jiskrova",
  "Jozefsk",
  "Juncka",
  "Jungmannova",
  "Jurigovo nmestie",
  "Jurovskho",
  "Jursk",
  "Justin",
  "K lomu",
  "K eleznej studienke",
  "Kaliniakova",
  "Kamenrska",
  "Kamenn nmestie",
  "Kapicova",
  "Kapitulsk",
  "Kapitulsk dvor",
  "Kapucnska",
  "Kapuianska",
  "Karadiova",
  "Karadiova",
  "Karadiova",
  "Karadiova",
  "Karlovesk",
  "Karlovesk rameno",
  "Karpatsk",
  "Kamrska",
  "Katielska",
  "Kaukazsk",
  "Kempelenova",
  "Kemarsk nmestie",
  "Kladnianska",
  "Klarisk",
  "Kltorsk",
  "Klatovsk",
  "Klatovsk",
  "Klemensova",
  "Klincov",
  "Klobuncka",
  "Klokoova",
  "Kukat",
  "Kmeovo nmestie",
  "Koceova",
  "Konkova",
  "Kohtova",
  "Kolrska",
  "Kolskova",
  "Kollrovo nmestie",
  "Kollrovo nmestie",
  "Kolm",
  "Komransk",
  "Komrnick",
  "Komrnick",
  "Komenskho nmestie",
  "Kominrska",
  "Komonicov",
  "Konopn",
  "Konvalinkov",
  "Konventn",
  "Kopanice",
  "Kopianska",
  "Kopernkova",
  "Korabinskho",
  "Koreniova",
  "Kostlivho",
  "Kostoln",
  "Koick",
  "Koick",
  "Koick",
  "Kovska",
  "Kovorobotncka",
  "Kozia",
  "Koziarka",
  "Kozmonautick",
  "Krajn",
  "Krakovsk",
  "Krovsk dolie",
  "Krasinskho",
  "Kraskova",
  "Krsna",
  "Krsnohorsk",
  "Krasovskho",
  "Krtka",
  "Krmryho",
  "Kremnick",
  "Kresnkova",
  "Kriv",
  "Krikova",
  "Krna",
  "Krna",
  "Krna",
  "Krna",
  "Krmanova",
  "Krompask",
  "Krupinsk",
  "Krupkova",
  "Kubniho",
  "Kubnska",
  "Kuklovsk",
  "Kukunova",
  "Kukurin",
  "Kulkova",
  "Kultrna",
  "Kupeckho",
  "Kpen",
  "Kutlkova",
  "Kutuzovova",
  "Kuzmnyho",
  "Kvaalova",
  "Kvetn",
  "Kerskho",
  "Kyjevsk",
  "Kysuck",
  "Laboreck",
  "Lackova",
  "Ladislava Sru",
  "adov",
  "Lachova",
  "aliov",
  "Lamask cesta",
  "Lamask cesta",
  "Lamanskho",
  "Landererova",
  "Langsfeldova",
  "anov",
  "Laskomerskho",
  "Lauekova",
  "Laurinsk",
  "Lazaretsk",
  "Lazaretsk",
  "Legerskho",
  "Legionrska",
  "Legionrska",
  "Lehockho",
  "Lehockho",
  "Lenardova",
  "Lermontovova",
  "Lesn",
  "Lekova",
  "Leteck",
  "Letisko M.R.tefnik",
  "Letn",
  "Levrska",
  "Levick",
  "Levosk",
  "Lidick",
  "Lietavsk",
  "Lichardova",
  "Lipov",
  "Lipovinov",
  "Liptovsk",
  "Listov",
  "Lie nivy",
  "Lie dolie",
  "Litovsk",
  "Lodn",
  "Lombardiniho",
  "Lomonosovova",
  "Lopencka",
  "Lovinskho",
  "ubietovsk",
  "ubinsk",
  "ubansk",
  "ubochnianska",
  "ubovnianska",
  "Lna",
  "udov nmestie",
  "udovta Fullu",
  "Luhaovick",
  "Luick",
  "Lun",
  "Lcejn",
  "Lykovcov",
  "M. Hella",
  "Magnetov",
  "Macharova",
  "Majakovskho",
  "Majernkova",
  "Mjkova",
  "Mjov",
  "Makovickho",
  "Mal",
  "Mal plenisko",
  "Malinov",
  "Mal Dradiak",
  "Mal trh",
  "Mamateyova",
  "Mamateyova",
  "Mnesovo nmestie",
  "Marinska",
  "Marie Curie-Sklodows",
  "Mrie Medveovej",
  "Markova",
  "Martyho",
  "Martkovej",
  "Martinekova",
  "Martinekova",
  "Martinengova",
  "Martinsk",
  "Mateja Bela",
  "Matejkova",
  "Matin",
  "Matova",
  "Meden",
  "Medzierka",
  "Medzilaboreck",
  "Merlotov",
  "Mesan",
  "Mestsk",
  "Meteorov",
  "Metodova",
  "Mickiewiczova",
  "Mierov",
  "Michalsk",
  "Mikovniho",
  "Mikulska",
  "Miletiova",
  "Miletiova",
  "Mikova",
  "Mikova",
  "Mikova",
  "Mliekrensk",
  "Mlynaroviova",
  "Mlynsk dolina",
  "Mlynsk dolina",
  "Mlynsk dolina",
  "Mlynsk luhy",
  "Mlynsk nivy",
  "Mlynsk nivy",
  "Mlynsk nivy",
  "Mlynsk nivy",
  "Mlynsk nivy",
  "Mlyny",
  "Modransk",
  "Mojmrova",
  "Mokr zhon",
  "Mokrohjska cesta",
  "Moldavsk",
  "Molecova",
  "Moravsk",
  "Moskovsk",
  "Most SNP",
  "Mostov",
  "Moovskho",
  "Motlia",
  "Moyzesova",
  "Mozartova",
  "Mraziarensk",
  "Mudroova",
  "Mudroova",
  "Mudroova",
  "Muchovo nmestie",
  "Murgaova",
  "Muktov",
  "Mutov",
  "Mzejn",
  "Myjavsk",
  "Mtna",
  "Mtna",
  "Na Barnku",
  "Na Brezinch",
  "Na Hrebienku",
  "Na Kalvrii",
  "Na Kamprke",
  "Na kopci",
  "Na kriovatkch",
  "Na lnoch",
  "Na pai",
  "Na piesku",
  "Na Rivire",
  "Na Sitine",
  "Na Slavne",
  "Na strni",
  "Na tyridsiatku",
  "Na vrati",
  "Na vku",
  "Na vsln",
  "Nblkova",
  "Nbreie arm. gen. L",
  "Nbren",
  "Nad Dunajom",
  "Nad lomom",
  "Nad lkami",
  "Nad lkami",
  "Nad ostrovom",
  "Nad Sihoou",
  "Nmestie 1. mja",
  "Nmestie Alexandra D",
  "Nmestie Biely kr",
  "Nmestie Hraniiarov",
  "Nmestie Jna Pavla",
  "Nmestie udovta t",
  "Nmestie Martina Ben",
  "Nm. M.R.tefnika",
  "Nmestie slobody",
  "Nmestie slobody",
  "Nmestie SNP",
  "Nmestie SNP",
  "Nmestie sv. Franti",
  "Narcisov",
  "Nedbalova",
  "Nekrasovova",
  "Neronetov",
  "Nerudova",
  "Nevdzov",
  "Nezbudkov",
  "Niov",
  "Nitrianska",
  "Ninn",
  "Nobelova",
  "Nobelovo nmestie",
  "Nov",
  "Nov Roavsk",
  "Novackho",
  "Nov plenisko",
  "Nov zhrady I",
  "Nov zhrady II",
  "Nov zhrady III",
  "Nov zhrady IV",
  "Nov zhrady V",
  "Nov zhrady VI",
  "Nov zhrady VII",
  "Novinrska",
  "Novobansk",
  "Novohradsk",
  "Novosvetsk",
  "Novosvetsk",
  "Novosvetsk",
  "Oben",
  "Obchodn",
  "Oovsk",
  "Odbojrov",
  "Odborrska",
  "Odborrske nmestie",
  "Odborrske nmestie",
  "Ohnicov",
  "Oknikova",
  "Okrun",
  "Olbrachtova",
  "Olejkrska",
  "Ondavsk",
  "Ondrejovova",
  "Oravsk",
  "Orechov cesta",
  "Orechov rad",
  "Oriekov",
  "Ormisova",
  "Osadn",
  "Ostravsk",
  "Ostredkov",
  "Osuskho",
  "Osvetov",
  "Otonelsk",
  "Ovrusk",
  "Ovsitsk nmestie",
  "Pajtnska",
  "Palackho",
  "Palrikova",
  "Palrikova",
  "Plavsk",
  "Palisdy",
  "Palisdy",
  "Palisdy",
  "Palkoviova",
  "Panensk",
  "Pankchova",
  "Pannska cesta",
  "Pansk",
  "Papnkovo nmestie",
  "Papraov",
  "Prikova",
  "Parkov",
  "Partiznska",
  "Pasienky",
  "Paulnyho",
  "Pavloviova",
  "Pavlovova",
  "Pavlovsk",
  "Paickho",
  "Patkov",
  "Penianska",
  "Perneck",
  "Pestovatesk",
  "Petersk",
  "Petzvalova",
  "Pezinsk",
  "Pieson",
  "Pieansk",
  "Pifflova",
  "Pilrikova",
  "Pionierska",
  "Pivokov",
  "Planckova",
  "Plant",
  "Pltencka",
  "Pluhov",
  "Plynrensk",
  "Plzensk",
  "Pobren",
  "Pod Brikom",
  "Pod Kalvriou",
  "Pod lesom",
  "Pod Rovnicami",
  "Pod vinicami",
  "Podhorskho",
  "Podjavorinskej",
  "Podluinskho",
  "Podnikov",
  "Podtatranskho",
  "Pohronsk",
  "Polrna",
  "Poloreckho",
  "Pon",
  "Posk",
  "Poludnkov",
  "Porubskho",
  "Potov",
  "Povask",
  "Povrazncka",
  "Povrazncka",
  "Prask",
  "Predstanin nmesti",
  "Prepotsk",
  "Preernova",
  "Preovsk",
  "Preovsk",
  "Preovsk",
  "Pri Bielom kri",
  "Pri dvore",
  "Pri Dynamitke",
  "Pri Habnskom mlyne",
  "Pri hradnej studni",
  "Pri sei",
  "Pri Starej Prachrni",
  "Pri Starom hji",
  "Pri Starom Mte",
  "Pri strelnici",
  "Pri Suchom mlyne",
  "Pri zvonici",
  "Pribinova",
  "Pribinova",
  "Pribinova",
  "Pribiova",
  "Pribylinsk",
  "Priena",
  "Priekopy",
  "Priemyseln",
  "Priemyseln",
  "Prievozsk",
  "Prievozsk",
  "Prievozsk",
  "Prkopova",
  "Primacilne nmestie",
  "Prstav",
  "Prstavn",
  "Prokofievova",
  "Prokopa Vekho",
  "Prokopova",
  "Prdov",
  "Prvosienkov",
  "Ppavov",
  "Pust",
  "Pukinova",
  "Raianska",
  "Raianska",
  "Raianske mto",
  "Radarov",
  "Rdiov",
  "Radlinskho",
  "Radnin",
  "Radnin nmestie",
  "Radvansk",
  "Rajsk",
  "Raketov",
  "Rkosov",
  "Rastislavova",
  "Rzusovo nbreie",
  "Repn",
  "Reetkova",
  "Revolun",
  "Rvov",
  "Revcka",
  "Rezedov",
  "Riazansk",
  "Riazansk",
  "Ribayov",
  "Riena",
  "Rigeleho",
  "Rzlingov",
  "Riznerova",
  "Robotncka",
  "Romanova",
  "Rntgenova",
  "Rosn",
  "Rovn",
  "Rovniankova",
  "Rovnkov",
  "Rozmarnov",
  "Roavsk",
  "Roavsk",
  "Roavsk",
  "Rubinsteinova",
  "Rudnayovo nmestie",
  "Rumanekov",
  "Rusovsk cesta",
  "Ruikov",
  "Ruinovsk",
  "Ruinovsk",
  "Ruinovsk",
  "Ruombersk",
  "Ruov dolina",
  "Ruov dolina",
  "Rybrska brna",
  "Rybn nmestie",
  "Rdzikov",
  "Sabinovsk",
  "Sabinovsk",
  "Sad Janka Kra",
  "Sadov",
  "Sartorisova",
  "Sasinkova",
  "Seberniho",
  "Seovsk",
  "Sedlrska",
  "Sedmokrskov",
  "Segnerova",
  "Sekulsk",
  "Semianova",
  "Senick",
  "Senn",
  "Schillerova",
  "Schody pri starej vo",
  "Sibrska",
  "Sienkiewiczova",
  "Silvnska",
  "Sinokvetn",
  "Skalick cesta",
  "Skaln",
  "Sklenrova",
  "Sklenrska",
  "Sldkoviova",
  "Sladov",
  "Slviie dolie",
  "Slavn",
  "Slep",
  "Sliaska",
  "Sliezska",
  "Slivkov",
  "Slnen",
  "Slovansk",
  "Slovinsk",
  "Slovnaftsk",
  "Slowackho",
  "Smetanova",
  "Smikova",
  "Smolenick",
  "Smolncka",
  "Smreianska",
  "Soferove schody",
  "Sochova",
  "Sokolsk",
  "Solivarsk",
  "Solonick",
  "Somolickho",
  "Somolickho",
  "Sosnov",
  "Spisk",
  "Spojn",
  "Spoloensk",
  "Sputnikov",
  "Sreznevskho",
  "Srnia",
  "Stachanovsk",
  "Stlicov",
  "Stanin",
  "Star ernicov",
  "Star Ivnska cesta",
  "Star Prievozsk",
  "Star Vajnorsk",
  "Star vinrska",
  "Star Grunty",
  "Star ihrisko",
  "Star zhrady",
  "Starhradsk",
  "Starohjska",
  "Staromestsk",
  "Starotursk chodnk",
  "Stavitesk",
  "Stodolova",
  "Stoklasov",
  "Strakova",
  "Strnick",
  "Strny dom",
  "Strenianska",
  "Stredn",
  "Streleck",
  "Strm cesta",
  "Strojncka",
  "Stropkovsk",
  "Strukov",
  "Studen",
  "Stuhov",
  "Sben",
  "Shvezdn",
  "Such mto",
  "Suchohradsk",
  "Skenncka",
  "Sovsk",
  "Sumbalova",
  "Smran",
  "San",
  "Svtho Vincenta",
  "Svtoplukova",
  "Svtoplukova",
  "Svtovojtesk",
  "Svetl",
  "Svbov",
  "Svidncka",
  "Svoradova",
  "Svria",
  "Syslia",
  "afrikovo nmestie",
  "afrikovo nmestie",
  "afrnov",
  "agtova",
  "alviov",
  "ancov",
  "ancov",
  "ancov",
  "ancov",
  "ndorova",
  "arisk",
  "ovsk",
  "atnska",
  "evenkova",
  "intavsk",
  "pkov",
  "karniclova",
  "kolsk",
  "kovrnia",
  "kulttyho",
  "oltsovej",
  "pieszova",
  "pitlska",
  "portov",
  "robrovo nmestie",
  "astn",
  "tedr",
  "tefnikova",
  "tefnikova",
  "tefnikova",
  "tefanoviova",
  "tefunkova",
  "tetinova",
  "tiavnick",
  "trova",
  "tyndlova",
  "ulekova",
  "ulekova",
  "ulekova",
  "umavsk",
  "uavcova",
  "ustekova",
  "vabinskho",
  "Tabakov",
  "Tablicova",
  "Tborsk",
  "Tajovskho",
  "Tallerova",
  "Teheln",
  "Technick",
  "Tekovsk",
  "Telocvin",
  "Tematnska",
  "Teplick",
  "Terchovsk",
  "Teslova",
  "Tetmayerova",
  "Thurzova",
  "Tich",
  "Tilgnerova",
  "Timravina",
  "Tobruck",
  "Tokajcka",
  "Tolstho",
  "Tomnkova",
  "Tomikova",
  "Tomikova",
  "Tomikova",
  "Tomikova",
  "Tomikova",
  "Topoianska",
  "Topoov",
  "Tovrensk",
  "Trebiovsk",
  "Trebiovsk",
  "Trebiovsk",
  "Trenianska",
  "Treskoova",
  "Trnavsk cesta",
  "Trnavsk cesta",
  "Trnavsk cesta",
  "Trnavsk cesta",
  "Trnavsk cesta",
  "Trnavsk mto",
  "Tov",
  "Trojdomy",
  "Tukova",
  "Tupolevova",
  "Turbnova",
  "Turianska",
  "Turnianska",
  "Tvarokova",
  "Tylova",
  "Tyrovo nbreie",
  "derncka",
  "doln",
  "Uhorkov",
  "Ukrajinsk",
  "Ulica 29. augusta",
  "Ulica 29. augusta",
  "Ulica 29. augusta",
  "Ulica 29. augusta",
  "Ulica Imricha Karva",
  "Ulica Jozefa Krnera",
  "Ulica Viktora Tegelh",
  "prkova",
  "radncka",
  "Urnov",
  "Urbnkova",
  "Ursnyho",
  "Urulnska",
  "zka",
  "V zhradch",
  "Vajanskho nbreie",
  "Vajnorsk",
  "Vajnorsk",
  "Vajnorsk",
  "Vajnorsk",
  "Vajnorsk",
  "Vajnorsk",
  "Vajnorsk",
  "Vajnorsk",
  "Vajnorsk",
  "Valask",
  "Valchrska",
  "Vansovej",
  "Vpenn",
  "Varnska",
  "Varavsk",
  "Varavsk",
  "Vavilovova",
  "Vavrnova",
  "Vazovova",
  "Velrska",
  "Velehradsk",
  "Veltlnska",
  "Ventrska",
  "Vetern",
  "Veternicov",
  "Vetvov",
  "Viedensk cesta",
  "Viedensk cesta",
  "Vietnamsk",
  "Vgask",
  "Vihorlatsk",
  "Viktornova",
  "Vilov",
  "Vincenta Hlonka",
  "Vnna",
  "Vlasteneck nmestie",
  "Vlkova",
  "Vlkova",
  "Vlkova",
  "Vodn vrch",
  "Votrubova",
  "Vrbesk",
  "Vrakunsk cesta",
  "Vranovsk",
  "Vretenov",
  "Vrchn",
  "Vrtock",
  "Vyhliadka",
  "Vyhnianska cesta",
  "Vysok",
  "Vyehradsk",
  "Vyn",
  "Wattova",
  "Wilsonova",
  "Wolkrova",
  "Za Kasrou",
  "Za sokolovou",
  "Za Stanicou",
  "Za tehelou",
  "Zborskho",
  "Zadunajsk cesta",
  "Zhorcka",
  "Zhradncka",
  "Zhradncka",
  "Zhradncka",
  "Zhradncka",
  "Zhrebsk",
  "Zhrebsk",
  "Zluick",
  "Zmock",
  "Zmock schody",
  "Zmoncka",
  "Zpadn",
  "Zpadn rad",
  "Zporosk",
  "Ztiie",
  "Zvodnkova",
  "Zelen",
  "Zelinrska",
  "Zimn",
  "Zlat piesky",
  "Zlat schody",
  "Znievska",
  "Zohorsk",
  "Zochova",
  "Zrinskho",
  "Zvolensk",
  "ab majer",
  "abotova",
  "ehrianska",
  "elezn",
  "elezniiarska",
  "ellova",
  "iarska",
  "idovsk",
  "ilinsk",
  "ilinsk",
  "ivnostensk",
  "ikova",
  "upn nmestie"
];

},{}],1108:[function(require,module,exports){
arguments[4][324][0].apply(exports,arguments)
},{"dup":324}],1109:[function(require,module,exports){
arguments[4][325][0].apply(exports,arguments)
},{"dup":325}],1110:[function(require,module,exports){
arguments[4][326][0].apply(exports,arguments)
},{"dup":326}],1111:[function(require,module,exports){
arguments[4][327][0].apply(exports,arguments)
},{"dup":327}],1112:[function(require,module,exports){
arguments[4][328][0].apply(exports,arguments)
},{"dup":328}],1113:[function(require,module,exports){
arguments[4][329][0].apply(exports,arguments)
},{"dup":329}],1114:[function(require,module,exports){
arguments[4][330][0].apply(exports,arguments)
},{"dup":330}],1115:[function(require,module,exports){
arguments[4][331][0].apply(exports,arguments)
},{"./adjective":1111,"./bs_noun":1112,"./bs_verb":1113,"./descriptor":1114,"./name":1116,"./noun":1117,"./suffix":1118,"dup":331}],1116:[function(require,module,exports){
arguments[4][332][0].apply(exports,arguments)
},{"dup":332}],1117:[function(require,module,exports){
arguments[4][333][0].apply(exports,arguments)
},{"dup":333}],1118:[function(require,module,exports){
arguments[4][334][0].apply(exports,arguments)
},{"dup":334}],1119:[function(require,module,exports){
var sk = {};
module['exports'] = sk;
sk.title = "Slovakian";
sk.address = require("./address");
sk.company = require("./company");
sk.internet = require("./internet");
sk.lorem = require("./lorem");
sk.name = require("./name");
sk.phone_number = require("./phone_number");

},{"./address":1102,"./company":1115,"./internet":1122,"./lorem":1123,"./name":1128,"./phone_number":1136}],1120:[function(require,module,exports){
module["exports"] = [
  "sk",
  "com",
  "net",
  "eu",
  "org"
];

},{}],1121:[function(require,module,exports){
module["exports"] = [
  "gmail.com",
  "zoznam.sk",
  "azet.sk"
];

},{}],1122:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":1120,"./free_email":1121,"dup":302}],1123:[function(require,module,exports){
arguments[4][342][0].apply(exports,arguments)
},{"./supplemental":1124,"./words":1125,"dup":342}],1124:[function(require,module,exports){
arguments[4][343][0].apply(exports,arguments)
},{"dup":343}],1125:[function(require,module,exports){
arguments[4][344][0].apply(exports,arguments)
},{"dup":344}],1126:[function(require,module,exports){
module["exports"] = [
  "Alexandra",
  "Karina",
  "Daniela",
  "Andrea",
  "Antnia",
  "Bohuslava",
  "Da",
  "Malvna",
  "Kristna",
  "Nataa",
  "Bohdana",
  "Drahomra",
  "Sra",
  "Zora",
  "Tamara",
  "Ema",
  "Tatiana",
  "Erika",
  "Veronika",
  "Agta",
  "Dorota",
  "Vanda",
  "Zoja",
  "Gabriela",
  "Perla",
  "Ida",
  "Liana",
  "Miloslava",
  "Vlasta",
  "Lvia",
  "Eleonra",
  "Etela",
  "Romana",
  "Zlatica",
  "Aneka",
  "Bohumila",
  "Frantika",
  "Angela",
  "Matilda",
  "Svetlana",
  "ubica",
  "Alena",
  "Soa",
  "Vieroslava",
  "Zita",
  "Miroslava",
  "Irena",
  "Milena",
  "Estera",
  "Justna",
  "Dana",
  "Danica",
  "Jela",
  "Jaroslava",
  "Jarmila",
  "Lea",
  "Anastzia",
  "Galina",
  "Lesana",
  "Hermna",
  "Monika",
  "Ingrida",
  "Viktria",
  "Blaena",
  "ofia",
  "Sofia",
  "Gizela",
  "Viola",
  "Gertrda",
  "Zina",
  "Jlia",
  "Juliana",
  "elmra",
  "Ela",
  "Vanesa",
  "Iveta",
  "Vilma",
  "Petronela",
  "aneta",
  "Xnia",
  "Karolna",
  "Lenka",
  "Laura",
  "Stanislava",
  "Margarta",
  "Dobroslava",
  "Blanka",
  "Valria",
  "Paulna",
  "Sidnia",
  "Adrina",
  "Beta",
  "Petra",
  "Melnia",
  "Diana",
  "Berta",
  "Patrcia",
  "Lujza",
  "Amlia",
  "Milota",
  "Nina",
  "Margita",
  "Kamila",
  "Duana",
  "Magdalna",
  "Oga",
  "Anna",
  "Hana",
  "Boena",
  "Marta",
  "Libua",
  "Boidara",
  "Dominika",
  "Hortenzia",
  "Jozefna",
  "tefnia",
  "ubomra",
  "Zuzana",
  "Darina",
  "Marcela",
  "Milica",
  "Elena",
  "Helena",
  "Ldia",
  "Anabela",
  "Jana",
  "Silvia",
  "Nikola",
  "Ruena",
  "Nora",
  "Drahoslava",
  "Linda",
  "Melinda",
  "Rebeka",
  "Rozlia",
  "Regna",
  "Alica",
  "Marianna",
  "Miriama",
  "Martina",
  "Mria",
  "Jolana",
  "udomila",
  "udmila",
  "Olympia",
  "Eugnia",
  "uboslava",
  "Zdenka",
  "Edita",
  "Michaela",
  "Stela",
  "Viera",
  "Natlia",
  "Elika",
  "Brigita",
  "Valentna",
  "Terzia",
  "Vladimra",
  "Hedviga",
  "Urua",
  "Alojza",
  "Kvetoslava",
  "Sabna",
  "Dobromila",
  "Klra",
  "Simona",
  "Aurlia",
  "Denisa",
  "Renta",
  "Irma",
  "Agnesa",
  "Klaudia",
  "Albeta",
  "Elvra",
  "Ceclia",
  "Emlia",
  "Katarna",
  "Henrieta",
  "Bibina",
  "Barbora",
  "Marna",
  "Izabela",
  "Hilda",
  "Otlia",
  "Lucia",
  "Branislava",
  "Bronislava",
  "Ivica",
  "Albna",
  "Kornlia",
  "Slva",
  "Slvka",
  "Judita",
  "Dagmara",
  "Adela",
  "Nadeda",
  "Eva",
  "Filomna",
  "Ivana",
  "Milada"
];

},{}],1127:[function(require,module,exports){
module["exports"] = [
  "Antalov",
  "Babkov",
  "Bahnov",
  "Balov",
  "Baranov",
  "Barankov",
  "Bartoviov",
  "Bartoov",
  "Baov",
  "Bernolkov",
  "Beov",
  "Bicekov",
  "Bielikov",
  "Blahov",
  "Bondrov",
  "Boskov",
  "Bokov",
  "Brezinov",
  "Bukovsk",
  "Chalupkov",
  "Chudkov",
  "Cibulov",
  "Cibulkov",
  "Cyprichov",
  "Cgerov",
  "Dankov",
  "Dakov",
  "Daov",
  "Debnrov",
  "Dejov",
  "Dekov",
  "Dolealov",
  "Doolomansk",
  "Droppov",
  "Dubovsk",
  "Dudekov",
  "Dulov",
  "Dullov",
  "Duskov",
  "Dvonov",
  "Dzurjaninov",
  "Dvidov",
  "Fabianov",
  "Fabinov",
  "Fajnorov",
  "Farkaovsk",
  "Ficov",
  "Filcov",
  "Filipov",
  "Finkov",
  "Ftorekov",
  "Gaparov",
  "Gaparoviov",
  "Gocnkov",
  "Gregorov",
  "Greguov",
  "Grznrov",
  "Hablkov",
  "Habudov",
  "Haldov",
  "Halukov",
  "Halkov",
  "Hankov",
  "Hanzalov",
  "Hakov",
  "Heretikov",
  "Hekov",
  "Hlavekov",
  "Hlinkov",
  "Holubov",
  "Holubyov",
  "Hossov",
  "Hozov",
  "Hrakov",
  "Hricov",
  "Hrmov",
  "Hruovsk",
  "Hubov",
  "Ihnakov",
  "Janeekov",
  "Janokov",
  "Jantooviov",
  "Jankov",
  "Janekov",
  "Jedovsk",
  "Jendekov",
  "Jonatov",
  "Jurinov",
  "Jurkoviov",
  "Jurkov",
  "Jnokov",
  "Kafendov",
  "Kalisk",
  "Karulov",
  "Kenov",
  "Klapkov",
  "Kmeov",
  "Kolesrov",
  "Kollrov",
  "Kolnikov",
  "Kolnkov",
  "Kolrov",
  "Korecov",
  "Kostkaov",
  "Kostrecov",
  "Kovov",
  "Kovikov",
  "Kozov",
  "Koiov",
  "Krajekov",
  "Krajov",
  "Krajoviov",
  "Krajrov",
  "Krlikov",
  "Krpov",
  "Kubkov",
  "Kyseov",
  "Kllayov",
  "Labudov",
  "Lepkov",
  "Liptkov",
  "Lisick",
  "Lubinov",
  "Lukov",
  "Luptkov",
  "Lkov",
  "Madejov",
  "Majesk",
  "Malachovsk",
  "Malekov",
  "Mamojkov",
  "Marcinkov",
  "Marinov",
  "Masarykov",
  "Maslov",
  "Matiakov",
  "Medveov",
  "Melcerov",
  "Meiarov",
  "Michalkov",
  "Mihalikov",
  "Mihlov",
  "Mihlikov",
  "Miklokov",
  "Mikulkov",
  "Mikuov",
  "Mikov",
  "Milotov",
  "Minov",
  "Mikov",
  "Mojiov",
  "Mokroov",
  "Morov",
  "Moravkov",
  "Mydlov",
  "Nemcov",
  "Novkov",
  "Obutov",
  "Ondruov",
  "Otenov",
  "Paukov",
  "Pavlikovsk",
  "Pavkov",
  "Paekov",
  "Pakov",
  "Peliknov",
  "Petrovick",
  "Petrukov",
  "Pekov",
  "Plchov",
  "Plekanecov",
  "Podhradsk",
  "Podkonick",
  "Poliakov",
  "Pupkov",
  "Rakov",
  "Repisk",
  "Romankov",
  "Rusov",
  "Ruikov",
  "Rybnekov",
  "Rybrov",
  "Rybrikov",
  "Samsonov",
  "Sedliakov",
  "Senkov",
  "Sklenkov",
  "Skokanov",
  "Skuteck",
  "Slaanov",
  "Slobodov",
  "Slobodnkov",
  "Slotov",
  "Slovkov",
  "Smrekov",
  "Stodolov",
  "Strakov",
  "Strniskov",
  "Svrbkov",
  "Smelov",
  "Skorov",
  "Tatarov",
  "Tatarkov",
  "Tatrov",
  "Tatrkaov",
  "Thomkov",
  "Tomeekov",
  "Tomkov",
  "Trubenov",
  "Turokov",
  "Uramov",
  "Urblkov",
  "Vajckov",
  "Vajdov",
  "Valachov",
  "Valachoviov",
  "Valentov",
  "Valukov",
  "Vanekov",
  "Veselov",
  "Vicenov",
  "Viovsk",
  "Vlachov",
  "Vojtekov",
  "Vydaren",
  "Zajacov",
  "Zimov",
  "Zimkov",
  "Zborsk",
  "Zbrikov",
  "apkoviov",
  "aploviov",
  "arnogursk",
  "iern",
  "obrdov",
  "aov",
  "uricov",
  "uriov",
  "idlov",
  "imonoviov",
  "kriniarov",
  "kulttyov",
  "majdov",
  "oltsov",
  "oltsov",
  "tefanov",
  "tefankov",
  "ulcov",
  "urkov",
  "vehlov",
  "astn"
];

},{}],1128:[function(require,module,exports){
arguments[4][347][0].apply(exports,arguments)
},{"./female_first_name":1126,"./female_last_name":1127,"./male_first_name":1129,"./male_last_name":1130,"./name":1131,"./prefix":1132,"./suffix":1133,"./title":1134,"dup":347}],1129:[function(require,module,exports){
module["exports"] = [
  "Drahoslav",
  "Severn",
  "Alexej",
  "Ernest",
  "Rastislav",
  "Radovan",
  "Dobroslav",
  "Dalibor",
  "Vincent",
  "Milo",
  "Timotej",
  "Gejza",
  "Bohu",
  "Alfonz",
  "Gapar",
  "Emil",
  "Erik",
  "Blaej",
  "Zdenko",
  "Dezider",
  "Arpd",
  "Valentn",
  "Pravoslav",
  "Jaromr",
  "Roman",
  "Matej",
  "Frederik",
  "Viktor",
  "Alexander",
  "Radomr",
  "Albn",
  "Bohumil",
  "Kazimr",
  "Fridrich",
  "Radoslav",
  "Tom",
  "Alan",
  "Branislav",
  "Bruno",
  "Gregor",
  "Vlastimil",
  "Boleslav",
  "Eduard",
  "Jozef",
  "Vazoslav",
  "Blahoslav",
  "Beadik",
  "Adrin",
  "Gabriel",
  "Marin",
  "Emanuel",
  "Miroslav",
  "Benjamn",
  "Hugo",
  "Richard",
  "Izidor",
  "Zoltn",
  "Albert",
  "Igor",
  "Jlius",
  "Ale",
  "Fedor",
  "Rudolf",
  "Valr",
  "Marcel",
  "Ervn",
  "Slavomr",
  "Vojtech",
  "Juraj",
  "Marek",
  "Jaroslav",
  "igmund",
  "Florin",
  "Roland",
  "Pankrc",
  "Servc",
  "Bonifc",
  "Svetozr",
  "Bernard",
  "Jlia",
  "Urban",
  "Duan",
  "Viliam",
  "Ferdinand",
  "Norbert",
  "Rbert",
  "Medard",
  "Zlatko",
  "Anton",
  "Vasil",
  "Vt",
  "Adolf",
  "Vratislav",
  "Alfrd",
  "Alojz",
  "Jn",
  "Tade",
  "Ladislav",
  "Peter",
  "Pavol",
  "Miloslav",
  "Prokop",
  "Cyril",
  "Metod",
  "Patrik",
  "Oliver",
  "Ivan",
  "Kamil",
  "Henrich",
  "Drahomr",
  "Bohuslav",
  "Ija",
  "Daniel",
  "Vladimr",
  "Jakub",
  "Kritof",
  "Ignc",
  "Gustv",
  "Jergu",
  "Dominik",
  "Oskar",
  "Vavrinec",
  "ubomr",
  "Mojmr",
  "Leonard",
  "Tichomr",
  "Filip",
  "Bartolomej",
  "udovt",
  "Samuel",
  "Augustn",
  "Belo",
  "Oleg",
  "Bystrk",
  "Ctibor",
  "udomil",
  "Kontantn",
  "uboslav",
  "Mat",
  "Mric",
  "ubo",
  "ubor",
  "Vladislav",
  "Cyprin",
  "Vclav",
  "Michal",
  "Jarolm",
  "Arnold",
  "Levoslav",
  "Frantiek",
  "Dionz",
  "Maximilin",
  "Koloman",
  "Boris",
  "Luk",
  "Kristin",
  "Vendeln",
  "Sergej",
  "Aurel",
  "Demeter",
  "Denis",
  "Hubert",
  "Karol",
  "Imrich",
  "Ren",
  "Bohumr",
  "Teodor",
  "Tibor",
  "Maro",
  "Martin",
  "Svtopluk",
  "Stanislav",
  "Leopold",
  "Eugen",
  "Flix",
  "Klement",
  "Kornel",
  "Milan",
  "Vratko",
  "Ondrej",
  "Andrej",
  "Edmund",
  "Oldrich",
  "Oto",
  "Mikul",
  "Ambrz",
  "Radz",
  "Bohdan",
  "Adam",
  "tefan",
  "Dvid",
  "Silvester"
];

},{}],1130:[function(require,module,exports){
module["exports"] = [
  "Antal",
  "Babka",
  "Bahna",
  "Bahno",
  "Bal",
  "Baran",
  "Baranka",
  "Bartovi",
  "Barto",
  "Baa",
  "Bernolk",
  "Beo",
  "Bicek",
  "Bielik",
  "Blaho",
  "Bondra",
  "Bosk",
  "Boka",
  "Brezina",
  "Bukovsk",
  "Chalupka",
  "Chudk",
  "Cibula",
  "Cibulka",
  "Cibua",
  "Cyprich",
  "Cger",
  "Danko",
  "Dako",
  "Dao",
  "Debnr",
  "Dej",
  "Dek",
  "Doleal",
  "Doolomansk",
  "Droppa",
  "Dubovsk",
  "Dudek",
  "Dula",
  "Dulla",
  "Dusk",
  "Dvon",
  "Dzurjanin",
  "Dvid",
  "Fabian",
  "Fabin",
  "Fajnor",
  "Farkaovsk",
  "Fico",
  "Filc",
  "Filip",
  "Finka",
  "Ftorek",
  "Gapar",
  "Gaparovi",
  "Gocnk",
  "Gregor",
  "Gregu",
  "Grznr",
  "Hablk",
  "Habuda",
  "Halda",
  "Haluka",
  "Halk",
  "Hanko",
  "Hanzal",
  "Hak",
  "Heretik",
  "Heko",
  "Hlavek",
  "Hlinka",
  "Holub",
  "Holuby",
  "Hossa",
  "Hoza",
  "Hrako",
  "Hric",
  "Hrmo",
  "Hruovsk",
  "Huba",
  "Ihnak",
  "Janeek",
  "Janoka",
  "Jantoovi",
  "Jank",
  "Janek",
  "Jedovsk",
  "Jendek",
  "Jonata",
  "Jurina",
  "Jurkovi",
  "Jurk",
  "Jnok",
  "Kafenda",
  "Kalisk",
  "Karul",
  "Ken",
  "Klapka",
  "Kme",
  "Kolesr",
  "Kollr",
  "Kolnik",
  "Kolnk",
  "Kolr",
  "Korec",
  "Kostka",
  "Kostrec",
  "Kov",
  "Kovik",
  "Koza",
  "Koi",
  "Krajek",
  "Kraji",
  "Krajo",
  "Krajovi",
  "Krajr",
  "Krlik",
  "Krpa",
  "Kubk",
  "Kyse",
  "Kllay",
  "Labuda",
  "Lepk",
  "Liptk",
  "Lisick",
  "Lubina",
  "Luk",
  "Luptk",
  "Lka",
  "Madej",
  "Majesk",
  "Malachovsk",
  "Malek",
  "Mamojka",
  "Marcinko",
  "Marin",
  "Masaryk",
  "Maslo",
  "Matiako",
  "Medve",
  "Melcer",
  "Meiar",
  "Michalk",
  "Mihalik",
  "Mihl",
  "Mihlik",
  "Mikloko",
  "Mikulk",
  "Miku",
  "Mik",
  "Milota",
  "Min",
  "Mik",
  "Moji",
  "Mokro",
  "Mora",
  "Moravk",
  "Mydlo",
  "Nemec",
  "Nitra",
  "Novk",
  "Obut",
  "Ondru",
  "Oten",
  "Pauko",
  "Pavlikovsk",
  "Pavk",
  "Paek",
  "Paka",
  "Pako",
  "Pelikn",
  "Petrovick",
  "Petruka",
  "Peko",
  "Plch",
  "Plekanec",
  "Podhradsk",
  "Podkonick",
  "Poliak",
  "Pupk",
  "Rak",
  "Repisk",
  "Romank",
  "Rus",
  "Ruika",
  "Rybnek",
  "Rybr",
  "Rybrik",
  "Samson",
  "Sedliak",
  "Senko",
  "Sklenka",
  "Skokan",
  "Skuteck",
  "Slaan",
  "Sloboda",
  "Slobodnk",
  "Slota",
  "Slovk",
  "Smrek",
  "Stodola",
  "Straka",
  "Strnisko",
  "Svrbk",
  "Smel",
  "Skora",
  "Tatar",
  "Tatarka",
  "Tatr",
  "Tatrka",
  "Thomka",
  "Tomeek",
  "Tomka",
  "Tomko",
  "Truben",
  "Turok",
  "Uram",
  "Urblk",
  "Vajck",
  "Vajda",
  "Valach",
  "Valachovi",
  "Valent",
  "Valuka",
  "Vanek",
  "Vesel",
  "Vicen",
  "Viovsk",
  "Vlach",
  "Vojtek",
  "Vydaren",
  "Zajac",
  "Zima",
  "Zimka",
  "Zborsk",
  "Zbrik",
  "apkovi",
  "aplovi",
  "arnogursk",
  "ierny",
  "obrda",
  "ao",
  "urica",
  "uri",
  "idlo",
  "imonovi",
  "kriniar",
  "kultty",
  "majda",
  "olts",
  "olts",
  "tefan",
  "tefanka",
  "ulc",
  "urka",
  "vehla",
  "astn"
];

},{}],1131:[function(require,module,exports){
arguments[4][350][0].apply(exports,arguments)
},{"dup":350}],1132:[function(require,module,exports){
arguments[4][351][0].apply(exports,arguments)
},{"dup":351}],1133:[function(require,module,exports){
arguments[4][352][0].apply(exports,arguments)
},{"dup":352}],1134:[function(require,module,exports){
arguments[4][523][0].apply(exports,arguments)
},{"dup":523}],1135:[function(require,module,exports){
module["exports"] = [
  "09## ### ###",
  "0## #### ####",
  "0# #### ####",
  "+421 ### ### ###"
];

},{}],1136:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":1135,"dup":312}],1137:[function(require,module,exports){
arguments[4][770][0].apply(exports,arguments)
},{"dup":770}],1138:[function(require,module,exports){
module["exports"] = [
  "#{city_prefix}#{city_suffix}"
];

},{}],1139:[function(require,module,exports){
module["exports"] = [
  "Sder",
  "Norr",
  "Vst",
  "ster",
  "Aling",
  "Ar",
  "Av",
  "Bo",
  "Br",
  "B",
  "Ek",
  "En",
  "Esk",
  "Fal",
  "Gv",
  "Gte",
  "Ha",
  "Helsing",
  "Karl",
  "Krist",
  "Kram",
  "Kung",
  "K",
  "Lyck",
  "Ny"
];

},{}],1140:[function(require,module,exports){
module["exports"] = [
  "stad",
  "land",
  "ss",
  "s",
  "holm",
  "tuna",
  "sta",
  "berg",
  "lv",
  "borg",
  "mora",
  "hamn",
  "fors",
  "kping",
  "by",
  "hult",
  "torp",
  "fred",
  "vik"
];

},{}],1141:[function(require,module,exports){
module["exports"] = [
  "s Vg",
  "s Gata"
];

},{}],1142:[function(require,module,exports){
module["exports"] = [
  "Ryssland",
  "Kanada",
  "Kina",
  "USA",
  "Brasilien",
  "Australien",
  "Indien",
  "Argentina",
  "Kazakstan",
  "Algeriet",
  "DR Kongo",
  "Danmark",
  "Frarna",
  "Grnland",
  "Saudiarabien",
  "Mexiko",
  "Indonesien",
  "Sudan",
  "Libyen",
  "Iran",
  "Mongoliet",
  "Peru",
  "Tchad",
  "Niger",
  "Angola",
  "Mali",
  "Sydafrika",
  "Colombia",
  "Etiopien",
  "Bolivia",
  "Mauretanien",
  "Egypten",
  "Tanzania",
  "Nigeria",
  "Venezuela",
  "Namibia",
  "Pakistan",
  "Moambique",
  "Turkiet",
  "Chile",
  "Zambia",
  "Marocko",
  "Vstsahara",
  "Burma",
  "Afghanistan",
  "Somalia",
  "Centralafrikanska republiken",
  "Sydsudan",
  "Ukraina",
  "Botswana",
  "Madagaskar",
  "Kenya",
  "Frankrike",
  "Franska Guyana",
  "Jemen",
  "Thailand",
  "Spanien",
  "Turkmenistan",
  "Kamerun",
  "Papua Nya Guinea",
  "Sverige",
  "Uzbekistan",
  "Irak",
  "Paraguay",
  "Zimbabwe",
  "Japan",
  "Tyskland",
  "Kongo",
  "Finland",
  "Malaysia",
  "Vietnam",
  "Norge",
  "Svalbard",
  "Jan Mayen",
  "Elfenbenskusten",
  "Polen",
  "Italien",
  "Filippinerna",
  "Ecuador",
  "Burkina Faso",
  "Nya Zeeland",
  "Gabon",
  "Guinea",
  "Storbritannien",
  "Ghana",
  "Rumnien",
  "Laos",
  "Uganda",
  "Guyana",
  "Oman",
  "Vitryssland",
  "Kirgizistan",
  "Senegal",
  "Syrien",
  "Kambodja",
  "Uruguay",
  "Tunisien",
  "Surinam",
  "Nepal",
  "Bangladesh",
  "Tadzjikistan",
  "Grekland",
  "Nicaragua",
  "Eritrea",
  "Nordkorea",
  "Malawi",
  "Benin",
  "Honduras",
  "Liberia",
  "Bulgarien",
  "Kuba",
  "Guatemala",
  "Island",
  "Sydkorea",
  "Ungern",
  "Portugal",
  "Jordanien",
  "Serbien",
  "Azerbajdzjan",
  "sterrike",
  "Frenade Arabemiraten",
  "Tjeckien",
  "Panama",
  "Sierra Leone",
  "Irland",
  "Georgien",
  "Sri Lanka",
  "Litauen",
  "Lettland",
  "Togo",
  "Kroatien",
  "Bosnien och Hercegovina",
  "Costa Rica",
  "Slovakien",
  "Dominikanska republiken",
  "Bhutan",
  "Estland",
  "Danmark",
  "Frarna",
  "Grnland",
  "Nederlnderna",
  "Schweiz",
  "Guinea-Bissau",
  "Taiwan",
  "Moldavien",
  "Belgien",
  "Lesotho",
  "Armenien",
  "Albanien",
  "Salomonarna",
  "Ekvatorialguinea",
  "Burundi",
  "Haiti",
  "Rwanda",
  "Makedonien",
  "Djibouti",
  "Belize",
  "Israel",
  "El Salvador",
  "Slovenien",
  "Fiji",
  "Kuwait",
  "Swaziland",
  "Timor-Leste",
  "Montenegro",
  "Bahamas",
  "Vanuatu",
  "Qatar",
  "Gambia",
  "Jamaica",
  "Kosovo",
  "Libanon",
  "Cypern",
  "Brunei",
  "Trinidad och Tobago",
  "Kap Verde",
  "Samoa",
  "Luxemburg",
  "Komorerna",
  "Mauritius",
  "So Tom och Prncipe",
  "Kiribati",
  "Dominica",
  "Tonga",
  "Mikronesiens federerade stater",
  "Singapore",
  "Bahrain",
  "Saint Lucia",
  "Andorra",
  "Palau",
  "Seychellerna",
  "Antigua och Barbuda",
  "Barbados",
  "Saint Vincent och Grenadinerna",
  "Grenada",
  "Malta",
  "Maldiverna",
  "Saint Kitts och Nevis",
  "Marshallarna",
  "Liechtenstein",
  "San Marino",
  "Tuvalu",
  "Nauru",
  "Monaco",
  "Vatikanstaten"
];

},{}],1143:[function(require,module,exports){
module["exports"] = [
  "Sverige"
];

},{}],1144:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.country = require("./country");
address.common_street_suffix = require("./common_street_suffix");
address.street_prefix = require("./street_prefix");
address.street_root = require("./street_root");
address.street_suffix = require("./street_suffix");
address.state = require("./state");
address.city = require("./city");
address.street_name = require("./street_name");
address.postcode = require("./postcode");
address.building_number = require("./building_number");
address.secondary_address = require("./secondary_address");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":1137,"./city":1138,"./city_prefix":1139,"./city_suffix":1140,"./common_street_suffix":1141,"./country":1142,"./default_country":1143,"./postcode":1145,"./secondary_address":1146,"./state":1147,"./street_address":1148,"./street_name":1149,"./street_prefix":1150,"./street_root":1151,"./street_suffix":1152}],1145:[function(require,module,exports){
arguments[4][638][0].apply(exports,arguments)
},{"dup":638}],1146:[function(require,module,exports){
module["exports"] = [
  "Lgh. ###",
  "Hus ###"
];

},{}],1147:[function(require,module,exports){
module["exports"] = [
  "Blekinge",
  "Dalarna",
  "Gotland",
  "Gvleborg",
  "Gteborg",
  "Halland",
  "Jmtland",
  "Jnkping",
  "Kalmar",
  "Kronoberg",
  "Norrbotten",
  "Skaraborg",
  "Skne",
  "Stockholm",
  "Sdermanland",
  "Uppsala",
  "Vrmland",
  "Vsterbotten",
  "Vsternorrland",
  "Vstmanland",
  "lvsborg",
  "rebro",
  "stergtland"
];

},{}],1148:[function(require,module,exports){
arguments[4][324][0].apply(exports,arguments)
},{"dup":324}],1149:[function(require,module,exports){
arguments[4][922][0].apply(exports,arguments)
},{"dup":922}],1150:[function(require,module,exports){
module["exports"] = [
  "Vstra",
  "stra",
  "Norra",
  "Sdra",
  "vre",
  "Undre"
];

},{}],1151:[function(require,module,exports){
module["exports"] = [
  "Bjrk",
  "Jrnvgs",
  "Ring",
  "Skol",
  "Skogs",
  "Ny",
  "Gran",
  "Idrotts",
  "Stor",
  "Kyrk",
  "Industri",
  "Park",
  "Strand",
  "Skol",
  "Trdgrd",
  "ngs",
  "Kyrko",
  "Villa",
  "Ek",
  "Kvarn",
  "Stations",
  "Back",
  "Furu",
  "Gen",
  "Fabriks",
  "ker",
  "Bck",
  "Asp"
];

},{}],1152:[function(require,module,exports){
module["exports"] = [
  "vgen",
  "gatan",
  "grnden",
  "grdet",
  "alln"
];

},{}],1153:[function(require,module,exports){
module["exports"] = [
  56,
  62,
  59
];

},{}],1154:[function(require,module,exports){
module["exports"] = [
  "#{common_cell_prefix}-###-####"
];

},{}],1155:[function(require,module,exports){
var cell_phone = {};
module['exports'] = cell_phone;
cell_phone.common_cell_prefix = require("./common_cell_prefix");
cell_phone.formats = require("./formats");

},{"./common_cell_prefix":1153,"./formats":1154}],1156:[function(require,module,exports){
module["exports"] = [
  "vit",
  "silver",
  "gr",
  "svart",
  "rd",
  "grn",
  "bl",
  "gul",
  "lila",
  "indigo",
  "guld",
  "brun",
  "rosa",
  "purpur",
  "korall"
];

},{}],1157:[function(require,module,exports){
module["exports"] = [
  "Bcker",
  "Filmer",
  "Musik",
  "Spel",
  "Elektronik",
  "Datorer",
  "Hem",
  "Trdgrd",
  "Verktyg",
  "Livsmedel",
  "Hlsa",
  "Sknhet",
  "Leksaker",
  "Kldsel",
  "Skor",
  "Smycken",
  "Sport"
];

},{}],1158:[function(require,module,exports){
arguments[4][290][0].apply(exports,arguments)
},{"./color":1156,"./department":1157,"./product_name":1159,"dup":290}],1159:[function(require,module,exports){
module["exports"] = {
  "adjective": [
    "Liten",
    "Ergonomisk",
    "Robust",
    "Intelligent",
    "St",
    "Otrolig",
    "Fatastisk",
    "Praktisk",
    "Slimmad",
    "Grym"
  ],
  "material": [
    "Stl",
    "Metall",
    "Tr",
    "Betong",
    "Plast",
    "Bomul",
    "Grnit",
    "Gummi",
    "Latex"
  ],
  "product": [
    "Stol",
    "Bil",
    "Dator",
    "Handskar",
    "Pants",
    "Shirt",
    "Table",
    "Shoes",
    "Hat"
  ]
};

},{}],1160:[function(require,module,exports){
arguments[4][425][0].apply(exports,arguments)
},{"./name":1161,"./suffix":1162,"dup":425}],1161:[function(require,module,exports){
module["exports"] = [
  "#{Name.last_name} #{suffix}",
  "#{Name.last_name}-#{Name.last_name}",
  "#{Name.last_name}, #{Name.last_name} #{suffix}"
];

},{}],1162:[function(require,module,exports){
module["exports"] = [
  "Gruppen",
  "AB",
  "HB",
  "Group",
  "Investment",
  "Kommanditbolag",
  "Aktiebolag"
];

},{}],1163:[function(require,module,exports){
arguments[4][296][0].apply(exports,arguments)
},{"./month":1164,"./weekday":1165,"dup":296}],1164:[function(require,module,exports){
// Source: http://unicode.org/cldr/trac/browser/tags/release-27/common/main/en.xml#L1799
module["exports"] = {
  wide: [
    "januari",
    "februari",
    "mars",
    "april",
    "maj",
    "juni",
    "juli",
    "augusti",
    "september",
    "oktober",
    "november",
    "december"
  ],
  abbr: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "aug",
    "sep",
    "okt",
    "nov",
    "dec"
  ]
};

},{}],1165:[function(require,module,exports){
// Source: http://unicode.org/cldr/trac/browser/tags/release-27/common/main/en.xml#L1847
module["exports"] = {
  wide: [
    "sndag",
    "mndag",
    "tisdag",
    "onsdag",
    "torsdag",
    "fredag",
    "lrdag"
  ],
  abbr: [
    "sn",
    "mn",
    "tis",
    "ons",
    "tor",
    "fre",
    "lr"
  ]
};

},{}],1166:[function(require,module,exports){
var sv = {};
module['exports'] = sv;
sv.title = "Swedish";
sv.address = require("./address");
sv.company = require("./company");
sv.internet = require("./internet");
sv.name = require("./name");
sv.phone_number = require("./phone_number");
sv.cell_phone = require("./cell_phone");
sv.commerce = require("./commerce");
sv.team = require("./team");
sv.date = require("./date");

},{"./address":1144,"./cell_phone":1155,"./commerce":1158,"./company":1160,"./date":1163,"./internet":1168,"./name":1171,"./phone_number":1177,"./team":1178}],1167:[function(require,module,exports){
module["exports"] = [
  "se",
  "nu",
  "info",
  "com",
  "org"
];

},{}],1168:[function(require,module,exports){
arguments[4][430][0].apply(exports,arguments)
},{"./domain_suffix":1167,"dup":430}],1169:[function(require,module,exports){
module["exports"] = [
  "Erik",
  "Lars",
  "Karl",
  "Anders",
  "Per",
  "Johan",
  "Nils",
  "Lennart",
  "Emil",
  "Hans"
];

},{}],1170:[function(require,module,exports){
module["exports"] = [
  "Maria",
  "Anna",
  "Margareta",
  "Elisabeth",
  "Eva",
  "Birgitta",
  "Kristina",
  "Karin",
  "Elisabet",
  "Marie"
];

},{}],1171:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.first_name_women = require("./first_name_women");
name.first_name_men = require("./first_name_men");
name.last_name = require("./last_name");
name.prefix = require("./prefix");
name.title = require("./title");
name.name = require("./name");

},{"./first_name_men":1169,"./first_name_women":1170,"./last_name":1172,"./name":1173,"./prefix":1174,"./title":1175}],1172:[function(require,module,exports){
module["exports"] = [
  "Johansson",
  "Andersson",
  "Karlsson",
  "Nilsson",
  "Eriksson",
  "Larsson",
  "Olsson",
  "Persson",
  "Svensson",
  "Gustafsson"
];

},{}],1173:[function(require,module,exports){
module["exports"] = [
  "#{first_name_women} #{last_name}",
  "#{first_name_men} #{last_name}",
  "#{first_name_women} #{last_name}",
  "#{first_name_men} #{last_name}",
  "#{first_name_women} #{last_name}",
  "#{first_name_men} #{last_name}",
  "#{prefix} #{first_name_men} #{last_name}",
  "#{prefix} #{first_name_women} #{last_name}"
];

},{}],1174:[function(require,module,exports){
module["exports"] = [
  "Dr.",
  "Prof.",
  "PhD."
];

},{}],1175:[function(require,module,exports){
arguments[4][523][0].apply(exports,arguments)
},{"dup":523}],1176:[function(require,module,exports){
module["exports"] = [
  "####-#####",
  "####-######"
];

},{}],1177:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":1176,"dup":312}],1178:[function(require,module,exports){
var team = {};
module['exports'] = team;
team.suffix = require("./suffix");
team.name = require("./name");

},{"./name":1179,"./suffix":1180}],1179:[function(require,module,exports){
module["exports"] = [
  "#{Address.city} #{suffix}"
];

},{}],1180:[function(require,module,exports){
module["exports"] = [
  "IF",
  "FF",
  "BK",
  "HK",
  "AIF",
  "SK",
  "FC",
  "SK",
  "BoIS",
  "FK",
  "BIS",
  "FIF",
  "IK"
];

},{}],1181:[function(require,module,exports){
arguments[4][356][0].apply(exports,arguments)
},{"dup":356}],1182:[function(require,module,exports){
module["exports"] = [
  "Adana",
  "Adyaman",
  "Afyon",
  "Ar",
  "Amasya",
  "Ankara",
  "Antalya",
  "Artvin",
  "Aydn",
  "Balkesir",
  "Bilecik",
  "Bingl",
  "Bitlis",
  "Bolu",
  "Burdur",
  "Bursa",
  "anakkale",
  "ankr",
  "orum",
  "Denizli",
  "Diyarbakr",
  "Edirne",
  "Elaz",
  "Erzincan",
  "Erzurum",
  "Eskiehir",
  "Gaziantep",
  "Giresun",
  "Gmhane",
  "Hakkari",
  "Hatay",
  "Isparta",
  "el (Mersin)",
  "stanbul",
  "zmir",
  "Kars",
  "Kastamonu",
  "Kayseri",
  "Krklareli",
  "Krehir",
  "Kocaeli",
  "Konya",
  "Ktahya",
  "Malatya",
  "Manisa",
  "K.mara",
  "Mardin",
  "Mula",
  "Mu",
  "Nevehir",
  "Nide",
  "Ordu",
  "Rize",
  "Sakarya",
  "Samsun",
  "Siirt",
  "Sinop",
  "Sivas",
  "Tekirda",
  "Tokat",
  "Trabzon",
  "Tunceli",
  "anlurfa",
  "Uak",
  "Van",
  "Yozgat",
  "Zonguldak",
  "Aksaray",
  "Bayburt",
  "Karaman",
  "Krkkale",
  "Batman",
  "rnak",
  "Bartn",
  "Ardahan",
  "Idr",
  "Yalova",
  "Karabk",
  "Kilis",
  "Osmaniye",
  "Dzce"
];

},{}],1183:[function(require,module,exports){
module["exports"] = [
  "Afganistan",
  "Almanya",
  "Amerika Birleik Devletleri",
  "Amerikan Samoa",
  "Andorra",
  "Angola",
  "Anguilla, ngiltere",
  "Antigua ve Barbuda",
  "Arjantin",
  "Arnavutluk",
  "Aruba, Hollanda",
  "Avustralya",
  "Avusturya",
  "Azerbaycan",
  "Bahama Adalar",
  "Bahreyn",
  "Banglade",
  "Barbados",
  "Belika",
  "Belize",
  "Benin",
  "Bermuda, ngiltere",
  "Beyaz Rusya",
  "Bhutan",
  "Birleik Arap Emirlikleri",
  "Birmanya (Myanmar)",
  "Bolivya",
  "Bosna Hersek",
  "Botswana",
  "Brezilya",
  "Brunei",
  "Bulgaristan",
  "Burkina Faso",
  "Burundi",
  "Cape Verde",
  "Cayman Adalar, ngiltere",
  "Cebelitark, ngiltere",
  "Cezayir",
  "Christmas Adas , Avusturalya",
  "Cibuti",
  "ad",
  "ek Cumhuriyeti",
  "in",
  "Danimarka",
  "Dou Timor",
  "Dominik Cumhuriyeti",
  "Dominika",
  "Ekvator",
  "Ekvator Ginesi",
  "El Salvador",
  "Endonezya",
  "Eritre",
  "Ermenistan",
  "Estonya",
  "Etiyopya",
  "Fas",
  "Fiji",
  "Fildii Sahili",
  "Filipinler",
  "Filistin",
  "Finlandiya",
  "Folkland Adalar, ngiltere",
  "Fransa",
  "Fransz Guyanas",
  "Fransz Gney Eyaletleri (Kerguelen Adalar)",
  "Fransz Polinezyas",
  "Gabon",
  "Galler",
  "Gambiya",
  "Gana",
  "Gine",
  "Gine-Bissau",
  "Grenada",
  "Grnland",
  "Guadalup, Fransa",
  "Guam, Amerika",
  "Guatemala",
  "Guyana",
  "Gney Afrika",
  "Gney Georgia ve Gney Sandvi Adalar, ngiltere",
  "Gney Kbrs Rum Ynetimi",
  "Gney Kore",
  "Grcistan H",
  "Haiti",
  "Hrvatistan",
  "Hindistan",
  "Hollanda",
  "Hollanda Antilleri",
  "Honduras",
  "Irak",
  "ngiltere",
  "ran",
  "rlanda",
  "spanya",
  "srail",
  "sve",
  "svire",
  "talya",
  "zlanda",
  "Jamaika",
  "Japonya",
  "Johnston Atoll, Amerika",
  "K.K.T.C.",
  "Kamboya",
  "Kamerun",
  "Kanada",
  "Kanarya Adalar",
  "Karada",
  "Katar",
  "Kazakistan",
  "Kenya",
  "Krgzistan",
  "Kiribati",
  "Kolombiya",
  "Komorlar",
  "Kongo",
  "Kongo Demokratik Cumhuriyeti",
  "Kosova",
  "Kosta Rika",
  "Kuveyt",
  "Kuzey rlanda",
  "Kuzey Kore",
  "Kuzey Maryana Adalar",
  "Kba",
  "Laos",
  "Lesotho",
  "Letonya",
  "Liberya",
  "Libya",
  "Liechtenstein",
  "Litvanya",
  "Lbnan",
  "Lksemburg",
  "Macaristan",
  "Madagaskar",
  "Makau (Makao)",
  "Makedonya",
  "Malavi",
  "Maldiv Adalar",
  "Malezya",
  "Mali",
  "Malta",
  "Maral Adalar",
  "Martinik, Fransa",
  "Mauritius",
  "Mayotte, Fransa",
  "Meksika",
  "Msr",
  "Midway Adalar, Amerika",
  "Mikronezya",
  "Moolistan",
  "Moldavya",
  "Monako",
  "Montserrat",
  "Moritanya",
  "Mozambik",
  "Namibia",
  "Nauru",
  "Nepal",
  "Nijer",
  "Nijerya",
  "Nikaragua",
  "Niue, Yeni Zelanda",
  "Norve",
  "Orta Afrika Cumhuriyeti",
  "zbekistan",
  "Pakistan",
  "Palau Adalar",
  "Palmyra Atoll, Amerika",
  "Panama",
  "Papua Yeni Gine",
  "Paraguay",
  "Peru",
  "Polonya",
  "Portekiz",
  "Porto Riko, Amerika",
  "Reunion, Fransa",
  "Romanya",
  "Ruanda",
  "Rusya Federasyonu",
  "Saint Helena, ngiltere",
  "Saint Martin, Fransa",
  "Saint Pierre ve Miquelon, Fransa",
  "Samoa",
  "San Marino",
  "Santa Kitts ve Nevis",
  "Santa Lucia",
  "Santa Vincent ve Grenadinler",
  "Sao Tome ve Principe",
  "Senegal",
  "Seyeller",
  "Srbistan",
  "Sierra Leone",
  "Singapur",
  "Slovakya",
  "Slovenya",
  "Solomon Adalar",
  "Somali",
  "Sri Lanka",
  "Sudan",
  "Surinam",
  "Suriye",
  "Suudi Arabistan",
  "Svalbard, Norve",
  "Svaziland",
  "ili",
  "Tacikistan",
  "Tanzanya",
  "Tayland",
  "Tayvan",
  "Togo",
  "Tonga",
  "Trinidad ve Tobago",
  "Tunus",
  "Turks ve Caicos Adalar, ngiltere",
  "Tuvalu",
  "Trkiye",
  "Trkmenistan",
  "Uganda",
  "Ukrayna",
  "Umman",
  "Uruguay",
  "rdn",
  "Vallis ve Futuna, Fransa",
  "Vanuatu",
  "Venezuela",
  "Vietnam",
  "Virgin Adalar, Amerika",
  "Virgin Adalar, ngiltere",
  "Wake Adalar, Amerika",
  "Yemen",
  "Yeni Kaledonya, Fransa",
  "Yeni Zelanda",
  "Yunanistan",
  "Zambiya",
  "Zimbabve"
];

},{}],1184:[function(require,module,exports){
module["exports"] = [
  "Trkiye"
];

},{}],1185:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city = require("./city");
address.street_root = require("./street_root");
address.country = require("./country");
address.postcode = require("./postcode");
address.default_country = require("./default_country");
address.building_number = require("./building_number");
address.street_name = require("./street_name");
address.street_address = require("./street_address");

},{"./building_number":1181,"./city":1182,"./country":1183,"./default_country":1184,"./postcode":1186,"./street_address":1187,"./street_name":1188,"./street_root":1189}],1186:[function(require,module,exports){
arguments[4][638][0].apply(exports,arguments)
},{"dup":638}],1187:[function(require,module,exports){
arguments[4][324][0].apply(exports,arguments)
},{"dup":324}],1188:[function(require,module,exports){
arguments[4][368][0].apply(exports,arguments)
},{"dup":368}],1189:[function(require,module,exports){
module["exports"] = [
  "Atatrk Bulvar",
  "Alparslan Trke Bulvar",
  "Ali etinkaya Caddesi",
  "Tevfik Fikret Caddesi",
  "Kocatepe Caddesi",
  "smet Paa Caddesi",
  "30 Austos Caddesi",
  "smet Attila Caddesi",
  "Namk Kemal Caddesi",
  "Ltfi Karadirek Caddesi",
  "Sarkaya Caddesi",
  "Yunus Emre Sokak",
  "Dar Sokak",
  "Fatih Sokak ",
  "Harman Yolu Sokak ",
  "Ergenekon Sokak  ",
  "lk Sokak",
  "Salk Sokak",
  "Okul Sokak",
  "Harman Alt Sokak",
  "Kaldrm Sokak",
  "Mevlana Sokak",
  "Gl Sokak",
  "Sran St Sokak",
  "Gven Yaka Sokak",
  "Saygl Sokak",
  "Meneke Sokak",
  "Dank Evler Sokak",
  "Sevgi Sokak",
  "Afyon Kaya Sokak",
  "Ouzhan Sokak",
  "bn-i Sina Sokak",
  "Okul Sokak",
  "Bahe Sokak",
  "Kypnar Sokak",
  "Kekeolu Sokak",
  "Bar Sokak",
  "Bayr Sokak",
  "Kerimolu Sokak",
  "Nalbant Sokak",
  "Bandak Sokak"
];

},{}],1190:[function(require,module,exports){
module["exports"] = [
  "+90-53#-###-##-##",
  "+90-54#-###-##-##",
  "+90-55#-###-##-##",
  "+90-50#-###-##-##"
];

},{}],1191:[function(require,module,exports){
arguments[4][371][0].apply(exports,arguments)
},{"./formats":1190,"dup":371}],1192:[function(require,module,exports){
var tr = {};
module['exports'] = tr;
tr.title = "Turkish";
tr.address = require("./address");
tr.internet = require("./internet");
tr.lorem = require("./lorem");
tr.phone_number = require("./phone_number");
tr.cell_phone = require("./cell_phone");
tr.name = require("./name");

},{"./address":1185,"./cell_phone":1191,"./internet":1194,"./lorem":1195,"./name":1198,"./phone_number":1204}],1193:[function(require,module,exports){
module["exports"] = [
  "com.tr",
  "com",
  "biz",
  "info",
  "name",
  "gov.tr"
];

},{}],1194:[function(require,module,exports){
arguments[4][430][0].apply(exports,arguments)
},{"./domain_suffix":1193,"dup":430}],1195:[function(require,module,exports){
arguments[4][380][0].apply(exports,arguments)
},{"./words":1196,"dup":380}],1196:[function(require,module,exports){
arguments[4][344][0].apply(exports,arguments)
},{"dup":344}],1197:[function(require,module,exports){
module["exports"] = [
  "Aba",
  "Abak",
  "Abaka",
  "Abakan",
  "Abakay",
  "Abar",
  "Abay",
  "Ab",
  "Ablay",
  "Ablu",
  "Abar",
  "A",
  "Ak",
  "Auk",
  "Adalan",
  "Adald",
  "Adalm",
  "Adar",
  "Ada",
  "Adberilgen",
  "Adgzel",
  "Adk",
  "Adkutlu",
  "Adkutluta",
  "Adl",
  "Adlbe",
  "Adraman",
  "Adsz",
  "Afar",
  "Afn",
  "Aabay",
  "Aakaan",
  "Aalak",
  "Alam",
  "Ak",
  "Aka",
  "Akata",
  "Akba",
  "Akbay",
  "Akboa",
  "Akbr",
  "Akbudak",
  "Akbura",
  "Akbulak",
  "Aka",
  "Akakoca",
  "Akora",
  "Akdemir",
  "Akdoan",
  "Ak",
  "Akbudak",
  "Akm",
  "Akn",
  "Akn",
  "Akkun",
  "Akkunlu",
  "Akkurt",
  "Akku",
  "Akpra",
  "Aksungur",
  "Aktan",
  "Al",
  "Ala",
  "Alaban",
  "Alabr",
  "Alada",
  "Aladoan",
  "Alakurt",
  "Alayunt",
  "Alayuntlu",
  "Aldemir",
  "Aldgerey",
  "Aldoan",
  "Algu",
  "Almga",
  "Alka",
  "Alkablk",
  "Alkaevli",
  "Alkan",
  "Alka",
  "Alk",
  "Alp",
  "Alpagut",
  "Alpam",
  "Alparsbe",
  "Alparslan",
  "Alpata",
  "Alpay",
  "Alpaya",
  "Alpaykaan",
  "Alpbams",
  "Alpbilge",
  "Alpdirek",
  "Alpdoan",
  "Alper",
  "Alperen",
  "Alpertunga",
  "Alpgerey",
  "Alp",
  "Alpilig",
  "Alpkara",
  "Alpkutlu",
  "Alpklk",
  "Alpal",
  "Alptegin",
  "Alpturul",
  "Alptunga",
  "Alpturan",
  "Alptutuk",
  "Alpulu",
  "Alpurungu",
  "Alpurungututuk",
  "Alpyrk",
  "Altan",
  "Altankaan",
  "Altankan",
  "Altay",
  "Altn",
  "Altnkaan",
  "Altnkan",
  "Altnoba",
  "Altntamgan",
  "Altntamgantarkan",
  "Altntarkan",
  "Altntay",
  "Altmkara",
  "Altuga",
  "Ama",
  "Amrak",
  "Amul",
  "Anuk",
  "Andarman",
  "Anl",
  "Ant",
  "Apa",
  "Apak",
  "Apatarkan",
  "Apranur",
  "Araboa",
  "Arademir",
  "Aral",
  "Arbay",
  "Arbuz",
  "Aruk",
  "Ard",
  "Argl",
  "Argu",
  "Argun",
  "Ar",
  "Arboa",
  "Ark",
  "Arkaan",
  "Arkdoruk",
  "Arn",
  "Arkn",
  "Ark",
  "Armaan",
  "Arna",
  "Arpat",
  "Arsal",
  "Arsl",
  "Arslan",
  "Arslanargun",
  "Arslanbr",
  "Arslansungur",
  "Arslantegin",
  "Arslanyabgu",
  "Arun",
  "Artnal",
  "Artuk",
  "Artuka",
  "Artut",
  "Aruk",
  "Asartegin",
  "As",
  "Asr",
  "Asu",
  "Aan",
  "Aanboa",
  "Aanturul",
  "Aantudun",
  "Akbulmu",
  "Akn",
  "Ataloul",
  "Auk",
  "Ata",
  "Atakaan",
  "Atakan",
  "Atalan",
  "Atald",
  "Atalm",
  "Ataman",
  "Atasagun",
  "Atasu",
  "Atberilgen",
  "Atgay",
  "Atkutlu",
  "Atkutluta",
  "Atla",
  "Atlgan",
  "Atm",
  "Atmer",
  "At",
  "Atl",
  "Atlbe",
  "Atlkaan",
  "Atmaca",
  "Atsz",
  "Atunu",
  "Avar",
  "Avlu",
  "Avar",
  "Ay",
  "Aya",
  "Ayas",
  "Aya",
  "Ayaz",
  "Aybalta",
  "Ayban",
  "Aybars",
  "Aybe",
  "Aydarkaan",
  "Aydemir",
  "Aydn",
  "Aydnalp",
  "Aydoan",
  "Aydodu",
  "Aydomu",
  "Aygrak",
  "Aytm",
  "Ayz",
  "Ayzda",
  "Aykaan",
  "Aykan",
  "Aykurt",
  "Aylu",
  "Aylutarkan",
  "Ayma",
  "Ayruk",
  "Aysl",
  "Aytak",
  "Ayyldz",
  "Azak",
  "Azban",
  "Azgan",
  "Azganaz",
  "Azl",
  "Babr",
  "Babur",
  "Baara",
  "Baayman",
  "Baman",
  "Badabul",
  "Badruk",
  "Badur",
  "Baa",
  "Baaalp",
  "Baabara",
  "Baan",
  "Baaatulu",
  "Baatarkan",
  "Baatengrikaan",
  "Baatur",
  "Baaturigi",
  "Baaturgerey",
  "Baaturipi",
  "Baatursepi",
  "Ba",
  "Bata",
  "Bakaul",
  "Bakr",
  "Bakrsokum",
  "Baks",
  "Bak",
  "Balaban",
  "Balaka",
  "Balakatay",
  "Balamr",
  "Balar",
  "Baldu",
  "Balkk",
  "Balta",
  "Baltac",
  "Baltar",
  "Baltr",
  "Baltur",
  "Bams",
  "Bangu",
  "Barak",
  "Baraktre",
  "Baran",
  "Barbe",
  "Barboa",
  "Barbol",
  "Barbulsun",
  "Bara",
  "Baradodu",
  "Baradomu",
  "Baradurdu",
  "Baradurmu",
  "Baran",
  "Baratoyun",
  "Bardbay",
  "Bargan",
  "Barmtay",
  "Barn",
  "Barkan",
  "Barkdodu",
  "Barkdomu",
  "Barkdurdu",
  "Barkdurmu",
  "Barkn",
  "Barlas",
  "Barlbay",
  "Barmaklak",
  "Barmakl",
  "Barman",
  "Bars",
  "Barsbe",
  "Barsboa",
  "Barsgan",
  "Barskan",
  "Barsurungu",
  "Bartu",
  "Basademir",
  "Basan",
  "Basanyalava",
  "Basar",
  "Basat",
  "Baskn",
  "Basml",
  "Bast",
  "Basturul",
  "Basu",
  "Basut",
  "Baak",
  "Babu",
  "Ba",
  "Bagan",
  "Bakrt",
  "Bakurt",
  "Batar",
  "Batrak",
  "Batu",
  "Batuk",
  "Batur",
  "Baturalp",
  "Bay",
  "Bayanar",
  "Bayankaan",
  "Bayat",
  "Bayazt",
  "Baybars",
  "Baybayk",
  "Baybien",
  "Bayboa",
  "Baybora",
  "Baybre",
  "Baydar",
  "Baydemir",
  "Baydur",
  "Bayk",
  "Baynur",
  "Bayndr",
  "Baykal",
  "Baykara",
  "Baykoca",
  "Baykuzu",
  "Baymnke",
  "Bayna",
  "Baynal",
  "Baypre",
  "Bayr",
  "Bayra",
  "Bayrak",
  "Bayram",
  "Bayrn",
  "Bayruk",
  "Baysungur",
  "Baytara",
  "Bayta",
  "Bayunur",
  "Bayur",
  "Bayurku",
  "Bayutmu",
  "Bayuttu",
  "Bazr",
  "Beeapa",
  "Bekem",
  "Be",
  "Bearslan",
  "Bebars",
  "Bebilgeikin",
  "Beboa",
  "Beur",
  "Bedemir",
  "Bedilli",
  "Bedurmu",
  "Bekulu",
  "Beta",
  "Betegin",
  "Betzn",
  "Begi",
  "Begil",
  "Begine",
  "Begitutuk",
  "Beglen",
  "Begni",
  "Bek",
  "Bekazl",
  "Bekbeke",
  "Beke",
  "Bekearslan",
  "Bekearslantegin",
  "Beketegin",
  "Beker",
  "Beklemi",
  "Bektr",
  "Belir",
  "Belek",
  "Belgi",
  "Belgc",
  "Beltir",
  "Bengi",
  "Beng",
  "Benlidemir",
  "Berdibe",
  "Berendey",
  "Berg",
  "Berginsenge",
  "Berk",
  "Berke",
  "Berki",
  "Berkyaruk",
  "Bermek",
  "Besentegin",
  "Betemir",
  "Beyizi",
  "Beyrek",
  "Beyrem",
  "Bk",
  "Bkc",
  "Bdn",
  "Btaybk",
  "Btr",
  "Biek",
  "Bilge",
  "Bilgebayunur",
  "Bilgebe",
  "Bilgeikin",
  "Bilgebara",
  "Bilgebaratamgan",
  "Bilgekaan",
  "Bilgekan",
  "Bilgekutluk",
  "Bilgeklur",
  "Bilgetaam",
  "Bilgetamgac",
  "Bilgetardu",
  "Bilgetegin",
  "Bilgetonyukuk",
  "Bilgez",
  "Bilgi",
  "Bilgin",
  "Bilig",
  "Biligknglsengn",
  "Bilik",
  "Binbei",
  "Bindir",
  "Boa",
  "Boa",
  "Boauk",
  "Boldaz",
  "Bolmu",
  "Bolsun",
  "Bolun",
  "Boncuk",
  "Bongul",
  "Bongulboa",
  "Bora",
  "Boran",
  "Borul",
  "Borluku",
  "Bornak",
  "Boyan",
  "Boyankulu",
  "Boylabaa",
  "Boylabaatarkan",
  "Boylakutlutarkan",
  "Bozan",
  "Bozbr",
  "Bozdoan",
  "Bozkurt",
  "Bozku",
  "Bozok",
  "Bgde",
  "Bge",
  "Bg",
  "Bkde",
  "Bkde",
  "Bke",
  "Blen",
  "Blkba",
  "Bnek",
  "Bnge",
  "Br",
  "Brbars",
  "Brsengn",
  "Brteine",
  "Buan",
  "Buur",
  "Buda",
  "Budak",
  "Budunlu",
  "Buday",
  "Bura",
  "Burakarakaan",
  "Bukak",
  "Bukaktutuk",
  "Bulaapan",
  "Bulak",
  "Bulan",
  "Buldur",
  "Bulgak",
  "Bulmaz",
  "Bulmu",
  "Bulu",
  "Bulu",
  "Buluk",
  "Bulu",
  "Bulut",
  "Bumn",
  "Bunsuz",
  "Burak",
  "Burguan",
  "Burkay",
  "Burslan",
  "Burulday",
  "Burulgu",
  "Burunduk",
  "Buulgan",
  "Butak",
  "Butuk",
  "Buyan",
  "Buyanuk",
  "Buyandemir",
  "Buyankara",
  "Buyat",
  "Buyra",
  "Buyru",
  "Buyruk",
  "Buza",
  "Buzatutuk",
  "Bds",
  "Bdstudun",
  "Bg",
  "Bgdz",
  "Bgdzemen",
  "Bge",
  "Bbilge",
  "Bkdz",
  "Bke",
  "Bkebuyra",
  "Bkebuyru",
  "Bkey",
  "Bktegin",
  "Bkboa",
  "Bmen",
  "Bnl",
  "Bre",
  "Brgt",
  "Brkek",
  "Brkt",
  "Brlk",
  "Cebe",
  "Ceyhun",
  "Clasun",
  "aba",
  "abdar",
  "abl",
  "abu",
  "aan",
  "aatay",
  "alar",
  "alayan",
  "ar",
  "arbe",
  "artegin",
  "aru",
  "alapkulu",
  "ankz",
  "emen",
  "emgen",
  "eykn",
  "ngr",
  "iek",
  "iem",
  "idem",
  "ilenti",
  "imen",
  "obulmak",
  "ocukbr",
  "okramayul",
  "olman",
  "olpan",
  "l",
  "Damla",
  "Deniz",
  "Dilek",
  "Diri",
  "Dizik",
  "Duru",
  "Dururbunsuz",
  "Duygu",
  "Ebin",
  "Ebkz",
  "Ebren",
  "Edil",
  "Ediz",
  "Egemen",
  "Erim",
  "Eke",
  "Ekim",
  "Ekin",
  "Elkin",
  "Elti",
  "Engin",
  "Erdem",
  "Erdeni",
  "Erdenizk",
  "Erdenikatun",
  "Erentz",
  "Ergene",
  "Ergenekatun",
  "Erin",
  "Erke",
  "Ermen",
  "Erten",
  "Ertenzk",
  "Esen",
  "Esenbike",
  "Eser",
  "Esin",
  "Etil",
  "Evin",
  "Eyiz",
  "Gelin",
  "Gelincik",
  "Gkbr",
  "Gke",
  "Gkegl",
  "Gken",
  "Gkiek",
  "Gkin",
  "Gnl",
  "Grn",
  "Gzde",
  "Glegen",
  "Glemen",
  "Gler",
  "Glmser",
  "Gm",
  "Gn",
  "Gnay",
  "Gniek",
  "Gndodu",
  "Gndomu",
  "Gne",
  "Gnyaruk",
  "Grbz",
  "Gvercin",
  "Gzey",
  "I",
  "Ik",
  "Il",
  "Ilay",
  "Ila",
  "Ilan",
  "Ilgn",
  "Inan",
  "Irmak",
  "Is",
  "Isk",
  "Iyk",
  "Iykta",
  "dil",
  "keme",
  "kiitoyun",
  "lbilge",
  "ldike",
  "lgeg",
  "mrem",
  "nci",
  "n",
  "rin",
  "rinkl",
  "rti",
  "til",
  "Kanc",
  "Kan",
  "Kapgar",
  "Karaca",
  "Karaa",
  "Karak",
  "Kargla",
  "Karlga",
  "Katun",
  "Katunkz",
  "Kayack",
  "Kayak",
  "Kaya",
  "Kaynak",
  "Kazan",
  "Kazkatun",
  "Kekik",
  "Keklik",
  "Kepez",
  "Kesme",
  "Keyken",
  "Kezlik",
  "Kmz",
  "Kmzn",
  "Kmzalma",
  "Kmzalmla",
  "Kriek",
  "Krgavul",
  "Krlang",
  "Kvan",
  "Kvlcm",
  "Kzdurmu",
  "Kzlalma"
];

},{}],1198:[function(require,module,exports){
arguments[4][432][0].apply(exports,arguments)
},{"./first_name":1197,"./last_name":1199,"./name":1200,"./prefix":1201,"dup":432}],1199:[function(require,module,exports){
module["exports"] = [
  "Abac",
  "Abadan",
  "Aclan",
  "Adal",
  "Adan",
  "Advar",
  "Akal",
  "Akan",
  "Akar ",
  "Akay",
  "Akaydn",
  "Akbulut",
  "Akgl",
  "Akk",
  "Akman",
  "Akyrek",
  "Akyz",
  "Akit",
  "Alnak",
  "Alpuan",
  "Alyanak",
  "Arcan",
  "Arslanolu",
  "Atakol",
  "Atan",
  "Avan",
  "Ayaydn",
  "Aybar",
  "Aydan",
  "Ayka",
  "Ayverdi",
  "Aaolu",
  "Akolu",
  "Babacan",
  "Babaolu",
  "Bademci",
  "Bakrcolu",
  "Balaban",
  "Balc",
  "Barbarosolu",
  "Baturalp",
  "Baykam",
  "Baolu",
  "Berberolu",
  "Beerler",
  "Beok",
  "Bier",
  "Bolatl",
  "Dalkran",
  "Dada",
  "Dalarolu",
  "Demirba",
  "Demirel",
  "Denkel",
  "Dizdar ",
  "Doan ",
  "Durak ",
  "Durmaz",
  "Duygulu",
  "Denkalkar",
  "Egeli",
  "Ekici",
  "Ekiolu",
  "Eliin",
  "Elmastaolu",
  "Eliboa",
  "Erbay",
  "Erberk",
  "Erbulak",
  "Erdoan",
  "Erez",
  "Erginsoy",
  "Erkekli",
  "Eronat",
  "Ertepnar",
  "Ertrk",
  "Eretin",
  "Evliyaolu",
  "Gnlta",
  "Gmpala",
  "Gnday",
  "Grmen",
  "Hakyemez",
  "Hamzaolu",
  "Ilcal",
  "Kahveci",
  "Kaplang",
  "Karabulut",
  "Karabcek",
  "Karada",
  "Karaduman",
  "Karaer",
  "Kasapolu",
  "Kavaklolu",
  "Kaya ",
  "Keserolu",
  "Keeci",
  "Kl",
  "Kra ",
  "Kocabyk",
  "Korol",
  "Koyuncu",
  "Ko",
  "Koolu",
  "Koyiit",
  "Kuday",
  "Kulakszolu",
  "Kumcuolu",
  "Kunt",
  "Kunter",
  "Kurutluolu",
  "Kutlay",
  "Kuzucu",
  "Krmk",
  "Kyba",
  "Kylolu",
  "Kkler",
  "Limoncuolu",
  "Mayho",
  "Menemenciolu",
  "Mertolu",
  "Nalbantolu",
  "Nebiolu",
  "Numanolu",
  "Okumu",
  "Okur",
  "Oralolu",
  "Orbay",
  "Ozansoy",
  "Pakst",
  "Pekkan",
  "Pektemek",
  "Polat",
  "Poyrazolu",
  "Poan",
  "Sadklar",
  "Samanc",
  "Sandalc",
  "Sarolu",
  "Saygner",
  "Sepeti",
  "Sezek",
  "Sinanolu",
  "Solmaz",
  "Szeri",
  "Sleymanolu",
  "Tahinciolu",
  "Tanrkulu",
  "Tazegl",
  "Tal",
  "Ta",
  "Tekand",
  "Tekeliolu",
  "Tokatlolu",
  "Tokgz",
  "Topalolu",
  "Topuolu",
  "Toraman",
  "Tunaboylu",
  "Tuneri",
  "Tulu",
  "Tuluk",
  "Trkdoan",
  "Trkylmaz",
  "Ttnc",
  "Tzn",
  "Uca",
  "Uluhan",
  "Veliolu",
  "Yaln",
  "Yazc",
  "Yetkiner",
  "Yeilkaya",
  "Yldrm ",
  "Yldzolu",
  "Ylmazer",
  "Yorulmaz",
  "amdal",
  "apanolu",
  "atalba",
  "aran",
  "etin",
  "etiner",
  "evik",
  "reki",
  "nr",
  "rge",
  "ymen",
  "zberk",
  "zbey",
  "zbir",
  "zdenak",
  "zdoan",
  "zgrkey",
  "zkara",
  "zkk ",
  "ztonga",
  "ztuna"
];

},{}],1200:[function(require,module,exports){
arguments[4][797][0].apply(exports,arguments)
},{"dup":797}],1201:[function(require,module,exports){
module["exports"] = [
  "Bay",
  "Bayan",
  "Dr.",
  "Prof. Dr."
];

},{}],1202:[function(require,module,exports){
module["exports"] = [
  "392",
  "510",
  "512",
  "522",
  "562",
  "564",
  "592",
  "594",
  "800",
  "811",
  "822",
  "850",
  "888",
  "898",
  "900",
  "322",
  "416",
  "272",
  "472",
  "382",
  "358",
  "312",
  "242",
  "478",
  "466",
  "256",
  "266",
  "378",
  "488",
  "458",
  "228",
  "426",
  "434",
  "374",
  "248",
  "224",
  "286",
  "376",
  "364",
  "258",
  "412",
  "380",
  "284",
  "424",
  "446",
  "442",
  "222",
  "342",
  "454",
  "456",
  "438",
  "326",
  "476",
  "246",
  "216",
  "212",
  "232",
  "344",
  "370",
  "338",
  "474",
  "366",
  "352",
  "318",
  "288",
  "386",
  "348",
  "262",
  "332",
  "274",
  "422",
  "236",
  "482",
  "324",
  "252",
  "436",
  "384",
  "388",
  "452",
  "328",
  "464",
  "264",
  "362",
  "484",
  "368",
  "346",
  "414",
  "486",
  "282",
  "356",
  "462",
  "428",
  "276",
  "432",
  "226",
  "354",
  "372"
];

},{}],1203:[function(require,module,exports){
module["exports"] = [
  "+90-###-###-##-##",
  "+90-###-###-#-###"
];

},{}],1204:[function(require,module,exports){
var phone_number = {};
module['exports'] = phone_number;
phone_number.area_code = require("./area_code");
phone_number.formats = require("./formats");

},{"./area_code":1202,"./formats":1203}],1205:[function(require,module,exports){
arguments[4][313][0].apply(exports,arguments)
},{"dup":313}],1206:[function(require,module,exports){
module["exports"] = [
  "#{city_name}",
  "#{city_prefix} #{Name.male_first_name}"
];

},{}],1207:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "-",
  "",
  "-",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1208:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  ""
];

},{}],1209:[function(require,module,exports){
module["exports"] = [
  ""
];

},{}],1210:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "  ",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "  ",
  "",
  "",
  "",
  "-",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "-",
  "",
  "",
  "",
  "",
  "",
  "  ",
  "",
  "",
  " ",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "-",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "-",
  "-",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "  ",
  "",
  "",
  "",
  "",
  "- ",
  "",
  "",
  " ",
  " ",
  "- ",
  " ",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "-",
  "-  ",
  " ",
  "",
  " ",
  "",
  "-  ",
  "-  ",
  "-",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  " ",
  "",
  "-",
  "",
  "",
  "",
  "",
  "",
  "  ",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "  ",
  "",
  "",
  "",
  "",
  "",
  " ",
  "",
  "",
  "",
  "",
  "",
  "",
  "-",
  "",
  ""
];

},{}],1211:[function(require,module,exports){
module["exports"] = [
  ""
];

},{}],1212:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.country = require("./country");
address.building_number = require("./building_number");
address.street_prefix = require("./street_prefix");
address.street_suffix = require("./street_suffix");
address.secondary_address = require("./secondary_address");
address.postcode = require("./postcode");
address.state = require("./state");
address.street_title = require("./street_title");
address.city_name = require("./city_name");
address.city = require("./city");
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":1205,"./city":1206,"./city_name":1207,"./city_prefix":1208,"./city_suffix":1209,"./country":1210,"./default_country":1211,"./postcode":1213,"./secondary_address":1214,"./state":1215,"./street_address":1216,"./street_name":1217,"./street_prefix":1218,"./street_suffix":1219,"./street_title":1220}],1213:[function(require,module,exports){
arguments[4][638][0].apply(exports,arguments)
},{"dup":638}],1214:[function(require,module,exports){
arguments[4][1062][0].apply(exports,arguments)
},{"dup":1062}],1215:[function(require,module,exports){
module["exports"] = [
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  "- ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  " ",
  "",
  ""
];

},{}],1216:[function(require,module,exports){
arguments[4][284][0].apply(exports,arguments)
},{"dup":284}],1217:[function(require,module,exports){
module["exports"] = [
  "#{street_prefix} #{Address.street_title}",
  "#{Address.street_title} #{street_suffix}"
];

},{}],1218:[function(require,module,exports){
module["exports"] = [
  ".",
  "",
  ".",
  "",
  ".",
  "",
  ".",
  ""
];

},{}],1219:[function(require,module,exports){
module["exports"] = [
  ""
];

},{}],1220:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1221:[function(require,module,exports){
arguments[4][292][0].apply(exports,arguments)
},{"./name":1222,"./prefix":1223,"./suffix":1224,"dup":292}],1222:[function(require,module,exports){
arguments[4][293][0].apply(exports,arguments)
},{"dup":293}],1223:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1224:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  ""
];

},{}],1225:[function(require,module,exports){
var uk = {};
module['exports'] = uk;
uk.title = "Ukrainian";
uk.address = require("./address");
uk.company = require("./company");
uk.internet = require("./internet");
uk.name = require("./name");
uk.phone_number = require("./phone_number");

},{"./address":1212,"./company":1221,"./internet":1228,"./name":1232,"./phone_number":1241}],1226:[function(require,module,exports){
module["exports"] = [
  "cherkassy.ua",
  "cherkasy.ua",
  "ck.ua",
  "cn.ua",
  "com.ua",
  "crimea.ua",
  "cv.ua",
  "dn.ua",
  "dnepropetrovsk.ua",
  "dnipropetrovsk.ua",
  "donetsk.ua",
  "dp.ua",
  "if.ua",
  "in.ua",
  "ivano-frankivsk.ua",
  "kh.ua",
  "kharkiv.ua",
  "kharkov.ua",
  "kherson.ua",
  "khmelnitskiy.ua",
  "kiev.ua",
  "kirovograd.ua",
  "km.ua",
  "kr.ua",
  "ks.ua",
  "lg.ua",
  "lt.ua",
  "lugansk.ua",
  "lutsk.ua",
  "lutsk.net",
  "lviv.ua",
  "mk.ua",
  "net.ua",
  "nikolaev.ua",
  "od.ua",
  "odessa.ua",
  "org.ua",
  "pl.ua",
  "pl.ua",
  "poltava.ua",
  "rovno.ua",
  "rv.ua",
  "sebastopol.ua",
  "sm.ua",
  "sumy.ua",
  "te.ua",
  "ternopil.ua",
  "ua",
  "uz.ua",
  "uzhgorod.ua",
  "vinnica.ua",
  "vn.ua",
  "volyn.net",
  "volyn.ua",
  "yalta.ua",
  "zaporizhzhe.ua",
  "zhitomir.ua",
  "zp.ua",
  "zt.ua",
  ""
];

},{}],1227:[function(require,module,exports){
module["exports"] = [
  "ukr.net",
  "ex.ua",
  "e-mail.ua",
  "i.ua",
  "meta.ua",
  "yandex.ua",
  "gmail.com"
];

},{}],1228:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./domain_suffix":1226,"./free_email":1227,"dup":302}],1229:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1230:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1231:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1232:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.male_first_name = require("./male_first_name");
name.male_middle_name = require("./male_middle_name");
name.male_last_name = require("./male_last_name");
name.female_first_name = require("./female_first_name");
name.female_middle_name = require("./female_middle_name");
name.female_last_name = require("./female_last_name");
name.prefix = require("./prefix");
name.suffix = require("./suffix");
name.title = require("./title");
name.name = require("./name");

},{"./female_first_name":1229,"./female_last_name":1230,"./female_middle_name":1231,"./male_first_name":1233,"./male_last_name":1234,"./male_middle_name":1235,"./name":1236,"./prefix":1237,"./suffix":1238,"./title":1239}],1233:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1234:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1235:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1236:[function(require,module,exports){
arguments[4][1090][0].apply(exports,arguments)
},{"dup":1090}],1237:[function(require,module,exports){
module["exports"] = [
  "",
  ""
];

},{}],1238:[function(require,module,exports){
module["exports"] = [
  ".",
  ".",
  ". . ",
  ". . ",
  ". . ",
  ". . ",
  ". . ",
  ". . ",
  ". . ",
  ". . ",
  ". . ",
  ". . ",
  ". . ",
  ". . ",
  ". . ",
  ". . ",
  ". . ",
  ". . "
];

},{}],1239:[function(require,module,exports){
module["exports"] = {
  "descriptor": [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  "level": [
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  "job": [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};

},{}],1240:[function(require,module,exports){
module["exports"] = [
  "(044) ###-##-##",
  "(050) ###-##-##",
  "(063) ###-##-##",
  "(066) ###-##-##",
  "(073) ###-##-##",
  "(091) ###-##-##",
  "(092) ###-##-##",
  "(093) ###-##-##",
  "(094) ###-##-##",
  "(095) ###-##-##",
  "(096) ###-##-##",
  "(097) ###-##-##",
  "(098) ###-##-##",
  "(099) ###-##-##"
];

},{}],1241:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":1240,"dup":312}],1242:[function(require,module,exports){
module["exports"] = [
  "#{city_root}"
];

},{}],1243:[function(require,module,exports){
module["exports"] = [
  "Bc Giang",
  "Bc Kn",
  "Bc Ninh",
  "Cao Bng",
  "in Bin",
  "H Giang",
  "H Nam",
  "H Ty",
  "Hi Dng",
  "TP Hi Phng",
  "Ha Bnh",
  "Hng Yn",
  "Lai Chu",
  "Lo Cai",
  "Lng Sn",
  "Nam nh",
  "Ninh Bnh",
  "Ph Th",
  "Qung Ninh",
  "Sn La",
  "Thi Bnh",
  "Thi Nguyn",
  "Tuyn Quang",
  "Vnh Phc",
  "Yn Bi",
  "TP  Nng",
  "Bnh nh",
  "k Lk",
  "k Nng",
  "Gia Lai",
  "H Tnh",
  "Khnh Ha",
  "Kon Tum",
  "Ngh An",
  "Ph Yn",
  "Qung Bnh",
  "Qung Nam",
  "Qung Ngi",
  "Qung Tr",
  "Thanh Ha",
  "Tha Thin Hu",
  "TP TP. H Ch Minh",
  "An Giang",
  "B Ra Vng Tu",
  "Bc Liu",
  "Bn Tre",
  "Bnh Dng",
  "Bnh Phc",
  "Bnh Thun",
  "C Mau",
  "TP Cn Th",
  "ng Nai",
  "ng Thp",
  "Hu Giang",
  "Kin Giang",
  "Lm ng",
  "Long An",
  "Ninh Thun",
  "Sc Trng",
  "Ty Ninh",
  "Tin Giang",
  "Tr Vinh",
  "Vnh Long"
];

},{}],1244:[function(require,module,exports){
module["exports"] = [
  "Avon",
  "Bedfordshire",
  "Berkshire",
  "Borders",
  "Buckinghamshire",
  "Cambridgeshire",
  "Central",
  "Cheshire",
  "Cleveland",
  "Clwyd",
  "Cornwall",
  "County Antrim",
  "County Armagh",
  "County Down",
  "County Fermanagh",
  "County Londonderry",
  "County Tyrone",
  "Cumbria",
  "Derbyshire",
  "Devon",
  "Dorset",
  "Dumfries and Galloway",
  "Durham",
  "Dyfed",
  "East Sussex",
  "Essex",
  "Fife",
  "Gloucestershire",
  "Grampian",
  "Greater Manchester",
  "Gwent",
  "Gwynedd County",
  "Hampshire",
  "Herefordshire",
  "Hertfordshire",
  "Highlands and Islands",
  "Humberside",
  "Isle of Wight",
  "Kent",
  "Lancashire",
  "Leicestershire",
  "Lincolnshire",
  "Lothian",
  "Merseyside",
  "Mid Glamorgan",
  "Norfolk",
  "North Yorkshire",
  "Northamptonshire",
  "Northumberland",
  "Nottinghamshire",
  "Oxfordshire",
  "Powys",
  "Rutland",
  "Shropshire",
  "Somerset",
  "South Glamorgan",
  "South Yorkshire",
  "Staffordshire",
  "Strathclyde",
  "Suffolk",
  "Surrey",
  "Tayside",
  "Tyne and Wear",
  "Vit Nam",
  "Warwickshire",
  "West Glamorgan",
  "West Midlands",
  "West Sussex",
  "West Yorkshire",
  "Wiltshire",
  "Worcestershire"
];

},{}],1245:[function(require,module,exports){
module["exports"] = [
  "Vit Nam"
];

},{}],1246:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city_root = require("./city_root");
address.city = require("./city");
address.county = require("./county");
address.default_country = require("./default_country");

},{"./city":1242,"./city_root":1243,"./county":1244,"./default_country":1245}],1247:[function(require,module,exports){
arguments[4][567][0].apply(exports,arguments)
},{"dup":567}],1248:[function(require,module,exports){
arguments[4][371][0].apply(exports,arguments)
},{"./formats":1247,"dup":371}],1249:[function(require,module,exports){
var company = {};
module['exports'] = company;
company.prefix = require("./prefix");
company.name = require("./name");

},{"./name":1250,"./prefix":1251}],1250:[function(require,module,exports){
module["exports"] = [
  "#{prefix} #{Name.last_name}"
];

},{}],1251:[function(require,module,exports){
module["exports"] = [
  "Cng ty",
  "Cty TNHH",
  "Cty",
  "Ca hng",
  "Trung tm",
  "Chi nhnh"
];

},{}],1252:[function(require,module,exports){
var vi = {};
module['exports'] = vi;
vi.title = "Vietnamese";
vi.address = require("./address");
vi.internet = require("./internet");
vi.phone_number = require("./phone_number");
vi.cell_phone = require("./cell_phone");
vi.name = require("./name");
vi.company = require("./company");
vi.lorem = require("./lorem");

},{"./address":1246,"./cell_phone":1248,"./company":1249,"./internet":1254,"./lorem":1255,"./name":1258,"./phone_number":1262}],1253:[function(require,module,exports){
module["exports"] = [
  "com",
  "net",
  "info",
  "vn",
  "com.vn"
];

},{}],1254:[function(require,module,exports){
arguments[4][430][0].apply(exports,arguments)
},{"./domain_suffix":1253,"dup":430}],1255:[function(require,module,exports){
arguments[4][380][0].apply(exports,arguments)
},{"./words":1256,"dup":380}],1256:[function(require,module,exports){
module["exports"] = [
  "",
  "ang",
  "",
  "",
  "",
  "khng",
  "bit",
  "g",
  "ht",
  "u",
  "nha",
  "th",
  "th",
  "l",
  "nh",
  "",
  "p",
  "ph",
  "vit",
  "v",
  "t",
  "thu",
  "mn",
  "mn",
  "mua",
  "mt",
  "hai",
  "ba",
  "bn",
  "nm",
  "su",
  "by",
  "tm",
  "chn",
  "mi",
  "thi",
  "vic",
  "ngh",
  "lm",
  "nh",
  "ca",
  "xe",
  "p",
  "c",
  "c",
  "khong",
  "khoan",
  "thuyn",
  "tu",
  "b",
  "lu",
  "xanh",
  "",
  "tm",
  "vng",
  "kim",
  "ch",
  "khu",
  "may",
  "v",
  "em",
  "anh",
  "yu",
  "thng",
  "thch",
  "con",
  "ci",
  "bn",
  "gh",
  "t",
  "qun",
  "o",
  "nn",
  "dp",
  "giy",
  "li",
  "c",
  "ght",
  "git",
  "cht",
  "ht",
  "ti",
  "bn",
  "tui",
  "tri",
  "trng",
  "my",
  "gi",
  "my",
  "hng",
  "ha",
  "leo",
  "ni",
  "bi",
  "bin",
  "chm",
  "xung",
  "nc",
  "ngt",
  "rung",
  "ng",
  "qu",
  "hng"
];

},{}],1257:[function(require,module,exports){
module["exports"] = [
  "Phm",
  "Nguyn",
  "Trn",
  "L",
  "L",
  "Hong",
  "Phan",
  "V",
  "Tng",
  "ng",
  "Bi",
  "",
  "H",
  "Ng",
  "Dng",
  "o",
  "on",
  "Vng",
  "Trnh",
  "inh",
  "Lm",
  "Phng",
  "Mai",
  "T",
  "Trng",
  "H"
];

},{}],1258:[function(require,module,exports){
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.last_name = require("./last_name");
name.name = require("./name");

},{"./first_name":1257,"./last_name":1259,"./name":1260}],1259:[function(require,module,exports){
module["exports"] = [
  "Nam",
  "Trung",
  "Thanh",
  "Th",
  "Vn",
  "Dng",
  "Tng",
  "Quc",
  "Nh",
  "Phm",
  "Nguyn",
  "Trn",
  "L",
  "L",
  "Hong",
  "Phan",
  "V",
  "Tng",
  "ng",
  "Bi",
  "",
  "H",
  "Ng",
  "Dng",
  "o",
  "on",
  "Vng",
  "Trnh",
  "inh",
  "Lm",
  "Phng",
  "Mai",
  "T",
  "Trng",
  "H",
  "Vinh",
  "Nhung",
  "Ha",
  "Tin",
  "Tm",
  "Bu",
  "Loan",
  "Hin",
  "Hi",
  "Vn",
  "Kha",
  "Minh",
  "Nhn",
  "Triu",
  "Tun",
  "Hu",
  "c",
  "Ph",
  "Khoa",
  "Thgn",
  "Sn",
  "Dung",
  "T",
  "Trinh",
  "Tho",
  "Sa",
  "Kim",
  "Long",
  "Thi",
  "Cng",
  "Ngc",
  "Sinh",
  "Khang",
  "Phong",
  "Thm",
  "Thu",
  "Thy",
  "Nhn"
];

},{}],1260:[function(require,module,exports){
module["exports"] = [
  "#{first_name} #{last_name}",
  "#{first_name} #{last_name} #{last_name}",
  "#{first_name} #{last_name} #{last_name} #{last_name}"
];

},{}],1261:[function(require,module,exports){
arguments[4][572][0].apply(exports,arguments)
},{"dup":572}],1262:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":1261,"dup":312}],1263:[function(require,module,exports){
module["exports"] = [
  "#####",
  "####",
  "###",
  "##",
  "#"
];

},{}],1264:[function(require,module,exports){
arguments[4][1138][0].apply(exports,arguments)
},{"dup":1138}],1265:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1266:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1267:[function(require,module,exports){
module["exports"] = [
  ""
];

},{}],1268:[function(require,module,exports){
var address = {};
module['exports'] = address;
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.building_number = require("./building_number");
address.street_suffix = require("./street_suffix");
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.city = require("./city");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");

},{"./building_number":1263,"./city":1264,"./city_prefix":1265,"./city_suffix":1266,"./default_country":1267,"./postcode":1269,"./state":1270,"./state_abbr":1271,"./street_address":1272,"./street_name":1273,"./street_suffix":1274}],1269:[function(require,module,exports){
arguments[4][1061][0].apply(exports,arguments)
},{"dup":1061}],1270:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1271:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1272:[function(require,module,exports){
module["exports"] = [
  "#{street_name}#{building_number}"
];

},{}],1273:[function(require,module,exports){
module["exports"] = [
  "#{Name.last_name}#{street_suffix}"
];

},{}],1274:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1275:[function(require,module,exports){
var zh_CN = {};
module['exports'] = zh_CN;
zh_CN.title = "Chinese";
zh_CN.address = require("./address");
zh_CN.name = require("./name");
zh_CN.phone_number = require("./phone_number");

},{"./address":1268,"./name":1277,"./phone_number":1281}],1276:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1277:[function(require,module,exports){
arguments[4][1258][0].apply(exports,arguments)
},{"./first_name":1276,"./last_name":1278,"./name":1279,"dup":1258}],1278:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1279:[function(require,module,exports){
module["exports"] = [
  "#{first_name}#{last_name}"
];

},{}],1280:[function(require,module,exports){
module["exports"] = [
  "###-########",
  "####-########",
  "###########"
];

},{}],1281:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":1280,"dup":312}],1282:[function(require,module,exports){
arguments[4][723][0].apply(exports,arguments)
},{"dup":723}],1283:[function(require,module,exports){
arguments[4][1138][0].apply(exports,arguments)
},{"dup":1138}],1284:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1285:[function(require,module,exports){
module["exports"] = [
  "",
  ""
];

},{}],1286:[function(require,module,exports){
module["exports"] = [
  "Taiwan (R.O.C.)"
];

},{}],1287:[function(require,module,exports){
arguments[4][1268][0].apply(exports,arguments)
},{"./building_number":1282,"./city":1283,"./city_prefix":1284,"./city_suffix":1285,"./default_country":1286,"./postcode":1288,"./state":1289,"./state_abbr":1290,"./street_address":1291,"./street_name":1292,"./street_suffix":1293,"dup":1268}],1288:[function(require,module,exports){
arguments[4][1061][0].apply(exports,arguments)
},{"dup":1061}],1289:[function(require,module,exports){
module["exports"] = [
  "",
  ""
];

},{}],1290:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1291:[function(require,module,exports){
module["exports"] = [
  "#{street_name}#{building_number}"
];

},{}],1292:[function(require,module,exports){
arguments[4][1273][0].apply(exports,arguments)
},{"dup":1273}],1293:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1294:[function(require,module,exports){
var zh_TW = {};
module['exports'] = zh_TW;
zh_TW.title = "Chinese (Taiwan)";
zh_TW.address = require("./address");
zh_TW.name = require("./name");
zh_TW.phone_number = require("./phone_number");

},{"./address":1287,"./name":1296,"./phone_number":1300}],1295:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1296:[function(require,module,exports){
arguments[4][1258][0].apply(exports,arguments)
},{"./first_name":1295,"./last_name":1297,"./name":1298,"dup":1258}],1297:[function(require,module,exports){
module["exports"] = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];

},{}],1298:[function(require,module,exports){
arguments[4][1279][0].apply(exports,arguments)
},{"dup":1279}],1299:[function(require,module,exports){
module["exports"] = [
  "0#-#######",
  "02-########",
  "09##-######"
];

},{}],1300:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"./formats":1299,"dup":312}],1301:[function(require,module,exports){

/**
 *
 * @namespace faker.lorem
 */
var Lorem = function (faker) {
  var self = this;
  var Helpers = faker.helpers;

  /**
   * word
   *
   * @method faker.lorem.word
   * @param {number} num
   */
  self.word = function (num) {
    return faker.random.arrayElement(faker.definitions.lorem.words);
  };

  /**
   * generates a space separated list of words
   *
   * @method faker.lorem.words
   * @param {number} num number of words, defaults to 3
   */
  self.words = function (num) {
      if (typeof num == 'undefined') { num = 3; }
      var words = [];
      for (var i = 0; i < num; i++) {
        words.push(faker.lorem.word());
      }
      return words.join(' ');
  };

  /**
   * sentence
   *
   * @method faker.lorem.sentence
   * @param {number} wordCount defaults to a random number between 3 and 10
   * @param {number} range
   */
  self.sentence = function (wordCount, range) {
      if (typeof wordCount == 'undefined') { wordCount = faker.random.number({ min: 3, max: 10 }); }
      // if (typeof range == 'undefined') { range = 7; }

      // strange issue with the node_min_test failing for captialize, please fix and add faker.lorem.back
      //return  faker.lorem.words(wordCount + Helpers.randomNumber(range)).join(' ').capitalize();

      var sentence = faker.lorem.words(wordCount);
      return sentence.charAt(0).toUpperCase() + sentence.slice(1) + '.';
  };

  /**
   * slug
   *
   * @method faker.lorem.slug
   * @param {number} wordCount number of words, defaults to 3
   */
  self.slug = function (wordCount) {
      var words = faker.lorem.words(wordCount);
      return Helpers.slugify(words);
  };

  /**
   * sentences
   *
   * @method faker.lorem.sentences
   * @param {number} sentenceCount defautls to a random number between 2 and 6
   * @param {string} separator defaults to `' '`
   */
  self.sentences = function (sentenceCount, separator) {
      if (typeof sentenceCount === 'undefined') { sentenceCount = faker.random.number({ min: 2, max: 6 });}
      if (typeof separator == 'undefined') { separator = " "; }
      var sentences = [];
      for (sentenceCount; sentenceCount > 0; sentenceCount--) {
        sentences.push(faker.lorem.sentence());
      }
      return sentences.join(separator);
  };

  /**
   * paragraph
   *
   * @method faker.lorem.paragraph
   * @param {number} sentenceCount defaults to 3
   */
  self.paragraph = function (sentenceCount) {
      if (typeof sentenceCount == 'undefined') { sentenceCount = 3; }
      return faker.lorem.sentences(sentenceCount + faker.random.number(3));
  };

  /**
   * paragraphs
   *
   * @method faker.lorem.paragraphs
   * @param {number} paragraphCount defaults to 3
   * @param {string} separator defaults to `'\n \r'`
   */
  self.paragraphs = function (paragraphCount, separator) {
    if (typeof separator === "undefined") {
      separator = "\n \r";
    }
    if (typeof paragraphCount == 'undefined') { paragraphCount = 3; }
    var paragraphs = [];
    for (paragraphCount; paragraphCount > 0; paragraphCount--) {
        paragraphs.push(faker.lorem.paragraph());
    }
    return paragraphs.join(separator);
  }

  /**
   * returns random text based on a random lorem method
   *
   * @method faker.lorem.text
   * @param {number} times
   */
  self.text = function loremText (times) {
    var loremMethods = ['lorem.word', 'lorem.words', 'lorem.sentence', 'lorem.sentences', 'lorem.paragraph', 'lorem.paragraphs', 'lorem.lines'];
    var randomLoremMethod = faker.random.arrayElement(loremMethods);
    return faker.fake('{{' + randomLoremMethod + '}}');
  };

  /**
   * returns lines of lorem separated by `'\n'`
   *
   * @method faker.lorem.lines
   * @param {number} lineCount defaults to a random number between 1 and 5
   */
  self.lines = function lines (lineCount) {
    if (typeof lineCount === 'undefined') { lineCount = faker.random.number({ min: 1, max: 5 });}
    return faker.lorem.sentences(lineCount, '\n')
  };

  return self;
};


module["exports"] = Lorem;

},{}],1302:[function(require,module,exports){
/**
 *
 * @namespace faker.name
 */
function Name (faker) {

  /**
   * firstName
   *
   * @method firstName
   * @param {mixed} gender
   * @memberof faker.name
   */
  this.firstName = function (gender) {
    if (typeof faker.definitions.name.male_first_name !== "undefined" && typeof faker.definitions.name.female_first_name !== "undefined") {
      // some locale datasets ( like ru ) have first_name split by gender. since the name.first_name field does not exist in these datasets,
      // we must randomly pick a name from either gender array so faker.name.firstName will return the correct locale data ( and not fallback )
      if (typeof gender !== 'number') {
        gender = faker.random.number(1);
      }
      if (gender === 0) {
        return faker.random.arrayElement(faker.locales[faker.locale].name.male_first_name)
      } else {
        return faker.random.arrayElement(faker.locales[faker.locale].name.female_first_name);
      }
    }
    return faker.random.arrayElement(faker.definitions.name.first_name);
  };

  /**
   * lastName
   *
   * @method lastName
   * @param {mixed} gender
   * @memberof faker.name
   */
  this.lastName = function (gender) {
    if (typeof faker.definitions.name.male_last_name !== "undefined" && typeof faker.definitions.name.female_last_name !== "undefined") {
      // some locale datasets ( like ru ) have last_name split by gender. i have no idea how last names can have genders, but also i do not speak russian
      // see above comment of firstName method
      if (typeof gender !== 'number') {
        gender = faker.random.number(1);
      }
      if (gender === 0) {
        return faker.random.arrayElement(faker.locales[faker.locale].name.male_last_name);
      } else {
        return faker.random.arrayElement(faker.locales[faker.locale].name.female_last_name);
      }
    }
    return faker.random.arrayElement(faker.definitions.name.last_name);
  };

  /**
   * findName
   *
   * @method findName
   * @param {string} firstName
   * @param {string} lastName
   * @param {mixed} gender
   * @memberof faker.name
   */
  this.findName = function (firstName, lastName, gender) {
      var r = faker.random.number(8);
      var prefix, suffix;
      // in particular locales first and last names split by gender,
      // thus we keep consistency by passing 0 as male and 1 as female
      if (typeof gender !== 'number') {
        gender = faker.random.number(1);
      }
      firstName = firstName || faker.name.firstName(gender);
      lastName = lastName || faker.name.lastName(gender);
      switch (r) {
      case 0:
          prefix = faker.name.prefix(gender);
          if (prefix) {
              return prefix + " " + firstName + " " + lastName;
          }
      case 1:
          suffix = faker.name.suffix(gender);
          if (suffix) {
              return firstName + " " + lastName + " " + suffix;
          }
      }

      return firstName + " " + lastName;
  };

  /**
   * jobTitle
   *
   * @method jobTitle
   * @memberof faker.name
   */
  this.jobTitle = function () {
    return  faker.name.jobDescriptor() + " " +
      faker.name.jobArea() + " " +
      faker.name.jobType();
  };
  
  /**
   * prefix
   *
   * @method prefix
   * @param {mixed} gender
   * @memberof faker.name
   */
  this.prefix = function (gender) {
    if (typeof faker.definitions.name.male_prefix !== "undefined" && typeof faker.definitions.name.female_prefix !== "undefined") {
      if (typeof gender !== 'number') {
        gender = faker.random.number(1);
      }
      if (gender === 0) {
        return faker.random.arrayElement(faker.locales[faker.locale].name.male_prefix);
      } else {
        return faker.random.arrayElement(faker.locales[faker.locale].name.female_prefix);
      }
    }
    return faker.random.arrayElement(faker.definitions.name.prefix);
  };

  /**
   * suffix
   *
   * @method suffix
   * @memberof faker.name
   */
  this.suffix = function () {
      return faker.random.arrayElement(faker.definitions.name.suffix);
  };

  /**
   * title
   *
   * @method title
   * @memberof faker.name
   */
  this.title = function() {
      var descriptor  = faker.random.arrayElement(faker.definitions.name.title.descriptor),
          level       = faker.random.arrayElement(faker.definitions.name.title.level),
          job         = faker.random.arrayElement(faker.definitions.name.title.job);

      return descriptor + " " + level + " " + job;
  };

  /**
   * jobDescriptor
   *
   * @method jobDescriptor
   * @memberof faker.name
   */
  this.jobDescriptor = function () {
    return faker.random.arrayElement(faker.definitions.name.title.descriptor);
  };

  /**
   * jobArea
   *
   * @method jobArea
   * @memberof faker.name
   */
  this.jobArea = function () {
    return faker.random.arrayElement(faker.definitions.name.title.level);
  };

  /**
   * jobType
   *
   * @method jobType
   * @memberof faker.name
   */
  this.jobType = function () {
    return faker.random.arrayElement(faker.definitions.name.title.job);
  };

}

module['exports'] = Name;

},{}],1303:[function(require,module,exports){
/**
 *
 * @namespace faker.phone
 */
var Phone = function (faker) {
  var self = this;

  /**
   * phoneNumber
   *
   * @method faker.phone.phoneNumber
   * @param {string} format
   */
  self.phoneNumber = function (format) {
      format = format || faker.phone.phoneFormats();
      return faker.helpers.replaceSymbolWithNumber(format);
  };

  // FIXME: this is strange passing in an array index.
  /**
   * phoneNumberFormat
   *
   * @method faker.phone.phoneFormatsArrayIndex
   * @param phoneFormatsArrayIndex
   */
  self.phoneNumberFormat = function (phoneFormatsArrayIndex) {
      phoneFormatsArrayIndex = phoneFormatsArrayIndex || 0;
      return faker.helpers.replaceSymbolWithNumber(faker.definitions.phone_number.formats[phoneFormatsArrayIndex]);
  };

  /**
   * phoneFormats
   *
   * @method faker.phone.phoneFormats
   */
  self.phoneFormats = function () {
    return faker.random.arrayElement(faker.definitions.phone_number.formats);
  };
  
  return self;

};

module['exports'] = Phone;
},{}],1304:[function(require,module,exports){
var mersenne = require('../vendor/mersenne');

/**
 *
 * @namespace faker.random
 */
function Random (faker, seed) {
  // Use a user provided seed if it exists
  if (seed) {
    if (Array.isArray(seed) && seed.length) {
      mersenne.seed_array(seed);
    }
    else {
      mersenne.seed(seed);
    }
  }
  /**
   * returns a single random number based on a max number or range
   *
   * @method faker.random.number
   * @param {mixed} options
   */
  this.number = function (options) {

    if (typeof options === "number") {
      options = {
        max: options
      };
    }

    options = options || {};

    if (typeof options.min === "undefined") {
      options.min = 0;
    }

    if (typeof options.max === "undefined") {
      options.max = 99999;
    }
    if (typeof options.precision === "undefined") {
      options.precision = 1;
    }

    // Make the range inclusive of the max value
    var max = options.max;
    if (max >= 0) {
      max += options.precision;
    }

    var randomNumber = options.precision * Math.floor(
      mersenne.rand(max / options.precision, options.min / options.precision));

    return randomNumber;

  }

  /**
   * takes an array and returns a random element of the array
   *
   * @method faker.random.arrayElement
   * @param {array} array
   */
  this.arrayElement = function (array) {
      array = array || ["a", "b", "c"];
      var r = faker.random.number({ max: array.length - 1 });
      return array[r];
  }

  /**
   * takes an object and returns the randomly key or value
   *
   * @method faker.random.objectElement
   * @param {object} object
   * @param {mixed} field
   */
  this.objectElement = function (object, field) {
      object = object || { "foo": "bar", "too": "car" };
      var array = Object.keys(object);
      var key = faker.random.arrayElement(array);

      return field === "key" ? key : object[key];
  }

  /**
   * uuid
   *
   * @method faker.random.uuid
   */
  this.uuid = function () {
      var self = this;
      var RFC4122_TEMPLATE = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
      var replacePlaceholders = function (placeholder) {
          var random = self.number({ min: 0, max: 15 });
          var value = placeholder == 'x' ? random : (random &0x3 | 0x8);
          return value.toString(16);
      };
      return RFC4122_TEMPLATE.replace(/[xy]/g, replacePlaceholders);
  }

  /**
   * boolean
   *
   * @method faker.random.boolean
   */
  this.boolean = function () {
      return !!faker.random.number(1)
  }

  // TODO: have ability to return specific type of word? As in: noun, adjective, verb, etc
  /**
   * word
   *
   * @method faker.random.word
   * @param {string} type
   */
  this.word = function randomWord (type) {

    var wordMethods = [
    'commerce.department',
    'commerce.productName',
    'commerce.productAdjective',
    'commerce.productMaterial',
    'commerce.product',
    'commerce.color',

    'company.catchPhraseAdjective',
    'company.catchPhraseDescriptor',
    'company.catchPhraseNoun',
    'company.bsAdjective',
    'company.bsBuzz',
    'company.bsNoun',
    'address.streetSuffix',
    'address.county',
    'address.country',
    'address.state',

    'finance.accountName',
    'finance.transactionType',
    'finance.currencyName',

    'hacker.noun',
    'hacker.verb',
    'hacker.adjective',
    'hacker.ingverb',
    'hacker.abbreviation',

    'name.jobDescriptor',
    'name.jobArea',
    'name.jobType'];

    // randomly pick from the many faker methods that can generate words
    var randomWordMethod = faker.random.arrayElement(wordMethods);
    return faker.fake('{{' + randomWordMethod + '}}');

  }

  /**
   * randomWords
   *
   * @method faker.random.words
   * @param {number} count defaults to a random value between 1 and 3
   */
  this.words = function randomWords (count) {
    var words = [];
    if (typeof count === "undefined") {
      count = faker.random.number({min:1, max: 3});
    }
    for (var i = 0; i<count; i++) {
      words.push(faker.random.word());
    }
    return words.join(' ');
  }

  /**
   * locale
   *
   * @method faker.random.image
   */
  this.image = function randomImage () {
    return faker.image.image();
  }

  /**
   * locale
   *
   * @method faker.random.locale
   */
  this.locale = function randomLocale () {
    return faker.random.arrayElement(Object.keys(faker.locales));
  };

  /**
   * alphaNumeric
   *
   * @method faker.random.alphaNumeric
   * @param {number} count defaults to 1
   */
  this.alphaNumeric = function alphaNumeric(count) {
    if (typeof count === "undefined") {
      count = 1;
    }

    var wholeString = "";
    for(var i = 0; i < count; i++) {
      wholeString += faker.random.arrayElement(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]);
    }

    return wholeString;
  };

  return this;

}

module['exports'] = Random;

},{"../vendor/mersenne":1306}],1305:[function(require,module,exports){
// generates fake data for many computer systems properties

/**
 *
 * @namespace faker.system
 */
function System (faker) {

  /**
   * generates a file name with extension or optional type
   *
   * @method faker.system.fileName
   * @param {string} ext
   * @param {string} type
   */
  this.fileName = function (ext, type) {
    var str = faker.fake("{{random.words}}.{{system.fileExt}}");
    str = str.replace(/ /g, '_');
    str = str.replace(/\,/g, '_');
    str = str.replace(/\-/g, '_');
    str = str.replace(/\\/g, '_');
    str = str.replace(/\//g, '_');
    str = str.toLowerCase();
    return str;
  };

  /**
   * commonFileName
   *
   * @method faker.system.commonFileName
   * @param {string} ext
   * @param {string} type
   */
  this.commonFileName = function (ext, type) {
    var str = faker.random.words() + "." + (ext || faker.system.commonFileExt());
    str = str.replace(/ /g, '_');
    str = str.replace(/\,/g, '_');
    str = str.replace(/\-/g, '_');
    str = str.replace(/\\/g, '_');
    str = str.replace(/\//g, '_');
    str = str.toLowerCase();
    return str;
  };

  /**
   * mimeType
   *
   * @method faker.system.mimeType
   */
  this.mimeType = function () {
    return faker.random.arrayElement(Object.keys(faker.definitions.system.mimeTypes));
  };

  /**
   * returns a commonly used file type
   *
   * @method faker.system.commonFileType
   */
  this.commonFileType = function () {
    var types = ['video', 'audio', 'image', 'text', 'application'];
    return faker.random.arrayElement(types)
  };

  /**
   * returns a commonly used file extension based on optional type
   *
   * @method faker.system.commonFileExt
   * @param {string} type
   */
  this.commonFileExt = function (type) {
    var types = [
      'application/pdf',
      'audio/mpeg',
      'audio/wav',
      'image/png',
      'image/jpeg',
      'image/gif',
      'video/mp4',
      'video/mpeg',
      'text/html'
    ];
    return faker.system.fileExt(faker.random.arrayElement(types));
  };


  /**
   * returns any file type available as mime-type
   *
   * @method faker.system.fileType
   */
  this.fileType = function () {
    var types = [];
    var mimes = faker.definitions.system.mimeTypes;
    Object.keys(mimes).forEach(function(m){
      var parts = m.split('/');
      if (types.indexOf(parts[0]) === -1) {
        types.push(parts[0]);
      }
    });
    return faker.random.arrayElement(types);
  };

  /**
   * fileExt
   *
   * @method faker.system.fileExt
   * @param {string} mimeType
   */
  this.fileExt = function (mimeType) {
    var exts = [];
    var mimes = faker.definitions.system.mimeTypes;

    // get specific ext by mime-type
    if (typeof mimes[mimeType] === "object") {
      return faker.random.arrayElement(mimes[mimeType].extensions);
    }

    // reduce mime-types to those with file-extensions
    Object.keys(mimes).forEach(function(m){
      if (mimes[m].extensions instanceof Array) {
        mimes[m].extensions.forEach(function(ext){
          exts.push(ext)
        });
      }
    });
    return faker.random.arrayElement(exts);
  };

  /**
   * not yet implemented
   *
   * @method faker.system.directoryPath
   */
  this.directoryPath = function () {
    // TODO
  };

  /**
   * not yet implemented
   *
   * @method faker.system.filePath
   */
  this.filePath = function () {
    // TODO
  };

  /**
   * semver
   *
   * @method faker.system.semver
   */
  this.semver = function () {
      return [faker.random.number(9),
              faker.random.number(9),
              faker.random.number(9)].join('.');
  }

}

module['exports'] = System;

},{}],1306:[function(require,module,exports){
// this program is a JavaScript version of Mersenne Twister, with concealment and encapsulation in class,
// an almost straight conversion from the original program, mt19937ar.c,
// translated by y. okada on July 17, 2006.
// and modified a little at july 20, 2006, but there are not any substantial differences.
// in this program, procedure descriptions and comments of original source code were not removed.
// lines commented with //c// were originally descriptions of c procedure. and a few following lines are appropriate JavaScript descriptions.
// lines commented with /* and */ are original comments.
// lines commented with // are additional comments in this JavaScript version.
// before using this version, create at least one instance of MersenneTwister19937 class, and initialize the each state, given below in c comments, of all the instances.
/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_genrand(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/

function MersenneTwister19937()
{
	/* constants should be scoped inside the class */
	var N, M, MATRIX_A, UPPER_MASK, LOWER_MASK;
	/* Period parameters */
	//c//#define N 624
	//c//#define M 397
	//c//#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
	//c//#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
	//c//#define LOWER_MASK 0x7fffffffUL /* least significant r bits */
	N = 624;
	M = 397;
	MATRIX_A = 0x9908b0df;   /* constant vector a */
	UPPER_MASK = 0x80000000; /* most significant w-r bits */
	LOWER_MASK = 0x7fffffff; /* least significant r bits */
	//c//static unsigned long mt[N]; /* the array for the state vector  */
	//c//static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */
	var mt = new Array(N);   /* the array for the state vector  */
	var mti = N+1;           /* mti==N+1 means mt[N] is not initialized */

	function unsigned32 (n1) // returns a 32-bits unsiged integer from an operand to which applied a bit operator.
	{
		return n1 < 0 ? (n1 ^ UPPER_MASK) + UPPER_MASK : n1;
	}

	function subtraction32 (n1, n2) // emulates lowerflow of a c 32-bits unsiged integer variable, instead of the operator -. these both arguments must be non-negative integers expressible using unsigned 32 bits.
	{
		return n1 < n2 ? unsigned32((0x100000000 - (n2 - n1)) & 0xffffffff) : n1 - n2;
	}

	function addition32 (n1, n2) // emulates overflow of a c 32-bits unsiged integer variable, instead of the operator +. these both arguments must be non-negative integers expressible using unsigned 32 bits.
	{
		return unsigned32((n1 + n2) & 0xffffffff)
	}

	function multiplication32 (n1, n2) // emulates overflow of a c 32-bits unsiged integer variable, instead of the operator *. these both arguments must be non-negative integers expressible using unsigned 32 bits.
	{
		var sum = 0;
		for (var i = 0; i < 32; ++i){
			if ((n1 >>> i) & 0x1){
				sum = addition32(sum, unsigned32(n2 << i));
			}
		}
		return sum;
	}

	/* initializes mt[N] with a seed */
	//c//void init_genrand(unsigned long s)
	this.init_genrand = function (s)
	{
		//c//mt[0]= s & 0xffffffff;
		mt[0]= unsigned32(s & 0xffffffff);
		for (mti=1; mti<N; mti++) {
			mt[mti] =
			//c//(1812433253 * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
			addition32(multiplication32(1812433253, unsigned32(mt[mti-1] ^ (mt[mti-1] >>> 30))), mti);
			/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
			/* In the previous versions, MSBs of the seed affect   */
			/* only MSBs of the array mt[].                        */
			/* 2002/01/09 modified by Makoto Matsumoto             */
			//c//mt[mti] &= 0xffffffff;
			mt[mti] = unsigned32(mt[mti] & 0xffffffff);
			/* for >32 bit machines */
		}
	}

	/* initialize by an array with array-length */
	/* init_key is the array for initializing keys */
	/* key_length is its length */
	/* slight change for C++, 2004/2/26 */
	//c//void init_by_array(unsigned long init_key[], int key_length)
	this.init_by_array = function (init_key, key_length)
	{
		//c//int i, j, k;
		var i, j, k;
		//c//init_genrand(19650218);
		this.init_genrand(19650218);
		i=1; j=0;
		k = (N>key_length ? N : key_length);
		for (; k; k--) {
			//c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525))
			//c//	+ init_key[j] + j; /* non linear */
			mt[i] = addition32(addition32(unsigned32(mt[i] ^ multiplication32(unsigned32(mt[i-1] ^ (mt[i-1] >>> 30)), 1664525)), init_key[j]), j);
			mt[i] =
			//c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */
			unsigned32(mt[i] & 0xffffffff);
			i++; j++;
			if (i>=N) { mt[0] = mt[N-1]; i=1; }
			if (j>=key_length) j=0;
		}
		for (k=N-1; k; k--) {
			//c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941))
			//c//- i; /* non linear */
			mt[i] = subtraction32(unsigned32((dbg=mt[i]) ^ multiplication32(unsigned32(mt[i-1] ^ (mt[i-1] >>> 30)), 1566083941)), i);
			//c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */
			mt[i] = unsigned32(mt[i] & 0xffffffff);
			i++;
			if (i>=N) { mt[0] = mt[N-1]; i=1; }
		}
		mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
	}

    /* moved outside of genrand_int32() by jwatte 2010-11-17; generate less garbage */
    var mag01 = [0x0, MATRIX_A];

	/* generates a random number on [0,0xffffffff]-interval */
	//c//unsigned long genrand_int32(void)
	this.genrand_int32 = function ()
	{
		//c//unsigned long y;
		//c//static unsigned long mag01[2]={0x0UL, MATRIX_A};
		var y;
		/* mag01[x] = x * MATRIX_A  for x=0,1 */

		if (mti >= N) { /* generate N words at one time */
			//c//int kk;
			var kk;

			if (mti == N+1)   /* if init_genrand() has not been called, */
				//c//init_genrand(5489); /* a default initial seed is used */
				this.init_genrand(5489); /* a default initial seed is used */

			for (kk=0;kk<N-M;kk++) {
				//c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
				//c//mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];
				y = unsigned32((mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK));
				mt[kk] = unsigned32(mt[kk+M] ^ (y >>> 1) ^ mag01[y & 0x1]);
			}
			for (;kk<N-1;kk++) {
				//c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
				//c//mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];
				y = unsigned32((mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK));
				mt[kk] = unsigned32(mt[kk+(M-N)] ^ (y >>> 1) ^ mag01[y & 0x1]);
			}
			//c//y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
			//c//mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];
			y = unsigned32((mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK));
			mt[N-1] = unsigned32(mt[M-1] ^ (y >>> 1) ^ mag01[y & 0x1]);
			mti = 0;
		}

		y = mt[mti++];

		/* Tempering */
		//c//y ^= (y >> 11);
		//c//y ^= (y << 7) & 0x9d2c5680;
		//c//y ^= (y << 15) & 0xefc60000;
		//c//y ^= (y >> 18);
		y = unsigned32(y ^ (y >>> 11));
		y = unsigned32(y ^ ((y << 7) & 0x9d2c5680));
		y = unsigned32(y ^ ((y << 15) & 0xefc60000));
		y = unsigned32(y ^ (y >>> 18));

		return y;
	}

	/* generates a random number on [0,0x7fffffff]-interval */
	//c//long genrand_int31(void)
	this.genrand_int31 = function ()
	{
		//c//return (genrand_int32()>>1);
		return (this.genrand_int32()>>>1);
	}

	/* generates a random number on [0,1]-real-interval */
	//c//double genrand_real1(void)
	this.genrand_real1 = function ()
	{
		//c//return genrand_int32()*(1.0/4294967295.0);
		return this.genrand_int32()*(1.0/4294967295.0);
		/* divided by 2^32-1 */
	}

	/* generates a random number on [0,1)-real-interval */
	//c//double genrand_real2(void)
	this.genrand_real2 = function ()
	{
		//c//return genrand_int32()*(1.0/4294967296.0);
		return this.genrand_int32()*(1.0/4294967296.0);
		/* divided by 2^32 */
	}

	/* generates a random number on (0,1)-real-interval */
	//c//double genrand_real3(void)
	this.genrand_real3 = function ()
	{
		//c//return ((genrand_int32()) + 0.5)*(1.0/4294967296.0);
		return ((this.genrand_int32()) + 0.5)*(1.0/4294967296.0);
		/* divided by 2^32 */
	}

	/* generates a random number on [0,1) with 53-bit resolution*/
	//c//double genrand_res53(void)
	this.genrand_res53 = function ()
	{
		//c//unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6;
		var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6;
		return(a*67108864.0+b)*(1.0/9007199254740992.0);
	}
	/* These real versions are due to Isaku Wada, 2002/01/09 added */
}

//  Exports: Public API

//  Export the twister class
exports.MersenneTwister19937 = MersenneTwister19937;

//  Export a simplified function to generate random numbers
var gen = new MersenneTwister19937;
gen.init_genrand((new Date).getTime() % 1000000000);

// Added max, min range functionality, Marak Squires Sept 11 2014
exports.rand = function(max, min) {
    if (max === undefined)
        {
        min = 0;
        max = 32768;
        }
    return Math.floor(gen.genrand_real2() * (max - min) + min);
}
exports.seed = function(S) {
    if (typeof(S) != 'number')
        {
        throw new Error("seed(S) must take numeric argument; is " + typeof(S));
        }
    gen.init_genrand(S);
}
exports.seed_array = function(A) {
    if (typeof(A) != 'object')
        {
        throw new Error("seed_array(A) must take array of numbers; is " + typeof(A));
        }
    gen.init_by_array(A);
}

},{}],1307:[function(require,module,exports){
/*

Copyright (c) 2012-2014 Jeffrey Mealo

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

------------------------------------------------------------------------------------------------------------------------

Based loosely on Luka Pusic's PHP Script: http://360percents.com/posts/php-random-user-agent-generator/

The license for that script is as follows:

"THE BEER-WARE LICENSE" (Revision 42):

<pusic93@gmail.com> wrote this file. As long as you retain this notice you can do whatever you want with this stuff.
If we meet some day, and you think this stuff is worth it, you can buy me a beer in return. Luka Pusic
*/

function rnd(a, b) {
    //calling rnd() with no arguments is identical to rnd(0, 100)
    a = a || 0;
    b = b || 100;

    if (typeof b === 'number' && typeof a === 'number') {
        //rnd(int min, int max) returns integer between min, max
        return (function (min, max) {
            if (min > max) {
                throw new RangeError('expected min <= max; got min = ' + min + ', max = ' + max);
            }
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }(a, b));
    }

    if (Object.prototype.toString.call(a) === "[object Array]") {
        //returns a random element from array (a), even weighting
        return a[Math.floor(Math.random() * a.length)];
    }

    if (a && typeof a === 'object') {
        //returns a random key from the passed object; keys are weighted by the decimal probability in their value
        return (function (obj) {
            var rand = rnd(0, 100) / 100, min = 0, max = 0, key, return_val;

            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    max = obj[key] + min;
                    return_val = key;
                    if (rand >= min && rand <= max) {
                        break;
                    }
                    min = min + obj[key];
                }
            }

            return return_val;
        }(a));
    }

    throw new TypeError('Invalid arguments passed to rnd. (' + (b ? a + ', ' + b : a) + ')');
}

function randomLang() {
    return rnd(['AB', 'AF', 'AN', 'AR', 'AS', 'AZ', 'BE', 'BG', 'BN', 'BO', 'BR', 'BS', 'CA', 'CE', 'CO', 'CS',
                'CU', 'CY', 'DA', 'DE', 'EL', 'EN', 'EO', 'ES', 'ET', 'EU', 'FA', 'FI', 'FJ', 'FO', 'FR', 'FY',
                'GA', 'GD', 'GL', 'GV', 'HE', 'HI', 'HR', 'HT', 'HU', 'HY', 'ID', 'IS', 'IT', 'JA', 'JV', 'KA',
                'KG', 'KO', 'KU', 'KW', 'KY', 'LA', 'LB', 'LI', 'LN', 'LT', 'LV', 'MG', 'MK', 'MN', 'MO', 'MS',
                'MT', 'MY', 'NB', 'NE', 'NL', 'NN', 'NO', 'OC', 'PL', 'PT', 'RM', 'RO', 'RU', 'SC', 'SE', 'SK',
                'SL', 'SO', 'SQ', 'SR', 'SV', 'SW', 'TK', 'TR', 'TY', 'UK', 'UR', 'UZ', 'VI', 'VO', 'YI', 'ZH']);
}

function randomBrowserAndOS() {
    var browser = rnd({
        chrome:    .45132810566,
        iexplorer: .27477061836,
        firefox:   .19384170608,
        safari:    .06186781118,
        opera:     .01574236955
    }),
    os = {
        chrome:  {win: .89,  mac: .09 , lin: .02},
        firefox: {win: .83,  mac: .16,  lin: .01},
        opera:   {win: .91,  mac: .03 , lin: .06},
        safari:  {win: .04 , mac: .96  },
        iexplorer: ['win']
    };

    return [browser, rnd(os[browser])];
}

function randomProc(arch) {
    var procs = {
        lin:['i686', 'x86_64'],
        mac: {'Intel' : .48, 'PPC': .01, 'U; Intel':.48, 'U; PPC' :.01},
        win:['', 'WOW64', 'Win64; x64']
    };
    return rnd(procs[arch]);
}

function randomRevision(dots) {
    var return_val = '';
    //generate a random revision
    //dots = 2 returns .x.y where x & y are between 0 and 9
    for (var x = 0; x < dots; x++) {
        return_val += '.' + rnd(0, 9);
    }
    return return_val;
}

var version_string = {
    net: function () {
        return [rnd(1, 4), rnd(0, 9), rnd(10000, 99999), rnd(0, 9)].join('.');
    },
    nt: function () {
        return rnd(5, 6) + '.' + rnd(0, 3);
    },
    ie: function () {
        return rnd(7, 11);
    },
    trident: function () {
        return rnd(3, 7) + '.' + rnd(0, 1);
    },
    osx: function (delim) {
        return [10, rnd(5, 10), rnd(0, 9)].join(delim || '.');
    },
    chrome: function () {
        return [rnd(13, 39), 0, rnd(800, 899), 0].join('.');
    },
    presto: function () {
        return '2.9.' + rnd(160, 190);
    },
    presto2: function () {
        return rnd(10, 12) + '.00';
    },
    safari: function () {
        return rnd(531, 538) + '.' + rnd(0, 2) + '.' + rnd(0,2);
    }
};

var browser = {
    firefox: function firefox(arch) {
        //https://developer.mozilla.org/en-US/docs/Gecko_user_agent_string_reference
        var firefox_ver = rnd(5, 15) + randomRevision(2),
            gecko_ver = 'Gecko/20100101 Firefox/' + firefox_ver,
            proc = randomProc(arch),
            os_ver = (arch === 'win') ? '(Windows NT ' + version_string.nt() + ((proc) ? '; ' + proc : '')
            : (arch === 'mac') ? '(Macintosh; ' + proc + ' Mac OS X ' + version_string.osx()
            : '(X11; Linux ' + proc;

        return 'Mozilla/5.0 ' + os_ver + '; rv:' + firefox_ver.slice(0, -2) + ') ' + gecko_ver;
    },

    iexplorer: function iexplorer() {
        var ver = version_string.ie();

        if (ver >= 11) {
            //http://msdn.microsoft.com/en-us/library/ie/hh869301(v=vs.85).aspx
            return 'Mozilla/5.0 (Windows NT 6.' + rnd(1,3) + '; Trident/7.0; ' + rnd(['Touch; ', '']) + 'rv:11.0) like Gecko';
        }

        //http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx
        return 'Mozilla/5.0 (compatible; MSIE ' + ver + '.0; Windows NT ' + version_string.nt() + '; Trident/' +
            version_string.trident() + ((rnd(0, 1) === 1) ? '; .NET CLR ' + version_string.net() : '') + ')';
    },

    opera: function opera(arch) {
        //http://www.opera.com/docs/history/
        var presto_ver = ' Presto/' + version_string.presto() + ' Version/' + version_string.presto2() + ')',
            os_ver = (arch === 'win') ? '(Windows NT ' + version_string.nt() + '; U; ' + randomLang() + presto_ver
            : (arch === 'lin') ? '(X11; Linux ' + randomProc(arch) + '; U; ' + randomLang() + presto_ver
            : '(Macintosh; Intel Mac OS X ' + version_string.osx() + ' U; ' + randomLang() + ' Presto/' +
            version_string.presto() + ' Version/' + version_string.presto2() + ')';

        return 'Opera/' + rnd(9, 14) + '.' + rnd(0, 99) + ' ' + os_ver;
    },

    safari: function safari(arch) {
        var safari = version_string.safari(),
            ver = rnd(4, 7) + '.' + rnd(0,1) + '.' + rnd(0,10),
            os_ver = (arch === 'mac') ? '(Macintosh; ' + randomProc('mac') + ' Mac OS X '+ version_string.osx('_') + ' rv:' + rnd(2, 6) + '.0; '+ randomLang() + ') '
            : '(Windows; U; Windows NT ' + version_string.nt() + ')';

        return 'Mozilla/5.0 ' + os_ver + 'AppleWebKit/' + safari + ' (KHTML, like Gecko) Version/' + ver + ' Safari/' + safari;
    },

    chrome: function chrome(arch) {
        var safari = version_string.safari(),
            os_ver = (arch === 'mac') ? '(Macintosh; ' + randomProc('mac') + ' Mac OS X ' + version_string.osx('_') + ') '
            : (arch === 'win') ? '(Windows; U; Windows NT ' + version_string.nt() + ')'
            : '(X11; Linux ' + randomProc(arch);

        return 'Mozilla/5.0 ' + os_ver + ' AppleWebKit/' + safari + ' (KHTML, like Gecko) Chrome/' + version_string.chrome() + ' Safari/' + safari;
    }
};

exports.generate = function generate() {
    var random = randomBrowserAndOS();
    return browser[random[0]](random[1]);
};

},{}],1308:[function(require,module,exports){
(function (global){
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.11';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });

        return result;
      }

      if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });

        return result;
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        if (isObject(srcValue)) {
          stack || (stack = new Stack);
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array == null ? 0 : array.length,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = (lodashFunc.name + ''),
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],1309:[function(require,module,exports){
// minimal library entry point.

"use strict";
module.exports = require("./src/index-minimal");

},{"./src/index-minimal":1310}],1310:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
}

// Set up buffer utility according to the environment
protobuf.Writer._configure(protobuf.BufferWriter);
configure();

},{"./reader":1311,"./reader_buffer":1312,"./roots":1313,"./rpc":1314,"./util/minimal":1317,"./writer":1318,"./writer_buffer":1319}],1311:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = util.Buffer
    ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer)
                ? new BufferReader(buffer)
                /* istanbul ignore next */
                : create_array(buffer);
        })(buffer);
    }
    /* istanbul ignore next */
    : create_array;

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"./util/minimal":1317}],1312:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

/* istanbul ignore else */
if (util.Buffer)
    BufferReader.prototype._slice = util.Buffer.prototype.slice;

/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

},{"./reader":1311,"./util/minimal":1317}],1313:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],1314:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");

},{"./rpc/service":1315}],1315:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"../util/minimal":1317}],1316:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"../util/minimal":1317}],1317:[function(require,module,exports){
(function (global){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

// global object reference
util.global = typeof window !== "undefined" && window
           || typeof global !== "undefined" && global
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 * @const
 */
util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./longbits":1316,"@protobufjs/aspromise":10,"@protobufjs/base64":11,"@protobufjs/eventemitter":12,"@protobufjs/float":13,"@protobufjs/inquire":14,"@protobufjs/pool":15,"@protobufjs/utf8":16}],1318:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = util.Buffer
    ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    }
    /* istanbul ignore next */
    : function create_array() {
        return new Writer();
    };

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
};

},{"./util/minimal":1317}],1319:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

var Buffer = util.Buffer;

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Buffer} Buffer
 */
BufferWriter.alloc = function alloc_buffer(size) {
    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
};

var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set"
    ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                           // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
    };

/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else
        buf.utf8Write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

},{"./util/minimal":1317,"./writer":1318}],1320:[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baage.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by Franois Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":1321,"./lib/tychei":1322,"./lib/xor128":1323,"./lib/xor4096":1324,"./lib/xorshift7":1325,"./lib/xorwow":1326,"./seedrandom":1327}],1321:[function(require,module,exports){
// A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],1322:[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],1323:[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],1324:[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],1325:[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// Franois Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],1326:[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],1327:[function(require,module,exports){
/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

// Detect the global object, even if operating in strict mode.
// http://stackoverflow.com/a/14387057/265298
var global = (0, eval)('this'),
    width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
}

// End anonymous scope, and pass initial values.
})(
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":2}]},{},[7]);
